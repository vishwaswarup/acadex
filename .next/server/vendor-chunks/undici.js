/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/undici";
exports.ids = ["vendor-chunks/undici"];
exports.modules = {

/***/ "(ssr)/./node_modules/undici/index.js":
/*!**************************************!*\
  !*** ./node_modules/undici/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Client = __webpack_require__(/*! ./lib/client */ \"(ssr)/./node_modules/undici/lib/client.js\")\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher.js\")\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst Pool = __webpack_require__(/*! ./lib/pool */ \"(ssr)/./node_modules/undici/lib/pool.js\")\nconst BalancedPool = __webpack_require__(/*! ./lib/balanced-pool */ \"(ssr)/./node_modules/undici/lib/balanced-pool.js\")\nconst Agent = __webpack_require__(/*! ./lib/agent */ \"(ssr)/./node_modules/undici/lib/agent.js\")\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = errors\nconst api = __webpack_require__(/*! ./lib/api */ \"(ssr)/./node_modules/undici/lib/api/index.js\")\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\")\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(ssr)/./node_modules/undici/lib/mock/mock-client.js\")\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(ssr)/./node_modules/undici/lib/mock/mock-agent.js\")\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(ssr)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(ssr)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst ProxyAgent = __webpack_require__(/*! ./lib/proxy-agent */ \"(ssr)/./node_modules/undici/lib/proxy-agent.js\")\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(ssr)/./node_modules/undici/lib/global.js\")\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/DecoratorHandler */ \"(ssr)/./node_modules/undici/lib/handler/DecoratorHandler.js\")\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/RedirectHandler */ \"(ssr)/./node_modules/undici/lib/handler/RedirectHandler.js\")\nconst createRedirectInterceptor = __webpack_require__(/*! ./lib/interceptor/redirectInterceptor */ \"(ssr)/./node_modules/undici/lib/interceptor/redirectInterceptor.js\")\n\nlet hasCrypto\ntry {\n  __webpack_require__(/*! crypto */ \"crypto\")\n  hasCrypto = true\n} catch {\n  hasCrypto = false\n}\n\nObject.assign(Dispatcher.prototype, api)\n\nmodule.exports.Dispatcher = Dispatcher\nmodule.exports.Client = Client\nmodule.exports.Pool = Pool\nmodule.exports.BalancedPool = BalancedPool\nmodule.exports.Agent = Agent\nmodule.exports.ProxyAgent = ProxyAgent\n\nmodule.exports.DecoratorHandler = DecoratorHandler\nmodule.exports.RedirectHandler = RedirectHandler\nmodule.exports.createRedirectInterceptor = createRedirectInterceptor\n\nmodule.exports.buildConnector = buildConnector\nmodule.exports.errors = errors\n\nfunction makeDispatcher (fn) {\n  return (url, opts, handler) => {\n    if (typeof opts === 'function') {\n      handler = opts\n      opts = null\n    }\n\n    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {\n      throw new InvalidArgumentError('invalid url')\n    }\n\n    if (opts != null && typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (opts && opts.path != null) {\n      if (typeof opts.path !== 'string') {\n        throw new InvalidArgumentError('invalid opts.path')\n      }\n\n      let path = opts.path\n      if (!opts.path.startsWith('/')) {\n        path = `/${path}`\n      }\n\n      url = new URL(util.parseOrigin(url).origin + path)\n    } else {\n      if (!opts) {\n        opts = typeof url === 'object' ? url : {}\n      }\n\n      url = util.parseURL(url)\n    }\n\n    const { agent, dispatcher = getGlobalDispatcher() } = opts\n\n    if (agent) {\n      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')\n    }\n\n    return fn.call(dispatcher, {\n      ...opts,\n      origin: url.origin,\n      path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n      method: opts.method || (opts.body ? 'PUT' : 'GET')\n    }, handler)\n  }\n}\n\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher\n\nif (util.nodeMajor > 16 || (util.nodeMajor === 16 && util.nodeMinor >= 8)) {\n  let fetchImpl = null\n  module.exports.fetch = async function fetch (resource) {\n    if (!fetchImpl) {\n      fetchImpl = (__webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/undici/lib/fetch/index.js\").fetch)\n    }\n\n    try {\n      return await fetchImpl(...arguments)\n    } catch (err) {\n      if (typeof err === 'object') {\n        Error.captureStackTrace(err, this)\n      }\n\n      throw err\n    }\n  }\n  module.exports.Headers = __webpack_require__(/*! ./lib/fetch/headers */ \"(ssr)/./node_modules/undici/lib/fetch/headers.js\").Headers\n  module.exports.Response = __webpack_require__(/*! ./lib/fetch/response */ \"(ssr)/./node_modules/undici/lib/fetch/response.js\").Response\n  module.exports.Request = __webpack_require__(/*! ./lib/fetch/request */ \"(ssr)/./node_modules/undici/lib/fetch/request.js\").Request\n  module.exports.FormData = __webpack_require__(/*! ./lib/fetch/formdata */ \"(ssr)/./node_modules/undici/lib/fetch/formdata.js\").FormData\n  module.exports.File = __webpack_require__(/*! ./lib/fetch/file */ \"(ssr)/./node_modules/undici/lib/fetch/file.js\").File\n  module.exports.FileReader = __webpack_require__(/*! ./lib/fileapi/filereader */ \"(ssr)/./node_modules/undici/lib/fileapi/filereader.js\").FileReader\n\n  const { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/fetch/global */ \"(ssr)/./node_modules/undici/lib/fetch/global.js\")\n\n  module.exports.setGlobalOrigin = setGlobalOrigin\n  module.exports.getGlobalOrigin = getGlobalOrigin\n\n  const { CacheStorage } = __webpack_require__(/*! ./lib/cache/cachestorage */ \"(ssr)/./node_modules/undici/lib/cache/cachestorage.js\")\n  const { kConstruct } = __webpack_require__(/*! ./lib/cache/symbols */ \"(ssr)/./node_modules/undici/lib/cache/symbols.js\")\n\n  // Cache & CacheStorage are tightly coupled with fetch. Even if it may run\n  // in an older version of Node, it doesn't have any use without fetch.\n  module.exports.caches = new CacheStorage(kConstruct)\n}\n\nif (util.nodeMajor >= 16) {\n  const { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__(/*! ./lib/cookies */ \"(ssr)/./node_modules/undici/lib/cookies/index.js\")\n\n  module.exports.deleteCookie = deleteCookie\n  module.exports.getCookies = getCookies\n  module.exports.getSetCookies = getSetCookies\n  module.exports.setCookie = setCookie\n\n  const { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/fetch/dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\n\n  module.exports.parseMIMEType = parseMIMEType\n  module.exports.serializeAMimeType = serializeAMimeType\n}\n\nif (util.nodeMajor >= 18 && hasCrypto) {\n  const { WebSocket } = __webpack_require__(/*! ./lib/websocket/websocket */ \"(ssr)/./node_modules/undici/lib/websocket/websocket.js\")\n\n  module.exports.WebSocket = WebSocket\n}\n\nmodule.exports.request = makeDispatcher(api.request)\nmodule.exports.stream = makeDispatcher(api.stream)\nmodule.exports.pipeline = makeDispatcher(api.pipeline)\nmodule.exports.connect = makeDispatcher(api.connect)\nmodule.exports.upgrade = makeDispatcher(api.upgrade)\n\nmodule.exports.MockClient = MockClient\nmodule.exports.MockPool = MockPool\nmodule.exports.MockAgent = MockAgent\nmodule.exports.mockErrors = mockErrors\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLHlGQUEyQjs7QUFFM0QsRUFBRSx3QkFBd0I7QUFDMUI7O0FBRUEsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9pbmRleC5qcz80MTYxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2xpYi9jbGllbnQnKVxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXInKVxuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9saWIvY29yZS9lcnJvcnMnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vbGliL3Bvb2wnKVxuY29uc3QgQmFsYW5jZWRQb29sID0gcmVxdWlyZSgnLi9saWIvYmFsYW5jZWQtcG9vbCcpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2FnZW50JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL2xpYi9jb3JlL3V0aWwnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gZXJyb3JzXG5jb25zdCBhcGkgPSByZXF1aXJlKCcuL2xpYi9hcGknKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2Nvbm5lY3QnKVxuY29uc3QgTW9ja0NsaWVudCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1jbGllbnQnKVxuY29uc3QgTW9ja0FnZW50ID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLWFnZW50JylcbmNvbnN0IE1vY2tQb29sID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLXBvb2wnKVxuY29uc3QgbW9ja0Vycm9ycyA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1lcnJvcnMnKVxuY29uc3QgUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4vbGliL3Byb3h5LWFnZW50JylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciwgc2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi9saWIvZ2xvYmFsJylcbmNvbnN0IERlY29yYXRvckhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9oYW5kbGVyL0RlY29yYXRvckhhbmRsZXInKVxuY29uc3QgUmVkaXJlY3RIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9SZWRpcmVjdEhhbmRsZXInKVxuY29uc3QgY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL3JlZGlyZWN0SW50ZXJjZXB0b3InKVxuXG5sZXQgaGFzQ3J5cHRvXG50cnkge1xuICByZXF1aXJlKCdjcnlwdG8nKVxuICBoYXNDcnlwdG8gPSB0cnVlXG59IGNhdGNoIHtcbiAgaGFzQ3J5cHRvID0gZmFsc2Vcbn1cblxuT2JqZWN0LmFzc2lnbihEaXNwYXRjaGVyLnByb3RvdHlwZSwgYXBpKVxuXG5tb2R1bGUuZXhwb3J0cy5EaXNwYXRjaGVyID0gRGlzcGF0Y2hlclxubW9kdWxlLmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50XG5tb2R1bGUuZXhwb3J0cy5Qb29sID0gUG9vbFxubW9kdWxlLmV4cG9ydHMuQmFsYW5jZWRQb29sID0gQmFsYW5jZWRQb29sXG5tb2R1bGUuZXhwb3J0cy5BZ2VudCA9IEFnZW50XG5tb2R1bGUuZXhwb3J0cy5Qcm94eUFnZW50ID0gUHJveHlBZ2VudFxuXG5tb2R1bGUuZXhwb3J0cy5EZWNvcmF0b3JIYW5kbGVyID0gRGVjb3JhdG9ySGFuZGxlclxubW9kdWxlLmV4cG9ydHMuUmVkaXJlY3RIYW5kbGVyID0gUmVkaXJlY3RIYW5kbGVyXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvclxuXG5tb2R1bGUuZXhwb3J0cy5idWlsZENvbm5lY3RvciA9IGJ1aWxkQ29ubmVjdG9yXG5tb2R1bGUuZXhwb3J0cy5lcnJvcnMgPSBlcnJvcnNcblxuZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIgKGZuKSB7XG4gIHJldHVybiAodXJsLCBvcHRzLCBoYW5kbGVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBoYW5kbGVyID0gb3B0c1xuICAgICAgb3B0cyA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoIXVybCB8fCAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHVybCAhPT0gJ29iamVjdCcgJiYgISh1cmwgaW5zdGFuY2VvZiBVUkwpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVybCcpXG4gICAgfVxuXG4gICAgaWYgKG9wdHMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAob3B0cyAmJiBvcHRzLnBhdGggIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzLnBhdGgnKVxuICAgICAgfVxuXG4gICAgICBsZXQgcGF0aCA9IG9wdHMucGF0aFxuICAgICAgaWYgKCFvcHRzLnBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHBhdGggPSBgLyR7cGF0aH1gXG4gICAgICB9XG5cbiAgICAgIHVybCA9IG5ldyBVUkwodXRpbC5wYXJzZU9yaWdpbih1cmwpLm9yaWdpbiArIHBhdGgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghb3B0cykge1xuICAgICAgICBvcHRzID0gdHlwZW9mIHVybCA9PT0gJ29iamVjdCcgPyB1cmwgOiB7fVxuICAgICAgfVxuXG4gICAgICB1cmwgPSB1dGlsLnBhcnNlVVJMKHVybClcbiAgICB9XG5cbiAgICBjb25zdCB7IGFnZW50LCBkaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIH0gPSBvcHRzXG5cbiAgICBpZiAoYWdlbnQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgb3B0cy5hZ2VudC4gRGlkIHlvdSBtZWFuIG9wdHMuY2xpZW50PycpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmNhbGwoZGlzcGF0Y2hlciwge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIG9yaWdpbjogdXJsLm9yaWdpbixcbiAgICAgIHBhdGg6IHVybC5zZWFyY2ggPyBgJHt1cmwucGF0aG5hbWV9JHt1cmwuc2VhcmNofWAgOiB1cmwucGF0aG5hbWUsXG4gICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8IChvcHRzLmJvZHkgPyAnUFVUJyA6ICdHRVQnKVxuICAgIH0sIGhhbmRsZXIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsRGlzcGF0Y2hlciA9IHNldEdsb2JhbERpc3BhdGNoZXJcbm1vZHVsZS5leHBvcnRzLmdldEdsb2JhbERpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyXG5cbmlmICh1dGlsLm5vZGVNYWpvciA+IDE2IHx8ICh1dGlsLm5vZGVNYWpvciA9PT0gMTYgJiYgdXRpbC5ub2RlTWlub3IgPj0gOCkpIHtcbiAgbGV0IGZldGNoSW1wbCA9IG51bGxcbiAgbW9kdWxlLmV4cG9ydHMuZmV0Y2ggPSBhc3luYyBmdW5jdGlvbiBmZXRjaCAocmVzb3VyY2UpIHtcbiAgICBpZiAoIWZldGNoSW1wbCkge1xuICAgICAgZmV0Y2hJbXBsID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gnKS5mZXRjaFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2hJbXBsKC4uLmFyZ3VtZW50cylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgZXJyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHRoaXMpXG4gICAgICB9XG5cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5IZWFkZXJzID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gvaGVhZGVycycpLkhlYWRlcnNcbiAgbW9kdWxlLmV4cG9ydHMuUmVzcG9uc2UgPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9yZXNwb25zZScpLlJlc3BvbnNlXG4gIG1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9yZXF1ZXN0JykuUmVxdWVzdFxuICBtb2R1bGUuZXhwb3J0cy5Gb3JtRGF0YSA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2Zvcm1kYXRhJykuRm9ybURhdGFcbiAgbW9kdWxlLmV4cG9ydHMuRmlsZSA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2ZpbGUnKS5GaWxlXG4gIG1vZHVsZS5leHBvcnRzLkZpbGVSZWFkZXIgPSByZXF1aXJlKCcuL2xpYi9maWxlYXBpL2ZpbGVyZWFkZXInKS5GaWxlUmVhZGVyXG5cbiAgY29uc3QgeyBzZXRHbG9iYWxPcmlnaW4sIGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gvZ2xvYmFsJylcblxuICBtb2R1bGUuZXhwb3J0cy5zZXRHbG9iYWxPcmlnaW4gPSBzZXRHbG9iYWxPcmlnaW5cbiAgbW9kdWxlLmV4cG9ydHMuZ2V0R2xvYmFsT3JpZ2luID0gZ2V0R2xvYmFsT3JpZ2luXG5cbiAgY29uc3QgeyBDYWNoZVN0b3JhZ2UgfSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlL2NhY2hlc3RvcmFnZScpXG4gIGNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi9saWIvY2FjaGUvc3ltYm9scycpXG5cbiAgLy8gQ2FjaGUgJiBDYWNoZVN0b3JhZ2UgYXJlIHRpZ2h0bHkgY291cGxlZCB3aXRoIGZldGNoLiBFdmVuIGlmIGl0IG1heSBydW5cbiAgLy8gaW4gYW4gb2xkZXIgdmVyc2lvbiBvZiBOb2RlLCBpdCBkb2Vzbid0IGhhdmUgYW55IHVzZSB3aXRob3V0IGZldGNoLlxuICBtb2R1bGUuZXhwb3J0cy5jYWNoZXMgPSBuZXcgQ2FjaGVTdG9yYWdlKGtDb25zdHJ1Y3QpXG59XG5cbmlmICh1dGlsLm5vZGVNYWpvciA+PSAxNikge1xuICBjb25zdCB7IGRlbGV0ZUNvb2tpZSwgZ2V0Q29va2llcywgZ2V0U2V0Q29va2llcywgc2V0Q29va2llIH0gPSByZXF1aXJlKCcuL2xpYi9jb29raWVzJylcblxuICBtb2R1bGUuZXhwb3J0cy5kZWxldGVDb29raWUgPSBkZWxldGVDb29raWVcbiAgbW9kdWxlLmV4cG9ydHMuZ2V0Q29va2llcyA9IGdldENvb2tpZXNcbiAgbW9kdWxlLmV4cG9ydHMuZ2V0U2V0Q29va2llcyA9IGdldFNldENvb2tpZXNcbiAgbW9kdWxlLmV4cG9ydHMuc2V0Q29va2llID0gc2V0Q29va2llXG5cbiAgY29uc3QgeyBwYXJzZU1JTUVUeXBlLCBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2RhdGFVUkwnKVxuXG4gIG1vZHVsZS5leHBvcnRzLnBhcnNlTUlNRVR5cGUgPSBwYXJzZU1JTUVUeXBlXG4gIG1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZUFNaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZVxufVxuXG5pZiAodXRpbC5ub2RlTWFqb3IgPj0gMTggJiYgaGFzQ3J5cHRvKSB7XG4gIGNvbnN0IHsgV2ViU29ja2V0IH0gPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQvd2Vic29ja2V0JylcblxuICBtb2R1bGUuZXhwb3J0cy5XZWJTb2NrZXQgPSBXZWJTb2NrZXRcbn1cblxubW9kdWxlLmV4cG9ydHMucmVxdWVzdCA9IG1ha2VEaXNwYXRjaGVyKGFwaS5yZXF1ZXN0KVxubW9kdWxlLmV4cG9ydHMuc3RyZWFtID0gbWFrZURpc3BhdGNoZXIoYXBpLnN0cmVhbSlcbm1vZHVsZS5leHBvcnRzLnBpcGVsaW5lID0gbWFrZURpc3BhdGNoZXIoYXBpLnBpcGVsaW5lKVxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IG1ha2VEaXNwYXRjaGVyKGFwaS5jb25uZWN0KVxubW9kdWxlLmV4cG9ydHMudXBncmFkZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS51cGdyYWRlKVxuXG5tb2R1bGUuZXhwb3J0cy5Nb2NrQ2xpZW50ID0gTW9ja0NsaWVudFxubW9kdWxlLmV4cG9ydHMuTW9ja1Bvb2wgPSBNb2NrUG9vbFxubW9kdWxlLmV4cG9ydHMuTW9ja0FnZW50ID0gTW9ja0FnZW50XG5tb2R1bGUuZXhwb3J0cy5tb2NrRXJyb3JzID0gbW9ja0Vycm9yc1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/agent.js":
/*!******************************************!*\
  !*** ./node_modules/undici/lib/agent.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/pool.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/undici/lib/client.js\")\nconst util = __webpack_require__(/*! ./core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst createRedirectInterceptor = __webpack_require__(/*! ./interceptor/redirectInterceptor */ \"(ssr)/./node_modules/undici/lib/interceptor/redirectInterceptor.js\")\nconst { WeakRef, FinalizationRegistry } = __webpack_require__(/*! ./compat/dispatcher-weakref */ \"(ssr)/./node_modules/undici/lib/compat/dispatcher-weakref.js\")()\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kFinalizer = Symbol('finalizer')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent)\n      ? options.interceptors.Agent\n      : [createRedirectInterceptor({ maxRedirections })]\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {\n      const ref = this[kClients].get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key)\n      }\n    })\n\n    const agent = this\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore next: gc is undeterministic */\n      if (client) {\n        ret += client[kRunning]\n      }\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    const ref = this[kClients].get(key)\n\n    let dispatcher = ref ? ref.deref() : null\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', this[kOnConnect])\n        .on('disconnect', this[kOnDisconnect])\n        .on('connectionError', this[kOnConnectionError])\n\n      this[kClients].set(key, new WeakRef(dispatcher))\n      this[kFinalizer].register(dispatcher, key)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    const closePromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        closePromises.push(client.close())\n      }\n    }\n\n    await Promise.all(closePromises)\n  }\n\n  async [kDestroy] (err) {\n    const destroyPromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        destroyPromises.push(client.destroy(err))\n      }\n    }\n\n    await Promise.all(destroyPromises)\n  }\n}\n\nmodule.exports = Agent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMscUVBQWU7QUFDeEQsUUFBUSxpRUFBaUUsRUFBRSxtQkFBTyxDQUFDLHVFQUFnQjtBQUNuRyx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLHVEQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQywyREFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsaUVBQWE7QUFDbEMsa0NBQWtDLG1CQUFPLENBQUMsNkdBQW1DO0FBQzdFLFFBQVEsZ0NBQWdDLEVBQUUsbUJBQU8sQ0FBQyxpR0FBNkI7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixxRUFBcUUsSUFBSTtBQUMxRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjs7QUFFdEQsdUJBQXVCO0FBQ3ZCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hZ2VudC5qcz85NjE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsga0NsaWVudHMsIGtSdW5uaW5nLCBrQ2xvc2UsIGtEZXN0cm95LCBrRGlzcGF0Y2gsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKVxuY29uc3QgY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vaW50ZXJjZXB0b3IvcmVkaXJlY3RJbnRlcmNlcHRvcicpXG5jb25zdCB7IFdlYWtSZWYsIEZpbmFsaXphdGlvblJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuL2NvbXBhdC9kaXNwYXRjaGVyLXdlYWtyZWYnKSgpXG5cbmNvbnN0IGtPbkNvbm5lY3QgPSBTeW1ib2woJ29uQ29ubmVjdCcpXG5jb25zdCBrT25EaXNjb25uZWN0ID0gU3ltYm9sKCdvbkRpc2Nvbm5lY3QnKVxuY29uc3Qga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKCdvbkNvbm5lY3Rpb25FcnJvcicpXG5jb25zdCBrTWF4UmVkaXJlY3Rpb25zID0gU3ltYm9sKCdtYXhSZWRpcmVjdGlvbnMnKVxuY29uc3Qga09uRHJhaW4gPSBTeW1ib2woJ29uRHJhaW4nKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuY29uc3Qga0ZpbmFsaXplciA9IFN5bWJvbCgnZmluYWxpemVyJylcbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gb3B0cyAmJiBvcHRzLmNvbm5lY3Rpb25zID09PSAxXG4gICAgPyBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbiAgICA6IG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgQWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yICh7IGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSwgbWF4UmVkaXJlY3Rpb25zID0gMCwgY29ubmVjdCwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0geyAuLi5jb25uZWN0IH1cbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0aW9ucy5pbnRlcmNlcHRvcnMgJiYgb3B0aW9ucy5pbnRlcmNlcHRvcnMuQWdlbnQgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyY2VwdG9ycy5BZ2VudClcbiAgICAgID8gb3B0aW9ucy5pbnRlcmNlcHRvcnMuQWdlbnRcbiAgICAgIDogW2NyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IoeyBtYXhSZWRpcmVjdGlvbnMgfSldXG5cbiAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbC5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tNYXhSZWRpcmVjdGlvbnNdID0gbWF4UmVkaXJlY3Rpb25zXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gICAgdGhpc1trQ2xpZW50c10gPSBuZXcgTWFwKClcbiAgICB0aGlzW2tGaW5hbGl6ZXJdID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBnYyBpcyB1bmRldGVybWluaXN0aWMgKi8ga2V5ID0+IHtcbiAgICAgIGNvbnN0IHJlZiA9IHRoaXNba0NsaWVudHNdLmdldChrZXkpXG4gICAgICBpZiAocmVmICE9PSB1bmRlZmluZWQgJiYgcmVmLmRlcmVmKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzW2tDbGllbnRzXS5kZWxldGUoa2V5KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBhZ2VudCA9IHRoaXNcblxuICAgIHRoaXNba09uRHJhaW5dID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgYWdlbnQuZW1pdCgnZHJhaW4nLCBvcmlnaW4sIFthZ2VudCwgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgIGFnZW50LmVtaXQoJ2Nvbm5lY3QnLCBvcmlnaW4sIFthZ2VudCwgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25EaXNjb25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgYWdlbnQuZW1pdCgnZGlzY29ubmVjdCcsIG9yaWdpbiwgW2FnZW50LCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgYWdlbnQuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgb3JpZ2luLCBbYWdlbnQsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIGxldCByZXQgPSAwXG4gICAgZm9yIChjb25zdCByZWYgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IHJlZi5kZXJlZigpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZ2MgaXMgdW5kZXRlcm1pbmlzdGljICovXG4gICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgIHJldCArPSBjbGllbnRba1J1bm5pbmddXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgbGV0IGtleVxuICAgIGlmIChvcHRzLm9yaWdpbiAmJiAodHlwZW9mIG9wdHMub3JpZ2luID09PSAnc3RyaW5nJyB8fCBvcHRzLm9yaWdpbiBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgIGtleSA9IFN0cmluZyhvcHRzLm9yaWdpbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLm9yaWdpbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBVUkwuJylcbiAgICB9XG5cbiAgICBjb25zdCByZWYgPSB0aGlzW2tDbGllbnRzXS5nZXQoa2V5KVxuXG4gICAgbGV0IGRpc3BhdGNoZXIgPSByZWYgPyByZWYuZGVyZWYoKSA6IG51bGxcbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcHRzLm9yaWdpbiwgdGhpc1trT3B0aW9uc10pXG4gICAgICAgIC5vbignZHJhaW4nLCB0aGlzW2tPbkRyYWluXSlcbiAgICAgICAgLm9uKCdjb25uZWN0JywgdGhpc1trT25Db25uZWN0XSlcbiAgICAgICAgLm9uKCdkaXNjb25uZWN0JywgdGhpc1trT25EaXNjb25uZWN0XSlcbiAgICAgICAgLm9uKCdjb25uZWN0aW9uRXJyb3InLCB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0pXG5cbiAgICAgIHRoaXNba0NsaWVudHNdLnNldChrZXksIG5ldyBXZWFrUmVmKGRpc3BhdGNoZXIpKVxuICAgICAgdGhpc1trRmluYWxpemVyXS5yZWdpc3RlcihkaXNwYXRjaGVyLCBrZXkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3BhdGNoZXIuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBjb25zdCBjbG9zZVByb21pc2VzID0gW11cbiAgICBmb3IgKGNvbnN0IHJlZiBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xpZW50ID0gcmVmLmRlcmVmKClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBnYyBpcyB1bmRldGVybWluaXN0aWMgKi9cbiAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgY2xvc2VQcm9taXNlcy5wdXNoKGNsaWVudC5jbG9zZSgpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGNsb3NlUHJvbWlzZXMpXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICBjb25zdCBkZXN0cm95UHJvbWlzZXMgPSBbXVxuICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGllbnQgPSByZWYuZGVyZWYoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGdjIGlzIHVuZGV0ZXJtaW5pc3RpYyAqL1xuICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICBkZXN0cm95UHJvbWlzZXMucHVzaChjbGllbnQuZGVzdHJveShlcnIpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGRlc3Ryb3lQcm9taXNlcylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/abort-signal.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/abort-signal.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\nconst kListener = Symbol('kListener')\nconst kSignal = Symbol('kSignal')\n\nfunction abort (self) {\n  if (self.abort) {\n    self.abort()\n  } else {\n    self.onError(new RequestAbortedError())\n  }\n}\n\nfunction addSignal (self, signal) {\n  self[kSignal] = null\n  self[kListener] = null\n\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    abort(self)\n    return\n  }\n\n  self[kSignal] = signal\n  self[kListener] = () => {\n    abort(self)\n  }\n\n  addAbortListener(self[kSignal], self[kListener])\n}\n\nfunction removeSignal (self) {\n  if (!self[kSignal]) {\n    return\n  }\n\n  if ('removeEventListener' in self[kSignal]) {\n    self[kSignal].removeEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].removeListener('abort', self[kListener])\n  }\n\n  self[kSignal] = null\n  self[kListener] = null\n}\n\nmodule.exports = {\n  addSignal,\n  removeSignal\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUNuRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzP2Q2NmYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBhZGRBYm9ydExpc3RlbmVyIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBSZXF1ZXN0QWJvcnRlZEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNvbnN0IGtMaXN0ZW5lciA9IFN5bWJvbCgna0xpc3RlbmVyJylcbmNvbnN0IGtTaWduYWwgPSBTeW1ib2woJ2tTaWduYWwnKVxuXG5mdW5jdGlvbiBhYm9ydCAoc2VsZikge1xuICBpZiAoc2VsZi5hYm9ydCkge1xuICAgIHNlbGYuYWJvcnQoKVxuICB9IGVsc2Uge1xuICAgIHNlbGYub25FcnJvcihuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFNpZ25hbCAoc2VsZiwgc2lnbmFsKSB7XG4gIHNlbGZba1NpZ25hbF0gPSBudWxsXG4gIHNlbGZba0xpc3RlbmVyXSA9IG51bGxcblxuICBpZiAoIXNpZ25hbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgYWJvcnQoc2VsZilcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNlbGZba1NpZ25hbF0gPSBzaWduYWxcbiAgc2VsZltrTGlzdGVuZXJdID0gKCkgPT4ge1xuICAgIGFib3J0KHNlbGYpXG4gIH1cblxuICBhZGRBYm9ydExpc3RlbmVyKHNlbGZba1NpZ25hbF0sIHNlbGZba0xpc3RlbmVyXSlcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU2lnbmFsIChzZWxmKSB7XG4gIGlmICghc2VsZltrU2lnbmFsXSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBzZWxmW2tTaWduYWxdKSB7XG4gICAgc2VsZltrU2lnbmFsXS5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHNlbGZba0xpc3RlbmVyXSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmW2tTaWduYWxdLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIHNlbGZba0xpc3RlbmVyXSlcbiAgfVxuXG4gIHNlbGZba1NpZ25hbF0gPSBudWxsXG4gIHNlbGZba0xpc3RlbmVyXSA9IG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZFNpZ25hbCxcbiAgcmVtb3ZlU2lnbmFsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-connect.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-connect.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n\n    let headers = rawHeaders\n    // Indicates is an HTTP2Session\n    if (headers != null) {\n      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    }\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQy9DLFFBQVEseURBQXlELEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDM0YsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksa0NBQWtDOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw0QkFBNEI7O0FBRXhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktY29ubmVjdC5qcz82ZDliIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ2FzeW5jX2hvb2tzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IsIFNvY2tldEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgQ29ubmVjdEhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG9wYXF1ZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9DT05ORUNUJylcblxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzICgpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2JhZCBjb25uZWN0JywgbnVsbClcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG5cbiAgICBsZXQgaGVhZGVycyA9IHJhd0hlYWRlcnNcbiAgICAvLyBJbmRpY2F0ZXMgaXMgYW4gSFRUUDJTZXNzaW9uXG4gICAgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICB9XG5cbiAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzb2NrZXQsXG4gICAgICBvcGFxdWUsXG4gICAgICBjb250ZXh0XG4gICAgfSlcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb25uZWN0IChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25uZWN0LmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gbmV3IENvbm5lY3RIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKVxuICAgIHRoaXMuZGlzcGF0Y2goeyAuLi5vcHRzLCBtZXRob2Q6ICdDT05ORUNUJyB9LCBjb25uZWN0SGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHMgJiYgb3B0cy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-pipeline.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-pipeline.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = __webpack_require__(/*! stream */ \"stream\")\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', util.nop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body && body.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { ret, res } = this\n\n    assert(!res, 'pipeline cannot be retried')\n\n    if (ret.destroyed) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers,\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', util.nop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMvQyxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsMkVBQWdCO0FBQzVELGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBLFlBQVksbUJBQW1COztBQUUvQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvQkFBb0I7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtEQUFrRDs7QUFFOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsNkJBQTZCOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsTUFBTTs7QUFFcEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksV0FBVzs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksMkJBQTJCOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1waXBlbGluZS5qcz9hYjNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIFJlYWRhYmxlLFxuICBEdXBsZXgsXG4gIFBhc3NUaHJvdWdoXG59ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ2FzeW5jX2hvb2tzJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbmNvbnN0IGtSZXN1bWUgPSBTeW1ib2woJ3Jlc3VtZScpXG5cbmNsYXNzIFBpcGVsaW5lUmVxdWVzdCBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKHsgYXV0b0Rlc3Ryb3k6IHRydWUgfSlcblxuICAgIHRoaXNba1Jlc3VtZV0gPSBudWxsXG4gIH1cblxuICBfcmVhZCAoKSB7XG4gICAgY29uc3QgeyBba1Jlc3VtZV06IHJlc3VtZSB9ID0gdGhpc1xuXG4gICAgaWYgKHJlc3VtZSkge1xuICAgICAgdGhpc1trUmVzdW1lXSA9IG51bGxcbiAgICAgIHJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9yZWFkKClcblxuICAgIGNhbGxiYWNrKGVycilcbiAgfVxufVxuXG5jbGFzcyBQaXBlbGluZVJlc3BvbnNlIGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAocmVzdW1lKSB7XG4gICAgc3VwZXIoeyBhdXRvRGVzdHJveTogdHJ1ZSB9KVxuICAgIHRoaXNba1Jlc3VtZV0gPSByZXN1bWVcbiAgfVxuXG4gIF9yZWFkICgpIHtcbiAgICB0aGlzW2tSZXN1bWVdKClcbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKGVycilcbiAgfVxufVxuXG5jbGFzcyBQaXBlbGluZUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGFuZGxlcicpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0c1xuXG4gICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgIH1cblxuICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBzdXBlcignVU5ESUNJX1BJUEVMSU5FJylcblxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlclxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcblxuICAgIHRoaXMucmVxID0gbmV3IFBpcGVsaW5lUmVxdWVzdCgpLm9uKCdlcnJvcicsIHV0aWwubm9wKVxuXG4gICAgdGhpcy5yZXQgPSBuZXcgRHVwbGV4KHtcbiAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogb3B0cy5vYmplY3RNb2RlLFxuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICByZWFkOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYm9keSB9ID0gdGhpc1xuXG4gICAgICAgIGlmIChib2R5ICYmIGJvZHkucmVzdW1lKSB7XG4gICAgICAgICAgYm9keS5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGU6IChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVxIH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKHJlcS5wdXNoKGNodW5rLCBlbmNvZGluZykgfHwgcmVxLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXFba1Jlc3VtZV0gPSBjYWxsYmFja1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogKGVyciwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgeyBib2R5LCByZXEsIHJlcywgcmV0LCBhYm9ydCB9ID0gdGhpc1xuXG4gICAgICAgIGlmICghZXJyICYmICFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYm9ydCAmJiBlcnIpIHtcbiAgICAgICAgICBhYm9ydCgpXG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgICAgICB1dGlsLmRlc3Ryb3kocmVxLCBlcnIpXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcblxuICAgICAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgfSkub24oJ3ByZWZpbmlzaCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVxIH0gPSB0aGlzXG5cbiAgICAgIC8vIE5vZGUgPCAxNSBkb2VzIG5vdCBjYWxsIF9maW5hbCBpbiBzYW1lIHRpY2suXG4gICAgICByZXEucHVzaChudWxsKVxuICAgIH0pXG5cbiAgICB0aGlzLnJlcyA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyByZXQsIHJlcyB9ID0gdGhpc1xuXG4gICAgYXNzZXJ0KCFyZXMsICdwaXBlbGluZSBjYW5ub3QgYmUgcmV0cmllZCcpXG5cbiAgICBpZiAocmV0LmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lKSB7XG4gICAgY29uc3QgeyBvcGFxdWUsIGhhbmRsZXIsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnJlcyA9IG5ldyBQaXBlbGluZVJlc3BvbnNlKHJlc3VtZSlcblxuICAgIGxldCBib2R5XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaGFuZGxlciA9IG51bGxcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgICBib2R5ID0gdGhpcy5ydW5JbkFzeW5jU2NvcGUoaGFuZGxlciwgbnVsbCwge1xuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBvcGFxdWUsXG4gICAgICAgIGJvZHk6IHRoaXMucmVzLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5yZXMub24oJ2Vycm9yJywgdXRpbC5ub3ApXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkub24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcignZXhwZWN0ZWQgUmVhZGFibGUnKVxuICAgIH1cblxuICAgIGJvZHlcbiAgICAgIC5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCwgYm9keSB9ID0gdGhpc1xuXG4gICAgICAgIGlmICghcmV0LnB1c2goY2h1bmspICYmIGJvZHkucGF1c2UpIHtcbiAgICAgICAgICBib2R5LnBhdXNlKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgdXRpbC5kZXN0cm95KHJldCwgZXJyKVxuICAgICAgfSlcbiAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIHJldC5wdXNoKG51bGwpXG4gICAgICB9KVxuICAgICAgLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIXJldC5fcmVhZGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICAgIHV0aWwuZGVzdHJveShyZXQsIG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcbiAgICByZXR1cm4gcmVzLnB1c2goY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG4gICAgcmVzLnB1c2gobnVsbClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG4gICAgdGhpcy5oYW5kbGVyID0gbnVsbFxuICAgIHV0aWwuZGVzdHJveShyZXQsIGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBwaXBlbGluZSAob3B0cywgaGFuZGxlcikge1xuICB0cnkge1xuICAgIGNvbnN0IHBpcGVsaW5lSGFuZGxlciA9IG5ldyBQaXBlbGluZUhhbmRsZXIob3B0cywgaGFuZGxlcilcbiAgICB0aGlzLmRpc3BhdGNoKHsgLi4ub3B0cywgYm9keTogcGlwZWxpbmVIYW5kbGVyLnJlcSB9LCBwaXBlbGluZUhhbmRsZXIpXG4gICAgcmV0dXJuIHBpcGVsaW5lSGFuZGxlci5yZXRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaCgpLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-request.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Readable = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/undici/lib/api/readable.js\")\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/api/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError\n    this.highWaterMark = highWaterMark\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n    const contentType = parsedHeaders['content-type']\n    const body = new Readable({ resume, abort, contentType, highWaterMark })\n\n    this.callback = null\n    this.res = body\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null,\n          { callback, body, contentType, statusCode, statusMessage, headers }\n        )\n      } else {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body,\n          context\n        })\n      }\n    }\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    util.parseHeaders(trailers, this.trailers)\n\n    res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosaUJBQWlCLG1CQUFPLENBQUMsbUVBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyxrRUFBYztBQUNuQyxRQUFRLDhCQUE4QixFQUFFLG1CQUFPLENBQUMsMkRBQVE7QUFDeEQsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQy9DLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxxRkFBcUY7O0FBRWpHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtRUFBbUU7O0FBRS9FOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLDJDQUEyQzs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTs7QUFFbEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksOEJBQThCOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktcmVxdWVzdC5qcz8zYWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ2FzeW5jX2hvb2tzJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgUmVxdWVzdEhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMsIHRocm93T25FcnJvciwgaGlnaFdhdGVyTWFyayB9ID0gb3B0c1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgaWYgKGhpZ2hXYXRlck1hcmsgJiYgKHR5cGVvZiBoaWdoV2F0ZXJNYXJrICE9PSAnbnVtYmVyJyB8fCBoaWdoV2F0ZXJNYXJrIDwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhpZ2hXYXRlck1hcmsnKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtZXRob2QnKVxuICAgICAgfVxuXG4gICAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSW5mbyBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIHN1cGVyKCdVTkRJQ0lfUkVRVUVTVCcpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keS5vbignZXJyb3InLCB1dGlsLm5vcCksIGVycilcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5yZXMgPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgdGhpcy50cmFpbGVycyA9IHt9XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcbiAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvclxuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGhpZ2hXYXRlck1hcmtcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICBib2R5Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgYWJvcnQsIGNvbnRleHQsIHJlc3BvbnNlSGVhZGVycywgaGlnaFdhdGVyTWFyayB9ID0gdGhpc1xuXG4gICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSA6IGhlYWRlcnNcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnNlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgY29uc3QgYm9keSA9IG5ldyBSZWFkYWJsZSh7IHJlc3VtZSwgYWJvcnQsIGNvbnRlbnRUeXBlLCBoaWdoV2F0ZXJNYXJrIH0pXG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgIHRoaXMucmVzID0gYm9keVxuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMudGhyb3dPbkVycm9yICYmIHN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjaywgbnVsbCxcbiAgICAgICAgICB7IGNhbGxiYWNrLCBib2R5LCBjb250ZW50VHlwZSwgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycyB9XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHRyYWlsZXJzOiB0aGlzLnRyYWlsZXJzLFxuICAgICAgICAgIG9wYXF1ZSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcbiAgICByZXR1cm4gcmVzLnB1c2goY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHV0aWwucGFyc2VIZWFkZXJzKHRyYWlsZXJzLCB0aGlzLnRyYWlsZXJzKVxuXG4gICAgcmVzLnB1c2gobnVsbClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmVzLCBjYWxsYmFjaywgYm9keSwgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgLy8gVE9ETzogRG9lcyB0aGlzIG5lZWQgcXVldWVNaWNyb3Rhc2s/XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVzKSB7XG4gICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgIC8vIEVuc3VyZSBhbGwgcXVldWVkIGhhbmRsZXJzIGFyZSBpbnZva2VkIGJlZm9yZSBkZXN0cm95aW5nIHJlcy5cbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdCAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmRpc3BhdGNoKG9wdHMsIG5ldyBSZXF1ZXN0SGFuZGxlcihvcHRzLCBjYWxsYmFjaykpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzICYmIG9wdHMub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVlc3RcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/api/api-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { finished, PassThrough } = __webpack_require__(/*! stream */ \"stream\")\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/api/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError || false\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { factory, opaque, context, callback, responseHeaders } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n\n    let res\n\n    if (this.throwOnError && statusCode >= 400) {\n      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n      const contentType = parsedHeaders['content-type']\n      res = new PassThrough()\n\n      this.callback = null\n      this.runInAsyncScope(getResolveErrorBodyCallback, null,\n        { callback, body: res, contentType, statusCode, statusMessage, headers }\n      )\n    } else {\n      if (factory === null) {\n        return\n      }\n\n      res = this.runInAsyncScope(factory, null, {\n        statusCode,\n        headers,\n        opaque,\n        context\n      })\n\n      if (\n        !res ||\n        typeof res.write !== 'function' ||\n        typeof res.end !== 'function' ||\n        typeof res.on !== 'function'\n      ) {\n        throw new InvalidReturnValueError('expected Writable')\n      }\n\n      // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n      finished(res, { readable: false }, (err) => {\n        const { callback, res, opaque, trailers, abort } = this\n\n        this.res = null\n        if (err || !res.readable) {\n          util.destroy(res, err)\n        }\n\n        this.callback = null\n        this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n        if (err) {\n          abort()\n        }\n      })\n    }\n\n    res.on('drain', resume)\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState && res._writableState.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res ? res.write(chunk) : true\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    if (!res) {\n      return\n    }\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsOEJBQThCLEVBQUUsbUJBQU8sQ0FBQywyREFBUTtBQUN4RCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDL0MsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFnQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHNFQUFzRTs7QUFFbEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHNEQUFzRDs7QUFFbEU7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDLGdCQUFnQix5Q0FBeUM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELGtCQUFrQjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNOztBQUVsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksOEJBQThCOztBQUUxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcz9jOGI0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGZpbmlzaGVkLCBQYXNzVGhyb3VnaCB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnYXN5bmNfaG9va3MnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuXG5jbGFzcyBTdHJlYW1IYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgbWV0aG9kLCBvcGFxdWUsIGJvZHksIG9uSW5mbywgcmVzcG9uc2VIZWFkZXJzLCB0aHJvd09uRXJyb3IgfSA9IG9wdHNcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZmFjdG9yeScpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgc3VwZXIoJ1VORElDSV9TVFJFQU0nKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHkub24oJ2Vycm9yJywgdXRpbC5ub3ApLCBlcnIpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMuZmFjdG9yeSA9IGZhY3RvcnlcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnJlcyA9IG51bGxcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLnRyYWlsZXJzID0gbnVsbFxuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3IgfHwgZmFsc2VcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICBib2R5Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IHsgZmFjdG9yeSwgb3BhcXVlLCBjb250ZXh0LCBjYWxsYmFjaywgcmVzcG9uc2VIZWFkZXJzIH0gPSB0aGlzXG5cbiAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZhY3RvcnkgPSBudWxsXG5cbiAgICBsZXQgcmVzXG5cbiAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgIGNvbnN0IHBhcnNlZEhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycykgOiBoZWFkZXJzXG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnNlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgICByZXMgPSBuZXcgUGFzc1Rocm91Z2goKVxuXG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrLCBudWxsLFxuICAgICAgICB7IGNhbGxiYWNrLCBib2R5OiByZXMsIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH1cbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZhY3RvcnkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJlcyA9IHRoaXMucnVuSW5Bc3luY1Njb3BlKGZhY3RvcnksIG51bGwsIHtcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgb3BhcXVlLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KVxuXG4gICAgICBpZiAoXG4gICAgICAgICFyZXMgfHxcbiAgICAgICAgdHlwZW9mIHJlcy53cml0ZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgcmVzLmVuZCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgcmVzLm9uICE9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSZXR1cm5WYWx1ZUVycm9yKCdleHBlY3RlZCBXcml0YWJsZScpXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEF2b2lkIGZpbmlzaGVkLiBJdCByZWdpc3RlcnMgYW4gdW5uZWNlc3NhcnkgYW1vdW50IG9mIGxpc3RlbmVycy5cbiAgICAgIGZpbmlzaGVkKHJlcywgeyByZWFkYWJsZTogZmFsc2UgfSwgKGVycikgPT4ge1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrLCByZXMsIG9wYXF1ZSwgdHJhaWxlcnMsIGFib3J0IH0gPSB0aGlzXG5cbiAgICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICAgIGlmIChlcnIgfHwgIXJlcy5yZWFkYWJsZSkge1xuICAgICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIgfHwgbnVsbCwgeyBvcGFxdWUsIHRyYWlsZXJzIH0pXG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGFib3J0KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXMub24oJ2RyYWluJywgcmVzdW1lKVxuXG4gICAgdGhpcy5yZXMgPSByZXNcblxuICAgIGNvbnN0IG5lZWREcmFpbiA9IHJlcy53cml0YWJsZU5lZWREcmFpbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHJlcy53cml0YWJsZU5lZWREcmFpblxuICAgICAgOiByZXMuX3dyaXRhYmxlU3RhdGUgJiYgcmVzLl93cml0YWJsZVN0YXRlLm5lZWREcmFpblxuXG4gICAgcmV0dXJuIG5lZWREcmFpbiAhPT0gdHJ1ZVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gcmVzID8gcmVzLndyaXRlKGNodW5rKSA6IHRydWVcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudHJhaWxlcnMgPSB1dGlsLnBhcnNlSGVhZGVycyh0cmFpbGVycylcblxuICAgIHJlcy5lbmQoKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXMsIGNhbGxiYWNrLCBvcGFxdWUsIGJvZHkgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5mYWN0b3J5ID0gbnVsbFxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmVhbSAob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc3RyZWFtLmNhbGwodGhpcywgb3B0cywgZmFjdG9yeSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgbmV3IFN0cmVhbUhhbmRsZXIob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cyAmJiBvcHRzLm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJlYW1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-upgrade.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-upgrade.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    assert.strictEqual(statusCode, 101)\n\n    removeSignal(this)\n\n    this.callback = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    this.dispatch({\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSx5REFBeUQsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUMzRixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDNUQsZUFBZSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtDQUFrQzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw0QkFBNEI7O0FBRXhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanM/MDNjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciwgU29ja2V0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnYXN5bmNfaG9va3MnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5jbGFzcyBVcGdyYWRlSGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgb3BhcXVlLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBzdXBlcignVU5ESUNJX1VQR1JBREUnKVxuXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICB9XG5cbiAgb25IZWFkZXJzICgpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2JhZCB1cGdyYWRlJywgbnVsbClcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwoc3RhdHVzQ29kZSwgMTAxKVxuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzb2NrZXQsXG4gICAgICBvcGFxdWUsXG4gICAgICBjb250ZXh0XG4gICAgfSlcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGdyYWRlIChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1cGdyYWRlLmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHVwZ3JhZGVIYW5kbGVyID0gbmV3IFVwZ3JhZGVIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKVxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICB1cGdyYWRlOiBvcHRzLnByb3RvY29sIHx8ICdXZWJzb2NrZXQnXG4gICAgfSwgdXBncmFkZUhhbmRsZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzICYmIG9wdHMub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZ3JhZGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/api/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(ssr)/./node_modules/undici/lib/api/api-request.js\")\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(ssr)/./node_modules/undici/lib/api/api-stream.js\")\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(ssr)/./node_modules/undici/lib/api/api-pipeline.js\")\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(ssr)/./node_modules/undici/lib/api/api-upgrade.js\")\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(ssr)/./node_modules/undici/lib/api/api-connect.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosdUhBQWlEO0FBQ2pELG9IQUErQztBQUMvQywwSEFBbUQ7QUFDbkQsdUhBQWlEO0FBQ2pELHVIQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9pbmRleC5qcz80MzQ5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cy5yZXF1ZXN0ID0gcmVxdWlyZSgnLi9hcGktcmVxdWVzdCcpXG5tb2R1bGUuZXhwb3J0cy5zdHJlYW0gPSByZXF1aXJlKCcuL2FwaS1zdHJlYW0nKVxubW9kdWxlLmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2FwaS1waXBlbGluZScpXG5tb2R1bGUuZXhwb3J0cy51cGdyYWRlID0gcmVxdWlyZSgnLi9hcGktdXBncmFkZScpXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gcmVxdWlyZSgnLi9hcGktY29ubmVjdCcpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/readable.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/api/readable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/nodejs/undici/pull/907\n\n\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\")\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { ReadableStreamFrom, toUSVString } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\nlet Blob\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('abort')\nconst kContentType = Symbol('kContentType')\n\nmodule.exports = class BodyReadable extends Readable {\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  emit (ev, ...args) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true\n    }\n    return super.emit(ev, ...args)\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144\n    const signal = opts && opts.signal\n    const abortFn = () => {\n      this.destroy()\n    }\n    let signalListenerCleanup\n    if (signal) {\n      if (typeof signal !== 'object' || !('aborted' in signal)) {\n        throw new InvalidArgumentError('signal must be an AbortSignal')\n      }\n      util.throwIfAborted(signal)\n      signalListenerCleanup = util.addAbortListener(signal, abortFn)\n    }\n    try {\n      for await (const chunk of this) {\n        util.throwIfAborted(signal)\n        limit -= Buffer.byteLength(chunk)\n        if (limit < 0) {\n          return\n        }\n      }\n    } catch {\n      util.throwIfAborted(signal)\n    } finally {\n      if (typeof signalListenerCleanup === 'function') {\n        signalListenerCleanup()\n      } else if (signalListenerCleanup) {\n        signalListenerCleanup[Symbol.dispose]()\n      }\n    }\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable')\n  }\n\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    }\n\n    stream\n      .on('error', function (err) {\n        consumeFinish(this[kConsume], err)\n      })\n      .on('close', function () {\n        if (this[kConsume].body !== null) {\n          consumeFinish(this[kConsume], new RequestAbortedError())\n        }\n      })\n\n    process.nextTick(consumeStart, stream[kConsume])\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk)\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)))\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst.buffer)\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = (__webpack_require__(/*! buffer */ \"buffer\").Blob)\n      }\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsUUFBUSwrREFBK0QsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUNqRyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxrQ0FBa0MsRUFBRSxtQkFBTyxDQUFDLGtFQUFjOztBQUVsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx3QkFBd0I7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHNDQUFzQzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQSxlQUFlLGtEQUFzQjtBQUNyQztBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0Q7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9yZWFkYWJsZS5qcz9hYWI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvOTA3XG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHsgUmVxdWVzdEFib3J0ZWRFcnJvciwgTm90U3VwcG9ydGVkRXJyb3IsIEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgUmVhZGFibGVTdHJlYW1Gcm9tLCB0b1VTVlN0cmluZyB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxubGV0IEJsb2JcblxuY29uc3Qga0NvbnN1bWUgPSBTeW1ib2woJ2tDb25zdW1lJylcbmNvbnN0IGtSZWFkaW5nID0gU3ltYm9sKCdrUmVhZGluZycpXG5jb25zdCBrQm9keSA9IFN5bWJvbCgna0JvZHknKVxuY29uc3Qga0Fib3J0ID0gU3ltYm9sKCdhYm9ydCcpXG5jb25zdCBrQ29udGVudFR5cGUgPSBTeW1ib2woJ2tDb250ZW50VHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQm9keVJlYWRhYmxlIGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAoe1xuICAgIHJlc3VtZSxcbiAgICBhYm9ydCxcbiAgICBjb250ZW50VHlwZSA9ICcnLFxuICAgIGhpZ2hXYXRlck1hcmsgPSA2NCAqIDEwMjQgLy8gU2FtZSBhcyBub2RlanMgZnMgc3RyZWFtcy5cbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgcmVhZDogcmVzdW1lLFxuICAgICAgaGlnaFdhdGVyTWFya1xuICAgIH0pXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkID0gZmFsc2VcblxuICAgIHRoaXNba0Fib3J0XSA9IGFib3J0XG4gICAgdGhpc1trQ29uc3VtZV0gPSBudWxsXG4gICAgdGhpc1trQm9keV0gPSBudWxsXG4gICAgdGhpc1trQ29udGVudFR5cGVdID0gY29udGVudFR5cGVcblxuICAgIC8vIElzIHN0cmVhbSBiZWluZyBjb25zdW1lZCB0aHJvdWdoIFJlYWRhYmxlIEFQST9cbiAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB0aGF0IHdlIGF2b2lkIGNoZWNraW5nXG4gICAgLy8gZm9yICdkYXRhJyBhbmQgJ3JlYWRhYmxlJyBsaXN0ZW5lcnMgaW4gdGhlIGhvdCBwYXRoXG4gICAgLy8gaW5zaWRlIHB1c2goKS5cbiAgICB0aGlzW2tSZWFkaW5nXSA9IGZhbHNlXG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIE5vZGUgPCAxNlxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBpZiAoIWVyciAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKGVycikge1xuICAgICAgdGhpc1trQWJvcnRdKClcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuZGVzdHJveShlcnIpXG4gIH1cblxuICBlbWl0IChldiwgLi4uYXJncykge1xuICAgIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICAvLyBOb2RlIDwgMTYuN1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnZXJyb3InKSB7XG4gICAgICAvLyBOb2RlIDwgMTZcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncylcbiAgfVxuXG4gIG9uIChldiwgLi4uYXJncykge1xuICAgIGlmIChldiA9PT0gJ2RhdGEnIHx8IGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgICB0aGlzW2tSZWFkaW5nXSA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLm9uKGV2LCAuLi5hcmdzKVxuICB9XG5cbiAgYWRkTGlzdGVuZXIgKGV2LCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBvZmYgKGV2LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgcmV0ID0gc3VwZXIub2ZmKGV2LCAuLi5hcmdzKVxuICAgIGlmIChldiA9PT0gJ2RhdGEnIHx8IGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgICB0aGlzW2tSZWFkaW5nXSA9IChcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwIHx8XG4gICAgICAgIHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDBcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgcmVtb3ZlTGlzdGVuZXIgKGV2LCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMub2ZmKGV2LCAuLi5hcmdzKVxuICB9XG5cbiAgcHVzaCAoY2h1bmspIHtcbiAgICBpZiAodGhpc1trQ29uc3VtZV0gJiYgY2h1bmsgIT09IG51bGwgJiYgdGhpcy5yZWFkYWJsZUxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3VtZVB1c2godGhpc1trQ29uc3VtZV0sIGNodW5rKVxuICAgICAgcmV0dXJuIHRoaXNba1JlYWRpbmddID8gc3VwZXIucHVzaChjaHVuaykgOiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wdXNoKGNodW5rKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LXRleHRcbiAgYXN5bmMgdGV4dCAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ3RleHQnKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWpzb25cbiAgYXN5bmMganNvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2pzb24nKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJsb2JcbiAgYXN5bmMgYmxvYiAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2Jsb2InKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWFycmF5YnVmZmVyXG4gIGFzeW5jIGFycmF5QnVmZmVyICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnYXJyYXlCdWZmZXInKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWZvcm1kYXRhXG4gIGFzeW5jIGZvcm1EYXRhICgpIHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQuXG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ib2R5dXNlZFxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHJldHVybiB1dGlsLmlzRGlzdHVyYmVkKHRoaXMpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYm9keVxuICBnZXQgYm9keSAoKSB7XG4gICAgaWYgKCF0aGlzW2tCb2R5XSkge1xuICAgICAgdGhpc1trQm9keV0gPSBSZWFkYWJsZVN0cmVhbUZyb20odGhpcylcbiAgICAgIGlmICh0aGlzW2tDb25zdW1lXSkge1xuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIHRoZSBiZXN0IHdheSB0byBmb3JjZSBhIGxvY2s/XG4gICAgICAgIHRoaXNba0JvZHldLmdldFJlYWRlcigpIC8vIEVuc3VyZSBzdHJlYW0gaXMgbG9ja2VkLlxuICAgICAgICBhc3NlcnQodGhpc1trQm9keV0ubG9ja2VkKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1trQm9keV1cbiAgfVxuXG4gIGFzeW5jIGR1bXAgKG9wdHMpIHtcbiAgICBsZXQgbGltaXQgPSBvcHRzICYmIE51bWJlci5pc0Zpbml0ZShvcHRzLmxpbWl0KSA/IG9wdHMubGltaXQgOiAyNjIxNDRcbiAgICBjb25zdCBzaWduYWwgPSBvcHRzICYmIG9wdHMuc2lnbmFsXG4gICAgY29uc3QgYWJvcnRGbiA9ICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfVxuICAgIGxldCBzaWduYWxMaXN0ZW5lckNsZWFudXBcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAodHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEFib3J0U2lnbmFsJylcbiAgICAgIH1cbiAgICAgIHV0aWwudGhyb3dJZkFib3J0ZWQoc2lnbmFsKVxuICAgICAgc2lnbmFsTGlzdGVuZXJDbGVhbnVwID0gdXRpbC5hZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgYWJvcnRGbilcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdGhpcykge1xuICAgICAgICB1dGlsLnRocm93SWZBYm9ydGVkKHNpZ25hbClcbiAgICAgICAgbGltaXQgLT0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspXG4gICAgICAgIGlmIChsaW1pdCA8IDApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgdXRpbC50aHJvd0lmQWJvcnRlZChzaWduYWwpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0eXBlb2Ygc2lnbmFsTGlzdGVuZXJDbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNpZ25hbExpc3RlbmVyQ2xlYW51cCgpXG4gICAgICB9IGVsc2UgaWYgKHNpZ25hbExpc3RlbmVyQ2xlYW51cCkge1xuICAgICAgICBzaWduYWxMaXN0ZW5lckNsZWFudXBbU3ltYm9sLmRpc3Bvc2VdKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW0tbG9ja2VkXG5mdW5jdGlvbiBpc0xvY2tlZCAoc2VsZikge1xuICAvLyBDb25zdW1lIGlzIGFuIGltcGxpY2l0IGxvY2suXG4gIHJldHVybiAoc2VsZltrQm9keV0gJiYgc2VsZltrQm9keV0ubG9ja2VkID09PSB0cnVlKSB8fCBzZWxmW2tDb25zdW1lXVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS11bnVzYWJsZVxuZnVuY3Rpb24gaXNVbnVzYWJsZSAoc2VsZikge1xuICByZXR1cm4gdXRpbC5pc0Rpc3R1cmJlZChzZWxmKSB8fCBpc0xvY2tlZChzZWxmKVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lIChzdHJlYW0sIHR5cGUpIHtcbiAgaWYgKGlzVW51c2FibGUoc3RyZWFtKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VudXNhYmxlJylcbiAgfVxuXG4gIGFzc2VydCghc3RyZWFtW2tDb25zdW1lXSlcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHN0cmVhbVtrQ29uc3VtZV0gPSB7XG4gICAgICB0eXBlLFxuICAgICAgc3RyZWFtLFxuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICAgIGxlbmd0aDogMCxcbiAgICAgIGJvZHk6IFtdXG4gICAgfVxuXG4gICAgc3RyZWFtXG4gICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjb25zdW1lRmluaXNoKHRoaXNba0NvbnN1bWVdLCBlcnIpXG4gICAgICB9KVxuICAgICAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXNba0NvbnN1bWVdLmJvZHkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdW1lRmluaXNoKHRoaXNba0NvbnN1bWVdLCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjb25zdW1lU3RhcnQsIHN0cmVhbVtrQ29uc3VtZV0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVTdGFydCAoY29uc3VtZSkge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB7IF9yZWFkYWJsZVN0YXRlOiBzdGF0ZSB9ID0gY29uc3VtZS5zdHJlYW1cblxuICBmb3IgKGNvbnN0IGNodW5rIG9mIHN0YXRlLmJ1ZmZlcikge1xuICAgIGNvbnN1bWVQdXNoKGNvbnN1bWUsIGNodW5rKVxuICB9XG5cbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBjb25zdW1lRW5kKHRoaXNba0NvbnN1bWVdKVxuICB9IGVsc2Uge1xuICAgIGNvbnN1bWUuc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdW1lRW5kKHRoaXNba0NvbnN1bWVdKVxuICAgIH0pXG4gIH1cblxuICBjb25zdW1lLnN0cmVhbS5yZXN1bWUoKVxuXG4gIHdoaWxlIChjb25zdW1lLnN0cmVhbS5yZWFkKCkgIT0gbnVsbCkge1xuICAgIC8vIExvb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdW1lRW5kIChjb25zdW1lKSB7XG4gIGNvbnN0IHsgdHlwZSwgYm9keSwgcmVzb2x2ZSwgc3RyZWFtLCBsZW5ndGggfSA9IGNvbnN1bWVcblxuICB0cnkge1xuICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHJlc29sdmUodG9VU1ZTdHJpbmcoQnVmZmVyLmNvbmNhdChib2R5KSkpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnanNvbicpIHtcbiAgICAgIHJlc29sdmUoSlNPTi5wYXJzZShCdWZmZXIuY29uY2F0KGJvZHkpKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheUJ1ZmZlcicpIHtcbiAgICAgIGNvbnN0IGRzdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcblxuICAgICAgbGV0IHBvcyA9IDBcbiAgICAgIGZvciAoY29uc3QgYnVmIG9mIGJvZHkpIHtcbiAgICAgICAgZHN0LnNldChidWYsIHBvcylcbiAgICAgICAgcG9zICs9IGJ1Zi5ieXRlTGVuZ3RoXG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoZHN0LmJ1ZmZlcilcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdibG9iJykge1xuICAgICAgaWYgKCFCbG9iKSB7XG4gICAgICAgIEJsb2IgPSByZXF1aXJlKCdidWZmZXInKS5CbG9iXG4gICAgICB9XG4gICAgICByZXNvbHZlKG5ldyBCbG9iKGJvZHksIHsgdHlwZTogc3RyZWFtW2tDb250ZW50VHlwZV0gfSkpXG4gICAgfVxuXG4gICAgY29uc3VtZUZpbmlzaChjb25zdW1lKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3VtZVB1c2ggKGNvbnN1bWUsIGNodW5rKSB7XG4gIGNvbnN1bWUubGVuZ3RoICs9IGNodW5rLmxlbmd0aFxuICBjb25zdW1lLmJvZHkucHVzaChjaHVuaylcbn1cblxuZnVuY3Rpb24gY29uc3VtZUZpbmlzaCAoY29uc3VtZSwgZXJyKSB7XG4gIGlmIChjb25zdW1lLmJvZHkgPT09IG51bGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChlcnIpIHtcbiAgICBjb25zdW1lLnJlamVjdChlcnIpXG4gIH0gZWxzZSB7XG4gICAgY29uc3VtZS5yZXNvbHZlKClcbiAgfVxuXG4gIGNvbnN1bWUudHlwZSA9IG51bGxcbiAgY29uc3VtZS5zdHJlYW0gPSBudWxsXG4gIGNvbnN1bWUucmVzb2x2ZSA9IG51bGxcbiAgY29uc3VtZS5yZWplY3QgPSBudWxsXG4gIGNvbnN1bWUubGVuZ3RoID0gMFxuICBjb25zdW1lLmJvZHkgPSBudWxsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/util.js":
/*!*********************************************!*\
  !*** ./node_modules/undici/lib/api/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\")\nconst {\n  ResponseStatusCodeError\n} = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { toUSVString } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\nasync function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {\n  assert(body)\n\n  let chunks = []\n  let limit = 0\n\n  for await (const chunk of body) {\n    chunks.push(chunk)\n    limit += chunk.length\n    if (limit > 128 * 1024) {\n      chunks = null\n      break\n    }\n  }\n\n  if (statusCode === 204 || !contentType || !chunks) {\n    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))\n    return\n  }\n\n  try {\n    if (contentType.startsWith('application/json')) {\n      const payload = JSON.parse(toUSVString(Buffer.concat(chunks)))\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))\n      return\n    }\n\n    if (contentType.startsWith('text/')) {\n      const payload = toUSVString(Buffer.concat(chunks))\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))\n      return\n    }\n  } catch (err) {\n    // Process in a fallback if error\n  }\n\n  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))\n}\n\nmodule.exports = { getResolveErrorBodyCallback }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM1QixRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLGtFQUFjOztBQUU5Qyw4Q0FBOEMsaUVBQWlFO0FBQy9HOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1GQUFtRixXQUFXLEVBQUUscUJBQXFCLGNBQWMsT0FBTztBQUMxSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixXQUFXLEVBQUUscUJBQXFCLGNBQWMsT0FBTztBQUM1STtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRkFBcUYsV0FBVyxFQUFFLHFCQUFxQixjQUFjLE9BQU87QUFDNUk7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlGQUFpRixXQUFXLEVBQUUscUJBQXFCLGNBQWMsT0FBTztBQUN4STs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvdXRpbC5qcz8yOTJlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7XG4gIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyB0b1VTVlN0cmluZyB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrICh7IGNhbGxiYWNrLCBib2R5LCBjb250ZW50VHlwZSwgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycyB9KSB7XG4gIGFzc2VydChib2R5KVxuXG4gIGxldCBjaHVua3MgPSBbXVxuICBsZXQgbGltaXQgPSAwXG5cbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG4gICAgY2h1bmtzLnB1c2goY2h1bmspXG4gICAgbGltaXQgKz0gY2h1bmsubGVuZ3RoXG4gICAgaWYgKGxpbWl0ID4gMTI4ICogMTAyNCkge1xuICAgICAgY2h1bmtzID0gbnVsbFxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdHVzQ29kZSA9PT0gMjA0IHx8ICFjb250ZW50VHlwZSB8fCAhY2h1bmtzKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKGBSZXNwb25zZSBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9JHtzdGF0dXNNZXNzYWdlID8gYDogJHtzdGF0dXNNZXNzYWdlfWAgOiAnJ31gLCBzdGF0dXNDb2RlLCBoZWFkZXJzKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UodG9VU1ZTdHJpbmcoQnVmZmVyLmNvbmNhdChjaHVua3MpKSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogJyd9YCwgc3RhdHVzQ29kZSwgaGVhZGVycywgcGF5bG9hZCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY29udGVudFR5cGUuc3RhcnRzV2l0aCgndGV4dC8nKSkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHRvVVNWU3RyaW5nKEJ1ZmZlci5jb25jYXQoY2h1bmtzKSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogJyd9YCwgc3RhdHVzQ29kZSwgaGVhZGVycywgcGF5bG9hZCkpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFByb2Nlc3MgaW4gYSBmYWxsYmFjayBpZiBlcnJvclxuICB9XG5cbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKGBSZXNwb25zZSBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9JHtzdGF0dXNNZXNzYWdlID8gYDogJHtzdGF0dXNNZXNzYWdlfWAgOiAnJ31gLCBzdGF0dXNDb2RlLCBoZWFkZXJzKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/balanced-pool.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/balanced-pool.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/undici/lib/pool-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/pool.js\")\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { parseOrigin } = __webpack_require__(/*! ./core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\nfunction getGreatestCommonDivisor (a, b) {\n  if (b === 0) return a\n  return getGreatestCommonDivisor(b, a % b)\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)\n      ? opts.interceptors.BalancedPool\n      : []\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0)\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9iYWxhbmNlZC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHFFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQWE7QUFDekIsYUFBYSxtQkFBTyxDQUFDLHVEQUFRO0FBQzdCLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx1RUFBZ0I7QUFDeEQsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyxpRUFBYTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsb0NBQW9DLElBQUk7QUFDekU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYmFsYW5jZWQtcG9vbC5qcz9hYzlkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvclxufSA9IHJlcXVpcmUoJy4vY29yZS9lcnJvcnMnKVxuY29uc3Qge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59ID0gcmVxdWlyZSgnLi9wb29sLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCB7IGtVcmwsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgcGFyc2VPcmlnaW4gfSA9IHJlcXVpcmUoJy4vY29yZS91dGlsJylcbmNvbnN0IGtGYWN0b3J5ID0gU3ltYm9sKCdmYWN0b3J5JylcblxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuY29uc3Qga0dyZWF0ZXN0Q29tbW9uRGl2aXNvciA9IFN5bWJvbCgna0dyZWF0ZXN0Q29tbW9uRGl2aXNvcicpXG5jb25zdCBrQ3VycmVudFdlaWdodCA9IFN5bWJvbCgna0N1cnJlbnRXZWlnaHQnKVxuY29uc3Qga0luZGV4ID0gU3ltYm9sKCdrSW5kZXgnKVxuY29uc3Qga1dlaWdodCA9IFN5bWJvbCgna1dlaWdodCcpXG5jb25zdCBrTWF4V2VpZ2h0UGVyU2VydmVyID0gU3ltYm9sKCdrTWF4V2VpZ2h0UGVyU2VydmVyJylcbmNvbnN0IGtFcnJvclBlbmFsdHkgPSBTeW1ib2woJ2tFcnJvclBlbmFsdHknKVxuXG5mdW5jdGlvbiBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IgKGEsIGIpIHtcbiAgaWYgKGIgPT09IDApIHJldHVybiBhXG4gIHJldHVybiBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IoYiwgYSAlIGIpXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgQmFsYW5jZWRQb29sIGV4dGVuZHMgUG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciAodXBzdHJlYW1zID0gW10sIHsgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LCAuLi5vcHRzIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba09wdGlvbnNdID0gb3B0c1xuICAgIHRoaXNba0luZGV4XSA9IC0xXG4gICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSAwXG5cbiAgICB0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdID0gdGhpc1trT3B0aW9uc10ubWF4V2VpZ2h0UGVyU2VydmVyIHx8IDEwMFxuICAgIHRoaXNba0Vycm9yUGVuYWx0eV0gPSB0aGlzW2tPcHRpb25zXS5lcnJvclBlbmFsdHkgfHwgMTVcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh1cHN0cmVhbXMpKSB7XG4gICAgICB1cHN0cmVhbXMgPSBbdXBzdHJlYW1zXVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBvcHRzLmludGVyY2VwdG9ycyAmJiBvcHRzLmludGVyY2VwdG9ycy5CYWxhbmNlZFBvb2wgJiYgQXJyYXkuaXNBcnJheShvcHRzLmludGVyY2VwdG9ycy5CYWxhbmNlZFBvb2wpXG4gICAgICA/IG9wdHMuaW50ZXJjZXB0b3JzLkJhbGFuY2VkUG9vbFxuICAgICAgOiBbXVxuICAgIHRoaXNba0ZhY3RvcnldID0gZmFjdG9yeVxuXG4gICAgZm9yIChjb25zdCB1cHN0cmVhbSBvZiB1cHN0cmVhbXMpIHtcbiAgICAgIHRoaXMuYWRkVXBzdHJlYW0odXBzdHJlYW0pXG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcbiAgfVxuXG4gIGFkZFVwc3RyZWFtICh1cHN0cmVhbSkge1xuICAgIGNvbnN0IHVwc3RyZWFtT3JpZ2luID0gcGFyc2VPcmlnaW4odXBzdHJlYW0pLm9yaWdpblxuXG4gICAgaWYgKHRoaXNba0NsaWVudHNdLmZpbmQoKHBvb2wpID0+IChcbiAgICAgIHBvb2xba1VybF0ub3JpZ2luID09PSB1cHN0cmVhbU9yaWdpbiAmJlxuICAgICAgcG9vbC5jbG9zZWQgIT09IHRydWUgJiZcbiAgICAgIHBvb2wuZGVzdHJveWVkICE9PSB0cnVlXG4gICAgKSkpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tGYWN0b3J5XSh1cHN0cmVhbU9yaWdpbiwgT2JqZWN0LmFzc2lnbih7fSwgdGhpc1trT3B0aW9uc10pKVxuXG4gICAgdGhpc1trQWRkQ2xpZW50XShwb29sKVxuICAgIHBvb2wub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBwb29sW2tXZWlnaHRdID0gTWF0aC5taW4odGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXSwgcG9vbFtrV2VpZ2h0XSArIHRoaXNba0Vycm9yUGVuYWx0eV0pXG4gICAgfSlcblxuICAgIHBvb2wub24oJ2Nvbm5lY3Rpb25FcnJvcicsICgpID0+IHtcbiAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcbiAgICB9KVxuXG4gICAgcG9vbC5vbignZGlzY29ubmVjdCcsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBhcmdzWzJdXG4gICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnVU5EX0VSUl9TT0NLRVQnKSB7XG4gICAgICAgIC8vIGRlY3JlYXNlIHRoZSB3ZWlnaHQgb2YgdGhlIHBvb2wuXG4gICAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgY2xpZW50W2tXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMgKCkge1xuICAgIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl0gPSB0aGlzW2tDbGllbnRzXS5tYXAocCA9PiBwW2tXZWlnaHRdKS5yZWR1Y2UoZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yLCAwKVxuICB9XG5cbiAgcmVtb3ZlVXBzdHJlYW0gKHVwc3RyZWFtKSB7XG4gICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luXG5cbiAgICBjb25zdCBwb29sID0gdGhpc1trQ2xpZW50c10uZmluZCgocG9vbCkgPT4gKFxuICAgICAgcG9vbFtrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmXG4gICAgICBwb29sLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgcG9vbC5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuXG4gICAgaWYgKHBvb2wpIHtcbiAgICAgIHRoaXNba1JlbW92ZUNsaWVudF0ocG9vbClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IHVwc3RyZWFtcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdXG4gICAgICAuZmlsdGVyKGRpc3BhdGNoZXIgPT4gZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiYgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWUpXG4gICAgICAubWFwKChwKSA9PiBwW2tVcmxdLm9yaWdpbilcbiAgfVxuXG4gIFtrR2V0RGlzcGF0Y2hlcl0gKCkge1xuICAgIC8vIFdlIHZhbGlkYXRlIHRoYXQgcG9vbHMgaXMgZ3JlYXRlciB0aGFuIDAsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmUgdG8gd2FpdCB1bnRpbCBhbiB1cHN0cmVhbVxuICAgIC8vIGlzIGFkZGVkLCB3aGljaCBtaWdodCBuZXZlciBoYXBwZW4uXG4gICAgaWYgKHRoaXNba0NsaWVudHNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trQ2xpZW50c10uZmluZChkaXNwYXRjaGVyID0+IChcbiAgICAgICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dICYmXG4gICAgICBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhbGxDbGllbnRzQnVzeSA9IHRoaXNba0NsaWVudHNdLm1hcChwb29sID0+IHBvb2xba05lZWREcmFpbl0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKVxuXG4gICAgaWYgKGFsbENsaWVudHNCdXN5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgY291bnRlciA9IDBcblxuICAgIGxldCBtYXhXZWlnaHRJbmRleCA9IHRoaXNba0NsaWVudHNdLmZpbmRJbmRleChwb29sID0+ICFwb29sW2tOZWVkRHJhaW5dKVxuXG4gICAgd2hpbGUgKGNvdW50ZXIrKyA8IHRoaXNba0NsaWVudHNdLmxlbmd0aCkge1xuICAgICAgdGhpc1trSW5kZXhdID0gKHRoaXNba0luZGV4XSArIDEpICUgdGhpc1trQ2xpZW50c10ubGVuZ3RoXG4gICAgICBjb25zdCBwb29sID0gdGhpc1trQ2xpZW50c11bdGhpc1trSW5kZXhdXVxuXG4gICAgICAvLyBmaW5kIHBvb2wgaW5kZXggd2l0aCB0aGUgbGFyZ2VzdCB3ZWlnaHRcbiAgICAgIGlmIChwb29sW2tXZWlnaHRdID4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdW2tXZWlnaHRdICYmICFwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgIG1heFdlaWdodEluZGV4ID0gdGhpc1trSW5kZXhdXG4gICAgICB9XG5cbiAgICAgIC8vIGRlY3JlYXNlIHRoZSBjdXJyZW50IHdlaWdodCBldmVyeSBgdGhpc1trQ2xpZW50c10ubGVuZ3RoYC5cbiAgICAgIGlmICh0aGlzW2tJbmRleF0gPT09IDApIHtcbiAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IHdlaWdodCB0byB0aGUgbmV4dCBsb3dlciB3ZWlnaHQuXG4gICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trQ3VycmVudFdlaWdodF0gLSB0aGlzW2tHcmVhdGVzdENvbW1vbkRpdmlzb3JdXG5cbiAgICAgICAgaWYgKHRoaXNba0N1cnJlbnRXZWlnaHRdIDw9IDApIHtcbiAgICAgICAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IHRoaXNba01heFdlaWdodFBlclNlcnZlcl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvb2xba1dlaWdodF0gPj0gdGhpc1trQ3VycmVudFdlaWdodF0gJiYgKCFwb29sW2tOZWVkRHJhaW5dKSkge1xuICAgICAgICByZXR1cm4gcG9vbFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdW2tXZWlnaHRdXG4gICAgdGhpc1trSW5kZXhdID0gbWF4V2VpZ2h0SW5kZXhcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYWxhbmNlZFBvb2xcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/balanced-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/cache/cache.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/cache/cache.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/cache/symbols.js\")\nconst { urlEquals, fieldValues: getFieldValues } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/cache/util.js\")\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { Response, cloneResponse } = __webpack_require__(/*! ../fetch/response */ \"(ssr)/./node_modules/undici/lib/fetch/response.js\")\nconst { Request } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/fetch/request.js\")\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ../fetch/symbols */ \"(ssr)/./node_modules/undici/lib/fetch/symbols.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/undici/lib/fetch/index.js\")\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(ssr)/./node_modules/undici/lib/global.js\")\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    this.#relevantRequestResponseList = arguments[1]\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.match' })\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    const p = await this.matchAll(request, options)\n\n    if (p.length === 0) {\n      return\n    }\n\n    return p[0]\n  }\n\n  async matchAll (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1])\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = []\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = new Response(response.body?.source ?? null)\n      const body = responseObject[kState].body\n      responseObject[kState] = response\n      responseObject[kState].body = body\n      responseObject[kHeaders][kHeadersList] = response.headersList\n      responseObject[kHeaders][kGuard] = 'immutable'\n\n      responseList.push(responseObject)\n    }\n\n    // 6.\n    return Object.freeze(responseList)\n  }\n\n  async add (request) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.add' })\n\n    request = webidl.converters.RequestInfo(request)\n\n    // 1.\n    const requests = [request]\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests)\n\n    // 3.\n    return await responseArrayPromise\n  }\n\n  async addAll (requests) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.addAll' })\n\n    requests = webidl.converters['sequence<RequestInfo>'](requests)\n\n    // 1.\n    const responsePromises = []\n\n    // 2.\n    const requestList = []\n\n    // 3.\n    for (const request of requests) {\n      if (typeof request === 'string') {\n        continue\n      }\n\n      // 3.1\n      const r = request[kState]\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: 'Cache.addAll',\n          message: 'Expected http/s scheme when method is not GET.'\n        })\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = []\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = new Request(request)[kState]\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: 'Cache.addAll',\n          message: 'Expected http/s scheme.'\n        })\n      }\n\n      // 5.4\n      r.initiator = 'fetch'\n      r.destination = 'subresource'\n\n      // 5.5\n      requestList.push(r)\n\n      // 5.6\n      const responsePromise = createDeferredPromise()\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        dispatcher: getGlobalDispatcher(),\n        processResponse (response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }))\n          } else if (response.headersList.contains('vary')) { // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }))\n\n                for (const controller of fetchControllers) {\n                  controller.abort()\n                }\n\n                return\n              }\n            }\n          }\n        },\n        processResponseEndOfBody (response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'))\n            return\n          }\n\n          // 2.\n          responsePromise.resolve(response)\n        }\n      }))\n\n      // 5.8\n      responsePromises.push(responsePromise.promise)\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises)\n\n    // 7.\n    const responses = await p\n\n    // 7.1\n    const operations = []\n\n    // 7.2\n    let index = 0\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put', // 7.3.2\n        request: requestList[index], // 7.3.3\n        response // 7.3.4\n      }\n\n      operations.push(operation) // 7.3.5\n\n      index++ // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise()\n\n    // 7.6.1\n    let errorData = null\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined)\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    // 7.7\n    return cacheJobPromise.promise\n  }\n\n  async put (request, response) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Cache.put' })\n\n    request = webidl.converters.RequestInfo(request)\n    response = webidl.converters.Response(response)\n\n    // 1.\n    let innerRequest = null\n\n    // 2.\n    if (request instanceof Request) {\n      innerRequest = request[kState]\n    } else { // 3.\n      innerRequest = new Request(request)[kState]\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Expected an http/s scheme when method is not GET'\n      })\n    }\n\n    // 5.\n    const innerResponse = response[kState]\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Got 206 status'\n      })\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: 'Cache.put',\n            message: 'Got * vary field value'\n          })\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Response body is locked or disturbed'\n      })\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse)\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise()\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream\n\n      // 11.2\n      const reader = stream.getReader()\n\n      // 11.3\n      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject)\n    } else {\n      bodyReadPromise.resolve(undefined)\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put', // 14.\n      request: innerRequest, // 15.\n      response: clonedResponse // 16.\n    }\n\n    // 17.\n    operations.push(operation)\n\n    // 19.\n    const bytes = await bodyReadPromise.promise\n\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise()\n\n    // 19.2.1\n    let errorData = null\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve()\n      } else { // 19.2.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  async delete (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.delete' })\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    /**\n     * @type {Request}\n     */\n    let r = null\n\n    if (request instanceof Request) {\n      r = request[kState]\n\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false\n      }\n    } else {\n      assert(typeof request === 'string')\n\n      r = new Request(request)[kState]\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    }\n\n    operations.push(operation)\n\n    const cacheJobPromise = createDeferredPromise()\n\n    let errorData = null\n    let requestResponses\n\n    try {\n      requestResponses = this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length)\n      } else {\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {readonly Request[]}\n   */\n  async keys (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') { // 2.2\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise()\n\n    // 5.\n    // 5.1\n    const requests = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0])\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = []\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = new Request('https://a')\n        requestObject[kState] = request\n        requestObject[kHeaders][kHeadersList] = request.headersList\n        requestObject[kHeaders][kGuard] = 'immutable'\n        requestObject[kRealm] = request.client\n\n        // 5.4.2.1\n        requestList.push(requestObject)\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList))\n    })\n\n    return promise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations (operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList\n\n    // 2.\n    const backupCache = [...cache]\n\n    // 3.\n    const addedItems = []\n\n    // 4.1\n    const resultList = []\n\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          })\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          })\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError')\n        }\n\n        // 4.2.4\n        let requestResponses\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options)\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return []\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1)\n          }\n        } else if (operation.type === 'put') { // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            })\n          }\n\n          // 4.2.6.2\n          const r = operation.request\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            })\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            })\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            })\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request)\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1)\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response])\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response])\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response])\n      }\n\n      // 4.3\n      return resultList\n    } catch (e) { // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache\n\n      // 5.3\n      throw e\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache (requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = []\n\n    const storage = targetStorage ?? this.#relevantRequestResponseList\n\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse)\n      }\n    }\n\n    return resultList\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem (requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url)\n\n    const cachedURL = new URL(request.url)\n\n    if (options?.ignoreSearch) {\n      cachedURL.search = ''\n\n      queryURL.search = ''\n    }\n\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false\n    }\n\n    if (\n      response == null ||\n      options?.ignoreVary ||\n      !response.headersList.contains('vary')\n    ) {\n      return true\n    }\n\n    const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false\n      }\n\n      const requestValue = request.headersList.get(fieldValue)\n      const queryValue = requestQuery.headersList.get(fieldValue)\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nconst cacheQueryOptionConverters = [\n  {\n    key: 'ignoreSearch',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'ignoreMethod',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'ignoreVary',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  }\n]\n\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)\n\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n  ...cacheQueryOptionConverters,\n  {\n    key: 'cacheName',\n    converter: webidl.converters.DOMString\n  }\n])\n\nwebidl.converters.Response = webidl.interfaceConverter(Response)\n\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(\n  webidl.converters.RequestInfo\n)\n\nmodule.exports = {\n  Cache\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLG1FQUFXO0FBQzFDLFFBQVEseUNBQXlDLEVBQUUsbUJBQU8sQ0FBQyw2REFBUTtBQUNuRSxRQUFRLG1DQUFtQyxFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDbkUsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDbEQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDNUMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDRFQUFtQjtBQUMvRCxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDBFQUFrQjtBQUM5QyxRQUFRLG1DQUFtQyxFQUFFLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3ZFLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzdDLFFBQVEsNERBQTRELEVBQUUsbUJBQU8sQ0FBQyxvRUFBZTtBQUM3RixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLDREQUFXOztBQUVuRDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYywrQ0FBK0M7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBLCtDQUErQyx1QkFBdUI7O0FBRXRFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9jYWNoZS5qcz85YjZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHVybEVxdWFscywgZmllbGRWYWx1ZXM6IGdldEZpZWxkVmFsdWVzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5LCBpc0Rpc3R1cmJlZCB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IFJlc3BvbnNlLCBjbG9uZVJlc3BvbnNlIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXNwb25zZScpXG5jb25zdCB7IFJlcXVlc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3JlcXVlc3QnKVxuY29uc3QgeyBrU3RhdGUsIGtIZWFkZXJzLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvc3ltYm9scycpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9pbmRleCcpXG5jb25zdCB7IHVybElzSHR0cEh0dHBzU2NoZW1lLCBjcmVhdGVEZWZlcnJlZFByb21pc2UsIHJlYWRBbGxCeXRlcyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBnZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuLi9nbG9iYWwnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1jYWNoZS1iYXRjaC1vcGVyYXRpb25cbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhY2hlQmF0Y2hPcGVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7J2RlbGV0ZScgfCAncHV0J30gdHlwZVxuICogQHByb3BlcnR5IHthbnl9IHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7YW55fSByZXNwb25zZVxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZXF1ZXN0LXJlc3BvbnNlLWxpc3RcbiAqIEB0eXBlZGVmIHtbYW55LCBhbnldW119IHJlcXVlc3RSZXNwb25zZUxpc3RcbiAqL1xuXG5jbGFzcyBDYWNoZSB7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVsZXZhbnQtcmVxdWVzdC1yZXNwb25zZS1saXN0XG4gICAqIEB0eXBlIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG5cbiAgICB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QgPSBhcmd1bWVudHNbMV1cbiAgfVxuXG4gIGFzeW5jIG1hdGNoIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGUubWF0Y2gnIH0pXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICAgIGNvbnN0IHAgPSBhd2FpdCB0aGlzLm1hdGNoQWxsKHJlcXVlc3QsIG9wdGlvbnMpXG5cbiAgICBpZiAocC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJldHVybiBwWzBdXG4gIH1cblxuICBhc3luYyBtYXRjaEFsbCAocmVxdWVzdCA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICAgIC8vIDEuXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAvLyAyLjEuMVxuICAgICAgICByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgICAgLy8gMi4xLjJcbiAgICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gMi4yLjFcbiAgICAgICAgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LlxuICAgIC8vIDUuMVxuICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdXG5cbiAgICAvLyA1LjJcbiAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyA1LjIuMVxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0KSB7XG4gICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlcXVlc3RSZXNwb25zZVsxXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyA1LjNcbiAgICAgIC8vIDUuMy4xXG4gICAgICBjb25zdCByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShyLCBvcHRpb25zKVxuXG4gICAgICAvLyA1LjMuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICByZXNwb25zZXMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS40XG4gICAgLy8gV2UgZG9uJ3QgaW1wbGVtZW50IENPUnMgc28gd2UgZG9uJ3QgbmVlZCB0byBsb29wIG92ZXIgdGhlIHJlc3BvbnNlcywgeWF5IVxuXG4gICAgLy8gNS41LjFcbiAgICBjb25zdCByZXNwb25zZUxpc3QgPSBbXVxuXG4gICAgLy8gNS41LjJcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgLy8gNS41LjIuMVxuICAgICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UocmVzcG9uc2UuYm9keT8uc291cmNlID8/IG51bGwpXG4gICAgICBjb25zdCBib2R5ID0gcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5ib2R5XG4gICAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdID0gcmVzcG9uc2VcbiAgICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uYm9keSA9IGJvZHlcbiAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gJ2ltbXV0YWJsZSdcblxuICAgICAgcmVzcG9uc2VMaXN0LnB1c2gocmVzcG9uc2VPYmplY3QpXG4gICAgfVxuXG4gICAgLy8gNi5cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXNwb25zZUxpc3QpXG4gIH1cblxuICBhc3luYyBhZGQgKHJlcXVlc3QpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGUuYWRkJyB9KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG5cbiAgICAvLyAxLlxuICAgIGNvbnN0IHJlcXVlc3RzID0gW3JlcXVlc3RdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlc3BvbnNlQXJyYXlQcm9taXNlID0gdGhpcy5hZGRBbGwocmVxdWVzdHMpXG5cbiAgICAvLyAzLlxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZUFycmF5UHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgYWRkQWxsIChyZXF1ZXN0cykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnIH0pXG5cbiAgICByZXF1ZXN0cyA9IHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxSZXF1ZXN0SW5mbz4nXShyZXF1ZXN0cylcblxuICAgIC8vIDEuXG4gICAgY29uc3QgcmVzcG9uc2VQcm9taXNlcyA9IFtdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlcXVlc3RMaXN0ID0gW11cblxuICAgIC8vIDMuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDMuMVxuICAgICAgY29uc3QgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICAvLyAzLjJcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpIHx8IHIubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgaHR0cC9zIHNjaGVtZSB3aGVuIG1ldGhvZCBpcyBub3QgR0VULidcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgZmV0Y2hpbmc+W119ICovXG4gICAgY29uc3QgZmV0Y2hDb250cm9sbGVycyA9IFtdXG5cbiAgICAvLyA1LlxuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgLy8gNS4xXG4gICAgICBjb25zdCByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuXG4gICAgICAvLyA1LjJcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgIG1lc3NhZ2U6ICdFeHBlY3RlZCBodHRwL3Mgc2NoZW1lLidcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gNS40XG4gICAgICByLmluaXRpYXRvciA9ICdmZXRjaCdcbiAgICAgIHIuZGVzdGluYXRpb24gPSAnc3VicmVzb3VyY2UnXG5cbiAgICAgIC8vIDUuNVxuICAgICAgcmVxdWVzdExpc3QucHVzaChyKVxuXG4gICAgICAvLyA1LjZcbiAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAgIC8vIDUuN1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5wdXNoKGZldGNoaW5nKHtcbiAgICAgICAgcmVxdWVzdDogcixcbiAgICAgICAgZGlzcGF0Y2hlcjogZ2V0R2xvYmFsRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gMS5cbiAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNiB8fCByZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID4gMjk5KSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlY2VpdmVkIGFuIGludmFsaWQgc3RhdHVzIGNvZGUgb3IgdGhlIHJlcXVlc3QgZmFpbGVkLidcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKSkgeyAvLyAyLlxuICAgICAgICAgICAgLy8gMi4xXG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgICAgICAgICAvLyAyLjJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgICAgICAgICAvLyAyLjIuMVxuICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdCh3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQgdmFyeSBmaWVsZCB2YWx1ZSdcbiAgICAgICAgICAgICAgICB9KSlcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiBmZXRjaENvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IChyZXNwb25zZSkge1xuICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignYWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyLlxuICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgICB9KSlcblxuICAgICAgLy8gNS44XG4gICAgICByZXNwb25zZVByb21pc2VzLnB1c2gocmVzcG9uc2VQcm9taXNlLnByb21pc2UpXG4gICAgfVxuXG4gICAgLy8gNi5cbiAgICBjb25zdCBwID0gUHJvbWlzZS5hbGwocmVzcG9uc2VQcm9taXNlcylcblxuICAgIC8vIDcuXG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgcFxuXG4gICAgLy8gNy4xXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvLyA3LjJcbiAgICBsZXQgaW5kZXggPSAwXG5cbiAgICAvLyA3LjNcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgLy8gNy4zLjFcbiAgICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ3B1dCcsIC8vIDcuMy4yXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RMaXN0W2luZGV4XSwgLy8gNy4zLjNcbiAgICAgICAgcmVzcG9uc2UgLy8gNy4zLjRcbiAgICAgIH1cblxuICAgICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbikgLy8gNy4zLjVcblxuICAgICAgaW5kZXgrKyAvLyA3LjMuNlxuICAgIH1cblxuICAgIC8vIDcuNVxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyA3LjYuMVxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG5cbiAgICAvLyA3LjYuMlxuICAgIHRyeSB7XG4gICAgICB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICAvLyA3LjYuM1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDcuNi4zLjFcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNy42LjMuMlxuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNy43XG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICBhc3luYyBwdXQgKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ0NhY2hlLnB1dCcgfSlcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIHJlc3BvbnNlID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2UocmVzcG9uc2UpXG5cbiAgICAvLyAxLlxuICAgIGxldCBpbm5lclJlcXVlc3QgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaW5uZXJSZXF1ZXN0ID0gcmVxdWVzdFtrU3RhdGVdXG4gICAgfSBlbHNlIHsgLy8gMy5cbiAgICAgIGlubmVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoaW5uZXJSZXF1ZXN0LnVybCkgfHwgaW5uZXJSZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnQ2FjaGUucHV0JyxcbiAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGFuIGh0dHAvcyBzY2hlbWUgd2hlbiBtZXRob2QgaXMgbm90IEdFVCdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNS5cbiAgICBjb25zdCBpbm5lclJlc3BvbnNlID0gcmVzcG9uc2Vba1N0YXRlXVxuXG4gICAgLy8gNi5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdDYWNoZS5wdXQnLFxuICAgICAgICBtZXNzYWdlOiAnR290IDIwNiBzdGF0dXMnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDcuXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKSkge1xuICAgICAgLy8gNy4xLlxuICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZFZhbHVlcyhpbm5lclJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgICAvLyA3LjIuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgICAgLy8gNy4yLjFcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICcqJykge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLnB1dCcsXG4gICAgICAgICAgICBtZXNzYWdlOiAnR290ICogdmFyeSBmaWVsZCB2YWx1ZSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gOC5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5ib2R5ICYmIChpc0Rpc3R1cmJlZChpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtKSB8fCBpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtLmxvY2tlZCkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnQ2FjaGUucHV0JyxcbiAgICAgICAgbWVzc2FnZTogJ1Jlc3BvbnNlIGJvZHkgaXMgbG9ja2VkIG9yIGRpc3R1cmJlZCdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gOS5cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IGNsb25lUmVzcG9uc2UoaW5uZXJSZXNwb25zZSlcblxuICAgIC8vIDEwLlxuICAgIGNvbnN0IGJvZHlSZWFkUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyAxMS5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDExLjFcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW1cblxuICAgICAgLy8gMTEuMlxuICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG5cbiAgICAgIC8vIDExLjNcbiAgICAgIHJlYWRBbGxCeXRlcyhyZWFkZXIpLnRoZW4oYm9keVJlYWRQcm9taXNlLnJlc29sdmUsIGJvZHlSZWFkUHJvbWlzZS5yZWplY3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHlSZWFkUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICB9XG5cbiAgICAvLyAxMi5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb25bXX0gKi9cbiAgICBjb25zdCBvcGVyYXRpb25zID0gW11cblxuICAgIC8vIDEzLlxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICB0eXBlOiAncHV0JywgLy8gMTQuXG4gICAgICByZXF1ZXN0OiBpbm5lclJlcXVlc3QsIC8vIDE1LlxuICAgICAgcmVzcG9uc2U6IGNsb25lZFJlc3BvbnNlIC8vIDE2LlxuICAgIH1cblxuICAgIC8vIDE3LlxuICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pXG5cbiAgICAvLyAxOS5cbiAgICBjb25zdCBieXRlcyA9IGF3YWl0IGJvZHlSZWFkUHJvbWlzZS5wcm9taXNlXG5cbiAgICBpZiAoY2xvbmVkUmVzcG9uc2UuYm9keSAhPSBudWxsKSB7XG4gICAgICBjbG9uZWRSZXNwb25zZS5ib2R5LnNvdXJjZSA9IGJ5dGVzXG4gICAgfVxuXG4gICAgLy8gMTkuMVxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyAxOS4yLjFcbiAgICBsZXQgZXJyb3JEYXRhID0gbnVsbFxuXG4gICAgLy8gMTkuMi4yXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuI2JhdGNoQ2FjaGVPcGVyYXRpb25zKG9wZXJhdGlvbnMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JEYXRhID0gZVxuICAgIH1cblxuICAgIC8vIDE5LjIuM1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDE5LjIuMy4xXG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH0gZWxzZSB7IC8vIDE5LjIuMy4yXG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZWplY3QoZXJyb3JEYXRhKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gY2FjaGVKb2JQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZSAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlLmRlbGV0ZScgfSlcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1JlcXVlc3R9XG4gICAgICovXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpXG5cbiAgICAgIHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119ICovXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICByZXF1ZXN0OiByLFxuICAgICAgb3B0aW9uc1xuICAgIH1cblxuICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pXG5cbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcbiAgICBsZXQgcmVxdWVzdFJlc3BvbnNlc1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKCEhcmVxdWVzdFJlc3BvbnNlcz8ubGVuZ3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RvbS1jYWNoZS1rZXlzXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtyZWFkb25seSBSZXF1ZXN0W119XG4gICAqL1xuICBhc3luYyBrZXlzIChyZXF1ZXN0ID0gdW5kZWZpbmVkLCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gMS5cbiAgICBsZXQgciA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMi4xXG4gICAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgLy8gMi4xLjFcbiAgICAgICAgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICAgIC8vIDIuMS4yXG4gICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuaWdub3JlTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7IC8vIDIuMlxuICAgICAgICByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuXG4gICAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyA1LlxuICAgIC8vIDUuMVxuICAgIGNvbnN0IHJlcXVlc3RzID0gW11cblxuICAgIC8vIDUuMlxuICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDUuMi4xXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QpIHtcbiAgICAgICAgLy8gNS4yLjEuMVxuICAgICAgICByZXF1ZXN0cy5wdXNoKHJlcXVlc3RSZXNwb25zZVswXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyA1LjNcbiAgICAgIC8vIDUuMy4xXG4gICAgICBjb25zdCByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShyLCBvcHRpb25zKVxuXG4gICAgICAvLyA1LjMuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICAvLyA1LjMuMi4xXG4gICAgICAgIHJlcXVlc3RzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzBdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuNFxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDUuNC4xXG4gICAgICBjb25zdCByZXF1ZXN0TGlzdCA9IFtdXG5cbiAgICAgIC8vIDUuNC4yXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdE9iamVjdCA9IG5ldyBSZXF1ZXN0KCdodHRwczovL2EnKVxuICAgICAgICByZXF1ZXN0T2JqZWN0W2tTdGF0ZV0gPSByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSByZXF1ZXN0LmhlYWRlcnNMaXN0XG4gICAgICAgIHJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSAnaW1tdXRhYmxlJ1xuICAgICAgICByZXF1ZXN0T2JqZWN0W2tSZWFsbV0gPSByZXF1ZXN0LmNsaWVudFxuXG4gICAgICAgIC8vIDUuNC4yLjFcbiAgICAgICAgcmVxdWVzdExpc3QucHVzaChyZXF1ZXN0T2JqZWN0KVxuICAgICAgfVxuXG4gICAgICAvLyA1LjQuM1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKE9iamVjdC5mcmVlemUocmVxdWVzdExpc3QpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jYmF0Y2gtY2FjaGUtb3BlcmF0aW9ucy1hbGdvcml0aG1cbiAgICogQHBhcmFtIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119IG9wZXJhdGlvbnNcbiAgICogQHJldHVybnMge3JlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjYmF0Y2hDYWNoZU9wZXJhdGlvbnMgKG9wZXJhdGlvbnMpIHtcbiAgICAvLyAxLlxuICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0XG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IGJhY2t1cENhY2hlID0gWy4uLmNhY2hlXVxuXG4gICAgLy8gMy5cbiAgICBjb25zdCBhZGRlZEl0ZW1zID0gW11cblxuICAgIC8vIDQuMVxuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIDQuMlxuICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICAvLyA0LjIuMVxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgIT09ICdkZWxldGUnICYmIG9wZXJhdGlvbi50eXBlICE9PSAncHV0Jykge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnb3BlcmF0aW9uIHR5cGUgZG9lcyBub3QgbWF0Y2ggXCJkZWxldGVcIiBvciBcInB1dFwiJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuMlxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnICYmIG9wZXJhdGlvbi5yZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWxldGUgb3BlcmF0aW9uIHNob3VsZCBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIHJlc3BvbnNlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuM1xuICAgICAgICBpZiAodGhpcy4jcXVlcnlDYWNoZShvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLm9wdGlvbnMsIGFkZGVkSXRlbXMpLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJz8/PycsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuNFxuICAgICAgICBsZXQgcmVxdWVzdFJlc3BvbnNlc1xuXG4gICAgICAgIC8vIDQuMi41XG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAvLyA0LjIuNS4xXG4gICAgICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5vcHRpb25zKVxuXG4gICAgICAgICAgLy8gVE9ETzogdGhlIHNwZWMgaXMgd3JvbmcsIHRoaXMgaXMgbmVlZGVkIHRvIHBhc3MgV1BUc1xuICAgICAgICAgIGlmIChyZXF1ZXN0UmVzcG9uc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjUuMlxuICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhY2hlLmluZGV4T2YocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG5cbiAgICAgICAgICAgIC8vIDQuMi41LjIuMVxuICAgICAgICAgICAgY2FjaGUuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdwdXQnKSB7IC8vIDQuMi42XG4gICAgICAgICAgLy8gNC4yLjYuMVxuICAgICAgICAgIGlmIChvcGVyYXRpb24ucmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAncHV0IG9wZXJhdGlvbiBzaG91bGQgaGF2ZSBhbiBhc3NvY2lhdGVkIHJlc3BvbnNlJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi4yXG4gICAgICAgICAgY29uc3QgciA9IG9wZXJhdGlvbi5yZXF1ZXN0XG5cbiAgICAgICAgICAvLyA0LjIuNi4zXG4gICAgICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyLnVybCkpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ2V4cGVjdGVkIGh0dHAgb3IgaHR0cHMgc2NoZW1lJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi40XG4gICAgICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnbm90IGdldCBtZXRob2QnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjVcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnb3B0aW9ucyBtdXN0IG5vdCBiZSBkZWZpbmVkJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi42XG4gICAgICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QpXG5cbiAgICAgICAgICAvLyA0LjIuNi43XG4gICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gY2FjaGUuaW5kZXhPZihyZXF1ZXN0UmVzcG9uc2UpXG4gICAgICAgICAgICBhc3NlcnQoaWR4ICE9PSAtMSlcblxuICAgICAgICAgICAgLy8gNC4yLjYuNy4xXG4gICAgICAgICAgICBjYWNoZS5zcGxpY2UoaWR4LCAxKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjhcbiAgICAgICAgICBjYWNoZS5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcblxuICAgICAgICAgIC8vIDQuMi42LjEwXG4gICAgICAgICAgYWRkZWRJdGVtcy5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi43XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG4gICAgICB9XG5cbiAgICAgIC8vIDQuM1xuICAgICAgcmV0dXJuIHJlc3VsdExpc3RcbiAgICB9IGNhdGNoIChlKSB7IC8vIDUuXG4gICAgICAvLyA1LjFcbiAgICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdC5sZW5ndGggPSAwXG5cbiAgICAgIC8vIDUuMlxuICAgICAgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0ID0gYmFja3VwQ2FjaGVcblxuICAgICAgLy8gNS4zXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI3F1ZXJ5LWNhY2hlXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0UXVlcnlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fSB0YXJnZXRTdG9yYWdlXG4gICAqIEByZXR1cm5zIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI3F1ZXJ5Q2FjaGUgKHJlcXVlc3RRdWVyeSwgb3B0aW9ucywgdGFyZ2V0U3RvcmFnZSkge1xuICAgIC8qKiBAdHlwZSB7cmVxdWVzdFJlc3BvbnNlTGlzdH0gKi9cbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW11cblxuICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXRTdG9yYWdlID8/IHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2Ygc3RvcmFnZSkge1xuICAgICAgY29uc3QgW2NhY2hlZFJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlXSA9IHJlcXVlc3RSZXNwb25zZVxuICAgICAgaWYgKHRoaXMuI3JlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbShyZXF1ZXN0UXVlcnksIGNhY2hlZFJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlLCBvcHRpb25zKSkge1xuICAgICAgICByZXN1bHRMaXN0LnB1c2gocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRMaXN0XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jcmVxdWVzdC1tYXRjaGVzLWNhY2hlZC1pdGVtLWFsZ29yaXRobVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFF1ZXJ5XG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7YW55IHwgbnVsbH0gcmVzcG9uc2VcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnMgfCB1bmRlZmluZWR9IG9wdGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAjcmVxdWVzdE1hdGNoZXNDYWNoZWRJdGVtIChyZXF1ZXN0UXVlcnksIHJlcXVlc3QsIHJlc3BvbnNlID0gbnVsbCwgb3B0aW9ucykge1xuICAgIC8vIGlmIChvcHRpb25zPy5pZ25vcmVNZXRob2QgPT09IGZhbHNlICYmIHJlcXVlc3QubWV0aG9kID09PSAnR0VUJykge1xuICAgIC8vICAgcmV0dXJuIGZhbHNlXG4gICAgLy8gfVxuXG4gICAgY29uc3QgcXVlcnlVUkwgPSBuZXcgVVJMKHJlcXVlc3RRdWVyeS51cmwpXG5cbiAgICBjb25zdCBjYWNoZWRVUkwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKVxuXG4gICAgaWYgKG9wdGlvbnM/Lmlnbm9yZVNlYXJjaCkge1xuICAgICAgY2FjaGVkVVJMLnNlYXJjaCA9ICcnXG5cbiAgICAgIHF1ZXJ5VVJMLnNlYXJjaCA9ICcnXG4gICAgfVxuXG4gICAgaWYgKCF1cmxFcXVhbHMocXVlcnlVUkwsIGNhY2hlZFVSTCwgdHJ1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHJlc3BvbnNlID09IG51bGwgfHxcbiAgICAgIG9wdGlvbnM/Lmlnbm9yZVZhcnkgfHxcbiAgICAgICFyZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVlc3RWYWx1ZSA9IHJlcXVlc3QuaGVhZGVyc0xpc3QuZ2V0KGZpZWxkVmFsdWUpXG4gICAgICBjb25zdCBxdWVyeVZhbHVlID0gcmVxdWVzdFF1ZXJ5LmhlYWRlcnNMaXN0LmdldChmaWVsZFZhbHVlKVxuXG4gICAgICAvLyBJZiBvbmUgaGFzIHRoZSBoZWFkZXIgYW5kIHRoZSBvdGhlciBkb2Vzbid0LCBvciBvbmUgaGFzXG4gICAgICAvLyBhIGRpZmZlcmVudCB2YWx1ZSB0aGFuIHRoZSBvdGhlciwgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAocmVxdWVzdFZhbHVlICE9PSBxdWVyeVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FjaGUucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDYWNoZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1hdGNoOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBtYXRjaEFsbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYWRkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhZGRBbGw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHB1dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5jb25zdCBjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycyA9IFtcbiAge1xuICAgIGtleTogJ2lnbm9yZVNlYXJjaCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2lnbm9yZU1ldGhvZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2lnbm9yZVZhcnknLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH1cbl1cblxud2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycylcblxud2ViaWRsLmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMsXG4gIHtcbiAgICBrZXk6ICdjYWNoZU5hbWUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihSZXNwb25zZSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPFJlcXVlc3RJbmZvPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mb1xuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FjaGVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/cache/cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/cache/cachestorage.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/cache/cachestorage.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/cache/symbols.js\")\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(ssr)/./node_modules/undici/lib/cache/cache.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\nclass CacheStorage {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */\n  #caches = new Map()\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, CacheStorage)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.match' })\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.MultiCacheQueryOptions(options)\n\n    // 1.\n    if (options.cacheName != null) {\n      // 1.1.1.1\n      if (this.#caches.has(options.cacheName)) {\n        // 1.1.1.1.1\n        const cacheList = this.#caches.get(options.cacheName)\n        const cache = new Cache(kConstruct, cacheList)\n\n        return await cache.match(request, options)\n      }\n    } else { // 2.\n      // 2.2\n      for (const cacheList of this.#caches.values()) {\n        const cache = new Cache(kConstruct, cacheList)\n\n        // 2.2.1.2\n        const response = await cache.match(request, options)\n\n        if (response !== undefined) {\n          return response\n        }\n      }\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async has (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.has' })\n\n    cacheName = webidl.converters.DOMString(cacheName)\n\n    // 2.1.1\n    // 2.2\n    return this.#caches.has(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */\n  async open (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.open' })\n\n    cacheName = webidl.converters.DOMString(cacheName)\n\n    // 2.1\n    if (this.#caches.has(cacheName)) {\n      // await caches.open('v1') !== await caches.open('v1')\n\n      // 2.1.1\n      const cache = this.#caches.get(cacheName)\n\n      // 2.1.1.1\n      return new Cache(kConstruct, cache)\n    }\n\n    // 2.2\n    const cache = []\n\n    // 2.3\n    this.#caches.set(cacheName, cache)\n\n    // 2.4\n    return new Cache(kConstruct, cache)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async delete (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.delete' })\n\n    cacheName = webidl.converters.DOMString(cacheName)\n\n    return this.#caches.delete(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {string[]}\n   */\n  async keys () {\n    webidl.brandCheck(this, CacheStorage)\n\n    // 2.1\n    const keys = this.#caches.keys()\n\n    // 2.2\n    return [...keys]\n  }\n}\n\nObject.defineProperties(CacheStorage.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CacheStorage',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  has: kEnumerableProperty,\n  open: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nmodule.exports = {\n  CacheStorage\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9jYWNoZXN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyxtRUFBVztBQUMxQyxRQUFRLFFBQVEsRUFBRSxtQkFBTyxDQUFDLCtEQUFTO0FBQ25DLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQzVDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQSwrQ0FBK0MsOEJBQThCOztBQUU3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDRCQUE0Qjs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZCQUE2Qjs7QUFFNUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLCtCQUErQjs7QUFFOUU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NhY2hlL2NhY2hlc3RvcmFnZS5qcz9iODc1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IENhY2hlIH0gPSByZXF1aXJlKCcuL2NhY2hlJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5jbGFzcyBDYWNoZVN0b3JhZ2Uge1xuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlbGV2YW50LW5hbWUtdG8tY2FjaGUtbWFwXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBpbXBvcnQoJy4vY2FjaGUnKS5yZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI2NhY2hlcyA9IG5ldyBNYXAoKVxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG4gIH1cblxuICBhc3luYyBtYXRjaCAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZVN0b3JhZ2UubWF0Y2gnIH0pXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gMS5cbiAgICBpZiAob3B0aW9ucy5jYWNoZU5hbWUgIT0gbnVsbCkge1xuICAgICAgLy8gMS4xLjEuMVxuICAgICAgaWYgKHRoaXMuI2NhY2hlcy5oYXMob3B0aW9ucy5jYWNoZU5hbWUpKSB7XG4gICAgICAgIC8vIDEuMS4xLjEuMVxuICAgICAgICBjb25zdCBjYWNoZUxpc3QgPSB0aGlzLiNjYWNoZXMuZ2V0KG9wdGlvbnMuY2FjaGVOYW1lKVxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZUxpc3QpXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gMi5cbiAgICAgIC8vIDIuMlxuICAgICAgZm9yIChjb25zdCBjYWNoZUxpc3Qgb2YgdGhpcy4jY2FjaGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlTGlzdClcblxuICAgICAgICAvLyAyLjIuMS4yXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCwgb3B0aW9ucylcblxuICAgICAgICBpZiAocmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2UtaGFzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBoYXMgKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGVTdG9yYWdlLmhhcycgfSlcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUpXG5cbiAgICAvLyAyLjEuMVxuICAgIC8vIDIuMlxuICAgIHJldHVybiB0aGlzLiNjYWNoZXMuaGFzKGNhY2hlTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkb20tY2FjaGVzdG9yYWdlLW9wZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZT59XG4gICAqL1xuICBhc3luYyBvcGVuIChjYWNoZU5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlU3RvcmFnZS5vcGVuJyB9KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSlcblxuICAgIC8vIDIuMVxuICAgIGlmICh0aGlzLiNjYWNoZXMuaGFzKGNhY2hlTmFtZSkpIHtcbiAgICAgIC8vIGF3YWl0IGNhY2hlcy5vcGVuKCd2MScpICE9PSBhd2FpdCBjYWNoZXMub3BlbigndjEnKVxuXG4gICAgICAvLyAyLjEuMVxuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLiNjYWNoZXMuZ2V0KGNhY2hlTmFtZSlcblxuICAgICAgLy8gMi4xLjEuMVxuICAgICAgcmV0dXJuIG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZSlcbiAgICB9XG5cbiAgICAvLyAyLjJcbiAgICBjb25zdCBjYWNoZSA9IFtdXG5cbiAgICAvLyAyLjNcbiAgICB0aGlzLiNjYWNoZXMuc2V0KGNhY2hlTmFtZSwgY2FjaGUpXG5cbiAgICAvLyAyLjRcbiAgICByZXR1cm4gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2UtZGVsZXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBkZWxldGUgKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGVTdG9yYWdlLmRlbGV0ZScgfSlcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUpXG5cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVzLmRlbGV0ZShjYWNoZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1rZXlzXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICovXG4gIGFzeW5jIGtleXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIC8vIDIuMVxuICAgIGNvbnN0IGtleXMgPSB0aGlzLiNjYWNoZXMua2V5cygpXG5cbiAgICAvLyAyLjJcbiAgICByZXR1cm4gWy4uLmtleXNdXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FjaGVTdG9yYWdlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2FjaGVTdG9yYWdlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWF0Y2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FjaGVTdG9yYWdlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/cache/cachestorage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/cache/symbols.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/cache/symbols.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kConstruct: Symbol('constructable')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NhY2hlL3N5bWJvbHMuanM/ODU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtDb25zdHJ1Y3Q6IFN5bWJvbCgnY29uc3RydWN0YWJsZScpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/cache/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/cache/util.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/cache/util.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\n\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */\nfunction urlEquals (A, B, excludeFragment = false) {\n  const serializedA = URLSerializer(A, excludeFragment)\n\n  const serializedB = URLSerializer(B, excludeFragment)\n\n  return serializedA === serializedB\n}\n\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */\nfunction fieldValues (header) {\n  assert(header !== null)\n\n  const values = []\n\n  for (let value of header.split(',')) {\n    value = value.trim()\n\n    if (!value.length) {\n      continue\n    } else if (!isValidHeaderName(value)) {\n      continue\n    }\n\n    values.push(value)\n  }\n\n  return values\n}\n\nmodule.exports = {\n  urlEquals,\n  fieldValues\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3BELFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyxvRUFBZTs7QUFFckQ7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NhY2hlL3V0aWwuanM/MWJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YVVSTCcpXG5jb25zdCB7IGlzVmFsaWRIZWFkZXJOYW1lIH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtZXF1YWxzXG4gKiBAcGFyYW0ge1VSTH0gQVxuICogQHBhcmFtIHtVUkx9IEJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gZXhjbHVkZUZyYWdtZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdXJsRXF1YWxzIChBLCBCLCBleGNsdWRlRnJhZ21lbnQgPSBmYWxzZSkge1xuICBjb25zdCBzZXJpYWxpemVkQSA9IFVSTFNlcmlhbGl6ZXIoQSwgZXhjbHVkZUZyYWdtZW50KVxuXG4gIGNvbnN0IHNlcmlhbGl6ZWRCID0gVVJMU2VyaWFsaXplcihCLCBleGNsdWRlRnJhZ21lbnQpXG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWRBID09PSBzZXJpYWxpemVkQlxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvNjk0ZDIwZDEzNGNiNTUzZDhkODllNTUwMGI5MTQ4MDEyYjFiYTI5OS9jb250ZW50L2Jyb3dzZXIvY2FjaGVfc3RvcmFnZS9jYWNoZV9zdG9yYWdlX2NhY2hlLmNjI0wyNjAtTDI2MlxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICovXG5mdW5jdGlvbiBmaWVsZFZhbHVlcyAoaGVhZGVyKSB7XG4gIGFzc2VydChoZWFkZXIgIT09IG51bGwpXG5cbiAgY29uc3QgdmFsdWVzID0gW11cblxuICBmb3IgKGxldCB2YWx1ZSBvZiBoZWFkZXIuc3BsaXQoJywnKSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZSh2YWx1ZSkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFsdWVzLnB1c2godmFsdWUpXG4gIH1cblxuICByZXR1cm4gdmFsdWVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1cmxFcXVhbHMsXG4gIGZpZWxkVmFsdWVzXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/cache/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/client.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/client.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// @ts-check\n\n\n\n/* global WebAssembly */\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst net = __webpack_require__(/*! net */ \"net\")\nconst http = __webpack_require__(/*! http */ \"http\")\nconst { pipeline } = __webpack_require__(/*! stream */ \"stream\")\nconst util = __webpack_require__(/*! ./core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst timers = __webpack_require__(/*! ./timers */ \"(ssr)/./node_modules/undici/lib/timers.js\")\nconst Request = __webpack_require__(/*! ./core/request */ \"(ssr)/./node_modules/undici/lib/core/request.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher-base.js\")\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError,\n  ClientDestroyedError\n} = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\")\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize,\n  kHTTPConnVersion,\n  // HTTP2\n  kHost,\n  kHTTP2Session,\n  kHTTP2SessionState,\n  kHTTP2BuildRequest,\n  kHTTP2CopyHeaders,\n  kHTTP1BuildRequest\n} = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = __webpack_require__(/*! http2 */ \"http2\")\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2\n\n// Experimental\nlet h2ExperimentalWarned = false\n\nconst FastBuffer = Buffer[Symbol.species]\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\")\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\n/**\n * @type {import('../types/client').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    allowH2,\n    maxConcurrentStreams\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)\n      ? interceptors.Client\n      : [createRedirectInterceptor({ maxRedirections })]\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kHTTPConnVersion] = 'h1'\n\n    // HTTP/2\n    this[kHTTP2Session] = null\n    this[kHTTP2SessionState] = !allowH2\n      ? null\n      : {\n        // streams: null, // Fixed queue of streams - For future support of `push`\n          openStreams: 0, // Keep track of them to decide wether or not unref the session\n          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n        }\n    this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n\n    const request = this[kHTTPConnVersion] === 'h2'\n      ? Request[kHTTP2BuildRequest](origin, opts, handler)\n      : Request[kHTTP1BuildRequest](origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      process.nextTick(resume, this)\n    } else {\n      resume(this, true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (!this[kSize]) {\n        resolve(null)\n      } else {\n        this[kClosedResolve] = resolve\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve()\n      }\n\n      if (this[kHTTP2Session] != null) {\n        util.destroy(this[kHTTP2Session], err)\n        this[kHTTP2Session] = null\n        this[kHTTP2SessionState] = null\n      }\n\n      if (!this[kSocket]) {\n        queueMicrotask(callback)\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err)\n      }\n\n      resume(this)\n    })\n  }\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n\n  if (id === 0) {\n    this[kSocket][kError] = err\n    onError(this[kClient], err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  util.destroy(this, new SocketError('other side closed'))\n  util.destroy(this[kSocket], new SocketError('other side closed'))\n}\n\nfunction onHTTP2GoAway (code) {\n  const client = this[kClient]\n  const err = new InformationalError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`)\n  client[kSocket] = null\n  client[kHTTP2Session] = null\n\n  if (client.destroyed) {\n    assert(this[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(this, request, err)\n    }\n  } else if (client[kRunning] > 0) {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect',\n    client[kUrl],\n    [client],\n    err\n  )\n\n  resume(client)\n}\n\nconst constants = __webpack_require__(/*! ./llhttp/constants */ \"(ssr)/./node_modules/undici/lib/llhttp/constants.js\")\nconst createRedirectInterceptor = __webpack_require__(/*! ./interceptor/redirectInterceptor */ \"(ssr)/./node_modules/undici/lib/interceptor/redirectInterceptor.js\")\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ./llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(__webpack_require__(/*! ./llhttp/llhttp_simd-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || __webpack_require__(/*! ./llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\"), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message =\n            'Response does not match the HTTP/1.1 protocol (' +\n            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n            ')'\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {\n      this.connection += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    let pause\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    try {\n      request.onComplete(headers)\n    } catch (err) {\n      errorRequest(client, request, err)\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client)\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  if (parser) {\n    parser.readMore()\n  }\n}\n\nfunction onSocketError (err) {\n  const { [kClient]: client, [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  if (client[kHTTPConnVersion] !== 'h2') {\n    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so for as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser, [kClient]: client } = this\n\n  if (client[kHTTPConnVersion] !== 'h2') {\n    if (parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client, [kParser]: parser } = this\n\n  if (client[kHTTPConnVersion] === 'h1' && parser) {\n    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n    }\n\n    this[kParser].destroy()\n    this[kParser] = null\n  }\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substr(1, idx - 1)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', () => {}), new ClientDestroyedError())\n      return\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    const isH2 = socket.alpnProtocol === 'h2'\n    if (isH2) {\n      if (!h2ExperimentalWarned) {\n        h2ExperimentalWarned = true\n        process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n          code: 'UNDICI-H2'\n        })\n      }\n\n      const session = http2.connect(client[kUrl], {\n        createConnection: () => socket,\n        peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams\n      })\n\n      client[kHTTPConnVersion] = 'h2'\n      session[kClient] = client\n      session[kSocket] = socket\n      session.on('error', onHttp2SessionError)\n      session.on('frameError', onHttp2FrameError)\n      session.on('end', onHttp2SessionEnd)\n      session.on('goaway', onHTTP2GoAway)\n      session.on('close', onSocketClose)\n      session.unref()\n\n      client[kHTTP2Session] = session\n      socket[kHTTP2Session] = session\n    } else {\n      if (!llhttpInstance) {\n        llhttpInstance = await llhttpPromise\n        llhttpPromise = null\n      }\n\n      socket[kNoRef] = false\n      socket[kWriting] = false\n      socket[kReset] = false\n      socket[kBlocking] = false\n      socket[kParser] = new Parser(client, socket, llhttpInstance)\n    }\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    client[kSocket] = socket\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    if (client.destroyed) {\n      return\n    }\n\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    const socket = client[kSocket]\n\n    if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket && !client[kHTTP2Session]) {\n      connect(client)\n      return\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          errorRequest(client, request, err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client[kRunning] > 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  if (client[kHTTPConnVersion] === 'h2') {\n    writeH2(client, client[kHTTP2Session], request)\n    return\n  }\n\n  const { body, method, path, host, upgrade, headers, blocking, reset } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'latin1')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeH2 (client, session, request) {\n  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request\n\n  let headers\n  if (typeof reqHeaders === 'string') headers = Request[kHTTP2CopyHeaders](reqHeaders.trim())\n  else headers = reqHeaders\n\n  if (upgrade) {\n    errorRequest(client, request, new Error('Upgrade not supported for H2'))\n    return false\n  }\n\n  try {\n    // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  let stream\n  const h2State = client[kHTTP2SessionState]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost]\n  headers[HTTP2_HEADER_METHOD] = method\n\n  if (method === 'CONNECT') {\n    session.ref()\n    // we are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n\n    if (stream.id && !stream.pending) {\n      request.onUpgrade(null, null, stream)\n      ++h2State.openStreams\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream)\n        ++h2State.openStreams\n      })\n    }\n\n    stream.once('close', () => {\n      h2State.openStreams -= 1\n      // TODO(HTTP/2): unref only if current streams count is 0\n      if (h2State.openStreams === 0) session.unref()\n    })\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omited when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  const shouldEndStream = method === 'GET' || method === 'HEAD'\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    /**\n     * @type {import('node:http2').ClientHttp2Stream}\n     */\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    /** @type {import('node:http2').ClientHttp2Stream} */\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new several streams open\n  ++h2State.openStreams\n\n  stream.once('response', headers => {\n    if (request.onHeaders(Number(headers[HTTP2_HEADER_STATUS]), headers, stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n  })\n\n  stream.once('end', () => {\n    request.onComplete([])\n  })\n\n  stream.on('data', (chunk) => {\n    if (request.onData(chunk) === false) stream.pause()\n  })\n\n  stream.once('close', () => {\n    h2State.openStreams -= 1\n    // TODO(HTTP/2): unref only if current streams count is 0\n    if (h2State.openStreams === 0) session.unref()\n  })\n\n  stream.once('error', function (err) {\n    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n      h2State.streams -= 1\n      util.destroy(stream, err)\n    }\n  })\n\n  stream.once('frameError', (type, code) => {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    errorRequest(client, request, err)\n\n    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n      h2State.streams -= 1\n      util.destroy(stream, err)\n    }\n  })\n\n  // stream.on('aborted', () => {\n  //   // TODO(HTTP/2): Support aborted\n  // })\n\n  // stream.on('timeout', () => {\n  //   // TODO(HTTP/2): Support timeout\n  // })\n\n  // stream.on('push', headers => {\n  //   // TODO(HTTP/2): Suppor push\n  // })\n\n  // stream.on('trailers', headers => {\n  //   // TODO(HTTP/2): Support trailers\n  // })\n\n  return true\n\n  function writeBodyH2 () {\n    /* istanbul ignore else: assertion */\n    if (!body) {\n      request.onRequestSent()\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      stream.cork()\n      stream.write(body)\n      stream.uncork()\n      stream.end()\n      request.onBodySent(body)\n      request.onRequestSent()\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable({\n          client,\n          request,\n          contentLength,\n          h2stream: stream,\n          expectsPayload,\n          body: body.stream(),\n          socket: client[kSocket],\n          header: ''\n        })\n      } else {\n        writeBlob({\n          body,\n          client,\n          request,\n          contentLength,\n          expectsPayload,\n          h2stream: stream,\n          header: '',\n          socket: client[kSocket]\n        })\n      }\n    } else if (util.isStream(body)) {\n      writeStream({\n        body,\n        client,\n        request,\n        contentLength,\n        expectsPayload,\n        socket: client[kSocket],\n        h2stream: stream,\n        header: ''\n      })\n    } else if (util.isIterable(body)) {\n      writeIterable({\n        body,\n        client,\n        request,\n        contentLength,\n        expectsPayload,\n        header: '',\n        h2stream: stream,\n        socket: client[kSocket]\n      })\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeStream ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  if (client[kHTTPConnVersion] === 'h2') {\n    // For HTTP/2, is enough to pipe the stream\n    const pipe = pipeline(\n      body,\n      h2stream,\n      (err) => {\n        if (err) {\n          util.destroy(body, err)\n          util.destroy(h2stream, err)\n        } else {\n          request.onRequestSent()\n        }\n      }\n    )\n\n    pipe.on('data', onPipeData)\n    pipe.once('end', () => {\n      pipe.removeListener('data', onPipeData)\n      util.destroy(pipe)\n    })\n\n    function onPipeData (chunk) {\n      request.onBodySent(chunk)\n    }\n\n    return\n  }\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    onFinished(new RequestAbortedError())\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  const isH2 = client[kHTTPConnVersion] === 'h2'\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    if (isH2) {\n      h2stream.cork()\n      h2stream.write(buffer)\n      h2stream.uncork()\n    } else {\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(buffer)\n      socket.uncork()\n    }\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(isH2 ? h2stream : socket, err)\n  }\n}\n\nasync function writeIterable ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  if (client[kHTTPConnVersion] === 'h2') {\n    h2stream\n      .on('close', onDrain)\n      .on('drain', onDrain)\n\n    try {\n      // It's up to the user to somehow abort the async iterable.\n      for await (const chunk of body) {\n        if (socket[kError]) {\n          throw socket[kError]\n        }\n\n        const res = h2stream.write(chunk)\n        request.onBodySent(chunk)\n        if (!res) {\n          await waitForDrain()\n        }\n      }\n    } catch (err) {\n      h2stream.destroy(err)\n    } finally {\n      request.onRequestSent()\n      h2stream.end()\n      h2stream\n        .off('close', onDrain)\n        .off('drain', onDrain)\n    }\n\n    return\n  }\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVo7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsaUVBQWE7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLDJEQUFVO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHVFQUFnQjtBQUN4Qyx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxxRUFBZTtBQUMzQix1QkFBdUIsbUJBQU8sQ0FBQyx1RUFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsdUVBQWdCOztBQUU1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLG9CQUFPO0FBQ3pCLEVBQUU7QUFDRjtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7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QUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlCQUFpQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGlCQUFpQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtDQUErQzs7QUFFM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxzQ0FBc0M7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw4Q0FBOEM7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwwRkFBMEY7O0FBRXRHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw4QkFBOEI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsdUNBQXVDOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHVDQUF1Qzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsdUNBQXVDOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlDQUFpQzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSw4REFBOEQ7O0FBRXhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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LFlBQVksK0VBQStFO0FBQzNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CLFFBQVE7QUFDUix3QkFBd0IsT0FBTztBQUMvQjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGlCQUFpQjs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NsaWVudC5qcz82MzhkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG4ndXNlIHN0cmljdCdcblxuLyogZ2xvYmFsIFdlYkFzc2VtYmx5ICovXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKVxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKVxuY29uc3QgeyBwaXBlbGluZSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpXG5jb25zdCB0aW1lcnMgPSByZXF1aXJlKCcuL3RpbWVycycpXG5jb25zdCBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9jb3JlL3JlcXVlc3QnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7XG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIEhlYWRlcnNUaW1lb3V0RXJyb3IsXG4gIEhlYWRlcnNPdmVyZmxvd0Vycm9yLFxuICBTb2NrZXRFcnJvcixcbiAgSW5mb3JtYXRpb25hbEVycm9yLFxuICBCb2R5VGltZW91dEVycm9yLFxuICBIVFRQUGFyc2VyRXJyb3IsXG4gIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IsXG4gIENsaWVudERlc3Ryb3llZEVycm9yXG59ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4vY29yZS9jb25uZWN0JylcbmNvbnN0IHtcbiAga1VybCxcbiAga1Jlc2V0LFxuICBrU2VydmVyTmFtZSxcbiAga0NsaWVudCxcbiAga0J1c3ksXG4gIGtQYXJzZXIsXG4gIGtDb25uZWN0LFxuICBrQmxvY2tpbmcsXG4gIGtSZXN1bWluZyxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrU2l6ZSxcbiAga1dyaXRpbmcsXG4gIGtRdWV1ZSxcbiAga0Nvbm5lY3RlZCxcbiAga0Nvbm5lY3RpbmcsXG4gIGtOZWVkRHJhaW4sXG4gIGtOb1JlZixcbiAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0LFxuICBrSG9zdEhlYWRlcixcbiAga1BlbmRpbmdJZHgsXG4gIGtSdW5uaW5nSWR4LFxuICBrRXJyb3IsXG4gIGtQaXBlbGluaW5nLFxuICBrU29ja2V0LFxuICBrS2VlcEFsaXZlVGltZW91dFZhbHVlLFxuICBrTWF4SGVhZGVyc1NpemUsXG4gIGtLZWVwQWxpdmVNYXhUaW1lb3V0LFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAga0hlYWRlcnNUaW1lb3V0LFxuICBrQm9keVRpbWVvdXQsXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoLFxuICBrQ29ubmVjdG9yLFxuICBrTWF4UmVkaXJlY3Rpb25zLFxuICBrTWF4UmVxdWVzdHMsXG4gIGtDb3VudGVyLFxuICBrQ2xvc2UsXG4gIGtEZXN0cm95LFxuICBrRGlzcGF0Y2gsXG4gIGtJbnRlcmNlcHRvcnMsXG4gIGtMb2NhbEFkZHJlc3MsXG4gIGtNYXhSZXNwb25zZVNpemUsXG4gIGtIVFRQQ29ublZlcnNpb24sXG4gIC8vIEhUVFAyXG4gIGtIb3N0LFxuICBrSFRUUDJTZXNzaW9uLFxuICBrSFRUUDJTZXNzaW9uU3RhdGUsXG4gIGtIVFRQMkJ1aWxkUmVxdWVzdCxcbiAga0hUVFAyQ29weUhlYWRlcnMsXG4gIGtIVFRQMUJ1aWxkUmVxdWVzdFxufSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2h0dHAyJyl9ICovXG5sZXQgaHR0cDJcbnRyeSB7XG4gIGh0dHAyID0gcmVxdWlyZSgnaHR0cDInKVxufSBjYXRjaCB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaHR0cDIgPSB7IGNvbnN0YW50czoge30gfVxufVxuXG5jb25zdCB7XG4gIGNvbnN0YW50czoge1xuICAgIEhUVFAyX0hFQURFUl9BVVRIT1JJVFksXG4gICAgSFRUUDJfSEVBREVSX01FVEhPRCxcbiAgICBIVFRQMl9IRUFERVJfUEFUSCxcbiAgICBIVFRQMl9IRUFERVJfU0NIRU1FLFxuICAgIEhUVFAyX0hFQURFUl9DT05URU5UX0xFTkdUSCxcbiAgICBIVFRQMl9IRUFERVJfRVhQRUNULFxuICAgIEhUVFAyX0hFQURFUl9TVEFUVVNcbiAgfVxufSA9IGh0dHAyXG5cbi8vIEV4cGVyaW1lbnRhbFxubGV0IGgyRXhwZXJpbWVudGFsV2FybmVkID0gZmFsc2VcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc11cblxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2tDbG9zZWRSZXNvbHZlJylcblxuY29uc3QgY2hhbm5lbHMgPSB7fVxuXG50cnkge1xuICBjb25zdCBkaWFnbm9zdGljc0NoYW5uZWwgPSByZXF1aXJlKCdkaWFnbm9zdGljc19jaGFubmVsJylcbiAgY2hhbm5lbHMuc2VuZEhlYWRlcnMgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpzZW5kSGVhZGVycycpXG4gIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpiZWZvcmVDb25uZWN0JylcbiAgY2hhbm5lbHMuY29ubmVjdEVycm9yID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdEVycm9yJylcbiAgY2hhbm5lbHMuY29ubmVjdGVkID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdGVkJylcbn0gY2F0Y2gge1xuICBjaGFubmVscy5zZW5kSGVhZGVycyA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdCA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuY29ubmVjdEVycm9yID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy5jb25uZWN0ZWQgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi4vdHlwZXMvY2xpZW50JykuZGVmYXVsdH1cbiAqL1xuY2xhc3MgQ2xpZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2NsaWVudCcpLkNsaWVudC5PcHRpb25zfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCB7XG4gICAgaW50ZXJjZXB0b3JzLFxuICAgIG1heEhlYWRlclNpemUsXG4gICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgc29ja2V0VGltZW91dCxcbiAgICByZXF1ZXN0VGltZW91dCxcbiAgICBjb25uZWN0VGltZW91dCxcbiAgICBib2R5VGltZW91dCxcbiAgICBpZGxlVGltZW91dCxcbiAgICBrZWVwQWxpdmUsXG4gICAga2VlcEFsaXZlVGltZW91dCxcbiAgICBtYXhLZWVwQWxpdmVUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZU1heFRpbWVvdXQsXG4gICAga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAgICBzb2NrZXRQYXRoLFxuICAgIHBpcGVsaW5pbmcsXG4gICAgdGxzLFxuICAgIHN0cmljdENvbnRlbnRMZW5ndGgsXG4gICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgbWF4UmVkaXJlY3Rpb25zLFxuICAgIGNvbm5lY3QsXG4gICAgbWF4UmVxdWVzdHNQZXJDbGllbnQsXG4gICAgbG9jYWxBZGRyZXNzLFxuICAgIG1heFJlc3BvbnNlU2l6ZSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5LFxuICAgIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCxcbiAgICAvLyBoMlxuICAgIGFsbG93SDIsXG4gICAgbWF4Q29uY3VycmVudFN0cmVhbXNcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKGtlZXBBbGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIGtlZXBBbGl2ZSwgdXNlIHBpcGVsaW5pbmc9MCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHNvY2tldFRpbWVvdXQsIHVzZSBoZWFkZXJzVGltZW91dCAmIGJvZHlUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHJlcXVlc3RUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoaWRsZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBpZGxlVGltZW91dCwgdXNlIGtlZXBBbGl2ZVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKG1heEtlZXBBbGl2ZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBtYXhLZWVwQWxpdmVUaW1lb3V0LCB1c2Uga2VlcEFsaXZlTWF4VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAobWF4SGVhZGVyU2l6ZSAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUobWF4SGVhZGVyU2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtYXhIZWFkZXJTaXplJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0UGF0aCAhPSBudWxsICYmIHR5cGVvZiBzb2NrZXRQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHNvY2tldFBhdGgnKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3RUaW1lb3V0KSB8fCBjb25uZWN0VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlVGltZW91dCkgfHwga2VlcEFsaXZlVGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVNYXhUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlTWF4VGltZW91dCkgfHwga2VlcEFsaXZlTWF4VGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZU1heFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQnKVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzVGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIoYm9keVRpbWVvdXQpIHx8IGJvZHlUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignYm9keVRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVybycpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChtYXhSZXF1ZXN0c1BlckNsaWVudCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXF1ZXN0c1BlckNsaWVudCkgfHwgbWF4UmVxdWVzdHNQZXJDbGllbnQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZXF1ZXN0c1BlckNsaWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAobG9jYWxBZGRyZXNzICE9IG51bGwgJiYgKHR5cGVvZiBsb2NhbEFkZHJlc3MgIT09ICdzdHJpbmcnIHx8IG5ldC5pc0lQKGxvY2FsQWRkcmVzcykgPT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2xvY2FsQWRkcmVzcyBtdXN0IGJlIHZhbGlkIHN0cmluZyBJUCBhZGRyZXNzJylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVzcG9uc2VTaXplICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlc3BvbnNlU2l6ZSkgfHwgbWF4UmVzcG9uc2VTaXplIDwgLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlc3BvbnNlU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgIT0gbnVsbCAmJlxuICAgICAgKCFOdW1iZXIuaXNJbnRlZ2VyKGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCkgfHwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IDwgLTEpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2F1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICAvLyBoMlxuICAgIGlmIChhbGxvd0gyICE9IG51bGwgJiYgdHlwZW9mIGFsbG93SDIgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdhbGxvd0gyIG11c3QgYmUgYSB2YWxpZCBib29sZWFuIHZhbHVlJylcbiAgICB9XG5cbiAgICBpZiAobWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCAmJiAodHlwZW9mIG1heENvbmN1cnJlbnRTdHJlYW1zICE9PSAnbnVtYmVyJyB8fCBtYXhDb25jdXJyZW50U3RyZWFtcyA8IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENvbmN1cnJlbnRTdHJlYW1zIG11c3QgYmUgYSBwb3NzaXRpdmUgaW50ZWdlciwgZ3JlYXRlciB0aGFuIDAnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHtcbiAgICAgICAgLi4udGxzLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgYWxsb3dIMixcbiAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgdGltZW91dDogY29ubmVjdFRpbWVvdXQsXG4gICAgICAgIC4uLih1dGlsLm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5ICYmIGF1dG9TZWxlY3RGYW1pbHkgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gaW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9ycy5DbGllbnQgJiYgQXJyYXkuaXNBcnJheShpbnRlcmNlcHRvcnMuQ2xpZW50KVxuICAgICAgPyBpbnRlcmNlcHRvcnMuQ2xpZW50XG4gICAgICA6IFtjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yKHsgbWF4UmVkaXJlY3Rpb25zIH0pXVxuICAgIHRoaXNba1VybF0gPSB1dGlsLnBhcnNlT3JpZ2luKHVybClcbiAgICB0aGlzW2tDb25uZWN0b3JdID0gY29ubmVjdFxuICAgIHRoaXNba1NvY2tldF0gPSBudWxsXG4gICAgdGhpc1trUGlwZWxpbmluZ10gPSBwaXBlbGluaW5nICE9IG51bGwgPyBwaXBlbGluaW5nIDogMVxuICAgIHRoaXNba01heEhlYWRlcnNTaXplXSA9IG1heEhlYWRlclNpemUgfHwgaHR0cC5tYXhIZWFkZXJTaXplXG4gICAgdGhpc1trS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdID0ga2VlcEFsaXZlVGltZW91dCA9PSBudWxsID8gNGUzIDoga2VlcEFsaXZlVGltZW91dFxuICAgIHRoaXNba0tlZXBBbGl2ZU1heFRpbWVvdXRdID0ga2VlcEFsaXZlTWF4VGltZW91dCA9PSBudWxsID8gNjAwZTMgOiBrZWVwQWxpdmVNYXhUaW1lb3V0XG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0gPSBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkID09IG51bGwgPyAxZTMgOiBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XVxuICAgIHRoaXNba1NlcnZlck5hbWVdID0gbnVsbFxuICAgIHRoaXNba0xvY2FsQWRkcmVzc10gPSBsb2NhbEFkZHJlc3MgIT0gbnVsbCA/IGxvY2FsQWRkcmVzcyA6IG51bGxcbiAgICB0aGlzW2tSZXN1bWluZ10gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba05lZWREcmFpbl0gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba0hvc3RIZWFkZXJdID0gYGhvc3Q6ICR7dGhpc1trVXJsXS5ob3N0bmFtZX0ke3RoaXNba1VybF0ucG9ydCA/IGA6JHt0aGlzW2tVcmxdLnBvcnR9YCA6ICcnfVxcclxcbmBcbiAgICB0aGlzW2tCb2R5VGltZW91dF0gPSBib2R5VGltZW91dCAhPSBudWxsID8gYm9keVRpbWVvdXQgOiAzMDBlM1xuICAgIHRoaXNba0hlYWRlcnNUaW1lb3V0XSA9IGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgPyBoZWFkZXJzVGltZW91dCA6IDMwMGUzXG4gICAgdGhpc1trU3RyaWN0Q29udGVudExlbmd0aF0gPSBzdHJpY3RDb250ZW50TGVuZ3RoID09IG51bGwgPyB0cnVlIDogc3RyaWN0Q29udGVudExlbmd0aFxuICAgIHRoaXNba01heFJlZGlyZWN0aW9uc10gPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzW2tNYXhSZXF1ZXN0c10gPSBtYXhSZXF1ZXN0c1BlckNsaWVudFxuICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgIHRoaXNba01heFJlc3BvbnNlU2l6ZV0gPSBtYXhSZXNwb25zZVNpemUgPiAtMSA/IG1heFJlc3BvbnNlU2l6ZSA6IC0xXG4gICAgdGhpc1trSFRUUENvbm5WZXJzaW9uXSA9ICdoMSdcblxuICAgIC8vIEhUVFAvMlxuICAgIHRoaXNba0hUVFAyU2Vzc2lvbl0gPSBudWxsXG4gICAgdGhpc1trSFRUUDJTZXNzaW9uU3RhdGVdID0gIWFsbG93SDJcbiAgICAgID8gbnVsbFxuICAgICAgOiB7XG4gICAgICAgIC8vIHN0cmVhbXM6IG51bGwsIC8vIEZpeGVkIHF1ZXVlIG9mIHN0cmVhbXMgLSBGb3IgZnV0dXJlIHN1cHBvcnQgb2YgYHB1c2hgXG4gICAgICAgICAgb3BlblN0cmVhbXM6IDAsIC8vIEtlZXAgdHJhY2sgb2YgdGhlbSB0byBkZWNpZGUgd2V0aGVyIG9yIG5vdCB1bnJlZiB0aGUgc2Vzc2lvblxuICAgICAgICAgIG1heENvbmN1cnJlbnRTdHJlYW1zOiBtYXhDb25jdXJyZW50U3RyZWFtcyAhPSBudWxsID8gbWF4Q29uY3VycmVudFN0cmVhbXMgOiAxMDAgLy8gTWF4IHBlZXJDb25jdXJyZW50U3RyZWFtcyBmb3IgYSBOb2RlIGgyIHNlcnZlclxuICAgICAgICB9XG4gICAgdGhpc1trSG9zdF0gPSBgJHt0aGlzW2tVcmxdLmhvc3RuYW1lfSR7dGhpc1trVXJsXS5wb3J0ID8gYDoke3RoaXNba1VybF0ucG9ydH1gIDogJyd9YFxuXG4gICAgLy8ga1F1ZXVlIGlzIGJ1aWx0IHVwIG9mIDMgc2VjdGlvbnMgc2VwYXJhdGVkIGJ5XG4gICAgLy8gdGhlIGtSdW5uaW5nSWR4IGFuZCBrUGVuZGluZ0lkeCBpbmRpY2VzLlxuICAgIC8vIHwgICBjb21wbGV0ZSAgIHwgICBydW5uaW5nICAgfCAgIHBlbmRpbmcgICB8XG4gICAgLy8gICAgICAgICAgICAgICAgXiBrUnVubmluZ0lkeCBeIGtQZW5kaW5nSWR4IF4ga1F1ZXVlLmxlbmd0aFxuICAgIC8vIGtSdW5uaW5nSWR4IHBvaW50cyB0byB0aGUgZmlyc3QgcnVubmluZyBlbGVtZW50LlxuICAgIC8vIGtQZW5kaW5nSWR4IHBvaW50cyB0byB0aGUgZmlyc3QgcGVuZGluZyBlbGVtZW50LlxuICAgIC8vIFRoaXMgaW1wbGVtZW50cyBhIGZhc3QgcXVldWUgd2l0aCBhbiBhbW9ydGl6ZWRcbiAgICAvLyB0aW1lIG9mIE8oMSkuXG5cbiAgICB0aGlzW2tRdWV1ZV0gPSBbXVxuICAgIHRoaXNba1J1bm5pbmdJZHhdID0gMFxuICAgIHRoaXNba1BlbmRpbmdJZHhdID0gMFxuICB9XG5cbiAgZ2V0IHBpcGVsaW5pbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQaXBlbGluaW5nXVxuICB9XG5cbiAgc2V0IHBpcGVsaW5pbmcgKHZhbHVlKSB7XG4gICAgdGhpc1trUGlwZWxpbmluZ10gPSB2YWx1ZVxuICAgIHJlc3VtZSh0aGlzLCB0cnVlKVxuICB9XG5cbiAgZ2V0IFtrUGVuZGluZ10gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUGVuZGluZ0lkeF1cbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICByZXR1cm4gdGhpc1trUGVuZGluZ0lkeF0gLSB0aGlzW2tSdW5uaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrU2l6ZV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUnVubmluZ0lkeF1cbiAgfVxuXG4gIGdldCBba0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiAhIXRoaXNba1NvY2tldF0gJiYgIXRoaXNba0Nvbm5lY3RpbmddICYmICF0aGlzW2tTb2NrZXRdLmRlc3Ryb3llZFxuICB9XG5cbiAgZ2V0IFtrQnVzeV0gKCkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXNba1NvY2tldF1cbiAgICByZXR1cm4gKFxuICAgICAgKHNvY2tldCAmJiAoc29ja2V0W2tSZXNldF0gfHwgc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXRba0Jsb2NraW5nXSkpIHx8XG4gICAgICAodGhpc1trU2l6ZV0gPj0gKHRoaXNba1BpcGVsaW5pbmddIHx8IDEpKSB8fFxuICAgICAgdGhpc1trUGVuZGluZ10gPiAwXG4gICAgKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlOiBvbmx5IHVzZWQgZm9yIHRlc3QgKi9cbiAgW2tDb25uZWN0XSAoY2IpIHtcbiAgICBjb25uZWN0KHRoaXMpXG4gICAgdGhpcy5vbmNlKCdjb25uZWN0JywgY2IpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IG9yaWdpbiA9IG9wdHMub3JpZ2luIHx8IHRoaXNba1VybF0ub3JpZ2luXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpc1trSFRUUENvbm5WZXJzaW9uXSA9PT0gJ2gyJ1xuICAgICAgPyBSZXF1ZXN0W2tIVFRQMkJ1aWxkUmVxdWVzdF0ob3JpZ2luLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgOiBSZXF1ZXN0W2tIVFRQMUJ1aWxkUmVxdWVzdF0ob3JpZ2luLCBvcHRzLCBoYW5kbGVyKVxuXG4gICAgdGhpc1trUXVldWVdLnB1c2gocmVxdWVzdClcbiAgICBpZiAodGhpc1trUmVzdW1pbmddKSB7XG4gICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0gZWxzZSBpZiAodXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgPT0gbnVsbCAmJiB1dGlsLmlzSXRlcmFibGUocmVxdWVzdC5ib2R5KSkge1xuICAgICAgLy8gV2FpdCBhIHRpY2sgaW4gY2FzZSBzdHJlYW0vaXRlcmF0b3IgaXMgZW5kZWQgaW4gdGhlIHNhbWUgdGljay5cbiAgICAgIHRoaXNba1Jlc3VtaW5nXSA9IDFcbiAgICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bWUodGhpcywgdHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpc1trUmVzdW1pbmddICYmIHRoaXNba05lZWREcmFpbl0gIT09IDIgJiYgdGhpc1trQnVzeV0pIHtcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAyXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl0gPCAyXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgLy8gVE9ETzogZm9yIEgyIHdlIG5lZWQgdG8gZ3JhY2VmdWxseSBmbHVzaCB0aGUgcmVtYWluaW5nIGVucXVldWVkXG4gICAgLy8gcmVxdWVzdCBhbmQgY2xvc2UgZWFjaCBzdHJlYW0uXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoIXRoaXNba1NpemVdKSB7XG4gICAgICAgIHJlc29sdmUobnVsbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gcmVzb2x2ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpc1trUXVldWVdLnNwbGljZSh0aGlzW2tQZW5kaW5nSWR4XSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICAgIGVycm9yUmVxdWVzdCh0aGlzLCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trQ2xvc2VkUmVzb2x2ZV0pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBTaG91bGQgd2UgZXJyb3IgaGVyZSB3aXRoIENsaWVudERlc3Ryb3llZEVycm9yP1xuICAgICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdKClcbiAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0hUVFAyU2Vzc2lvbl0gIT0gbnVsbCkge1xuICAgICAgICB1dGlsLmRlc3Ryb3kodGhpc1trSFRUUDJTZXNzaW9uXSwgZXJyKVxuICAgICAgICB0aGlzW2tIVFRQMlNlc3Npb25dID0gbnVsbFxuICAgICAgICB0aGlzW2tIVFRQMlNlc3Npb25TdGF0ZV0gPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpc1trU29ja2V0XSkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuZGVzdHJveSh0aGlzW2tTb2NrZXRdLm9uKCdjbG9zZScsIGNhbGxiYWNrKSwgZXJyKVxuICAgICAgfVxuXG4gICAgICByZXN1bWUodGhpcylcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJTZXNzaW9uRXJyb3IgKGVycikge1xuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcblxuICBvbkVycm9yKHRoaXNba0NsaWVudF0sIGVycilcbn1cblxuZnVuY3Rpb24gb25IdHRwMkZyYW1lRXJyb3IgKHR5cGUsIGNvZGUsIGlkKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoYEhUVFAvMjogXCJmcmFtZUVycm9yXCIgcmVjZWl2ZWQgLSB0eXBlICR7dHlwZX0sIGNvZGUgJHtjb2RlfWApXG5cbiAgaWYgKGlkID09PSAwKSB7XG4gICAgdGhpc1trU29ja2V0XVtrRXJyb3JdID0gZXJyXG4gICAgb25FcnJvcih0aGlzW2tDbGllbnRdLCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gb25IdHRwMlNlc3Npb25FbmQgKCkge1xuICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcpKVxuICB1dGlsLmRlc3Ryb3kodGhpc1trU29ja2V0XSwgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcpKVxufVxuXG5mdW5jdGlvbiBvbkhUVFAyR29Bd2F5IChjb2RlKSB7XG4gIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudF1cbiAgY29uc3QgZXJyID0gbmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcIkdPQVdBWVwiIGZyYW1lIHJlY2VpdmVkIHdpdGggY29kZSAke2NvZGV9YClcbiAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICBjbGllbnRba0hUVFAyU2Vzc2lvbl0gPSBudWxsXG5cbiAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICBhc3NlcnQodGhpc1trUGVuZGluZ10gPT09IDApXG5cbiAgICAvLyBGYWlsIGVudGlyZSBxdWV1ZS5cbiAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgZXJyb3JSZXF1ZXN0KHRoaXMsIHJlcXVlc3QsIGVycilcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDApIHtcbiAgICAvLyBGYWlsIGhlYWQgb2YgcGlwZWxpbmUuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG5cbiAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG5cbiAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLFxuICAgIGNsaWVudFtrVXJsXSxcbiAgICBbY2xpZW50XSxcbiAgICBlcnJcbiAgKVxuXG4gIHJlc3VtZShjbGllbnQpXG59XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGxodHRwL2NvbnN0YW50cycpXG5jb25zdCBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi9pbnRlcmNlcHRvci9yZWRpcmVjdEludGVyY2VwdG9yJylcbmNvbnN0IEVNUFRZX0JVRiA9IEJ1ZmZlci5hbGxvYygwKVxuXG5hc3luYyBmdW5jdGlvbiBsYXp5bGxodHRwICgpIHtcbiAgY29uc3QgbGxodHRwV2FzbURhdGEgPSBwcm9jZXNzLmVudi5KRVNUX1dPUktFUl9JRCA/IHJlcXVpcmUoJy4vbGxodHRwL2xsaHR0cC13YXNtLmpzJykgOiB1bmRlZmluZWRcblxuICBsZXQgbW9kXG4gIHRyeSB7XG4gICAgbW9kID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShCdWZmZXIuZnJvbShyZXF1aXJlKCcuL2xsaHR0cC9sbGh0dHBfc2ltZC13YXNtLmpzJyksICdiYXNlNjQnKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAvLyBXZSBjb3VsZCBjaGVjayBpZiB0aGUgZXJyb3Igd2FzIGNhdXNlZCBieSB0aGUgc2ltZCBvcHRpb24gbm90XG4gICAgLy8gYmVpbmcgZW5hYmxlZCwgYnV0IHRoZSBvY2N1cnJpbmcgb2YgdGhpcyBvdGhlciBlcnJvclxuICAgIC8vICogaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8xMTQ5NVxuICAgIC8vIGdvdCBtZSB0byByZW1vdmUgdGhhdCBjaGVjayB0byBhdm9pZCBicmVha2luZyBOb2RlIDEyLlxuICAgIG1vZCA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUoQnVmZmVyLmZyb20obGxodHRwV2FzbURhdGEgfHwgcmVxdWlyZSgnLi9sbGh0dHAvbGxodHRwLXdhc20uanMnKSwgJ2Jhc2U2NCcpKVxuICB9XG5cbiAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZCwge1xuICAgIGVudjoge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5cbiAgICAgIHdhc21fb25fdXJsOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fc3RhdHVzOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uU3RhdHVzKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fbWVzc2FnZV9iZWdpbjogKHApID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VCZWdpbigpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2hlYWRlcl9maWVsZDogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlckZpZWxkKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25faGVhZGVyX3ZhbHVlOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyVmFsdWUobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9oZWFkZXJzX2NvbXBsZXRlOiAocCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgc2hvdWxkS2VlcEFsaXZlKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJzQ29tcGxldGUoc3RhdHVzQ29kZSwgQm9vbGVhbih1cGdyYWRlKSwgQm9vbGVhbihzaG91bGRLZWVwQWxpdmUpKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9ib2R5OiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uQm9keShuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX21lc3NhZ2VfY29tcGxldGU6IChwKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKSB8fCAwXG4gICAgICB9XG5cbiAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgfVxuICB9KVxufVxuXG5sZXQgbGxodHRwSW5zdGFuY2UgPSBudWxsXG5sZXQgbGxodHRwUHJvbWlzZSA9IGxhenlsbGh0dHAoKVxubGxodHRwUHJvbWlzZS5jYXRjaCgpXG5cbmxldCBjdXJyZW50UGFyc2VyID0gbnVsbFxubGV0IGN1cnJlbnRCdWZmZXJSZWYgPSBudWxsXG5sZXQgY3VycmVudEJ1ZmZlclNpemUgPSAwXG5sZXQgY3VycmVudEJ1ZmZlclB0ciA9IG51bGxcblxuY29uc3QgVElNRU9VVF9IRUFERVJTID0gMVxuY29uc3QgVElNRU9VVF9CT0RZID0gMlxuY29uc3QgVElNRU9VVF9JRExFID0gM1xuXG5jbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvciAoY2xpZW50LCBzb2NrZXQsIHsgZXhwb3J0cyB9KSB7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShjbGllbnRba01heEhlYWRlcnNTaXplXSkgJiYgY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV0gPiAwKVxuXG4gICAgdGhpcy5sbGh0dHAgPSBleHBvcnRzXG4gICAgdGhpcy5wdHIgPSB0aGlzLmxsaHR0cC5sbGh0dHBfYWxsb2MoY29uc3RhbnRzLlRZUEUuUkVTUE9OU0UpXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gbnVsbFxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMudXBncmFkZSA9IGZhbHNlXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuICAgIHRoaXMuaGVhZGVyc01heFNpemUgPSBjbGllbnRba01heEhlYWRlcnNTaXplXVxuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gZmFsc2VcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gICAgdGhpcy5yZXN1bWUgPSB0aGlzLnJlc3VtZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmJ5dGVzUmVhZCA9IDBcblxuICAgIHRoaXMua2VlcEFsaXZlID0gJydcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSAnJ1xuICAgIHRoaXMuY29ubmVjdGlvbiA9ICcnXG4gICAgdGhpcy5tYXhSZXNwb25zZVNpemUgPSBjbGllbnRba01heFJlc3BvbnNlU2l6ZV1cbiAgfVxuXG4gIHNldFRpbWVvdXQgKHZhbHVlLCB0eXBlKSB7XG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IHR5cGVcbiAgICBpZiAodmFsdWUgIT09IHRoaXMudGltZW91dFZhbHVlKSB7XG4gICAgICB0aW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lcnMuc2V0VGltZW91dChvblBhcnNlclRpbWVvdXQsIHZhbHVlLCB0aGlzKVxuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgICBpZiAodGhpcy50aW1lb3V0LnVucmVmKSB7XG4gICAgICAgICAgdGhpcy50aW1lb3V0LnVucmVmKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgICAgfVxuICAgICAgdGhpcy50aW1lb3V0VmFsdWUgPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXN1bWUgKCkge1xuICAgIGlmICh0aGlzLnNvY2tldC5kZXN0cm95ZWQgfHwgIXRoaXMucGF1c2VkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKVxuXG4gICAgdGhpcy5sbGh0dHAubGxodHRwX3Jlc3VtZSh0aGlzLnB0cilcblxuICAgIGFzc2VydCh0aGlzLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMuZXhlY3V0ZSh0aGlzLnNvY2tldC5yZWFkKCkgfHwgRU1QVFlfQlVGKSAvLyBGbHVzaCBwYXJzZXIuXG4gICAgdGhpcy5yZWFkTW9yZSgpXG4gIH1cblxuICByZWFkTW9yZSAoKSB7XG4gICAgd2hpbGUgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLnB0cikge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLnNvY2tldC5yZWFkKClcbiAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRlKGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIGV4ZWN1dGUgKGRhdGEpIHtcbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKVxuICAgIGFzc2VydCghdGhpcy5wYXVzZWQpXG5cbiAgICBjb25zdCB7IHNvY2tldCwgbGxodHRwIH0gPSB0aGlzXG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiBjdXJyZW50QnVmZmVyU2l6ZSkge1xuICAgICAgaWYgKGN1cnJlbnRCdWZmZXJQdHIpIHtcbiAgICAgICAgbGxodHRwLmZyZWUoY3VycmVudEJ1ZmZlclB0cilcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRCdWZmZXJTaXplID0gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gNDA5NikgKiA0MDk2XG4gICAgICBjdXJyZW50QnVmZmVyUHRyID0gbGxodHRwLm1hbGxvYyhjdXJyZW50QnVmZmVyU2l6ZSlcbiAgICB9XG5cbiAgICBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgY3VycmVudEJ1ZmZlclB0ciwgY3VycmVudEJ1ZmZlclNpemUpLnNldChkYXRhKVxuXG4gICAgLy8gQ2FsbCBgZXhlY3V0ZWAgb24gdGhlIHdhc20gcGFyc2VyLlxuICAgIC8vIFdlIHBhc3MgdGhlIGBsbGh0dHBfcGFyc2VyYCBwb2ludGVyIGFkZHJlc3MsIHRoZSBwb2ludGVyIGFkZHJlc3Mgb2YgYnVmZmVyIHZpZXcgZGF0YSxcbiAgICAvLyBhbmQgZmluYWxseSB0aGUgbGVuZ3RoIG9mIGJ5dGVzIHRvIHBhcnNlLlxuICAgIC8vIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gZXJyb3IgY29kZSBvciBgY29uc3RhbnRzLkVSUk9SLk9LYC5cbiAgICB0cnkge1xuICAgICAgbGV0IHJldFxuXG4gICAgICB0cnkge1xuICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gZGF0YVxuICAgICAgICBjdXJyZW50UGFyc2VyID0gdGhpc1xuICAgICAgICByZXQgPSBsbGh0dHAubGxodHRwX2V4ZWN1dGUodGhpcy5wdHIsIGN1cnJlbnRCdWZmZXJQdHIsIGRhdGEubGVuZ3RoKVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYXRjaCAqL1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UGFyc2VyID0gbnVsbFxuICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCBvZmZzZXQgPSBsbGh0dHAubGxodHRwX2dldF9lcnJvcl9wb3ModGhpcy5wdHIpIC0gY3VycmVudEJ1ZmZlclB0clxuXG4gICAgICBpZiAocmV0ID09PSBjb25zdGFudHMuRVJST1IuUEFVU0VEX1VQR1JBREUpIHtcbiAgICAgICAgdGhpcy5vblVwZ3JhZGUoZGF0YS5zbGljZShvZmZzZXQpKVxuICAgICAgfSBlbHNlIGlmIChyZXQgPT09IGNvbnN0YW50cy5FUlJPUi5QQVVTRUQpIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gICAgICAgIHNvY2tldC51bnNoaWZ0KGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSBjb25zdGFudHMuRVJST1IuT0spIHtcbiAgICAgICAgY29uc3QgcHRyID0gbGxodHRwLmxsaHR0cF9nZXRfZXJyb3JfcmVhc29uKHRoaXMucHRyKVxuICAgICAgICBsZXQgbWVzc2FnZSA9ICcnXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICAgICAgaWYgKHB0cikge1xuICAgICAgICAgIGNvbnN0IGxlbiA9IG5ldyBVaW50OEFycmF5KGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBwdHIpLmluZGV4T2YoMClcbiAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICdSZXNwb25zZSBkb2VzIG5vdCBtYXRjaCB0aGUgSFRUUC8xLjEgcHJvdG9jb2wgKCcgK1xuICAgICAgICAgICAgQnVmZmVyLmZyb20obGxodHRwLm1lbW9yeS5idWZmZXIsIHB0ciwgbGVuKS50b1N0cmluZygpICtcbiAgICAgICAgICAgICcpJ1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBIVFRQUGFyc2VyRXJyb3IobWVzc2FnZSwgY29uc3RhbnRzLkVSUk9SW3JldF0sIGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKVxuXG4gICAgdGhpcy5sbGh0dHAubGxodHRwX2ZyZWUodGhpcy5wdHIpXG4gICAgdGhpcy5wdHIgPSBudWxsXG5cbiAgICB0aW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IG51bGxcblxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgfVxuXG4gIG9uU3RhdHVzIChidWYpIHtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBidWYudG9TdHJpbmcoKVxuICB9XG5cbiAgb25NZXNzYWdlQmVnaW4gKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjbGllbnQgfSA9IHRoaXNcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gIH1cblxuICBvbkhlYWRlckZpZWxkIChidWYpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmhlYWRlcnMubGVuZ3RoXG5cbiAgICBpZiAoKGxlbiAmIDEpID09PSAwKSB7XG4gICAgICB0aGlzLmhlYWRlcnMucHVzaChidWYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tsZW4gLSAxXSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyc1tsZW4gLSAxXSwgYnVmXSlcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrSGVhZGVyKGJ1Zi5sZW5ndGgpXG4gIH1cblxuICBvbkhlYWRlclZhbHVlIChidWYpIHtcbiAgICBsZXQgbGVuID0gdGhpcy5oZWFkZXJzLmxlbmd0aFxuXG4gICAgaWYgKChsZW4gJiAxKSA9PT0gMSkge1xuICAgICAgdGhpcy5oZWFkZXJzLnB1c2goYnVmKVxuICAgICAgbGVuICs9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzW2xlbiAtIDFdID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW2xlbiAtIDFdLCBidWZdKVxuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuaGVhZGVyc1tsZW4gLSAyXVxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgIHRoaXMua2VlcEFsaXZlICs9IGJ1Zi50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnY29ubmVjdGlvbicpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbiArPSBidWYudG9TdHJpbmcoKVxuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTQgJiYga2V5LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgICAgdGhpcy5jb250ZW50TGVuZ3RoICs9IGJ1Zi50b1N0cmluZygpXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0hlYWRlcihidWYubGVuZ3RoKVxuICB9XG5cbiAgdHJhY2tIZWFkZXIgKGxlbikge1xuICAgIHRoaXMuaGVhZGVyc1NpemUgKz0gbGVuXG4gICAgaWYgKHRoaXMuaGVhZGVyc1NpemUgPj0gdGhpcy5oZWFkZXJzTWF4U2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMuc29ja2V0LCBuZXcgSGVhZGVyc092ZXJmbG93RXJyb3IoKSlcbiAgICB9XG4gIH1cblxuICBvblVwZ3JhZGUgKGhlYWQpIHtcbiAgICBjb25zdCB7IHVwZ3JhZGUsIGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNDb2RlIH0gPSB0aGlzXG5cbiAgICBhc3NlcnQodXBncmFkZSlcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGFzc2VydChyZXF1ZXN0KVxuXG4gICAgYXNzZXJ0KCFzb2NrZXQuZGVzdHJveWVkKVxuICAgIGFzc2VydChzb2NrZXQgPT09IGNsaWVudFtrU29ja2V0XSlcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuICAgIGFzc2VydChyZXF1ZXN0LnVwZ3JhZGUgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gbnVsbFxuXG4gICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcblxuICAgIHNvY2tldC51bnNoaWZ0KGhlYWQpXG5cbiAgICBzb2NrZXRba1BhcnNlcl0uZGVzdHJveSgpXG4gICAgc29ja2V0W2tQYXJzZXJdID0gbnVsbFxuXG4gICAgc29ja2V0W2tDbGllbnRdID0gbnVsbFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuICAgIHNvY2tldFxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uU29ja2V0RXJyb3IpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgb25Tb2NrZXRSZWFkYWJsZSlcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25Tb2NrZXRFbmQpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSlcblxuICAgIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigndXBncmFkZScpKVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICB9XG5cbiAgICByZXN1bWUoY2xpZW50KVxuICB9XG5cbiAgb25IZWFkZXJzQ29tcGxldGUgKHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkge1xuICAgIGNvbnN0IHsgY2xpZW50LCBzb2NrZXQsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSA9IHRoaXNcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBhc3NlcnQoIXRoaXMudXBncmFkZSlcbiAgICBhc3NlcnQodGhpcy5zdGF0dXNDb2RlIDwgMjAwKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPT09IDEwMCkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFNvY2tldEVycm9yKCdiYWQgcmVzcG9uc2UnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICAvKiB0aGlzIGNhbiBvbmx5IGhhcHBlbiBpZiBzZXJ2ZXIgaXMgbWlzYmVoYXZpbmcgKi9cbiAgICBpZiAodXBncmFkZSAmJiAhcmVxdWVzdC51cGdyYWRlKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoJ2JhZCB1cGdyYWRlJywgdXRpbC5nZXRTb2NrZXRJbmZvKHNvY2tldCkpKVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRoaXMudGltZW91dFR5cGUsIFRJTUVPVVRfSEVBREVSUylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IChcbiAgICAgIHNob3VsZEtlZXBBbGl2ZSB8fFxuICAgICAgLy8gT3ZlcnJpZGUgbGxodHRwIHZhbHVlIHdoaWNoIGRvZXMgbm90IGFsbG93IGtlZXBBbGl2ZSBmb3IgSEVBRC5cbiAgICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnICYmICFzb2NrZXRba1Jlc2V0XSAmJiB0aGlzLmNvbm5lY3Rpb24udG9Mb3dlckNhc2UoKSA9PT0gJ2tlZXAtYWxpdmUnKVxuICAgIClcblxuICAgIGlmICh0aGlzLnN0YXR1c0NvZGUgPj0gMjAwKSB7XG4gICAgICBjb25zdCBib2R5VGltZW91dCA9IHJlcXVlc3QuYm9keVRpbWVvdXQgIT0gbnVsbFxuICAgICAgICA/IHJlcXVlc3QuYm9keVRpbWVvdXRcbiAgICAgICAgOiBjbGllbnRba0JvZHlUaW1lb3V0XVxuICAgICAgdGhpcy5zZXRUaW1lb3V0KGJvZHlUaW1lb3V0LCBUSU1FT1VUX0JPRFkpXG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMSlcbiAgICAgIHRoaXMudXBncmFkZSA9IHRydWVcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAxKVxuICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZVxuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHRoaXMuc2hvdWxkS2VlcEFsaXZlICYmIGNsaWVudFtrUGlwZWxpbmluZ10pIHtcbiAgICAgIGNvbnN0IGtlZXBBbGl2ZVRpbWVvdXQgPSB0aGlzLmtlZXBBbGl2ZSA/IHV0aWwucGFyc2VLZWVwQWxpdmVUaW1lb3V0KHRoaXMua2VlcEFsaXZlKSA6IG51bGxcblxuICAgICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gTWF0aC5taW4oXG4gICAgICAgICAga2VlcEFsaXZlVGltZW91dCAtIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0sXG4gICAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVNYXhUaW1lb3V0XVxuICAgICAgICApXG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IGNsaWVudFtrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0b3AgbW9yZSByZXF1ZXN0cyBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuXG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBsZXQgcGF1c2VcbiAgICB0cnkge1xuICAgICAgcGF1c2UgPSByZXF1ZXN0Lm9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCB0aGlzLnJlc3VtZSwgc3RhdHVzVGV4dCkgPT09IGZhbHNlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0W2tCbG9ja2luZ10pIHtcbiAgICAgIHNvY2tldFtrQmxvY2tpbmddID0gZmFsc2VcbiAgICAgIHJlc3VtZShjbGllbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdXNlID8gY29uc3RhbnRzLkVSUk9SLlBBVVNFRCA6IDBcbiAgfVxuXG4gIG9uQm9keSAoYnVmKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgbWF4UmVzcG9uc2VTaXplIH0gPSB0aGlzXG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhpcy50aW1lb3V0VHlwZSwgVElNRU9VVF9CT0RZKVxuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzc2VydChzdGF0dXNDb2RlID49IDIwMClcblxuICAgIGlmIChtYXhSZXNwb25zZVNpemUgPiAtMSAmJiB0aGlzLmJ5dGVzUmVhZCArIGJ1Zi5sZW5ndGggPiBtYXhSZXNwb25zZVNpemUpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yKCkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICB0aGlzLmJ5dGVzUmVhZCArPSBidWYubGVuZ3RoXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHJlcXVlc3Qub25EYXRhKGJ1ZikgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gIH1cblxuICBvbk1lc3NhZ2VDb21wbGV0ZSAoKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgaGVhZGVycywgY29udGVudExlbmd0aCwgYnl0ZXNSZWFkLCBzaG91bGRLZWVwQWxpdmUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkICYmICghc3RhdHVzQ29kZSB8fCBzaG91bGRLZWVwQWxpdmUpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG5cbiAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAxMDApXG5cbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLmJ5dGVzUmVhZCA9IDBcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSAnJ1xuICAgIHRoaXMua2VlcEFsaXZlID0gJydcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSAnJ1xuXG4gICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIGJlIGhhbmRsZWQgYnkgbGxodHRwPyAqL1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIGNvbnRlbnRMZW5ndGggJiYgYnl0ZXNSZWFkICE9PSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCkpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmVxdWVzdC5vbkNvbXBsZXRlKGhlYWRlcnMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgfVxuXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGlmIChzb2NrZXRba1dyaXRpbmddKSB7XG4gICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY2xpZW50W2tSdW5uaW5nXSwgMClcbiAgICAgIC8vIFJlc3BvbnNlIGNvbXBsZXRlZCBiZWZvcmUgcmVxdWVzdC5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoIXNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigncmVzZXQnKSlcbiAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgfSBlbHNlIGlmIChzb2NrZXRba1Jlc2V0XSAmJiBjbGllbnRba1J1bm5pbmddID09PSAwKSB7XG4gICAgICAvLyBEZXN0cm95IHNvY2tldCBvbmNlIGFsbCByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGF0IHRoZSB0YWlsIG9mIHRoZSBwaXBlbGluZSBpcyB0aGUgb25lXG4gICAgICAvLyB0aGF0IHJlcXVlc3RlZCByZXNldCBhbmQgbm8gZnVydGhlciByZXF1ZXN0cyBzaG91bGRcbiAgICAgIC8vIGhhdmUgYmVlbiBxdWV1ZWQgc2luY2UgdGhlbi5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSA9PT0gMSkge1xuICAgICAgLy8gV2UgbXVzdCB3YWl0IGEgZnVsbCBldmVudCBsb29wIGN5Y2xlIHRvIHJldXNlIHRoaXMgc29ja2V0IHRvIG1ha2Ugc3VyZVxuICAgICAgLy8gdGhhdCBub24tc3BlYyBjb21wbGlhbnQgc2VydmVycyBhcmUgbm90IGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24gZXZlbiBpZiB0aGV5XG4gICAgICAvLyBzYWlkIHRoZXkgd29uJ3QuXG4gICAgICBzZXRJbW1lZGlhdGUocmVzdW1lLCBjbGllbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VtZShjbGllbnQpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUGFyc2VyVGltZW91dCAocGFyc2VyKSB7XG4gIGNvbnN0IHsgc29ja2V0LCB0aW1lb3V0VHlwZSwgY2xpZW50IH0gPSBwYXJzZXJcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgIGlmICghc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXQud3JpdGFibGVOZWVkRHJhaW4gfHwgY2xpZW50W2tSdW5uaW5nXSA+IDEpIHtcbiAgICAgIGFzc2VydCghcGFyc2VyLnBhdXNlZCwgJ2Nhbm5vdCBiZSBwYXVzZWQgd2hpbGUgd2FpdGluZyBmb3IgaGVhZGVycycpXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSGVhZGVyc1RpbWVvdXRFcnJvcigpKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9CT0RZKSB7XG4gICAgaWYgKCFwYXJzZXIucGF1c2VkKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgQm9keVRpbWVvdXRFcnJvcigpKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9JRExFKSB7XG4gICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDAgJiYgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdKVxuICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3NvY2tldCBpZGxlIHRpbWVvdXQnKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBvblNvY2tldFJlYWRhYmxlICgpIHtcbiAgY29uc3QgeyBba1BhcnNlcl06IHBhcnNlciB9ID0gdGhpc1xuICBpZiAocGFyc2VyKSB7XG4gICAgcGFyc2VyLnJlYWRNb3JlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBvblNvY2tldEVycm9yIChlcnIpIHtcbiAgY29uc3QgeyBba0NsaWVudF06IGNsaWVudCwgW2tQYXJzZXJdOiBwYXJzZXIgfSA9IHRoaXNcblxuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dICE9PSAnaDInKSB7XG4gICAgLy8gT24gTWFjIE9TLCB3ZSBnZXQgYW4gRUNPTk5SRVNFVCBldmVuIGlmIHRoZXJlIGlzIGEgZnVsbCBib2R5IHRvIGJlIGZvcndhcmRlZFxuICAgIC8vIHRvIHRoZSB1c2VyLlxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VDT05OUkVTRVQnICYmIHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmb3IgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBlcnJcblxuICBvbkVycm9yKHRoaXNba0NsaWVudF0sIGVycilcbn1cblxuZnVuY3Rpb24gb25FcnJvciAoY2xpZW50LCBlcnIpIHtcbiAgaWYgKFxuICAgIGNsaWVudFtrUnVubmluZ10gPT09IDAgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfU09DS0VUJ1xuICApIHtcbiAgICAvLyBFcnJvciBpcyBub3QgY2F1c2VkIGJ5IHJ1bm5pbmcgcmVxdWVzdCBhbmQgbm90IGEgcmVjb3ZlcmFibGVcbiAgICAvLyBzb2NrZXQgZXJyb3IuXG5cbiAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nSWR4XSA9PT0gY2xpZW50W2tSdW5uaW5nSWR4XSlcblxuICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgfVxuICAgIGFzc2VydChjbGllbnRba1NpemVdID09PSAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0RW5kICgpIHtcbiAgY29uc3QgeyBba1BhcnNlcl06IHBhcnNlciwgW2tDbGllbnRdOiBjbGllbnQgfSA9IHRoaXNcblxuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dICE9PSAnaDInKSB7XG4gICAgaWYgKHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmYXIgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSkpXG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICBjb25zdCB7IFtrQ2xpZW50XTogY2xpZW50LCBba1BhcnNlcl06IHBhcnNlciB9ID0gdGhpc1xuXG4gIGlmIChjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPT09ICdoMScgJiYgcGFyc2VyKSB7XG4gICAgaWYgKCF0aGlzW2tFcnJvcl0gJiYgcGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIC8vIFdlIHRyZWF0IGFsbCBpbmNvbWluZyBkYXRhIHNvIGZhciBhcyBhIHZhbGlkIHJlc3BvbnNlLlxuICAgICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICB9XG5cbiAgICB0aGlzW2tQYXJzZXJdLmRlc3Ryb3koKVxuICAgIHRoaXNba1BhcnNlcl0gPSBudWxsXG4gIH1cblxuICBjb25zdCBlcnIgPSB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpXG5cbiAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuXG4gIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApXG5cbiAgICAvLyBGYWlsIGVudGlyZSBxdWV1ZS5cbiAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycpIHtcbiAgICAvLyBGYWlsIGhlYWQgb2YgcGlwZWxpbmUuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG5cbiAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG5cbiAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBlcnIpXG5cbiAgcmVzdW1lKGNsaWVudClcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdCAoY2xpZW50KSB7XG4gIGFzc2VydCghY2xpZW50W2tDb25uZWN0aW5nXSlcbiAgYXNzZXJ0KCFjbGllbnRba1NvY2tldF0pXG5cbiAgbGV0IHsgaG9zdCwgaG9zdG5hbWUsIHByb3RvY29sLCBwb3J0IH0gPSBjbGllbnRba1VybF1cblxuICAvLyBSZXNvbHZlIGlwdjZcbiAgaWYgKGhvc3RuYW1lWzBdID09PSAnWycpIHtcbiAgICBjb25zdCBpZHggPSBob3N0bmFtZS5pbmRleE9mKCddJylcblxuICAgIGFzc2VydChpZHggIT09IC0xKVxuICAgIGNvbnN0IGlwID0gaG9zdG5hbWUuc3Vic3RyKDEsIGlkeCAtIDEpXG5cbiAgICBhc3NlcnQobmV0LmlzSVAoaXApKVxuICAgIGhvc3RuYW1lID0gaXBcbiAgfVxuXG4gIGNsaWVudFtrQ29ubmVjdGluZ10gPSB0cnVlXG5cbiAgaWYgKGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5iZWZvcmVDb25uZWN0LnB1Ymxpc2goe1xuICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICBob3N0LFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LFxuICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl1cbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzb2NrZXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjbGllbnRba0Nvbm5lY3Rvcl0oe1xuICAgICAgICBob3N0LFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LCAoZXJyLCBzb2NrZXQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShzb2NrZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHt9KSwgbmV3IENsaWVudERlc3Ryb3llZEVycm9yKCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIGFzc2VydChzb2NrZXQpXG5cbiAgICBjb25zdCBpc0gyID0gc29ja2V0LmFscG5Qcm90b2NvbCA9PT0gJ2gyJ1xuICAgIGlmIChpc0gyKSB7XG4gICAgICBpZiAoIWgyRXhwZXJpbWVudGFsV2FybmVkKSB7XG4gICAgICAgIGgyRXhwZXJpbWVudGFsV2FybmVkID0gdHJ1ZVxuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdIMiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgICAgICBjb2RlOiAnVU5ESUNJLUgyJ1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChjbGllbnRba1VybF0sIHtcbiAgICAgICAgY3JlYXRlQ29ubmVjdGlvbjogKCkgPT4gc29ja2V0LFxuICAgICAgICBwZWVyTWF4Q29uY3VycmVudFN0cmVhbXM6IGNsaWVudFtrSFRUUDJTZXNzaW9uU3RhdGVdLm1heENvbmN1cnJlbnRTdHJlYW1zXG4gICAgICB9KVxuXG4gICAgICBjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPSAnaDInXG4gICAgICBzZXNzaW9uW2tDbGllbnRdID0gY2xpZW50XG4gICAgICBzZXNzaW9uW2tTb2NrZXRdID0gc29ja2V0XG4gICAgICBzZXNzaW9uLm9uKCdlcnJvcicsIG9uSHR0cDJTZXNzaW9uRXJyb3IpXG4gICAgICBzZXNzaW9uLm9uKCdmcmFtZUVycm9yJywgb25IdHRwMkZyYW1lRXJyb3IpXG4gICAgICBzZXNzaW9uLm9uKCdlbmQnLCBvbkh0dHAyU2Vzc2lvbkVuZClcbiAgICAgIHNlc3Npb24ub24oJ2dvYXdheScsIG9uSFRUUDJHb0F3YXkpXG4gICAgICBzZXNzaW9uLm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG4gICAgICBzZXNzaW9uLnVucmVmKClcblxuICAgICAgY2xpZW50W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuICAgICAgc29ja2V0W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWxsaHR0cEluc3RhbmNlKSB7XG4gICAgICAgIGxsaHR0cEluc3RhbmNlID0gYXdhaXQgbGxodHRwUHJvbWlzZVxuICAgICAgICBsbGh0dHBQcm9taXNlID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBzb2NrZXRba05vUmVmXSA9IGZhbHNlXG4gICAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gZmFsc2VcbiAgICAgIHNvY2tldFtrQmxvY2tpbmddID0gZmFsc2VcbiAgICAgIHNvY2tldFtrUGFyc2VyXSA9IG5ldyBQYXJzZXIoY2xpZW50LCBzb2NrZXQsIGxsaHR0cEluc3RhbmNlKVxuICAgIH1cblxuICAgIHNvY2tldFtrQ291bnRlcl0gPSAwXG4gICAgc29ja2V0W2tNYXhSZXF1ZXN0c10gPSBjbGllbnRba01heFJlcXVlc3RzXVxuICAgIHNvY2tldFtrQ2xpZW50XSA9IGNsaWVudFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuXG4gICAgc29ja2V0XG4gICAgICAub24oJ2Vycm9yJywgb25Tb2NrZXRFcnJvcilcbiAgICAgIC5vbigncmVhZGFibGUnLCBvblNvY2tldFJlYWRhYmxlKVxuICAgICAgLm9uKCdlbmQnLCBvblNvY2tldEVuZClcbiAgICAgIC5vbignY2xvc2UnLCBvblNvY2tldENsb3NlKVxuXG4gICAgY2xpZW50W2tTb2NrZXRdID0gc29ja2V0XG5cbiAgICBpZiAoY2hhbm5lbHMuY29ubmVjdGVkLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jb25uZWN0ZWQucHVibGlzaCh7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgICBob3N0LFxuICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgICBsb2NhbEFkZHJlc3M6IGNsaWVudFtrTG9jYWxBZGRyZXNzXVxuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXSxcbiAgICAgICAgc29ja2V0XG4gICAgICB9KVxuICAgIH1cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIGlmIChjaGFubmVscy5jb25uZWN0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RFcnJvci5wdWJsaXNoKHtcbiAgICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgcG9ydCxcbiAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdLFxuICAgICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RvcjogY2xpZW50W2tDb25uZWN0b3JdLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcbiAgICAgIHdoaWxlIChjbGllbnRba1BlbmRpbmddID4gMCAmJiBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdXS5zZXJ2ZXJuYW1lID09PSBjbGllbnRba1NlcnZlck5hbWVdKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdKytdXG4gICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihjbGllbnQsIGVycilcbiAgICB9XG5cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuICB9XG5cbiAgcmVzdW1lKGNsaWVudClcbn1cblxuZnVuY3Rpb24gZW1pdERyYWluIChjbGllbnQpIHtcbiAgY2xpZW50W2tOZWVkRHJhaW5dID0gMFxuICBjbGllbnQuZW1pdCgnZHJhaW4nLCBjbGllbnRba1VybF0sIFtjbGllbnRdKVxufVxuXG5mdW5jdGlvbiByZXN1bWUgKGNsaWVudCwgc3luYykge1xuICBpZiAoY2xpZW50W2tSZXN1bWluZ10gPT09IDIpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNsaWVudFtrUmVzdW1pbmddID0gMlxuXG4gIF9yZXN1bWUoY2xpZW50LCBzeW5jKVxuICBjbGllbnRba1Jlc3VtaW5nXSA9IDBcblxuICBpZiAoY2xpZW50W2tSdW5uaW5nSWR4XSA+IDI1Nikge1xuICAgIGNsaWVudFtrUXVldWVdLnNwbGljZSgwLCBjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gLT0gY2xpZW50W2tSdW5uaW5nSWR4XVxuICAgIGNsaWVudFtrUnVubmluZ0lkeF0gPSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc3VtZSAoY2xpZW50LCBzeW5jKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0gJiYgIWNsaWVudFtrU2l6ZV0pIHtcbiAgICAgIGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0oKVxuICAgICAgY2xpZW50W2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XVxuXG4gICAgaWYgKHNvY2tldCAmJiAhc29ja2V0LmRlc3Ryb3llZCAmJiBzb2NrZXQuYWxwblByb3RvY29sICE9PSAnaDInKSB7XG4gICAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCkge1xuICAgICAgICBpZiAoIXNvY2tldFtrTm9SZWZdICYmIHNvY2tldC51bnJlZikge1xuICAgICAgICAgIHNvY2tldC51bnJlZigpXG4gICAgICAgICAgc29ja2V0W2tOb1JlZl0gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnJlZikge1xuICAgICAgICBzb2NrZXQucmVmKClcbiAgICAgICAgc29ja2V0W2tOb1JlZl0gPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCkge1xuICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0lETEUpIHtcbiAgICAgICAgICBzb2NrZXRba1BhcnNlcl0uc2V0VGltZW91dChjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0sIFRJTUVPVVRfSURMRSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBzb2NrZXRba1BhcnNlcl0uc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICAgICAgICBjb25zdCBoZWFkZXJzVGltZW91dCA9IHJlcXVlc3QuaGVhZGVyc1RpbWVvdXQgIT0gbnVsbFxuICAgICAgICAgICAgPyByZXF1ZXN0LmhlYWRlcnNUaW1lb3V0XG4gICAgICAgICAgICA6IGNsaWVudFtrSGVhZGVyc1RpbWVvdXRdXG4gICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoaGVhZGVyc1RpbWVvdXQsIFRJTUVPVVRfSEVBREVSUylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0J1c3ldKSB7XG4gICAgICBjbGllbnRba05lZWREcmFpbl0gPSAyXG4gICAgfSBlbHNlIGlmIChjbGllbnRba05lZWREcmFpbl0gPT09IDIpIHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDFcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RHJhaW4sIGNsaWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXREcmFpbihjbGllbnQpXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1BlbmRpbmddID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+PSAoY2xpZW50W2tQaXBlbGluaW5nXSB8fCAxKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF1dXG5cbiAgICBpZiAoY2xpZW50W2tVcmxdLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiBjbGllbnRba1NlcnZlck5hbWVdICE9PSByZXF1ZXN0LnNlcnZlcm5hbWUpIHtcbiAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY2xpZW50W2tTZXJ2ZXJOYW1lXSA9IHJlcXVlc3Quc2VydmVybmFtZVxuXG4gICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5zZXJ2ZXJuYW1lICE9PSByZXF1ZXN0LnNlcnZlcm5hbWUpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcignc2VydmVybmFtZSBjaGFuZ2VkJykpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0Nvbm5lY3RpbmddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXNvY2tldCAmJiAhY2xpZW50W2tIVFRQMlNlc3Npb25dKSB7XG4gICAgICBjb25uZWN0KGNsaWVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkIHx8IHNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0W2tSZXNldF0gfHwgc29ja2V0W2tCbG9ja2luZ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAhcmVxdWVzdC5pZGVtcG90ZW50KSB7XG4gICAgICAvLyBOb24taWRlbXBvdGVudCByZXF1ZXN0IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgLy8gY291bGQgY2F1c2UgZmFpbHVyZS5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAocmVxdWVzdC51cGdyYWRlIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpKSB7XG4gICAgICAvLyBEb24ndCBkaXNwYXRjaCBhbiB1cGdyYWRlIHVudGlsIGFsbCBwcmVjZWRpbmcgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAvLyBBIG1pc2JlaGF2aW5nIHNlcnZlciBtaWdodCB1cGdyYWRlIHRoZSBjb25uZWN0aW9uIGJlZm9yZSBhbGwgcGlwZWxpbmVkXG4gICAgICAvLyByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodXRpbC5pc1N0cmVhbShyZXF1ZXN0LmJvZHkpICYmIHV0aWwuYm9keUxlbmd0aChyZXF1ZXN0LmJvZHkpID09PSAwKSB7XG4gICAgICByZXF1ZXN0LmJvZHlcbiAgICAgICAgLm9uKCdkYXRhJywgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXRpbC5kZXN0cm95KHRoaXMpXG4gICAgICAgIH0pXG5cbiAgICAgIHJlcXVlc3QuYm9keSA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiZcbiAgICAgICh1dGlsLmlzU3RyZWFtKHJlcXVlc3QuYm9keSkgfHwgdXRpbC5pc0FzeW5jSXRlcmFibGUocmVxdWVzdC5ib2R5KSkpIHtcbiAgICAgIC8vIFJlcXVlc3Qgd2l0aCBzdHJlYW0gb3IgaXRlcmF0b3IgYm9keSBjYW4gZXJyb3Igd2hpbGUgb3RoZXIgcmVxdWVzdHNcbiAgICAgIC8vIGFyZSBpbmZsaWdodCBhbmQgaW5kaXJlY3RseSBlcnJvciB0aG9zZSBhcyB3ZWxsLlxuICAgICAgLy8gRW5zdXJlIHRoaXMgZG9lc24ndCBoYXBwZW4gYnkgd2FpdGluZyBmb3IgaW5mbGlnaHRcbiAgICAgIC8vIHRvIGNvbXBsZXRlIGJlZm9yZSBkaXNwYXRjaGluZy5cblxuICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgLy8gY291bGQgY2F1c2UgZmFpbHVyZS5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghcmVxdWVzdC5hYm9ydGVkICYmIHdyaXRlKGNsaWVudCwgcmVxdWVzdCkpIHtcbiAgICAgIGNsaWVudFtrUGVuZGluZ0lkeF0rK1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tQZW5kaW5nSWR4XSwgMSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGUgKGNsaWVudCwgcmVxdWVzdCkge1xuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dID09PSAnaDInKSB7XG4gICAgd3JpdGVIMihjbGllbnQsIGNsaWVudFtrSFRUUDJTZXNzaW9uXSwgcmVxdWVzdClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHsgYm9keSwgbWV0aG9kLCBwYXRoLCBob3N0LCB1cGdyYWRlLCBoZWFkZXJzLCBibG9ja2luZywgcmVzZXQgfSA9IHJlcXVlc3RcblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4xXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjJcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuNVxuXG4gIC8vIFNlbmRpbmcgYSBwYXlsb2FkIGJvZHkgb24gYSByZXF1ZXN0IHRoYXQgZG9lcyBub3RcbiAgLy8gZXhwZWN0IGl0IGNhbiBjYXVzZSB1bmRlZmluZWQgYmVoYXZpb3Igb24gc29tZVxuICAvLyBzZXJ2ZXJzIGFuZCBjb3JydXB0IGNvbm5lY3Rpb24gc3RhdGUuIERvIG5vdFxuICAvLyByZS11c2UgdGhlIGNvbm5lY3Rpb24gZm9yIGZ1cnRoZXIgcmVxdWVzdHMuXG5cbiAgY29uc3QgZXhwZWN0c1BheWxvYWQgPSAoXG4gICAgbWV0aG9kID09PSAnUFVUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BPU1QnIHx8XG4gICAgbWV0aG9kID09PSAnUEFUQ0gnXG4gIClcblxuICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVHJ5IHRvIHJlYWQgRU9GIGluIG9yZGVyIHRvIGdldCBsZW5ndGguXG4gICAgYm9keS5yZWFkKDApXG4gIH1cblxuICBsZXQgY29udGVudExlbmd0aCA9IHV0aWwuYm9keUxlbmd0aChib2R5KVxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aCA9IHJlcXVlc3QuY29udGVudExlbmd0aFxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDAgJiYgIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuICAgIC8vIEEgdXNlciBhZ2VudCBTSE9VTEQgTk9UIHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgZmllbGQgd2hlblxuICAgIC8vIHRoZSByZXF1ZXN0IG1lc3NhZ2UgZG9lcyBub3QgY29udGFpbiBhIHBheWxvYWQgYm9keSBhbmQgdGhlIG1ldGhvZFxuICAgIC8vIHNlbWFudGljcyBkbyBub3QgYW50aWNpcGF0ZSBzdWNoIGEgYm9keS5cblxuICAgIGNvbnRlbnRMZW5ndGggPSBudWxsXG4gIH1cblxuICBpZiAocmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBudWxsICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gY29udGVudExlbmd0aCkge1xuICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgfVxuXG4gIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XVxuXG4gIHRyeSB7XG4gICAgcmVxdWVzdC5vbkNvbm5lY3QoKGVycikgPT4ge1xuICAgICAgaWYgKHJlcXVlc3QuYWJvcnRlZCB8fCByZXF1ZXN0LmNvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyIHx8IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ2Fib3J0ZWQnKSlcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWNvbGxpbmEvdW5kaWNpL2lzc3Vlcy8yNThcbiAgICAvLyBDbG9zZSBhZnRlciBhIEhFQUQgcmVxdWVzdCB0byBpbnRlcm9wIHdpdGggbWlzYmVoYXZpbmcgc2VydmVyc1xuICAgIC8vIHRoYXQgbWF5IHNlbmQgYSBib2R5IGluIHRoZSByZXNwb25zZS5cblxuICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICB9XG5cbiAgaWYgKHVwZ3JhZGUgfHwgbWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAvLyBPbiBDT05ORUNUIG9yIHVwZ3JhZGUsIGJsb2NrIHBpcGVsaW5lIGZyb20gZGlzcGF0Y2hpbmcgZnVydGhlclxuICAgIC8vIHJlcXVlc3RzIG9uIHRoaXMgY29ubmVjdGlvbi5cblxuICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICB9XG5cbiAgaWYgKHJlc2V0ICE9IG51bGwpIHtcbiAgICBzb2NrZXRba1Jlc2V0XSA9IHJlc2V0XG4gIH1cblxuICBpZiAoY2xpZW50W2tNYXhSZXF1ZXN0c10gJiYgc29ja2V0W2tDb3VudGVyXSsrID49IGNsaWVudFtrTWF4UmVxdWVzdHNdKSB7XG4gICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gIH1cblxuICBpZiAoYmxvY2tpbmcpIHtcbiAgICBzb2NrZXRba0Jsb2NraW5nXSA9IHRydWVcbiAgfVxuXG4gIGxldCBoZWFkZXIgPSBgJHttZXRob2R9ICR7cGF0aH0gSFRUUC8xLjFcXHJcXG5gXG5cbiAgaWYgKHR5cGVvZiBob3N0ID09PSAnc3RyaW5nJykge1xuICAgIGhlYWRlciArPSBgaG9zdDogJHtob3N0fVxcclxcbmBcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIgKz0gY2xpZW50W2tIb3N0SGVhZGVyXVxuICB9XG5cbiAgaWYgKHVwZ3JhZGUpIHtcbiAgICBoZWFkZXIgKz0gYGNvbm5lY3Rpb246IHVwZ3JhZGVcXHJcXG51cGdyYWRlOiAke3VwZ3JhZGV9XFxyXFxuYFxuICB9IGVsc2UgaWYgKGNsaWVudFtrUGlwZWxpbmluZ10gJiYgIXNvY2tldFtrUmVzZXRdKSB7XG4gICAgaGVhZGVyICs9ICdjb25uZWN0aW9uOiBrZWVwLWFsaXZlXFxyXFxuJ1xuICB9IGVsc2Uge1xuICAgIGhlYWRlciArPSAnY29ubmVjdGlvbjogY2xvc2VcXHJcXG4nXG4gIH1cblxuICBpZiAoaGVhZGVycykge1xuICAgIGhlYWRlciArPSBoZWFkZXJzXG4gIH1cblxuICBpZiAoY2hhbm5lbHMuc2VuZEhlYWRlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5zZW5kSGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdCwgaGVhZGVyczogaGVhZGVyLCBzb2NrZXQgfSlcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBhc3NlcnRpb24gKi9cbiAgaWYgKCFib2R5KSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDApIHtcbiAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IG51bGwsICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICB9XG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuYnl0ZUxlbmd0aCwgJ2J1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG5cbiAgICBzb2NrZXQuY29yaygpXG4gICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgIHNvY2tldC53cml0ZShib2R5KVxuICAgIHNvY2tldC51bmNvcmsoKVxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChib2R5KVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSkge1xuICAgIGlmICh0eXBlb2YgYm9keS5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdyaXRlSXRlcmFibGUoeyBib2R5OiBib2R5LnN0cmVhbSgpLCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZUJsb2IoeyBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICAgIH1cbiAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgd3JpdGVTdHJlYW0oeyBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgIHdyaXRlSXRlcmFibGUoeyBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHdyaXRlSDIgKGNsaWVudCwgc2Vzc2lvbiwgcmVxdWVzdCkge1xuICBjb25zdCB7IGJvZHksIG1ldGhvZCwgcGF0aCwgaG9zdCwgdXBncmFkZSwgZXhwZWN0Q29udGludWUsIHNpZ25hbCwgaGVhZGVyczogcmVxSGVhZGVycyB9ID0gcmVxdWVzdFxuXG4gIGxldCBoZWFkZXJzXG4gIGlmICh0eXBlb2YgcmVxSGVhZGVycyA9PT0gJ3N0cmluZycpIGhlYWRlcnMgPSBSZXF1ZXN0W2tIVFRQMkNvcHlIZWFkZXJzXShyZXFIZWFkZXJzLnRyaW0oKSlcbiAgZWxzZSBoZWFkZXJzID0gcmVxSGVhZGVyc1xuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IEVycm9yKCdVcGdyYWRlIG5vdCBzdXBwb3J0ZWQgZm9yIEgyJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRPRE8oSFRUUC8yKTogU2hvdWxkIHdlIGNhbGwgb25Db25uZWN0IGltbWVkaWF0ZWx5IG9yIG9uIHN0cmVhbSByZWFkeSBldmVudD9cbiAgICByZXF1ZXN0Lm9uQ29ubmVjdCgoZXJyKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlcXVlc3QuY29tcGxldGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBsZXQgc3RyZWFtXG4gIGNvbnN0IGgyU3RhdGUgPSBjbGllbnRba0hUVFAyU2Vzc2lvblN0YXRlXVxuXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBob3N0IHx8IGNsaWVudFtrSG9zdF1cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfTUVUSE9EXSA9IG1ldGhvZFxuXG4gIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgIHNlc3Npb24ucmVmKClcbiAgICAvLyB3ZSBhcmUgYWxyZWFkeSBjb25uZWN0ZWQsIHN0cmVhbXMgYXJlIHBlbmRpbmcsIGZpcnN0IHJlcXVlc3RcbiAgICAvLyB3aWxsIGNyZWF0ZSBhIG5ldyBzdHJlYW0uIFdlIHRyaWdnZXIgYSByZXF1ZXN0IHRvIGNyZWF0ZSB0aGUgc3RyZWFtIGFuZCB3YWl0IHVudGlsXG4gICAgLy8gYHJlYWR5YCBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAvLyBXZSBkaXNhYmxlZCBlbmRTdHJlYW0gdG8gYWxsb3cgdGhlIHVzZXIgdG8gd3JpdGUgdG8gdGhlIHN0cmVhbVxuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7IGVuZFN0cmVhbTogZmFsc2UsIHNpZ25hbCB9KVxuXG4gICAgaWYgKHN0cmVhbS5pZCAmJiAhc3RyZWFtLnBlbmRpbmcpIHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICsraDJTdGF0ZS5vcGVuU3RyZWFtc1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ub25jZSgncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICAgKytoMlN0YXRlLm9wZW5TdHJlYW1zXG4gICAgICB9KVxuICAgIH1cblxuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGgyU3RhdGUub3BlblN0cmVhbXMgLT0gMVxuICAgICAgLy8gVE9ETyhIVFRQLzIpOiB1bnJlZiBvbmx5IGlmIGN1cnJlbnQgc3RyZWFtcyBjb3VudCBpcyAwXG4gICAgICBpZiAoaDJTdGF0ZS5vcGVuU3RyZWFtcyA9PT0gMCkgc2Vzc2lvbi51bnJlZigpXG4gICAgfSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzU0MCNzZWN0aW9uLTguM1xuICAvLyA6cGF0aCBhbmQgOnNjaGVtZSBoZWFkZXJzIG11c3QgYmUgb21pdGVkIHdoZW4gc2VuZGluZyBDT05ORUNUXG5cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF0gPSBwYXRoXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX1NDSEVNRV0gPSAnaHR0cHMnXG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4yXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjVcblxuICAvLyBTZW5kaW5nIGEgcGF5bG9hZCBib2R5IG9uIGEgcmVxdWVzdCB0aGF0IGRvZXMgbm90XG4gIC8vIGV4cGVjdCBpdCBjYW4gY2F1c2UgdW5kZWZpbmVkIGJlaGF2aW9yIG9uIHNvbWVcbiAgLy8gc2VydmVycyBhbmQgY29ycnVwdCBjb25uZWN0aW9uIHN0YXRlLiBEbyBub3RcbiAgLy8gcmUtdXNlIHRoZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIHJlcXVlc3RzLlxuXG4gIGNvbnN0IGV4cGVjdHNQYXlsb2FkID0gKFxuICAgIG1ldGhvZCA9PT0gJ1BVVCcgfHxcbiAgICBtZXRob2QgPT09ICdQT1NUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BBVENIJ1xuICApXG5cbiAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRyeSB0byByZWFkIEVPRiBpbiBvcmRlciB0byBnZXQgbGVuZ3RoLlxuICAgIGJvZHkucmVhZCgwKVxuICB9XG5cbiAgbGV0IGNvbnRlbnRMZW5ndGggPSB1dGlsLmJvZHlMZW5ndGgoYm9keSlcblxuICBpZiAoY29udGVudExlbmd0aCA9PSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aCA9IHJlcXVlc3QuY29udGVudExlbmd0aFxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDAgfHwgIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuICAgIC8vIEEgdXNlciBhZ2VudCBTSE9VTEQgTk9UIHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgZmllbGQgd2hlblxuICAgIC8vIHRoZSByZXF1ZXN0IG1lc3NhZ2UgZG9lcyBub3QgY29udGFpbiBhIHBheWxvYWQgYm9keSBhbmQgdGhlIG1ldGhvZFxuICAgIC8vIHNlbWFudGljcyBkbyBub3QgYW50aWNpcGF0ZSBzdWNoIGEgYm9keS5cblxuICAgIGNvbnRlbnRMZW5ndGggPSBudWxsXG4gIH1cblxuICBpZiAocmVxdWVzdC5jb250ZW50TGVuZ3RoICE9IG51bGwgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgIGFzc2VydChib2R5LCAnbm8gYm9keSBtdXN0IG5vdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9DT05URU5UX0xFTkdUSF0gPSBgJHtjb250ZW50TGVuZ3RofWBcbiAgfVxuXG4gIHNlc3Npb24ucmVmKClcblxuICBjb25zdCBzaG91bGRFbmRTdHJlYW0gPSBtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnXG4gIGlmIChleHBlY3RDb250aW51ZSkge1xuICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0VYUEVDVF0gPSAnMTAwLWNvbnRpbnVlJ1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJ25vZGU6aHR0cDInKS5DbGllbnRIdHRwMlN0cmVhbX1cbiAgICAgKi9cbiAgICBzdHJlYW0gPSBzZXNzaW9uLnJlcXVlc3QoaGVhZGVycywgeyBlbmRTdHJlYW06IHNob3VsZEVuZFN0cmVhbSwgc2lnbmFsIH0pXG5cbiAgICBzdHJlYW0ub25jZSgnY29udGludWUnLCB3cml0ZUJvZHlIMilcbiAgfSBlbHNlIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnbm9kZTpodHRwMicpLkNsaWVudEh0dHAyU3RyZWFtfSAqL1xuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7XG4gICAgICBlbmRTdHJlYW06IHNob3VsZEVuZFN0cmVhbSxcbiAgICAgIHNpZ25hbFxuICAgIH0pXG4gICAgd3JpdGVCb2R5SDIoKVxuICB9XG5cbiAgLy8gSW5jcmVtZW50IGNvdW50ZXIgYXMgd2UgaGF2ZSBuZXcgc2V2ZXJhbCBzdHJlYW1zIG9wZW5cbiAgKytoMlN0YXRlLm9wZW5TdHJlYW1zXG5cbiAgc3RyZWFtLm9uY2UoJ3Jlc3BvbnNlJywgaGVhZGVycyA9PiB7XG4gICAgaWYgKHJlcXVlc3Qub25IZWFkZXJzKE51bWJlcihoZWFkZXJzW0hUVFAyX0hFQURFUl9TVEFUVVNdKSwgaGVhZGVycywgc3RyZWFtLnJlc3VtZS5iaW5kKHN0cmVhbSksICcnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHN0cmVhbS5wYXVzZSgpXG4gICAgfVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgcmVxdWVzdC5vbkNvbXBsZXRlKFtdKVxuICB9KVxuXG4gIHN0cmVhbS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgIGlmIChyZXF1ZXN0Lm9uRGF0YShjaHVuaykgPT09IGZhbHNlKSBzdHJlYW0ucGF1c2UoKVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICBoMlN0YXRlLm9wZW5TdHJlYW1zIC09IDFcbiAgICAvLyBUT0RPKEhUVFAvMik6IHVucmVmIG9ubHkgaWYgY3VycmVudCBzdHJlYW1zIGNvdW50IGlzIDBcbiAgICBpZiAoaDJTdGF0ZS5vcGVuU3RyZWFtcyA9PT0gMCkgc2Vzc2lvbi51bnJlZigpXG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbGllbnRba0hUVFAyU2Vzc2lvbl0gJiYgIWNsaWVudFtrSFRUUDJTZXNzaW9uXS5kZXN0cm95ZWQgJiYgIXRoaXMuY2xvc2VkICYmICF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgaDJTdGF0ZS5zdHJlYW1zIC09IDFcbiAgICAgIHV0aWwuZGVzdHJveShzdHJlYW0sIGVycilcbiAgICB9XG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2ZyYW1lRXJyb3InLCAodHlwZSwgY29kZSkgPT4ge1xuICAgIGNvbnN0IGVyciA9IG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoYEhUVFAvMjogXCJmcmFtZUVycm9yXCIgcmVjZWl2ZWQgLSB0eXBlICR7dHlwZX0sIGNvZGUgJHtjb2RlfWApXG4gICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuXG4gICAgaWYgKGNsaWVudFtrSFRUUDJTZXNzaW9uXSAmJiAhY2xpZW50W2tIVFRQMlNlc3Npb25dLmRlc3Ryb3llZCAmJiAhdGhpcy5jbG9zZWQgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICBoMlN0YXRlLnN0cmVhbXMgLT0gMVxuICAgICAgdXRpbC5kZXN0cm95KHN0cmVhbSwgZXJyKVxuICAgIH1cbiAgfSlcblxuICAvLyBzdHJlYW0ub24oJ2Fib3J0ZWQnLCAoKSA9PiB7XG4gIC8vICAgLy8gVE9ETyhIVFRQLzIpOiBTdXBwb3J0IGFib3J0ZWRcbiAgLy8gfSlcblxuICAvLyBzdHJlYW0ub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gIC8vICAgLy8gVE9ETyhIVFRQLzIpOiBTdXBwb3J0IHRpbWVvdXRcbiAgLy8gfSlcblxuICAvLyBzdHJlYW0ub24oJ3B1c2gnLCBoZWFkZXJzID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvciBwdXNoXG4gIC8vIH0pXG5cbiAgLy8gc3RyZWFtLm9uKCd0cmFpbGVycycsIGhlYWRlcnMgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9ydCB0cmFpbGVyc1xuICAvLyB9KVxuXG4gIHJldHVybiB0cnVlXG5cbiAgZnVuY3Rpb24gd3JpdGVCb2R5SDIgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBhc3NlcnRpb24gKi9cbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5ieXRlTGVuZ3RoLCAnYnVmZmVyIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICAgIHN0cmVhbS5jb3JrKClcbiAgICAgIHN0cmVhbS53cml0ZShib2R5KVxuICAgICAgc3RyZWFtLnVuY29yaygpXG4gICAgICBzdHJlYW0uZW5kKClcbiAgICAgIHJlcXVlc3Qub25Cb2R5U2VudChib2R5KVxuICAgICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSkge1xuICAgICAgaWYgKHR5cGVvZiBib2R5LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3cml0ZUl0ZXJhYmxlKHtcbiAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIGgyc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgICAgZXhwZWN0c1BheWxvYWQsXG4gICAgICAgICAgYm9keTogYm9keS5zdHJlYW0oKSxcbiAgICAgICAgICBzb2NrZXQ6IGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgICBoZWFkZXI6ICcnXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUJsb2Ioe1xuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgY2xpZW50LFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgICBleHBlY3RzUGF5bG9hZCxcbiAgICAgICAgICBoMnN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgIGhlYWRlcjogJycsXG4gICAgICAgICAgc29ja2V0OiBjbGllbnRba1NvY2tldF1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIHdyaXRlU3RyZWFtKHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZCxcbiAgICAgICAgc29ja2V0OiBjbGllbnRba1NvY2tldF0sXG4gICAgICAgIGgyc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgIGhlYWRlcjogJydcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzSXRlcmFibGUoYm9keSkpIHtcbiAgICAgIHdyaXRlSXRlcmFibGUoe1xuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgIGV4cGVjdHNQYXlsb2FkLFxuICAgICAgICBoZWFkZXI6ICcnLFxuICAgICAgICBoMnN0cmVhbTogc3RyZWFtLFxuICAgICAgICBzb2NrZXQ6IGNsaWVudFtrU29ja2V0XVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmVhbSAoeyBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQgfSkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCAhPT0gMCB8fCBjbGllbnRba1J1bm5pbmddID09PSAwLCAnc3RyZWFtIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgaWYgKGNsaWVudFtrSFRUUENvbm5WZXJzaW9uXSA9PT0gJ2gyJykge1xuICAgIC8vIEZvciBIVFRQLzIsIGlzIGVub3VnaCB0byBwaXBlIHRoZSBzdHJlYW1cbiAgICBjb25zdCBwaXBlID0gcGlwZWxpbmUoXG4gICAgICBib2R5LFxuICAgICAgaDJzdHJlYW0sXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgICAgICAgIHV0aWwuZGVzdHJveShoMnN0cmVhbSwgZXJyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG5cbiAgICBwaXBlLm9uKCdkYXRhJywgb25QaXBlRGF0YSlcbiAgICBwaXBlLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICAgIHBpcGUucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvblBpcGVEYXRhKVxuICAgICAgdXRpbC5kZXN0cm95KHBpcGUpXG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIG9uUGlwZURhdGEgKGNodW5rKSB7XG4gICAgICByZXF1ZXN0Lm9uQm9keVNlbnQoY2h1bmspXG4gICAgfVxuXG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgZmluaXNoZWQgPSBmYWxzZVxuXG4gIGNvbnN0IHdyaXRlciA9IG5ldyBBc3luY1dyaXRlcih7IHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pXG5cbiAgY29uc3Qgb25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCF3cml0ZXIud3JpdGUoY2h1bmspICYmIHRoaXMucGF1c2UpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3kodGhpcywgZXJyKVxuICAgIH1cbiAgfVxuICBjb25zdCBvbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJvZHkucmVzdW1lKSB7XG4gICAgICBib2R5LnJlc3VtZSgpXG4gICAgfVxuICB9XG4gIGNvbnN0IG9uQWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgb25GaW5pc2hlZChuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICB9XG4gIGNvbnN0IG9uRmluaXNoZWQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBmaW5pc2hlZCA9IHRydWVcblxuICAgIGFzc2VydChzb2NrZXQuZGVzdHJveWVkIHx8IChzb2NrZXRba1dyaXRpbmddICYmIGNsaWVudFtrUnVubmluZ10gPD0gMSkpXG5cbiAgICBzb2NrZXRcbiAgICAgIC5vZmYoJ2RyYWluJywgb25EcmFpbilcbiAgICAgIC5vZmYoJ2Vycm9yJywgb25GaW5pc2hlZClcblxuICAgIGJvZHlcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSlcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25GaW5pc2hlZClcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQWJvcnQpXG5cbiAgICBpZiAoIWVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd3JpdGVyLmVuZCgpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBlcnIgPSBlclxuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlci5kZXN0cm95KGVycilcblxuICAgIGlmIChlcnIgJiYgKGVyci5jb2RlICE9PSAnVU5EX0VSUl9JTkZPJyB8fCBlcnIubWVzc2FnZSAhPT0gJ3Jlc2V0JykpIHtcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuZGVzdHJveShib2R5KVxuICAgIH1cbiAgfVxuXG4gIGJvZHlcbiAgICAub24oJ2RhdGEnLCBvbkRhdGEpXG4gICAgLm9uKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgIC5vbignZXJyb3InLCBvbkZpbmlzaGVkKVxuICAgIC5vbignY2xvc2UnLCBvbkFib3J0KVxuXG4gIGlmIChib2R5LnJlc3VtZSkge1xuICAgIGJvZHkucmVzdW1lKClcbiAgfVxuXG4gIHNvY2tldFxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuICAgIC5vbignZXJyb3InLCBvbkZpbmlzaGVkKVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUJsb2IgKHsgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgJ2Jsb2IgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gIGNvbnN0IGlzSDIgPSBjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPT09ICdoMidcbiAgdHJ5IHtcbiAgICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsICYmIGNvbnRlbnRMZW5ndGggIT09IGJvZHkuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpXG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXdhaXQgYm9keS5hcnJheUJ1ZmZlcigpKVxuXG4gICAgaWYgKGlzSDIpIHtcbiAgICAgIGgyc3RyZWFtLmNvcmsoKVxuICAgICAgaDJzdHJlYW0ud3JpdGUoYnVmZmVyKVxuICAgICAgaDJzdHJlYW0udW5jb3JrKClcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LmNvcmsoKVxuICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgc29ja2V0LndyaXRlKGJ1ZmZlcilcbiAgICAgIHNvY2tldC51bmNvcmsoKVxuICAgIH1cblxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChidWZmZXIpXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIHJlc3VtZShjbGllbnQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHV0aWwuZGVzdHJveShpc0gyID8gaDJzdHJlYW0gOiBzb2NrZXQsIGVycilcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUl0ZXJhYmxlICh7IGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdpdGVyYXRvciBib2R5IGNhbm5vdCBiZSBwaXBlbGluZWQnKVxuXG4gIGxldCBjYWxsYmFjayA9IG51bGxcbiAgZnVuY3Rpb24gb25EcmFpbiAoKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgIGNiKClcbiAgICB9XG4gIH1cblxuICBjb25zdCB3YWl0Rm9yRHJhaW4gPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXNzZXJ0KGNhbGxiYWNrID09PSBudWxsKVxuXG4gICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICByZWplY3Qoc29ja2V0W2tFcnJvcl0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gcmVzb2x2ZVxuICAgIH1cbiAgfSlcblxuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dID09PSAnaDInKSB7XG4gICAgaDJzdHJlYW1cbiAgICAgIC5vbignY2xvc2UnLCBvbkRyYWluKVxuICAgICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG5cbiAgICB0cnkge1xuICAgICAgLy8gSXQncyB1cCB0byB0aGUgdXNlciB0byBzb21laG93IGFib3J0IHRoZSBhc3luYyBpdGVyYWJsZS5cbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzID0gaDJzdHJlYW0ud3JpdGUoY2h1bmspXG4gICAgICAgIHJlcXVlc3Qub25Cb2R5U2VudChjaHVuaylcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICBhd2FpdCB3YWl0Rm9yRHJhaW4oKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBoMnN0cmVhbS5kZXN0cm95KGVycilcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgICAgIGgyc3RyZWFtLmVuZCgpXG4gICAgICBoMnN0cmVhbVxuICAgICAgICAub2ZmKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgICAgIC5vZmYoJ2RyYWluJywgb25EcmFpbilcbiAgICB9XG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIHNvY2tldFxuICAgIC5vbignY2xvc2UnLCBvbkRyYWluKVxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuXG4gIGNvbnN0IHdyaXRlciA9IG5ldyBBc3luY1dyaXRlcih7IHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pXG4gIHRyeSB7XG4gICAgLy8gSXQncyB1cCB0byB0aGUgdXNlciB0byBzb21laG93IGFib3J0IHRoZSBhc3luYyBpdGVyYWJsZS5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgICAgfVxuXG4gICAgICBpZiAoIXdyaXRlci53cml0ZShjaHVuaykpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvckRyYWluKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZXIuZW5kKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgd3JpdGVyLmRlc3Ryb3koZXJyKVxuICB9IGZpbmFsbHkge1xuICAgIHNvY2tldFxuICAgICAgLm9mZignY2xvc2UnLCBvbkRyYWluKVxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICB9XG59XG5cbmNsYXNzIEFzeW5jV3JpdGVyIHtcbiAgY29uc3RydWN0b3IgKHsgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSkge1xuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGhcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMFxuICAgIHRoaXMuZXhwZWN0c1BheWxvYWQgPSBleHBlY3RzUGF5bG9hZFxuICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gdHJ1ZVxuICB9XG5cbiAgd3JpdGUgKGNodW5rKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgYnl0ZXNXcml0dGVuLCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0gPSB0aGlzXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rKVxuICAgIGlmICghbGVuKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFdlIHNob3VsZCBkZWZlciB3cml0aW5nIGNodW5rcy5cbiAgICBpZiAoY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiBieXRlc1dyaXR0ZW4gKyBsZW4gPiBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgfVxuXG4gICAgc29ja2V0LmNvcmsoKVxuXG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn10cmFuc2Zlci1lbmNvZGluZzogY2h1bmtlZFxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICBzb2NrZXQud3JpdGUoYFxcclxcbiR7bGVuLnRvU3RyaW5nKDE2KX1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICB9XG5cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBsZW5cblxuICAgIGNvbnN0IHJldCA9IHNvY2tldC53cml0ZShjaHVuaylcblxuICAgIHNvY2tldC51bmNvcmsoKVxuXG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICAgIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZW5kICgpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIsIHJlcXVlc3QgfSA9IHRoaXNcbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcbiAgICAgIGlmIChleHBlY3RzUGF5bG9hZCkge1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgICAgIC8vIEEgdXNlciBhZ2VudCBTSE9VTEQgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGluIGEgcmVxdWVzdCBtZXNzYWdlIHdoZW5cbiAgICAgICAgLy8gbm8gVHJhbnNmZXItRW5jb2RpbmcgaXMgc2VudCBhbmQgdGhlIHJlcXVlc3QgbWV0aG9kIGRlZmluZXMgYSBtZWFuaW5nXG4gICAgICAgIC8vIGZvciBhbiBlbmNsb3NlZCBwYXlsb2FkIGJvZHkuXG5cbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogMFxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgIHNvY2tldC53cml0ZSgnXFxyXFxuMFxcclxcblxcclxcbicsICdsYXRpbjEnKVxuICAgIH1cblxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIGJ5dGVzV3JpdHRlbiAhPT0gY29udGVudExlbmd0aCkge1xuICAgICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQgJiYgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICBzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bWUoY2xpZW50KVxuICB9XG5cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIGNsaWVudCB9ID0gdGhpc1xuXG4gICAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA8PSAxLCAncGlwZWxpbmUgc2hvdWxkIG9ubHkgY29udGFpbiB0aGlzIHJlcXVlc3QnKVxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgZXJyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlcnJvclJlcXVlc3QgKGNsaWVudCwgcmVxdWVzdCwgZXJyKSB7XG4gIHRyeSB7XG4gICAgcmVxdWVzdC5vbkVycm9yKGVycilcbiAgICBhc3NlcnQocmVxdWVzdC5hYm9ydGVkKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjbGllbnQuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/compat/dispatcher-weakref.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/compat/dispatcher-weakref.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore file: only for Node 12 */\n\nconst { kConnected, kSize } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\n\nclass CompatWeakRef {\n  constructor (value) {\n    this.value = value\n  }\n\n  deref () {\n    return this.value[kConnected] === 0 && this.value[kSize] === 0\n      ? undefined\n      : this.value\n  }\n}\n\nclass CompatFinalizer {\n  constructor (finalizer) {\n    this.finalizer = finalizer\n  }\n\n  register (dispatcher, key) {\n    if (dispatcher.on) {\n      dispatcher.on('disconnect', () => {\n        if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n          this.finalizer(key)\n        }\n      })\n    }\n  }\n}\n\nmodule.exports = function () {\n  // FIXME: remove workaround when the Node bug is fixed\n  // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\n  if (process.env.NODE_V8_COVERAGE) {\n    return {\n      WeakRef: CompatWeakRef,\n      FinalizationRegistry: CompatFinalizer\n    }\n  }\n  return {\n    WeakRef: global.WeakRef || CompatWeakRef,\n    FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb21wYXQvZGlzcGF0Y2hlci13ZWFrcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaOztBQUVBLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb21wYXQvZGlzcGF0Y2hlci13ZWFrcmVmLmpzPzAzZDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlOiBvbmx5IGZvciBOb2RlIDEyICovXG5cbmNvbnN0IHsga0Nvbm5lY3RlZCwga1NpemUgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5cbmNsYXNzIENvbXBhdFdlYWtSZWYge1xuICBjb25zdHJ1Y3RvciAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIGRlcmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVtrQ29ubmVjdGVkXSA9PT0gMCAmJiB0aGlzLnZhbHVlW2tTaXplXSA9PT0gMFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogdGhpcy52YWx1ZVxuICB9XG59XG5cbmNsYXNzIENvbXBhdEZpbmFsaXplciB7XG4gIGNvbnN0cnVjdG9yIChmaW5hbGl6ZXIpIHtcbiAgICB0aGlzLmZpbmFsaXplciA9IGZpbmFsaXplclxuICB9XG5cbiAgcmVnaXN0ZXIgKGRpc3BhdGNoZXIsIGtleSkge1xuICAgIGlmIChkaXNwYXRjaGVyLm9uKSB7XG4gICAgICBkaXNwYXRjaGVyLm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBpZiAoZGlzcGF0Y2hlcltrQ29ubmVjdGVkXSA9PT0gMCAmJiBkaXNwYXRjaGVyW2tTaXplXSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZmluYWxpemVyKGtleSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEZJWE1FOiByZW1vdmUgd29ya2Fyb3VuZCB3aGVuIHRoZSBOb2RlIGJ1ZyBpcyBmaXhlZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0I2lzc3VlY29tbWVudC0xNzQxNzc2MzA4XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFdlYWtSZWY6IENvbXBhdFdlYWtSZWYsXG4gICAgICBGaW5hbGl6YXRpb25SZWdpc3RyeTogQ29tcGF0RmluYWxpemVyXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgV2Vha1JlZjogZ2xvYmFsLldlYWtSZWYgfHwgQ29tcGF0V2Vha1JlZixcbiAgICBGaW5hbGl6YXRpb25SZWdpc3RyeTogZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5IHx8IENvbXBhdEZpbmFsaXplclxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/compat/dispatcher-weakref.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/cookies/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/cookies/constants.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096\n\nmodule.exports = {\n  maxAttributeValueSize,\n  maxNameValuePairSize\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL2NvbnN0YW50cy5qcz85NzUyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jY29va2llLW1heGltdW0tYXR0cmlidXRlLXZhbHVlLXNpemVcbmNvbnN0IG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSA9IDEwMjRcblxuLy8gaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI2Nvb2tpZS1tYXhpbXVtLW5hbWUtdmFsdWUtcGFpci1zaXplXG5jb25zdCBtYXhOYW1lVmFsdWVQYWlyU2l6ZSA9IDQwOTZcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSxcbiAgbWF4TmFtZVZhbHVlUGFpclNpemVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/cookies/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/cookies/index.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/cookies/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/undici/lib/cookies/parse.js\")\nconst { stringify, getHeadersList } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/cookies/util.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/undici/lib/fetch/headers.js\")\n\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number|undefined} expires\n * @property {number|undefined} maxAge\n * @property {string|undefined} domain\n * @property {string|undefined} path\n * @property {boolean|undefined} secure\n * @property {boolean|undefined} httpOnly\n * @property {'Strict'|'Lax'|'None'} sameSite\n * @property {string[]} unparsed\n */\n\n/**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */\nfunction getCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, { header: 'getCookies' })\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  const cookie = headers.get('cookie')\n  const out = {}\n\n  if (!cookie) {\n    return out\n  }\n\n  for (const piece of cookie.split(';')) {\n    const [name, ...value] = piece.split('=')\n\n    out[name.trim()] = value.join('=')\n  }\n\n  return out\n}\n\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */\nfunction deleteCookie (headers, name, attributes) {\n  webidl.argumentLengthCheck(arguments, 2, { header: 'deleteCookie' })\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  name = webidl.converters.DOMString(name)\n  attributes = webidl.converters.DeleteCookieAttributes(attributes)\n\n  // Matches behavior of\n  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n  setCookie(headers, {\n    name,\n    value: '',\n    expires: new Date(0),\n    ...attributes\n  })\n}\n\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */\nfunction getSetCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, { header: 'getSetCookies' })\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  const cookies = getHeadersList(headers).cookies\n\n  if (!cookies) {\n    return []\n  }\n\n  // In older versions of undici, cookies is a list of name:value.\n  return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair))\n}\n\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */\nfunction setCookie (headers, cookie) {\n  webidl.argumentLengthCheck(arguments, 2, { header: 'setCookie' })\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  cookie = webidl.converters.Cookie(cookie)\n\n  const str = stringify(cookie)\n\n  if (str) {\n    headers.append('Set-Cookie', stringify(cookie))\n  }\n}\n\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: null\n  }\n])\n\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n  {\n    converter: webidl.converters.DOMString,\n    key: 'name'\n  },\n  {\n    converter: webidl.converters.DOMString,\n    key: 'value'\n  },\n  {\n    converter: webidl.nullableConverter((value) => {\n      if (typeof value === 'number') {\n        return webidl.converters['unsigned long long'](value)\n      }\n\n      return new Date(value)\n    }),\n    key: 'expires',\n    defaultValue: null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters['long long']),\n    key: 'maxAge',\n    defaultValue: null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'secure',\n    defaultValue: null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'httpOnly',\n    defaultValue: null\n  },\n  {\n    converter: webidl.converters.USVString,\n    key: 'sameSite',\n    allowedValues: ['Strict', 'Lax', 'None']\n  },\n  {\n    converter: webidl.sequenceConverter(webidl.converters.DOMString),\n    key: 'unparsed',\n    defaultValue: []\n  }\n])\n\nmodule.exports = {\n  getCookies,\n  deleteCookie,\n  getSetCookies,\n  setCookie\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUztBQUM1QyxRQUFRLDRCQUE0QixFQUFFLG1CQUFPLENBQUMsK0RBQVE7QUFDdEQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDNUMsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQywwRUFBa0I7O0FBRTlDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyx1QkFBdUI7QUFDckMsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxtQkFBbUI7QUFDakMsY0FBYyxtQkFBbUI7QUFDakMsY0FBYyx1QkFBdUI7QUFDckMsY0FBYyxVQUFVO0FBQ3hCOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkNBQTZDLHNCQUFzQjs7QUFFbkUsd0NBQXdDLGVBQWU7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsZ0NBQWdDLFlBQVk7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCOztBQUVyRSx3Q0FBd0MsZUFBZTs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUI7O0FBRXRFLHdDQUF3QyxlQUFlOztBQUV2RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7O0FBRWxFLHdDQUF3QyxlQUFlOztBQUV2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL2luZGV4LmpzP2E3NDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcGFyc2VTZXRDb29raWUgfSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzdHJpbmdpZnksIGdldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IEhlYWRlcnMgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2hlYWRlcnMnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvb2tpZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZVxuICogQHByb3BlcnR5IHtEYXRlfG51bWJlcnx1bmRlZmluZWR9IGV4cGlyZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfHVuZGVmaW5lZH0gbWF4QWdlXG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IGRvbWFpblxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBwYXRoXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBzZWN1cmVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IGh0dHBPbmx5XG4gKiBAcHJvcGVydHkgeydTdHJpY3QnfCdMYXgnfCdOb25lJ30gc2FtZVNpdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHVucGFyc2VkXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBnZXRDb29raWVzIChoZWFkZXJzKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdnZXRDb29raWVzJyB9KVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIGNvbnN0IGNvb2tpZSA9IGhlYWRlcnMuZ2V0KCdjb29raWUnKVxuICBjb25zdCBvdXQgPSB7fVxuXG4gIGlmICghY29va2llKSB7XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZm9yIChjb25zdCBwaWVjZSBvZiBjb29raWUuc3BsaXQoJzsnKSkge1xuICAgIGNvbnN0IFtuYW1lLCAuLi52YWx1ZV0gPSBwaWVjZS5zcGxpdCgnPScpXG5cbiAgICBvdXRbbmFtZS50cmltKCldID0gdmFsdWUuam9pbignPScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IHBhdGg/OiBzdHJpbmcsIGRvbWFpbj86IHN0cmluZyB9fHVuZGVmaW5lZH0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZUNvb2tpZSAoaGVhZGVycywgbmFtZSwgYXR0cmlidXRlcykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnZGVsZXRlQ29va2llJyB9KVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcobmFtZSlcbiAgYXR0cmlidXRlcyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMoYXR0cmlidXRlcylcblxuICAvLyBNYXRjaGVzIGJlaGF2aW9yIG9mXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vX3N0ZC9ibG9iLzYzODI3YjE2MzMwYjgyNDg5YTA0NjE0MDI3YzMzYjc5MDRlMDhiZTUvaHR0cC9jb29raWUudHMjTDI3OFxuICBzZXRDb29raWUoaGVhZGVycywge1xuICAgIG5hbWUsXG4gICAgdmFsdWU6ICcnLFxuICAgIGV4cGlyZXM6IG5ldyBEYXRlKDApLFxuICAgIC4uLmF0dHJpYnV0ZXNcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtDb29raWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2V0Q29va2llcyAoaGVhZGVycykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnZ2V0U2V0Q29va2llcycgfSlcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb25zdCBjb29raWVzID0gZ2V0SGVhZGVyc0xpc3QoaGVhZGVycykuY29va2llc1xuXG4gIGlmICghY29va2llcykge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLy8gSW4gb2xkZXIgdmVyc2lvbnMgb2YgdW5kaWNpLCBjb29raWVzIGlzIGEgbGlzdCBvZiBuYW1lOnZhbHVlLlxuICByZXR1cm4gY29va2llcy5tYXAoKHBhaXIpID0+IHBhcnNlU2V0Q29va2llKEFycmF5LmlzQXJyYXkocGFpcikgPyBwYWlyWzFdIDogcGFpcikpXG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge0Nvb2tpZX0gY29va2llXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gc2V0Q29va2llIChoZWFkZXJzLCBjb29raWUpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ3NldENvb2tpZScgfSlcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb29raWUgPSB3ZWJpZGwuY29udmVydGVycy5Db29raWUoY29va2llKVxuXG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShjb29raWUpXG5cbiAgaWYgKHN0cikge1xuICAgIGhlYWRlcnMuYXBwZW5kKCdTZXQtQ29va2llJywgc3RyaW5naWZ5KGNvb2tpZSkpXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuRGVsZXRlQ29va2llQXR0cmlidXRlcyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAncGF0aCcsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ2RvbWFpbicsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNvb2tpZSA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGtleTogJ25hbWUnXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBrZXk6ICd2YWx1ZSdcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSh2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKVxuICAgIH0pLFxuICAgIGtleTogJ2V4cGlyZXMnLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddKSxcbiAgICBrZXk6ICdtYXhBZ2UnLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdkb21haW4nLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdwYXRoJyxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4pLFxuICAgIGtleTogJ3NlY3VyZScsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ib29sZWFuKSxcbiAgICBrZXk6ICdodHRwT25seScsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBrZXk6ICdzYW1lU2l0ZScsXG4gICAgYWxsb3dlZFZhbHVlczogWydTdHJpY3QnLCAnTGF4JywgJ05vbmUnXVxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICd1bnBhcnNlZCcsXG4gICAgZGVmYXVsdFZhbHVlOiBbXVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29va2llcyxcbiAgZGVsZXRlQ29va2llLFxuICBnZXRTZXRDb29raWVzLFxuICBzZXRDb29raWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/cookies/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/cookies/parse.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/cookies/parse.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/cookies/constants.js\")\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/cookies/util.js\")\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */\nfunction parseSetCookie (header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null\n  }\n\n  let nameValuePair = ''\n  let unparsedAttributes = ''\n  let name = ''\n  let value = ''\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = { position: 0 }\n\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)\n    unparsedAttributes = header.slice(position.position)\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = { position: 0 }\n    name = collectASequenceOfCodePointsFast(\n      '=',\n      nameValuePair,\n      position\n    )\n    value = nameValuePair.slice(position.position + 1)\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim()\n  value = value.trim()\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  return {\n    name, value, ...parseUnparsedAttributes(unparsedAttributes)\n  }\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */\nfunction parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';')\n  unparsedAttributes = unparsedAttributes.slice(1)\n\n  let cookieAv = ''\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(\n      ';',\n      unparsedAttributes,\n      { position: 0 }\n    )\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes\n    unparsedAttributes = ''\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = ''\n  let attributeValue = ''\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = { position: 0 }\n\n    attributeName = collectASequenceOfCodePointsFast(\n      '=',\n      cookieAv,\n      position\n    )\n    attributeValue = cookieAv.slice(position.position + 1)\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim()\n  attributeValue = attributeValue.trim()\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase()\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue)\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0)\n\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue)\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1)\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase()\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = ''\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/'\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default'\n\n    const attributeValueLowercase = attributeValue.toLowerCase()\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None'\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict'\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax'\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement\n  } else {\n    cookieAttributeList.unparsed ??= []\n\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n}\n\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsOENBQThDLEVBQUUsbUJBQU8sQ0FBQyx5RUFBYTtBQUM3RSxRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsK0RBQVE7QUFDL0MsUUFBUSxtQ0FBbUMsRUFBRSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN2RSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHdCQUF3QjtBQUN4QjtBQUNBLCtDQUErQztBQUMvQztBQUNBLGlDQUFpQztBQUNqQyx1QkFBdUI7O0FBRXZCLHVEQUF1RDtBQUN2RDtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVywrQkFBK0I7QUFDMUM7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLHlDQUF5QyxjQUFjLEdBQUcsZUFBZTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL3BhcnNlLmpzP2NlZmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbWF4TmFtZVZhbHVlUGFpclNpemUsIG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBpc0NUTEV4Y2x1ZGluZ0h0YWIgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhVVJMJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFBhcnNlcyB0aGUgZmllbGQtdmFsdWUgYXR0cmlidXRlcyBvZiBhIHNldC1jb29raWUgaGVhZGVyIHN0cmluZy5cbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNFxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICogQHJldHVybnMgaWYgdGhlIGhlYWRlciBpcyBpbnZhbGlkLCBudWxsIHdpbGwgYmUgcmV0dXJuZWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VTZXRDb29raWUgKGhlYWRlcikge1xuICAvLyAxLiBJZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgY29udGFpbnMgYSAleDAwLTA4IC8gJXgwQS0xRiAvICV4N0ZcbiAgLy8gICAgY2hhcmFjdGVyIChDVEwgY2hhcmFjdGVycyBleGNsdWRpbmcgSFRBQik6IEFib3J0IHRoZXNlIHN0ZXBzIGFuZFxuICAvLyAgICBpZ25vcmUgdGhlIHNldC1jb29raWUtc3RyaW5nIGVudGlyZWx5LlxuICBpZiAoaXNDVExFeGNsdWRpbmdIdGFiKGhlYWRlcikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IG5hbWVWYWx1ZVBhaXIgPSAnJ1xuICBsZXQgdW5wYXJzZWRBdHRyaWJ1dGVzID0gJydcbiAgbGV0IG5hbWUgPSAnJ1xuICBsZXQgdmFsdWUgPSAnJ1xuXG4gIC8vIDIuIElmIHRoZSBzZXQtY29va2llLXN0cmluZyBjb250YWlucyBhICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXI6XG4gIGlmIChoZWFkZXIuaW5jbHVkZXMoJzsnKSkge1xuICAgIC8vIDEuIFRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIHVwIHRvLFxuICAgIC8vICAgIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzQiAoXCI7XCIpLCBhbmQgdGhlIHVucGFyc2VkLVxuICAgIC8vICAgIGF0dHJpYnV0ZXMgY29uc2lzdCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBzZXQtY29va2llLXN0cmluZ1xuICAgIC8vICAgIChpbmNsdWRpbmcgdGhlICV4M0IgKFwiO1wiKSBpbiBxdWVzdGlvbikuXG4gICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAgIG5hbWVWYWx1ZVBhaXIgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCgnOycsIGhlYWRlciwgcG9zaXRpb24pXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gaGVhZGVyLnNsaWNlKHBvc2l0aW9uLnBvc2l0aW9uKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGNvbnNpc3RzIG9mIGFsbCB0aGUgY2hhcmFjdGVyc1xuICAgIC8vICAgIGNvbnRhaW5lZCBpbiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcsIGFuZCB0aGUgdW5wYXJzZWQtXG4gICAgLy8gICAgYXR0cmlidXRlcyBpcyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIG5hbWVWYWx1ZVBhaXIgPSBoZWFkZXJcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGxhY2tzIGEgJXgzRCAoXCI9XCIpIGNoYXJhY3RlciwgdGhlblxuICAvLyAgICB0aGUgbmFtZSBzdHJpbmcgaXMgZW1wdHksIGFuZCB0aGUgdmFsdWUgc3RyaW5nIGlzIHRoZSB2YWx1ZSBvZlxuICAvLyAgICBuYW1lLXZhbHVlLXBhaXIuXG4gIGlmICghbmFtZVZhbHVlUGFpci5pbmNsdWRlcygnPScpKSB7XG4gICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyXG4gIH0gZWxzZSB7XG4gICAgLy8gICAgT3RoZXJ3aXNlLCB0aGUgbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgdXAgdG8sIGJ1dFxuICAgIC8vICAgIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNEIChcIj1cIikgY2hhcmFjdGVyLCBhbmQgdGhlIChwb3NzaWJseVxuICAgIC8vICAgIGVtcHR5KSB2YWx1ZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGZpcnN0XG4gICAgLy8gICAgJXgzRCAoXCI9XCIpIGNoYXJhY3Rlci5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuICAgIG5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc9JyxcbiAgICAgIG5hbWVWYWx1ZVBhaXIsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXIuc2xpY2UocG9zaXRpb24ucG9zaXRpb24gKyAxKVxuICB9XG5cbiAgLy8gNC4gUmVtb3ZlIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIFdTUCBjaGFyYWN0ZXJzIGZyb20gdGhlIG5hbWVcbiAgLy8gICAgc3RyaW5nIGFuZCB0aGUgdmFsdWUgc3RyaW5nLlxuICBuYW1lID0gbmFtZS50cmltKClcbiAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAvLyA1LiBJZiB0aGUgc3VtIG9mIHRoZSBsZW5ndGhzIG9mIHRoZSBuYW1lIHN0cmluZyBhbmQgdGhlIHZhbHVlIHN0cmluZ1xuICAvLyAgICBpcyBtb3JlIHRoYW4gNDA5NiBvY3RldHMsIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpZ25vcmUgdGhlIHNldC1cbiAgLy8gICAgY29va2llLXN0cmluZyBlbnRpcmVseS5cbiAgaWYgKG5hbWUubGVuZ3RoICsgdmFsdWUubGVuZ3RoID4gbWF4TmFtZVZhbHVlUGFpclNpemUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gNi4gVGhlIGNvb2tpZS1uYW1lIGlzIHRoZSBuYW1lIHN0cmluZywgYW5kIHRoZSBjb29raWUtdmFsdWUgaXMgdGhlXG4gIC8vICAgIHZhbHVlIHN0cmluZy5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLCB2YWx1ZSwgLi4ucGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzKVxuICB9XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSByZW1haW5pbmcgYXR0cmlidXRlcyBvZiBhIHNldC1jb29raWUgaGVhZGVyXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjRcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bnBhcnNlZEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7W09iamVjdC48c3RyaW5nLCB1bmtub3duPl09e319IGNvb2tpZUF0dHJpYnV0ZUxpc3RcbiAqL1xuZnVuY3Rpb24gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXMgKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdCA9IHt9KSB7XG4gIC8vIDEuIElmIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzIHN0cmluZyBpcyBlbXB0eSwgc2tpcCB0aGUgcmVzdCBvZlxuICAvLyAgICB0aGVzZSBzdGVwcy5cbiAgaWYgKHVucGFyc2VkQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29va2llQXR0cmlidXRlTGlzdFxuICB9XG5cbiAgLy8gMi4gRGlzY2FyZCB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzICh3aGljaFxuICAvLyAgICB3aWxsIGJlIGEgJXgzQiAoXCI7XCIpIGNoYXJhY3RlcikuXG4gIGFzc2VydCh1bnBhcnNlZEF0dHJpYnV0ZXNbMF0gPT09ICc7JylcbiAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gdW5wYXJzZWRBdHRyaWJ1dGVzLnNsaWNlKDEpXG5cbiAgbGV0IGNvb2tpZUF2ID0gJydcblxuICAvLyAzLiBJZiB0aGUgcmVtYWluaW5nIHVucGFyc2VkLWF0dHJpYnV0ZXMgY29udGFpbnMgYSAleDNCIChcIjtcIilcbiAgLy8gICAgY2hhcmFjdGVyOlxuICBpZiAodW5wYXJzZWRBdHRyaWJ1dGVzLmluY2x1ZGVzKCc7JykpIHtcbiAgICAvLyAxLiBDb25zdW1lIHRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzIHVwIHRvLCBidXRcbiAgICAvLyAgICBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzQiAoXCI7XCIpIGNoYXJhY3Rlci5cbiAgICBjb29raWVBdiA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJzsnLFxuICAgICAgdW5wYXJzZWRBdHRyaWJ1dGVzLFxuICAgICAgeyBwb3NpdGlvbjogMCB9XG4gICAgKVxuICAgIHVucGFyc2VkQXR0cmlidXRlcyA9IHVucGFyc2VkQXR0cmlidXRlcy5zbGljZShjb29raWVBdi5sZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gQ29uc3VtZSB0aGUgcmVtYWluZGVyIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzLlxuICAgIGNvb2tpZUF2ID0gdW5wYXJzZWRBdHRyaWJ1dGVzXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gJydcbiAgfVxuXG4gIC8vIExldCB0aGUgY29va2llLWF2IHN0cmluZyBiZSB0aGUgY2hhcmFjdGVycyBjb25zdW1lZCBpbiB0aGlzIHN0ZXAuXG5cbiAgbGV0IGF0dHJpYnV0ZU5hbWUgPSAnJ1xuICBsZXQgYXR0cmlidXRlVmFsdWUgPSAnJ1xuXG4gIC8vIDQuIElmIHRoZSBjb29raWUtYXYgc3RyaW5nIGNvbnRhaW5zIGEgJXgzRCAoXCI9XCIpIGNoYXJhY3RlcjpcbiAgaWYgKGNvb2tpZUF2LmluY2x1ZGVzKCc9JykpIHtcbiAgICAvLyAxLiBUaGUgKHBvc3NpYmx5IGVtcHR5KSBhdHRyaWJ1dGUtbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlXG4gICAgLy8gICAgY2hhcmFjdGVycyB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNEIChcIj1cIilcbiAgICAvLyAgICBjaGFyYWN0ZXIsIGFuZCB0aGUgKHBvc3NpYmx5IGVtcHR5KSBhdHRyaWJ1dGUtdmFsdWUgc3RyaW5nXG4gICAgLy8gICAgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKVxuICAgIC8vICAgIGNoYXJhY3Rlci5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gICAgYXR0cmlidXRlTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJz0nLFxuICAgICAgY29va2llQXYsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgICBhdHRyaWJ1dGVWYWx1ZSA9IGNvb2tpZUF2LnNsaWNlKHBvc2l0aW9uLnBvc2l0aW9uICsgMSlcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBUaGUgYXR0cmlidXRlLW5hbWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBlbnRpcmUgY29va2llLWF2XG4gICAgLy8gICAgc3RyaW5nLCBhbmQgdGhlIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmcgaXMgZW1wdHkuXG4gICAgYXR0cmlidXRlTmFtZSA9IGNvb2tpZUF2XG4gIH1cblxuICAvLyA1LiBSZW1vdmUgYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgV1NQIGNoYXJhY3RlcnMgZnJvbSB0aGUgYXR0cmlidXRlLVxuICAvLyAgICBuYW1lIHN0cmluZyBhbmQgdGhlIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmcuXG4gIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lLnRyaW0oKVxuICBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZVZhbHVlLnRyaW0oKVxuXG4gIC8vIDYuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgbG9uZ2VyIHRoYW4gMTAyNCBvY3RldHMsIGlnbm9yZSB0aGVcbiAgLy8gICAgY29va2llLWF2IHN0cmluZyBhbmQgcmV0dXJuIHRvIFN0ZXAgMSBvZiB0aGlzIGFsZ29yaXRobS5cbiAgaWYgKGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCA+IG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSkge1xuICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gIH1cblxuICAvLyA3LiBQcm9jZXNzIHRoZSBhdHRyaWJ1dGUtbmFtZSBhbmQgYXR0cmlidXRlLXZhbHVlIGFjY29yZGluZyB0byB0aGVcbiAgLy8gICAgcmVxdWlyZW1lbnRzIGluIHRoZSBmb2xsb3dpbmcgc3Vic2VjdGlvbnMuICAoTm90aWNlIHRoYXRcbiAgLy8gICAgYXR0cmlidXRlcyB3aXRoIHVucmVjb2duaXplZCBhdHRyaWJ1dGUtbmFtZXMgYXJlIGlnbm9yZWQuKVxuICBjb25zdCBhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID0gYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC4xXG4gIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gIC8vIFwiRXhwaXJlc1wiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuICBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2V4cGlyZXMnKSB7XG4gICAgLy8gMS4gTGV0IHRoZSBleHBpcnktdGltZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIGF0dHJpYnV0ZS12YWx1ZVxuICAgIC8vICAgIGFzIGNvb2tpZS1kYXRlIChzZWUgU2VjdGlvbiA1LjEuMSkuXG4gICAgY29uc3QgZXhwaXJ5VGltZSA9IG5ldyBEYXRlKGF0dHJpYnV0ZVZhbHVlKVxuXG4gICAgLy8gMi4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBmYWlsZWQgdG8gcGFyc2UgYXMgYSBjb29raWUgZGF0ZSwgaWdub3JlXG4gICAgLy8gICAgdGhlIGNvb2tpZS1hdi5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuZXhwaXJlcyA9IGV4cGlyeVRpbWVcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnbWF4LWFnZScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjJcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIk1heC1cbiAgICAvLyBBZ2VcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgYSBESUdJVCBvciBhXG4gICAgLy8gICAgXCItXCIgY2hhcmFjdGVyLCBpZ25vcmUgdGhlIGNvb2tpZS1hdi5cbiAgICBjb25zdCBjaGFyQ29kZSA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJDb2RlQXQoMClcblxuICAgIGlmICgoY2hhckNvZGUgPCA0OCB8fCBjaGFyQ29kZSA+IDU3KSAmJiBhdHRyaWJ1dGVWYWx1ZVswXSAhPT0gJy0nKSB7XG4gICAgICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxuICAgIH1cblxuICAgIC8vIDIuIElmIHRoZSByZW1haW5kZXIgb2YgYXR0cmlidXRlLXZhbHVlIGNvbnRhaW5zIGEgbm9uLURJR0lUXG4gICAgLy8gICAgY2hhcmFjdGVyLCBpZ25vcmUgdGhlIGNvb2tpZS1hdi5cbiAgICBpZiAoIS9eXFxkKyQvLnRlc3QoYXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxuICAgIH1cblxuICAgIC8vIDMuIExldCBkZWx0YS1zZWNvbmRzIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUgY29udmVydGVkIHRvIGFuIGludGVnZXIuXG4gICAgY29uc3QgZGVsdGFTZWNvbmRzID0gTnVtYmVyKGF0dHJpYnV0ZVZhbHVlKVxuXG4gICAgLy8gNC4gTGV0IGNvb2tpZS1hZ2UtbGltaXQgYmUgdGhlIG1heGltdW0gYWdlIG9mIHRoZSBjb29raWUgKHdoaWNoXG4gICAgLy8gICAgU0hPVUxEIGJlIDQwMCBkYXlzIG9yIGxlc3MsIHNlZSBTZWN0aW9uIDQuMS4yLjIpLlxuXG4gICAgLy8gNS4gU2V0IGRlbHRhLXNlY29uZHMgdG8gdGhlIHNtYWxsZXIgb2YgaXRzIHByZXNlbnQgdmFsdWUgYW5kIGNvb2tpZS1cbiAgICAvLyAgICBhZ2UtbGltaXQuXG4gICAgLy8gZGVsdGFTZWNvbmRzID0gTWF0aC5taW4oZGVsdGFTZWNvbmRzICogMTAwMCwgbWF4RXhwaXJlc01zKVxuXG4gICAgLy8gNi4gSWYgZGVsdGEtc2Vjb25kcyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVybyAoMCksIGxldCBleHBpcnktXG4gICAgLy8gICAgdGltZSBiZSB0aGUgZWFybGllc3QgcmVwcmVzZW50YWJsZSBkYXRlIGFuZCB0aW1lLiAgT3RoZXJ3aXNlLCBsZXRcbiAgICAvLyAgICB0aGUgZXhwaXJ5LXRpbWUgYmUgdGhlIGN1cnJlbnQgZGF0ZSBhbmQgdGltZSBwbHVzIGRlbHRhLXNlY29uZHNcbiAgICAvLyAgICBzZWNvbmRzLlxuICAgIC8vIGNvbnN0IGV4cGlyeVRpbWUgPSBkZWx0YVNlY29uZHMgPD0gMCA/IERhdGUubm93KCkgOiBEYXRlLm5vdygpICsgZGVsdGFTZWNvbmRzXG5cbiAgICAvLyA3LiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIE1heC1BZ2UgYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBleHBpcnktdGltZS5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0Lm1heEFnZSA9IGRlbHRhU2Vjb25kc1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdkb21haW4nKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC4zXG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJEb21haW5cIixcbiAgICAvLyB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gTGV0IGNvb2tpZS1kb21haW4gYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZS5cbiAgICBsZXQgY29va2llRG9tYWluID0gYXR0cmlidXRlVmFsdWVcblxuICAgIC8vIDIuIElmIGNvb2tpZS1kb21haW4gc3RhcnRzIHdpdGggJXgyRSAoXCIuXCIpLCBsZXQgY29va2llLWRvbWFpbiBiZVxuICAgIC8vICAgIGNvb2tpZS1kb21haW4gd2l0aG91dCBpdHMgbGVhZGluZyAleDJFIChcIi5cIikuXG4gICAgaWYgKGNvb2tpZURvbWFpblswXSA9PT0gJy4nKSB7XG4gICAgICBjb29raWVEb21haW4gPSBjb29raWVEb21haW4uc2xpY2UoMSlcbiAgICB9XG5cbiAgICAvLyAzLiBDb252ZXJ0IHRoZSBjb29raWUtZG9tYWluIHRvIGxvd2VyIGNhc2UuXG4gICAgY29va2llRG9tYWluID0gY29va2llRG9tYWluLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIDQuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgRG9tYWluIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2YgY29va2llLWRvbWFpbi5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LmRvbWFpbiA9IGNvb2tpZURvbWFpblxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdwYXRoJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNFxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiUGF0aFwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5IG9yIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gICAgLy8gICAgYXR0cmlidXRlLXZhbHVlIGlzIG5vdCAleDJGIChcIi9cIik6XG4gICAgbGV0IGNvb2tpZVBhdGggPSAnJ1xuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZS5sZW5ndGggPT09IDAgfHwgYXR0cmlidXRlVmFsdWVbMF0gIT09ICcvJykge1xuICAgICAgLy8gMS4gTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBkZWZhdWx0LXBhdGguXG4gICAgICBjb29raWVQYXRoID0gJy8nXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZTpcblxuICAgICAgLy8gMS4gTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUuXG4gICAgICBjb29raWVQYXRoID0gYXR0cmlidXRlVmFsdWVcbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIFBhdGggYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBjb29raWUtcGF0aC5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnBhdGggPSBjb29raWVQYXRoXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3NlY3VyZScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjVcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIlNlY3VyZVwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgYXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0XG4gICAgLy8gd2l0aCBhbiBhdHRyaWJ1dGUtbmFtZSBvZiBTZWN1cmUgYW5kIGFuIGVtcHR5IGF0dHJpYnV0ZS12YWx1ZS5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3Quc2VjdXJlID0gdHJ1ZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdodHRwb25seScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjZcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZ1xuICAgIC8vIFwiSHR0cE9ubHlcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBhcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtXG4gICAgLy8gYXR0cmlidXRlLWxpc3Qgd2l0aCBhbiBhdHRyaWJ1dGUtbmFtZSBvZiBIdHRwT25seSBhbmQgYW4gZW1wdHlcbiAgICAvLyBhdHRyaWJ1dGUtdmFsdWUuXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0Lmh0dHBPbmx5ID0gdHJ1ZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdzYW1lc2l0ZScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjdcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZ1xuICAgIC8vIFwiU2FtZVNpdGVcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93czpcblxuICAgIC8vIDEuIExldCBlbmZvcmNlbWVudCBiZSBcIkRlZmF1bHRcIi5cbiAgICBsZXQgZW5mb3JjZW1lbnQgPSAnRGVmYXVsdCdcblxuICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlID0gYXR0cmlidXRlVmFsdWUudG9Mb3dlckNhc2UoKVxuICAgIC8vIDIuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJOb25lXCIsIHNldCBlbmZvcmNlbWVudCB0byBcIk5vbmVcIi5cbiAgICBpZiAoYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UuaW5jbHVkZXMoJ25vbmUnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnTm9uZSdcbiAgICB9XG5cbiAgICAvLyAzLiBJZiBjb29raWUtYXYncyBhdHRyaWJ1dGUtdmFsdWUgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAgIC8vICAgIFwiU3RyaWN0XCIsIHNldCBlbmZvcmNlbWVudCB0byBcIlN0cmljdFwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnc3RyaWN0JykpIHtcbiAgICAgIGVuZm9yY2VtZW50ID0gJ1N0cmljdCdcbiAgICB9XG5cbiAgICAvLyA0LiBJZiBjb29raWUtYXYncyBhdHRyaWJ1dGUtdmFsdWUgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAgIC8vICAgIFwiTGF4XCIsIHNldCBlbmZvcmNlbWVudCB0byBcIkxheFwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnbGF4JykpIHtcbiAgICAgIGVuZm9yY2VtZW50ID0gJ0xheCdcbiAgICB9XG5cbiAgICAvLyA1LiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIFwiU2FtZVNpdGVcIiBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mXG4gICAgLy8gICAgZW5mb3JjZW1lbnQuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5zYW1lU2l0ZSA9IGVuZm9yY2VtZW50XG4gIH0gZWxzZSB7XG4gICAgY29va2llQXR0cmlidXRlTGlzdC51bnBhcnNlZCA/Pz0gW11cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QudW5wYXJzZWQucHVzaChgJHthdHRyaWJ1dGVOYW1lfT0ke2F0dHJpYnV0ZVZhbHVlfWApXG4gIH1cblxuICAvLyA4LiBSZXR1cm4gdG8gU3RlcCAxIG9mIHRoaXMgYWxnb3JpdGhtLlxuICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VTZXRDb29raWUsXG4gIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/cookies/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/cookies/util.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/cookies/util.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\n\nfunction isCTLExcludingHtab (value) {\n  if (value.length === 0) {\n    return false\n  }\n\n  for (const char of value) {\n    const code = char.charCodeAt(0)\n\n    if (\n      (code >= 0x00 || code <= 0x08) ||\n      (code >= 0x0A || code <= 0x1F) ||\n      code === 0x7F\n    ) {\n      return false\n    }\n  }\n}\n\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */\nfunction validateCookieName (name) {\n  for (const char of name) {\n    const code = char.charCodeAt(0)\n\n    if (\n      (code <= 0x20 || code > 0x7F) ||\n      char === '(' ||\n      char === ')' ||\n      char === '>' ||\n      char === '<' ||\n      char === '@' ||\n      char === ',' ||\n      char === ';' ||\n      char === ':' ||\n      char === '\\\\' ||\n      char === '\"' ||\n      char === '/' ||\n      char === '[' ||\n      char === ']' ||\n      char === '?' ||\n      char === '=' ||\n      char === '{' ||\n      char === '}'\n    ) {\n      throw new Error('Invalid cookie name')\n    }\n  }\n}\n\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */\nfunction validateCookieValue (value) {\n  for (const char of value) {\n    const code = char.charCodeAt(0)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31)\n      code === 0x22 ||\n      code === 0x2C ||\n      code === 0x3B ||\n      code === 0x5C ||\n      code > 0x7E // non-ascii\n    ) {\n      throw new Error('Invalid header value')\n    }\n  }\n}\n\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */\nfunction validateCookiePath (path) {\n  for (const char of path) {\n    const code = char.charCodeAt(0)\n\n    if (code < 0x21 || char === ';') {\n      throw new Error('Invalid cookie path')\n    }\n  }\n}\n\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */\nfunction validateCookieDomain (domain) {\n  if (\n    domain.startsWith('-') ||\n    domain.endsWith('.') ||\n    domain.endsWith('-')\n  ) {\n    throw new Error('Invalid cookie domain')\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */\nfunction toIMFDate (date) {\n  if (typeof date === 'number') {\n    date = new Date(date)\n  }\n\n  const days = [\n    'Sun', 'Mon', 'Tue', 'Wed',\n    'Thu', 'Fri', 'Sat'\n  ]\n\n  const months = [\n    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n  ]\n\n  const dayName = days[date.getUTCDay()]\n  const day = date.getUTCDate().toString().padStart(2, '0')\n  const month = months[date.getUTCMonth()]\n  const year = date.getUTCFullYear()\n  const hour = date.getUTCHours().toString().padStart(2, '0')\n  const minute = date.getUTCMinutes().toString().padStart(2, '0')\n  const second = date.getUTCSeconds().toString().padStart(2, '0')\n\n  return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`\n}\n\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */\nfunction validateCookieMaxAge (maxAge) {\n  if (maxAge < 0) {\n    throw new Error('Invalid cookie max-age')\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */\nfunction stringify (cookie) {\n  if (cookie.name.length === 0) {\n    return null\n  }\n\n  validateCookieName(cookie.name)\n  validateCookieValue(cookie.value)\n\n  const out = [`${cookie.name}=${cookie.value}`]\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n  if (cookie.name.startsWith('__Secure-')) {\n    cookie.secure = true\n  }\n\n  if (cookie.name.startsWith('__Host-')) {\n    cookie.secure = true\n    cookie.domain = null\n    cookie.path = '/'\n  }\n\n  if (cookie.secure) {\n    out.push('Secure')\n  }\n\n  if (cookie.httpOnly) {\n    out.push('HttpOnly')\n  }\n\n  if (typeof cookie.maxAge === 'number') {\n    validateCookieMaxAge(cookie.maxAge)\n    out.push(`Max-Age=${cookie.maxAge}`)\n  }\n\n  if (cookie.domain) {\n    validateCookieDomain(cookie.domain)\n    out.push(`Domain=${cookie.domain}`)\n  }\n\n  if (cookie.path) {\n    validateCookiePath(cookie.path)\n    out.push(`Path=${cookie.path}`)\n  }\n\n  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {\n    out.push(`Expires=${toIMFDate(cookie.expires)}`)\n  }\n\n  if (cookie.sameSite) {\n    out.push(`SameSite=${cookie.sameSite}`)\n  }\n\n  for (const part of cookie.unparsed) {\n    if (!part.includes('=')) {\n      throw new Error('Invalid unparsed')\n    }\n\n    const [key, ...value] = part.split('=')\n\n    out.push(`${key.trim()}=${value.join('=')}`)\n  }\n\n  return out.join('; ')\n}\n\nlet kHeadersListNode\n\nfunction getHeadersList (headers) {\n  if (headers[kHeadersList]) {\n    return headers[kHeadersList]\n  }\n\n  if (!kHeadersListNode) {\n    kHeadersListNode = Object.getOwnPropertySymbols(headers).find(\n      (symbol) => symbol.description === 'headers list'\n    )\n\n    assert(kHeadersListNode, 'Headers cannot be parsed')\n  }\n\n  const headersList = headers[kHeadersListNode]\n  assert(headersList)\n\n  return headersList\n}\n\nmodule.exports = {\n  isCTLExcludingHtab,\n  stringify,\n  getHeadersList\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG9CQUFvQixNQUFNO0FBQzFCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsSUFBSTtBQUNKLElBQUk7O0FBRUosOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxRQUFRLElBQUksS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSyxHQUFHLE9BQU8sR0FBRyxRQUFRO0FBQzFFOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVksR0FBRyxhQUFhOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQzs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7O0FBRUE7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixXQUFXLEdBQUcsZ0JBQWdCO0FBQzlDOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy91dGlsLmpzPzBkMTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcblxuZnVuY3Rpb24gaXNDVExFeGNsdWRpbmdIdGFiICh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGNoYXIgb2YgdmFsdWUpIHtcbiAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoXG4gICAgICAoY29kZSA+PSAweDAwIHx8IGNvZGUgPD0gMHgwOCkgfHxcbiAgICAgIChjb2RlID49IDB4MEEgfHwgY29kZSA8PSAweDFGKSB8fFxuICAgICAgY29kZSA9PT0gMHg3RlxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuIENIQVIgICAgICAgICAgID0gPGFueSBVUy1BU0NJSSBjaGFyYWN0ZXIgKG9jdGV0cyAwIC0gMTI3KT5cbiB0b2tlbiAgICAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gc2VwYXJhdG9ycyAgICAgPSBcIihcIiB8IFwiKVwiIHwgXCI8XCIgfCBcIj5cIiB8IFwiQFwiXG4gICAgICAgICAgICAgICAgfCBcIixcIiB8IFwiO1wiIHwgXCI6XCIgfCBcIlxcXCIgfCA8XCI+XG4gICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gICAgICAgICAgICAgICAgfCBcIntcIiB8IFwifVwiIHwgU1AgfCBIVFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVOYW1lIChuYW1lKSB7XG4gIGZvciAoY29uc3QgY2hhciBvZiBuYW1lKSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKFxuICAgICAgKGNvZGUgPD0gMHgyMCB8fCBjb2RlID4gMHg3RikgfHxcbiAgICAgIGNoYXIgPT09ICcoJyB8fFxuICAgICAgY2hhciA9PT0gJyknIHx8XG4gICAgICBjaGFyID09PSAnPicgfHxcbiAgICAgIGNoYXIgPT09ICc8JyB8fFxuICAgICAgY2hhciA9PT0gJ0AnIHx8XG4gICAgICBjaGFyID09PSAnLCcgfHxcbiAgICAgIGNoYXIgPT09ICc7JyB8fFxuICAgICAgY2hhciA9PT0gJzonIHx8XG4gICAgICBjaGFyID09PSAnXFxcXCcgfHxcbiAgICAgIGNoYXIgPT09ICdcIicgfHxcbiAgICAgIGNoYXIgPT09ICcvJyB8fFxuICAgICAgY2hhciA9PT0gJ1snIHx8XG4gICAgICBjaGFyID09PSAnXScgfHxcbiAgICAgIGNoYXIgPT09ICc/JyB8fFxuICAgICAgY2hhciA9PT0gJz0nIHx8XG4gICAgICBjaGFyID09PSAneycgfHxcbiAgICAgIGNoYXIgPT09ICd9J1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBuYW1lJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gY29va2llLXZhbHVlICAgICAgPSAqY29va2llLW9jdGV0IC8gKCBEUVVPVEUgKmNvb2tpZS1vY3RldCBEUVVPVEUgKVxuIGNvb2tpZS1vY3RldCAgICAgID0gJXgyMSAvICV4MjMtMkIgLyAleDJELTNBIC8gJXgzQy01QiAvICV4NUQtN0VcbiAgICAgICAgICAgICAgICAgICAgICAgOyBVUy1BU0NJSSBjaGFyYWN0ZXJzIGV4Y2x1ZGluZyBDVExzLFxuICAgICAgICAgICAgICAgICAgICAgICA7IHdoaXRlc3BhY2UgRFFVT1RFLCBjb21tYSwgc2VtaWNvbG9uLFxuICAgICAgICAgICAgICAgICAgICAgICA7IGFuZCBiYWNrc2xhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZVZhbHVlICh2YWx1ZSkge1xuICBmb3IgKGNvbnN0IGNoYXIgb2YgdmFsdWUpIHtcbiAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMSB8fCAvLyBleGNsdWRlIENUTHMgKDAtMzEpXG4gICAgICBjb2RlID09PSAweDIyIHx8XG4gICAgICBjb2RlID09PSAweDJDIHx8XG4gICAgICBjb2RlID09PSAweDNCIHx8XG4gICAgICBjb2RlID09PSAweDVDIHx8XG4gICAgICBjb2RlID4gMHg3RSAvLyBub24tYXNjaWlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZWFkZXIgdmFsdWUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIHBhdGgtdmFsdWUgICAgICAgID0gPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIFwiO1wiPlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVQYXRoIChwYXRoKSB7XG4gIGZvciAoY29uc3QgY2hhciBvZiBwYXRoKSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKGNvZGUgPCAweDIxIHx8IGNoYXIgPT09ICc7Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBwYXRoJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJIGhhdmUgbm8gaWRlYSB3aHkgdGhlc2UgdmFsdWVzIGFyZW4ndCBhbGxvd2VkIHRvIGJlIGhvbmVzdCxcbiAqIGJ1dCBEZW5vIHRlc3RzIHRoZXNlLiAtIEtoYWZyYVxuICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZURvbWFpbiAoZG9tYWluKSB7XG4gIGlmIChcbiAgICBkb21haW4uc3RhcnRzV2l0aCgnLScpIHx8XG4gICAgZG9tYWluLmVuZHNXaXRoKCcuJykgfHxcbiAgICBkb21haW4uZW5kc1dpdGgoJy0nKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIGRvbWFpbicpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tNy4xLjEuMVxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZGF0ZVxuICBJTUYtZml4ZGF0ZSAgPSBkYXktbmFtZSBcIixcIiBTUCBkYXRlMSBTUCB0aW1lLW9mLWRheSBTUCBHTVRcbiAgOyBmaXhlZCBsZW5ndGgvem9uZS9jYXBpdGFsaXphdGlvbiBzdWJzZXQgb2YgdGhlIGZvcm1hdFxuICA7IHNlZSBTZWN0aW9uIDMuMyBvZiBbUkZDNTMyMl1cblxuICBkYXktbmFtZSAgICAgPSAleDRELjZGLjZFIDsgXCJNb25cIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0Ljc1LjY1IDsgXCJUdWVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU3LjY1LjY0IDsgXCJXZWRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0LjY4Ljc1IDsgXCJUaHVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQ2LjcyLjY5IDsgXCJGcmlcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjYxLjc0IDsgXCJTYXRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjc1LjZFIDsgXCJTdW5cIiwgY2FzZS1zZW5zaXRpdmVcbiAgZGF0ZTEgICAgICAgID0gZGF5IFNQIG1vbnRoIFNQIHllYXJcbiAgICAgICAgICAgICAgICAgIDsgZS5nLiwgMDIgSnVuIDE5ODJcblxuICBkYXkgICAgICAgICAgPSAyRElHSVRcbiAgbW9udGggICAgICAgID0gJXg0QS42MS42RSA7IFwiSmFuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ni42NS42MiA7IFwiRmViXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43MiA7IFwiTWFyXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43MC43MiA7IFwiQXByXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43OSA7IFwiTWF5XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42RSA7IFwiSnVuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42QyA7IFwiSnVsXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43NS42NyA7IFwiQXVnXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My42NS43MCA7IFwiU2VwXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ri42My43NCA7IFwiT2N0XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RS42Ri43NiA7IFwiTm92XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0NC42NS42MyA7IFwiRGVjXCIsIGNhc2Utc2Vuc2l0aXZlXG4gIHllYXIgICAgICAgICA9IDRESUdJVFxuXG4gIEdNVCAgICAgICAgICA9ICV4NDcuNEQuNTQgOyBcIkdNVFwiLCBjYXNlLXNlbnNpdGl2ZVxuXG4gIHRpbWUtb2YtZGF5ICA9IGhvdXIgXCI6XCIgbWludXRlIFwiOlwiIHNlY29uZFxuICAgICAgICAgICAgICA7IDAwOjAwOjAwIC0gMjM6NTk6NjAgKGxlYXAgc2Vjb25kKVxuXG4gIGhvdXIgICAgICAgICA9IDJESUdJVFxuICBtaW51dGUgICAgICAgPSAyRElHSVRcbiAgc2Vjb25kICAgICAgID0gMkRJR0lUXG4gKi9cbmZ1bmN0aW9uIHRvSU1GRGF0ZSAoZGF0ZSkge1xuICBpZiAodHlwZW9mIGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpXG4gIH1cblxuICBjb25zdCBkYXlzID0gW1xuICAgICdTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLFxuICAgICdUaHUnLCAnRnJpJywgJ1NhdCdcbiAgXVxuXG4gIGNvbnN0IG1vbnRocyA9IFtcbiAgICAnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLFxuICAgICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYydcbiAgXVxuXG4gIGNvbnN0IGRheU5hbWUgPSBkYXlzW2RhdGUuZ2V0VVRDRGF5KCldXG4gIGNvbnN0IGRheSA9IGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKVxuICBjb25zdCBtb250aCA9IG1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldXG4gIGNvbnN0IHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcbiAgY29uc3QgaG91ciA9IGRhdGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJylcbiAgY29uc3QgbWludXRlID0gZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpXG4gIGNvbnN0IHNlY29uZCA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKVxuXG4gIHJldHVybiBgJHtkYXlOYW1lfSwgJHtkYXl9ICR7bW9udGh9ICR7eWVhcn0gJHtob3VyfToke21pbnV0ZX06JHtzZWNvbmR9IEdNVGBcbn1cblxuLyoqXG4gbWF4LWFnZS1hdiAgICAgICAgPSBcIk1heC1BZ2U9XCIgbm9uLXplcm8tZGlnaXQgKkRJR0lUXG4gICAgICAgICAgICAgICAgICAgICAgIDsgSW4gcHJhY3RpY2UsIGJvdGggZXhwaXJlcy1hdiBhbmQgbWF4LWFnZS1hdlxuICAgICAgICAgICAgICAgICAgICAgICA7IGFyZSBsaW1pdGVkIHRvIGRhdGVzIHJlcHJlc2VudGFibGUgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgIDsgdXNlciBhZ2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBZ2VcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVNYXhBZ2UgKG1heEFnZSkge1xuICBpZiAobWF4QWdlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgbWF4LWFnZScpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2MjY1I3NlY3Rpb24tNC4xLjFcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuQ29va2llfSBjb29raWVcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5IChjb29raWUpIHtcbiAgaWYgKGNvb2tpZS5uYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YWxpZGF0ZUNvb2tpZU5hbWUoY29va2llLm5hbWUpXG4gIHZhbGlkYXRlQ29va2llVmFsdWUoY29va2llLnZhbHVlKVxuXG4gIGNvbnN0IG91dCA9IFtgJHtjb29raWUubmFtZX09JHtjb29raWUudmFsdWV9YF1cblxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1jb29raWUtcHJlZml4ZXMtMDAjc2VjdGlvbi0zLjFcbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtY29va2llLXByZWZpeGVzLTAwI3NlY3Rpb24tMy4yXG4gIGlmIChjb29raWUubmFtZS5zdGFydHNXaXRoKCdfX1NlY3VyZS0nKSkge1xuICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlXG4gIH1cblxuICBpZiAoY29va2llLm5hbWUuc3RhcnRzV2l0aCgnX19Ib3N0LScpKSB7XG4gICAgY29va2llLnNlY3VyZSA9IHRydWVcbiAgICBjb29raWUuZG9tYWluID0gbnVsbFxuICAgIGNvb2tpZS5wYXRoID0gJy8nXG4gIH1cblxuICBpZiAoY29va2llLnNlY3VyZSkge1xuICAgIG91dC5wdXNoKCdTZWN1cmUnKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5odHRwT25seSkge1xuICAgIG91dC5wdXNoKCdIdHRwT25seScpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvb2tpZS5tYXhBZ2UgPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVDb29raWVNYXhBZ2UoY29va2llLm1heEFnZSlcbiAgICBvdXQucHVzaChgTWF4LUFnZT0ke2Nvb2tpZS5tYXhBZ2V9YClcbiAgfVxuXG4gIGlmIChjb29raWUuZG9tYWluKSB7XG4gICAgdmFsaWRhdGVDb29raWVEb21haW4oY29va2llLmRvbWFpbilcbiAgICBvdXQucHVzaChgRG9tYWluPSR7Y29va2llLmRvbWFpbn1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5wYXRoKSB7XG4gICAgdmFsaWRhdGVDb29raWVQYXRoKGNvb2tpZS5wYXRoKVxuICAgIG91dC5wdXNoKGBQYXRoPSR7Y29va2llLnBhdGh9YClcbiAgfVxuXG4gIGlmIChjb29raWUuZXhwaXJlcyAmJiBjb29raWUuZXhwaXJlcy50b1N0cmluZygpICE9PSAnSW52YWxpZCBEYXRlJykge1xuICAgIG91dC5wdXNoKGBFeHBpcmVzPSR7dG9JTUZEYXRlKGNvb2tpZS5leHBpcmVzKX1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5zYW1lU2l0ZSkge1xuICAgIG91dC5wdXNoKGBTYW1lU2l0ZT0ke2Nvb2tpZS5zYW1lU2l0ZX1gKVxuICB9XG5cbiAgZm9yIChjb25zdCBwYXJ0IG9mIGNvb2tpZS51bnBhcnNlZCkge1xuICAgIGlmICghcGFydC5pbmNsdWRlcygnPScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5wYXJzZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IFtrZXksIC4uLnZhbHVlXSA9IHBhcnQuc3BsaXQoJz0nKVxuXG4gICAgb3V0LnB1c2goYCR7a2V5LnRyaW0oKX09JHt2YWx1ZS5qb2luKCc9Jyl9YClcbiAgfVxuXG4gIHJldHVybiBvdXQuam9pbignOyAnKVxufVxuXG5sZXQga0hlYWRlcnNMaXN0Tm9kZVxuXG5mdW5jdGlvbiBnZXRIZWFkZXJzTGlzdCAoaGVhZGVycykge1xuICBpZiAoaGVhZGVyc1trSGVhZGVyc0xpc3RdKSB7XG4gICAgcmV0dXJuIGhlYWRlcnNba0hlYWRlcnNMaXN0XVxuICB9XG5cbiAgaWYgKCFrSGVhZGVyc0xpc3ROb2RlKSB7XG4gICAga0hlYWRlcnNMaXN0Tm9kZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaGVhZGVycykuZmluZChcbiAgICAgIChzeW1ib2wpID0+IHN5bWJvbC5kZXNjcmlwdGlvbiA9PT0gJ2hlYWRlcnMgbGlzdCdcbiAgICApXG5cbiAgICBhc3NlcnQoa0hlYWRlcnNMaXN0Tm9kZSwgJ0hlYWRlcnMgY2Fubm90IGJlIHBhcnNlZCcpXG4gIH1cblxuICBjb25zdCBoZWFkZXJzTGlzdCA9IGhlYWRlcnNba0hlYWRlcnNMaXN0Tm9kZV1cbiAgYXNzZXJ0KGhlYWRlcnNMaXN0KVxuXG4gIHJldHVybiBoZWFkZXJzTGlzdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNDVExFeGNsdWRpbmdIdGFiLFxuICBzdHJpbmdpZnksXG4gIGdldEhlYWRlcnNMaXN0XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/cookies/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst net = __webpack_require__(/*! net */ \"net\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {\n  SessionCache = class WeakSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n      this._sessionRegistry = new global.FinalizationRegistry((key) => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return\n        }\n\n        const ref = this._sessionCache.get(key)\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key)\n        }\n      })\n    }\n\n    get (sessionKey) {\n      const ref = this._sessionCache.get(sessionKey)\n      return ref ? ref.deref() : null\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      this._sessionCache.set(sessionKey, new WeakRef(session))\n      this._sessionRegistry.register(session, sessionKey)\n    }\n  }\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n    }\n\n    get (sessionKey) {\n      return this._sessionCache.get(sessionKey)\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const { value: oldestKey } = this._sessionCache.keys().next()\n        this._sessionCache.delete(oldestKey)\n      }\n\n      this._sessionCache.set(sessionKey, session)\n    }\n  }\n}\n\nfunction buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = __webpack_require__(/*! tls */ \"tls\")\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        // TODO(HTTP/2): Add support for h2c\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout)\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction setupTimeout (onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {}\n  }\n\n  let s1 = null\n  let s2 = null\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout())\n      } else {\n        onConnectTimeout()\n      }\n    })\n  }, timeout)\n  return () => {\n    clearTimeout(timeoutId)\n    clearImmediate(s1)\n    clearImmediate(s2)\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsUUFBUSw0Q0FBNEMsRUFBRSxtQkFBTyxDQUFDLGdFQUFVOztBQUV4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMERBQTBEO0FBQ3JGO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNFQUFzRTtBQUNuRztBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9jb25uZWN0LmpzPzVhZjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBDb25uZWN0VGltZW91dEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5cbmxldCB0bHMgLy8gaW5jbHVkZSB0bHMgY29uZGl0aW9uYWxseSBzaW5jZSBpdCBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZVxuXG4vLyBUT0RPOiBzZXNzaW9uIHJlLXVzZSBkb2VzIG5vdCB3YWl0IGZvciB0aGUgZmlyc3Rcbi8vIGNvbm5lY3Rpb24gdG8gcmVzb2x2ZSB0aGUgc2Vzc2lvbiBhbmQgbWlnaHQgdGhlcmVmb3JlXG4vLyByZXNvbHZlIHRoZSBzYW1lIHNlcnZlcm5hbWUgbXVsdGlwbGUgdGltZXMgZXZlbiB3aGVuXG4vLyByZS11c2UgaXMgZW5hYmxlZC5cblxubGV0IFNlc3Npb25DYWNoZVxuLy8gRklYTUU6IHJlbW92ZSB3b3JrYXJvdW5kIHdoZW4gdGhlIE5vZGUgYnVnIGlzIGZpeGVkXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0I2lzc3VlY29tbWVudC0xNzQxNzc2MzA4XG5pZiAoZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmICFwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFKSB7XG4gIFNlc3Npb25DYWNoZSA9IGNsYXNzIFdlYWtTZXNzaW9uQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yIChtYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPSBtYXhDYWNoZWRTZXNzaW9uc1xuICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlID0gbmV3IE1hcCgpXG4gICAgICB0aGlzLl9zZXNzaW9uUmVnaXN0cnkgPSBuZXcgZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5KChrZXkpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3Nlc3Npb25DYWNoZS5zaXplIDwgdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuX3Nlc3Npb25DYWNoZS5nZXQoa2V5KVxuICAgICAgICBpZiAocmVmICE9PSB1bmRlZmluZWQgJiYgcmVmLmRlcmVmKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5kZWxldGUoa2V5KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGdldCAoc2Vzc2lvbktleSkge1xuICAgICAgY29uc3QgcmVmID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmdldChzZXNzaW9uS2V5KVxuICAgICAgcmV0dXJuIHJlZiA/IHJlZi5kZXJlZigpIDogbnVsbFxuICAgIH1cblxuICAgIHNldCAoc2Vzc2lvbktleSwgc2Vzc2lvbikge1xuICAgICAgaWYgKHRoaXMuX21heENhY2hlZFNlc3Npb25zID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUuc2V0KHNlc3Npb25LZXksIG5ldyBXZWFrUmVmKHNlc3Npb24pKVxuICAgICAgdGhpcy5fc2Vzc2lvblJlZ2lzdHJ5LnJlZ2lzdGVyKHNlc3Npb24sIHNlc3Npb25LZXkpXG4gICAgfVxuICB9XG59IGVsc2Uge1xuICBTZXNzaW9uQ2FjaGUgPSBjbGFzcyBTaW1wbGVTZXNzaW9uQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yIChtYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPSBtYXhDYWNoZWRTZXNzaW9uc1xuICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlID0gbmV3IE1hcCgpXG4gICAgfVxuXG4gICAgZ2V0IChzZXNzaW9uS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbkNhY2hlLmdldChzZXNzaW9uS2V5KVxuICAgIH1cblxuICAgIHNldCAoc2Vzc2lvbktleSwgc2Vzc2lvbikge1xuICAgICAgaWYgKHRoaXMuX21heENhY2hlZFNlc3Npb25zID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc2Vzc2lvbkNhY2hlLnNpemUgPj0gdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGRlc3Qgc2Vzc2lvblxuICAgICAgICBjb25zdCB7IHZhbHVlOiBvbGRlc3RLZXkgfSA9IHRoaXMuX3Nlc3Npb25DYWNoZS5rZXlzKCkubmV4dCgpXG4gICAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5kZWxldGUob2xkZXN0S2V5KVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUuc2V0KHNlc3Npb25LZXksIHNlc3Npb24pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ29ubmVjdG9yICh7IGFsbG93SDIsIG1heENhY2hlZFNlc3Npb25zLCBzb2NrZXRQYXRoLCB0aW1lb3V0LCAuLi5vcHRzIH0pIHtcbiAgaWYgKG1heENhY2hlZFNlc3Npb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heENhY2hlZFNlc3Npb25zKSB8fCBtYXhDYWNoZWRTZXNzaW9ucyA8IDApKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhDYWNoZWRTZXNzaW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB7IHBhdGg6IHNvY2tldFBhdGgsIC4uLm9wdHMgfVxuICBjb25zdCBzZXNzaW9uQ2FjaGUgPSBuZXcgU2Vzc2lvbkNhY2hlKG1heENhY2hlZFNlc3Npb25zID09IG51bGwgPyAxMDAgOiBtYXhDYWNoZWRTZXNzaW9ucylcbiAgdGltZW91dCA9IHRpbWVvdXQgPT0gbnVsbCA/IDEwZTMgOiB0aW1lb3V0XG4gIGFsbG93SDIgPSBhbGxvd0gyICE9IG51bGwgPyBhbGxvd0gyIDogZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbm5lY3QgKHsgaG9zdG5hbWUsIGhvc3QsIHByb3RvY29sLCBwb3J0LCBzZXJ2ZXJuYW1lLCBsb2NhbEFkZHJlc3MsIGh0dHBTb2NrZXQgfSwgY2FsbGJhY2spIHtcbiAgICBsZXQgc29ja2V0XG4gICAgaWYgKHByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgaWYgKCF0bHMpIHtcbiAgICAgICAgdGxzID0gcmVxdWlyZSgndGxzJylcbiAgICAgIH1cbiAgICAgIHNlcnZlcm5hbWUgPSBzZXJ2ZXJuYW1lIHx8IG9wdGlvbnMuc2VydmVybmFtZSB8fCB1dGlsLmdldFNlcnZlck5hbWUoaG9zdCkgfHwgbnVsbFxuXG4gICAgICBjb25zdCBzZXNzaW9uS2V5ID0gc2VydmVybmFtZSB8fCBob3N0bmFtZVxuICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSkgfHwgbnVsbFxuXG4gICAgICBhc3NlcnQoc2Vzc2lvbktleSlcblxuICAgICAgc29ja2V0ID0gdGxzLmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiAxNjM4NCwgLy8gVExTIGluIG5vZGUgY2FuJ3QgaGF2ZSBiaWdnZXIgSFdNIGFueXdheS4uLlxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzZXJ2ZXJuYW1lLFxuICAgICAgICBzZXNzaW9uLFxuICAgICAgICBsb2NhbEFkZHJlc3MsXG4gICAgICAgIC8vIFRPRE8oSFRUUC8yKTogQWRkIHN1cHBvcnQgZm9yIGgyY1xuICAgICAgICBBTFBOUHJvdG9jb2xzOiBhbGxvd0gyID8gWydodHRwLzEuMScsICdoMiddIDogWydodHRwLzEuMSddLFxuICAgICAgICBzb2NrZXQ6IGh0dHBTb2NrZXQsIC8vIHVwZ3JhZGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgcG9ydDogcG9ydCB8fCA0NDMsXG4gICAgICAgIGhvc3Q6IGhvc3RuYW1lXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXRcbiAgICAgICAgLm9uKCdzZXNzaW9uJywgZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBDYW4gYSBzZXNzaW9uIGJlY29tZSBpbnZhbGlkIG9uY2UgZXN0YWJsaXNoZWQ/IERvbid0IHRoaW5rIHNvP1xuICAgICAgICAgIHNlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KCFodHRwU29ja2V0LCAnaHR0cFNvY2tldCBjYW4gb25seSBiZSBzZW50IG9uIFRMUyB1cGRhdGUnKVxuICAgICAgc29ja2V0ID0gbmV0LmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiA2NCAqIDEwMjQsIC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGxvY2FsQWRkcmVzcyxcbiAgICAgICAgcG9ydDogcG9ydCB8fCA4MCxcbiAgICAgICAgaG9zdDogaG9zdG5hbWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gU2V0IFRDUCBrZWVwIGFsaXZlIG9wdGlvbnMgb24gdGhlIHNvY2tldCBoZXJlIGluc3RlYWQgb2YgaW4gY29ubmVjdCgpIGZvciB0aGUgY2FzZSBvZiBhc3NpZ25pbmcgdGhlIHNvY2tldFxuICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZSA9PSBudWxsIHx8IG9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICBjb25zdCBrZWVwQWxpdmVJbml0aWFsRGVsYXkgPSBvcHRpb25zLmtlZXBBbGl2ZUluaXRpYWxEZWxheSA9PT0gdW5kZWZpbmVkID8gNjBlMyA6IG9wdGlvbnMua2VlcEFsaXZlSW5pdGlhbERlbGF5XG4gICAgICBzb2NrZXQuc2V0S2VlcEFsaXZlKHRydWUsIGtlZXBBbGl2ZUluaXRpYWxEZWxheSlcbiAgICB9XG5cbiAgICBjb25zdCBjYW5jZWxUaW1lb3V0ID0gc2V0dXBUaW1lb3V0KCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoc29ja2V0KSwgdGltZW91dClcblxuICAgIHNvY2tldFxuICAgICAgLnNldE5vRGVsYXkodHJ1ZSlcbiAgICAgIC5vbmNlKHByb3RvY29sID09PSAnaHR0cHM6JyA/ICdzZWN1cmVDb25uZWN0JyA6ICdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWxUaW1lb3V0KClcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgY2IobnVsbCwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQoKVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICByZXR1cm4gc29ja2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBUaW1lb3V0IChvbkNvbm5lY3RUaW1lb3V0LCB0aW1lb3V0KSB7XG4gIGlmICghdGltZW91dCkge1xuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG5cbiAgbGV0IHMxID0gbnVsbFxuICBsZXQgczIgPSBudWxsXG4gIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vIHNldEltbWVkaWF0ZSBpcyBhZGRlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwcmlvdG9yaXNlIHNvY2tldCBlcnJvciBldmVudHMgb3ZlciB0aW1lb3V0c1xuICAgIHMxID0gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIC8vIFdpbmRvd3MgbmVlZHMgYW4gZXh0cmEgc2V0SW1tZWRpYXRlIHByb2JhYmx5IGR1ZSB0byBpbXBsZW1lbnRhdGlvbiBkaWZmZXJlbmNlcyBpbiB0aGUgc29ja2V0IGxvZ2ljXG4gICAgICAgIHMyID0gc2V0SW1tZWRpYXRlKCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uQ29ubmVjdFRpbWVvdXQoKVxuICAgICAgfVxuICAgIH0pXG4gIH0sIHRpbWVvdXQpXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICBjbGVhckltbWVkaWF0ZShzMSlcbiAgICBjbGVhckltbWVkaWF0ZShzMilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbm5lY3RUaW1lb3V0IChzb2NrZXQpIHtcbiAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IENvbm5lY3RUaW1lb3V0RXJyb3IoKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZENvbm5lY3RvclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/errors.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/core/errors.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass UndiciError extends Error {\n  constructor (message) {\n    super(message)\n    this.name = 'UndiciError'\n    this.code = 'UND_ERR'\n  }\n}\n\nclass ConnectTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ConnectTimeoutError)\n    this.name = 'ConnectTimeoutError'\n    this.message = message || 'Connect Timeout Error'\n    this.code = 'UND_ERR_CONNECT_TIMEOUT'\n  }\n}\n\nclass HeadersTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, HeadersTimeoutError)\n    this.name = 'HeadersTimeoutError'\n    this.message = message || 'Headers Timeout Error'\n    this.code = 'UND_ERR_HEADERS_TIMEOUT'\n  }\n}\n\nclass HeadersOverflowError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, HeadersOverflowError)\n    this.name = 'HeadersOverflowError'\n    this.message = message || 'Headers Overflow Error'\n    this.code = 'UND_ERR_HEADERS_OVERFLOW'\n  }\n}\n\nclass BodyTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, BodyTimeoutError)\n    this.name = 'BodyTimeoutError'\n    this.message = message || 'Body Timeout Error'\n    this.code = 'UND_ERR_BODY_TIMEOUT'\n  }\n}\n\nclass ResponseStatusCodeError extends UndiciError {\n  constructor (message, statusCode, headers, body) {\n    super(message)\n    Error.captureStackTrace(this, ResponseStatusCodeError)\n    this.name = 'ResponseStatusCodeError'\n    this.message = message || 'Response Status Code Error'\n    this.code = 'UND_ERR_RESPONSE_STATUS_CODE'\n    this.body = body\n    this.status = statusCode\n    this.statusCode = statusCode\n    this.headers = headers\n  }\n}\n\nclass InvalidArgumentError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InvalidArgumentError)\n    this.name = 'InvalidArgumentError'\n    this.message = message || 'Invalid Argument Error'\n    this.code = 'UND_ERR_INVALID_ARG'\n  }\n}\n\nclass InvalidReturnValueError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InvalidReturnValueError)\n    this.name = 'InvalidReturnValueError'\n    this.message = message || 'Invalid Return Value Error'\n    this.code = 'UND_ERR_INVALID_RETURN_VALUE'\n  }\n}\n\nclass RequestAbortedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, RequestAbortedError)\n    this.name = 'AbortError'\n    this.message = message || 'Request aborted'\n    this.code = 'UND_ERR_ABORTED'\n  }\n}\n\nclass InformationalError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InformationalError)\n    this.name = 'InformationalError'\n    this.message = message || 'Request information'\n    this.code = 'UND_ERR_INFO'\n  }\n}\n\nclass RequestContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, RequestContentLengthMismatchError)\n    this.name = 'RequestContentLengthMismatchError'\n    this.message = message || 'Request body length does not match content-length header'\n    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ResponseContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ResponseContentLengthMismatchError)\n    this.name = 'ResponseContentLengthMismatchError'\n    this.message = message || 'Response body length does not match content-length header'\n    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ClientDestroyedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ClientDestroyedError)\n    this.name = 'ClientDestroyedError'\n    this.message = message || 'The client is destroyed'\n    this.code = 'UND_ERR_DESTROYED'\n  }\n}\n\nclass ClientClosedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ClientClosedError)\n    this.name = 'ClientClosedError'\n    this.message = message || 'The client is closed'\n    this.code = 'UND_ERR_CLOSED'\n  }\n}\n\nclass SocketError extends UndiciError {\n  constructor (message, socket) {\n    super(message)\n    Error.captureStackTrace(this, SocketError)\n    this.name = 'SocketError'\n    this.message = message || 'Socket error'\n    this.code = 'UND_ERR_SOCKET'\n    this.socket = socket\n  }\n}\n\nclass NotSupportedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, NotSupportedError)\n    this.name = 'NotSupportedError'\n    this.message = message || 'Not supported error'\n    this.code = 'UND_ERR_NOT_SUPPORTED'\n  }\n}\n\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, NotSupportedError)\n    this.name = 'MissingUpstreamError'\n    this.message = message || 'No upstream has been added to the BalancedPool'\n    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'\n  }\n}\n\nclass HTTPParserError extends Error {\n  constructor (message, code, data) {\n    super(message)\n    Error.captureStackTrace(this, HTTPParserError)\n    this.name = 'HTTPParserError'\n    this.code = code ? `HPE_${code}` : undefined\n    this.data = data ? data.toString() : undefined\n  }\n}\n\nclass ResponseExceededMaxSizeError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ResponseExceededMaxSizeError)\n    this.name = 'ResponseExceededMaxSizeError'\n    this.message = message || 'Response content exceeded max size'\n    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE'\n  }\n}\n\nmodule.exports = {\n  HTTPParserError,\n  UndiciError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  BodyTimeoutError,\n  RequestContentLengthMismatchError,\n  ConnectTimeoutError,\n  ResponseStatusCodeError,\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  InformationalError,\n  SocketError,\n  NotSupportedError,\n  ResponseContentLengthMismatchError,\n  BalancedPoolMissingUpstreamError,\n  ResponseExceededMaxSizeError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvZXJyb3JzLmpzP2EyN2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIFVuZGljaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1VuZGljaUVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSJ1xuICB9XG59XG5cbmNsYXNzIENvbm5lY3RUaW1lb3V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDb25uZWN0VGltZW91dEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdDb25uZWN0VGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0Nvbm5lY3QgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9DT05ORUNUX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc1RpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEhlYWRlcnNUaW1lb3V0RXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0hlYWRlcnNUaW1lb3V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSGVhZGVycyBUaW1lb3V0IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0hFQURFUlNfVElNRU9VVCdcbiAgfVxufVxuXG5jbGFzcyBIZWFkZXJzT3ZlcmZsb3dFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEhlYWRlcnNPdmVyZmxvd0Vycm9yKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzT3ZlcmZsb3dFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdIZWFkZXJzIE92ZXJmbG93IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0hFQURFUlNfT1ZFUkZMT1cnXG4gIH1cbn1cblxuY2xhc3MgQm9keVRpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEJvZHlUaW1lb3V0RXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0JvZHlUaW1lb3V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnQm9keSBUaW1lb3V0IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0JPRFlfVElNRU9VVCdcbiAgfVxufVxuXG5jbGFzcyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZVN0YXR1c0NvZGVFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXNwb25zZSBTdGF0dXMgQ29kZSBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNQT05TRV9TVEFUVVNfQ09ERSdcbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgfVxufVxuXG5jbGFzcyBJbnZhbGlkQXJndW1lbnRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludmFsaWRBcmd1bWVudEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkQXJndW1lbnRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdJbnZhbGlkIEFyZ3VtZW50IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lOVkFMSURfQVJHJ1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZFJldHVyblZhbHVlRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRSZXR1cm5WYWx1ZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0ludmFsaWQgUmV0dXJuIFZhbHVlIEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJ1xuICB9XG59XG5cbmNsYXNzIFJlcXVlc3RBYm9ydGVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXF1ZXN0QWJvcnRlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdBYm9ydEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgYWJvcnRlZCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9BQk9SVEVEJ1xuICB9XG59XG5cbmNsYXNzIEluZm9ybWF0aW9uYWxFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEluZm9ybWF0aW9uYWxFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnSW5mb3JtYXRpb25hbEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgaW5mb3JtYXRpb24nXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5GTydcbiAgfVxufVxuXG5jbGFzcyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVzcG9uc2UgYm9keSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggY29udGVudC1sZW5ndGggaGVhZGVyJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU19DT05URU5UX0xFTkdUSF9NSVNNQVRDSCdcbiAgfVxufVxuXG5jbGFzcyBDbGllbnREZXN0cm95ZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENsaWVudERlc3Ryb3llZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdDbGllbnREZXN0cm95ZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGUgY2xpZW50IGlzIGRlc3Ryb3llZCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9ERVNUUk9ZRUQnXG4gIH1cbn1cblxuY2xhc3MgQ2xpZW50Q2xvc2VkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDbGllbnRDbG9zZWRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnQ2xpZW50Q2xvc2VkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIGNsaWVudCBpcyBjbG9zZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQ0xPU0VEJ1xuICB9XG59XG5cbmNsYXNzIFNvY2tldEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc29ja2V0KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBTb2NrZXRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnU29ja2V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnU29ja2V0IGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1NPQ0tFVCdcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICB9XG59XG5cbmNsYXNzIE5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm90U3VwcG9ydGVkRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ05vdFN1cHBvcnRlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ05vdCBzdXBwb3J0ZWQgZXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfTk9UX1NVUFBPUlRFRCdcbiAgfVxufVxuXG5jbGFzcyBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5vdFN1cHBvcnRlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdNaXNzaW5nVXBzdHJlYW1FcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdObyB1cHN0cmVhbSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgQmFsYW5jZWRQb29sJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0JQTF9NSVNTSU5HX1VQU1RSRUFNJ1xuICB9XG59XG5cbmNsYXNzIEhUVFBQYXJzZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvZGUsIGRhdGEpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEhUVFBQYXJzZXJFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnSFRUUFBhcnNlckVycm9yJ1xuICAgIHRoaXMuY29kZSA9IGNvZGUgPyBgSFBFXyR7Y29kZX1gIDogdW5kZWZpbmVkXG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IGRhdGEudG9TdHJpbmcoKSA6IHVuZGVmaW5lZFxuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGNvbnRlbnQgZXhjZWVkZWQgbWF4IHNpemUnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVTX0VYQ0VFREVEX01BWF9TSVpFJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBIVFRQUGFyc2VyRXJyb3IsXG4gIFVuZGljaUVycm9yLFxuICBIZWFkZXJzVGltZW91dEVycm9yLFxuICBIZWFkZXJzT3ZlcmZsb3dFcnJvcixcbiAgQm9keVRpbWVvdXRFcnJvcixcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBDb25uZWN0VGltZW91dEVycm9yLFxuICBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgU29ja2V0RXJyb3IsXG4gIE5vdFN1cHBvcnRlZEVycm9yLFxuICBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcixcbiAgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvclxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/request.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\n// tokenRegExp and headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nconst tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/\n\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/\n\nconst kHandler = Symbol('handler')\n\nconst channels = {}\n\nlet extractBody\n\ntry {\n  const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\")\n  channels.create = diagnosticsChannel.channel('undici:request:create')\n  channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent')\n  channels.headers = diagnosticsChannel.channel('undici:request:headers')\n  channels.trailers = diagnosticsChannel.channel('undici:request:trailers')\n  channels.error = diagnosticsChannel.channel('undici:request:error')\n} catch {\n  channels.create = { hasSubscribers: false }\n  channels.bodySent = { hasSubscribers: false }\n  channels.headers = { hasSubscribers: false }\n  channels.trailers = { hasSubscribers: false }\n  channels.error = { hasSubscribers: false }\n}\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    query,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout,\n    reset,\n    throwOnError,\n    expectContinue\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (\n      path[0] !== '/' &&\n      !(path.startsWith('http://') || path.startsWith('https://')) &&\n      method !== 'CONNECT'\n    ) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    } else if (invalidPathRegex.exec(path) !== null) {\n      throw new InvalidArgumentError('invalid request path')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    } else if (tokenRegExp.exec(method) === null) {\n      throw new InvalidArgumentError('invalid request method')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    if (reset != null && typeof reset !== 'boolean') {\n      throw new InvalidArgumentError('invalid reset')\n    }\n\n    if (expectContinue != null && typeof expectContinue !== 'boolean') {\n      throw new InvalidArgumentError('invalid expectContinue')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.throwOnError = throwOnError === true\n\n    this.method = method\n\n    if (body == null) {\n      this.body = null\n    } else if (util.isStream(body)) {\n      this.body = body\n    } else if (util.isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (ArrayBuffer.isView(body)) {\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null\n    } else if (body instanceof ArrayBuffer) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = query ? util.buildURL(path, query) : path\n\n    this.origin = origin\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking == null ? false : blocking\n\n    this.reset = reset == null ? null : reset\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = ''\n\n    // Only for H2\n    this.expectContinue = expectContinue != null ? expectContinue : false\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      const keys = Object.keys(headers)\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        processHeader(this, key, headers[key])\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    if (util.isFormDataLike(this.body)) {\n      if (util.nodeMajor < 16 || (util.nodeMajor === 16 && util.nodeMinor < 8)) {\n        throw new InvalidArgumentError('Form-Data bodies are only supported in node v16.8 and newer.')\n      }\n\n      if (!extractBody) {\n        extractBody = (__webpack_require__(/*! ../fetch/body.js */ \"(ssr)/./node_modules/undici/lib/fetch/body.js\").extractBody)\n      }\n\n      const [bodyStream, contentType] = extractBody(body)\n      if (this.contentType == null) {\n        this.contentType = contentType\n        this.headers += `content-type: ${contentType}\\r\\n`\n      }\n      this.body = bodyStream.stream\n      this.contentLength = bodyStream.length\n    } else if (util.isBlobLike(body) && this.contentType == null && body.type) {\n      this.contentType = body.type\n      this.headers += `content-type: ${body.type}\\r\\n`\n    }\n\n    util.validateHandler(handler, method, upgrade)\n\n    this.servername = util.getServerName(this.host)\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this[kHandler].onBodySent) {\n      try {\n        this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.onError(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onConnect(abort)\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onData(chunk)\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    assert(!this.aborted)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n    return this[kHandler].onComplete(trailers)\n  }\n\n  onError (error) {\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n    return this[kHandler].onError(error)\n  }\n\n  // TODO: adjust to support H2\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n\n  static [kHTTP1BuildRequest] (origin, opts, handler) {\n    // TODO: Migrate header parsing here, to make Requests\n    // HTTP agnostic\n    return new Request(origin, opts, handler)\n  }\n\n  static [kHTTP2BuildRequest] (origin, opts, handler) {\n    const headers = opts.headers\n    opts = { ...opts, headers: null }\n\n    const request = new Request(origin, opts, handler)\n\n    request.headers = {}\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(request, headers[i], headers[i + 1], true)\n      }\n    } else if (headers && typeof headers === 'object') {\n      const keys = Object.keys(headers)\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        processHeader(request, key, headers[key], true)\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    return request\n  }\n\n  static [kHTTP2CopyHeaders] (raw) {\n    const rawHeaders = raw.split('\\r\\n')\n    const headers = {}\n\n    for (const header of rawHeaders) {\n      const [key, value] = header.split(': ')\n\n      if (value == null || value.length === 0) continue\n\n      if (headers[key]) headers[key] += `,${value}`\n      else headers[key] = value\n    }\n\n    return headers\n  }\n}\n\nfunction processHeaderValue (key, val, skipAppend) {\n  if (val && typeof val === 'object') {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  }\n\n  val = val != null ? `${val}` : ''\n\n  if (headerCharRegex.exec(val) !== null) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  }\n\n  return skipAppend ? val : `${key}: ${val}\\r\\n`\n}\n\nfunction processHeader (request, key, val, skipAppend = false) {\n  if (val && (typeof val === 'object' && !Array.isArray(val))) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  if (\n    request.host === null &&\n    key.length === 4 &&\n    key.toLowerCase() === 'host'\n  ) {\n    if (headerCharRegex.exec(val) !== null) {\n      throw new InvalidArgumentError(`invalid ${key} header`)\n    }\n    // Consumed by Client\n    request.host = val\n  } else if (\n    request.contentLength === null &&\n    key.length === 14 &&\n    key.toLowerCase() === 'content-length'\n  ) {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (\n    request.contentType === null &&\n    key.length === 12 &&\n    key.toLowerCase() === 'content-type'\n  ) {\n    request.contentType = val\n    if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend)\n    else request.headers += processHeaderValue(key, val)\n  } else if (\n    key.length === 17 &&\n    key.toLowerCase() === 'transfer-encoding'\n  ) {\n    throw new InvalidArgumentError('invalid transfer-encoding header')\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'connection'\n  ) {\n    const value = typeof val === 'string' ? val.toLowerCase() : null\n    if (value !== 'close' && value !== 'keep-alive') {\n      throw new InvalidArgumentError('invalid connection header')\n    } else if (value === 'close') {\n      request.reset = true\n    }\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'keep-alive'\n  ) {\n    throw new InvalidArgumentError('invalid keep-alive header')\n  } else if (\n    key.length === 7 &&\n    key.toLowerCase() === 'upgrade'\n  ) {\n    throw new InvalidArgumentError('invalid upgrade header')\n  } else if (\n    key.length === 6 &&\n    key.toLowerCase() === 'expect'\n  ) {\n    throw new NotSupportedError('expect header not supported')\n  } else if (tokenRegExp.exec(key) === null) {\n    throw new InvalidArgumentError('invalid header key')\n  } else {\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (skipAppend) {\n          if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`\n          else request.headers[key] = processHeaderValue(key, val[i], skipAppend)\n        } else {\n          request.headers += processHeaderValue(key, val[i])\n        }\n      }\n    } else {\n      if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend)\n      else request.headers += processHeaderValue(key, val)\n    }\n  }\n}\n\nmodule.exports = Request\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0VBQVU7QUFDdEIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsNERBQTRELEVBQUUsbUJBQU8sQ0FBQyxrRUFBVztBQUN6RixhQUFhLG1CQUFPLENBQUMsNERBQVE7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyxnREFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDBHQUF1QztBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLDJCQUEyQixtQ0FBbUM7QUFDL0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDs7QUFFQSx5QkFBeUIsSUFBSTs7QUFFN0I7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDs7QUFFQSwrQkFBK0IsSUFBSSxJQUFJLElBQUk7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25ELElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLGdFQUFnRSw0Q0FBNEM7QUFDNUc7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanM/OTQ2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgTm90U3VwcG9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBrSFRUUDJCdWlsZFJlcXVlc3QsIGtIVFRQMkNvcHlIZWFkZXJzLCBrSFRUUDFCdWlsZFJlcXVlc3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcblxuLy8gdG9rZW5SZWdFeHAgYW5kIGhlYWRlckNoYXJSZWdleCBoYXZlIGJlZW4gbGlmdGVkIGZyb21cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21haW4vbGliL19odHRwX2NvbW1vbi5qc1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIGdpdmVuIHZhbCBpcyBhIHZhbGlkIEhUVFAgdG9rZW5cbiAqIHBlciB0aGUgcnVsZXMgZGVmaW5lZCBpbiBSRkMgNzIzMFxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yLjZcbiAqL1xuY29uc3QgdG9rZW5SZWdFeHAgPSAvXltcXF5fYGEtekEtWlxcLTAtOSEjJCUmJyorLnx+XSskL1xuXG4vKipcbiAqIE1hdGNoZXMgaWYgdmFsIGNvbnRhaW5zIGFuIGludmFsaWQgZmllbGQtdmNoYXJcbiAqICBmaWVsZC12YWx1ZSAgICA9ICooIGZpZWxkLWNvbnRlbnQgLyBvYnMtZm9sZCApXG4gKiAgZmllbGQtY29udGVudCAgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiAgZmllbGQtdmNoYXIgICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKi9cbmNvbnN0IGhlYWRlckNoYXJSZWdleCA9IC9bXlxcdFxceDIwLVxceDdlXFx4ODAtXFx4ZmZdL1xuXG4vLyBWZXJpZmllcyB0aGF0IGEgZ2l2ZW4gcGF0aCBpcyB2YWxpZCBkb2VzIG5vdCBjb250YWluIGNvbnRyb2wgY2hhcnMgXFx4MDAgdG8gXFx4MjBcbmNvbnN0IGludmFsaWRQYXRoUmVnZXggPSAvW15cXHUwMDIxLVxcdTAwZmZdL1xuXG5jb25zdCBrSGFuZGxlciA9IFN5bWJvbCgnaGFuZGxlcicpXG5cbmNvbnN0IGNoYW5uZWxzID0ge31cblxubGV0IGV4dHJhY3RCb2R5XG5cbnRyeSB7XG4gIGNvbnN0IGRpYWdub3N0aWNzQ2hhbm5lbCA9IHJlcXVpcmUoJ2RpYWdub3N0aWNzX2NoYW5uZWwnKVxuICBjaGFubmVscy5jcmVhdGUgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Y3JlYXRlJylcbiAgY2hhbm5lbHMuYm9keVNlbnQgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Ym9keVNlbnQnKVxuICBjaGFubmVscy5oZWFkZXJzID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmhlYWRlcnMnKVxuICBjaGFubmVscy50cmFpbGVycyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDp0cmFpbGVycycpXG4gIGNoYW5uZWxzLmVycm9yID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJylcbn0gY2F0Y2gge1xuICBjaGFubmVscy5jcmVhdGUgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG4gIGNoYW5uZWxzLmJvZHlTZW50ID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy5oZWFkZXJzID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy50cmFpbGVycyA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuZXJyb3IgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG59XG5cbmNsYXNzIFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCB7XG4gICAgcGF0aCxcbiAgICBtZXRob2QsXG4gICAgYm9keSxcbiAgICBoZWFkZXJzLFxuICAgIHF1ZXJ5LFxuICAgIGlkZW1wb3RlbnQsXG4gICAgYmxvY2tpbmcsXG4gICAgdXBncmFkZSxcbiAgICBoZWFkZXJzVGltZW91dCxcbiAgICBib2R5VGltZW91dCxcbiAgICByZXNldCxcbiAgICB0aHJvd09uRXJyb3IsXG4gICAgZXhwZWN0Q29udGludWVcbiAgfSwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGF0aFswXSAhPT0gJy8nICYmXG4gICAgICAhKHBhdGguc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHBhdGguc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkgJiZcbiAgICAgIG1ldGhvZCAhPT0gJ0NPTk5FQ1QnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBhYnNvbHV0ZSBVUkwgb3Igc3RhcnQgd2l0aCBhIHNsYXNoJylcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQYXRoUmVnZXguZXhlYyhwYXRoKSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgcGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKHRva2VuUmVnRXhwLmV4ZWMobWV0aG9kKSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSAmJiB0eXBlb2YgdXBncmFkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndXBncmFkZSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhlYWRlcnNUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGJvZHlUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAocmVzZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzZXQgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlc2V0JylcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0Q29udGludWUgIT0gbnVsbCAmJiB0eXBlb2YgZXhwZWN0Q29udGludWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGV4cGVjdENvbnRpbnVlJylcbiAgICB9XG5cbiAgICB0aGlzLmhlYWRlcnNUaW1lb3V0ID0gaGVhZGVyc1RpbWVvdXRcblxuICAgIHRoaXMuYm9keVRpbWVvdXQgPSBib2R5VGltZW91dFxuXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3IgPT09IHRydWVcblxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG5cbiAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJvZHkgPSBudWxsXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBib2R5IDogbnVsbFxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ1ZmZlci5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keS5idWZmZXIsIGJvZHkuYnl0ZU9mZnNldCwgYm9keS5ieXRlTGVuZ3RoKSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkubGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKGJvZHkpIHx8IHV0aWwuaXNJdGVyYWJsZShib2R5KSB8fCB1dGlsLmlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5IG11c3QgYmUgYSBzdHJpbmcsIGEgQnVmZmVyLCBhIFJlYWRhYmxlIHN0cmVhbSwgYW4gaXRlcmFibGUsIG9yIGFuIGFzeW5jIGl0ZXJhYmxlJylcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZVxuXG4gICAgdGhpcy51cGdyYWRlID0gdXBncmFkZSB8fCBudWxsXG5cbiAgICB0aGlzLnBhdGggPSBxdWVyeSA/IHV0aWwuYnVpbGRVUkwocGF0aCwgcXVlcnkpIDogcGF0aFxuXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cblxuICAgIHRoaXMuaWRlbXBvdGVudCA9IGlkZW1wb3RlbnQgPT0gbnVsbFxuICAgICAgPyBtZXRob2QgPT09ICdIRUFEJyB8fCBtZXRob2QgPT09ICdHRVQnXG4gICAgICA6IGlkZW1wb3RlbnRcblxuICAgIHRoaXMuYmxvY2tpbmcgPSBibG9ja2luZyA9PSBudWxsID8gZmFsc2UgOiBibG9ja2luZ1xuXG4gICAgdGhpcy5yZXNldCA9IHJlc2V0ID09IG51bGwgPyBudWxsIDogcmVzZXRcblxuICAgIHRoaXMuaG9zdCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsXG5cbiAgICB0aGlzLmhlYWRlcnMgPSAnJ1xuXG4gICAgLy8gT25seSBmb3IgSDJcbiAgICB0aGlzLmV4cGVjdENvbnRpbnVlID0gZXhwZWN0Q29udGludWUgIT0gbnVsbCA/IGV4cGVjdENvbnRpbnVlIDogZmFsc2VcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBpZiAoaGVhZGVycy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBhcnJheSBtdXN0IGJlIGV2ZW4nKVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywgaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICAgIH1cblxuICAgIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKHRoaXMuYm9keSkpIHtcbiAgICAgIGlmICh1dGlsLm5vZGVNYWpvciA8IDE2IHx8ICh1dGlsLm5vZGVNYWpvciA9PT0gMTYgJiYgdXRpbC5ub2RlTWlub3IgPCA4KSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0Zvcm0tRGF0YSBib2RpZXMgYXJlIG9ubHkgc3VwcG9ydGVkIGluIG5vZGUgdjE2LjggYW5kIG5ld2VyLicpXG4gICAgICB9XG5cbiAgICAgIGlmICghZXh0cmFjdEJvZHkpIHtcbiAgICAgICAgZXh0cmFjdEJvZHkgPSByZXF1aXJlKCcuLi9mZXRjaC9ib2R5LmpzJykuZXh0cmFjdEJvZHlcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2JvZHlTdHJlYW0sIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgICBpZiAodGhpcy5jb250ZW50VHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZVxuICAgICAgICB0aGlzLmhlYWRlcnMgKz0gYGNvbnRlbnQtdHlwZTogJHtjb250ZW50VHlwZX1cXHJcXG5gXG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkgPSBib2R5U3RyZWFtLnN0cmVhbVxuICAgICAgdGhpcy5jb250ZW50TGVuZ3RoID0gYm9keVN0cmVhbS5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSAmJiB0aGlzLmNvbnRlbnRUeXBlID09IG51bGwgJiYgYm9keS50eXBlKSB7XG4gICAgICB0aGlzLmNvbnRlbnRUeXBlID0gYm9keS50eXBlXG4gICAgICB0aGlzLmhlYWRlcnMgKz0gYGNvbnRlbnQtdHlwZTogJHtib2R5LnR5cGV9XFxyXFxuYFxuICAgIH1cblxuICAgIHV0aWwudmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIsIG1ldGhvZCwgdXBncmFkZSlcblxuICAgIHRoaXMuc2VydmVybmFtZSA9IHV0aWwuZ2V0U2VydmVyTmFtZSh0aGlzLmhvc3QpXG5cbiAgICB0aGlzW2tIYW5kbGVyXSA9IGhhbmRsZXJcblxuICAgIGlmIChjaGFubmVscy5jcmVhdGUuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNyZWF0ZS5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcyB9KVxuICAgIH1cbiAgfVxuXG4gIG9uQm9keVNlbnQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQoY2h1bmspXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblJlcXVlc3RTZW50ICgpIHtcbiAgICBpZiAoY2hhbm5lbHMuYm9keVNlbnQuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmJvZHlTZW50LnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pXG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db25uZWN0KGFib3J0KVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgaWYgKGNoYW5uZWxzLmhlYWRlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMsIHJlc3BvbnNlOiB7IHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSB9KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25EYXRhKGNodW5rKVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuXG4gICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlXG4gICAgaWYgKGNoYW5uZWxzLnRyYWlsZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy50cmFpbGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgdHJhaWxlcnMgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gIH1cblxuICBvbkVycm9yIChlcnJvcikge1xuICAgIGlmIChjaGFubmVscy5lcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuZXJyb3IucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMsIGVycm9yIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25FcnJvcihlcnJvcilcbiAgfVxuXG4gIC8vIFRPRE86IGFkanVzdCB0byBzdXBwb3J0IEgyXG4gIGFkZEhlYWRlciAoa2V5LCB2YWx1ZSkge1xuICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5LCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhdGljIFtrSFRUUDFCdWlsZFJlcXVlc3RdIChvcmlnaW4sIG9wdHMsIGhhbmRsZXIpIHtcbiAgICAvLyBUT0RPOiBNaWdyYXRlIGhlYWRlciBwYXJzaW5nIGhlcmUsIHRvIG1ha2UgUmVxdWVzdHNcbiAgICAvLyBIVFRQIGFnbm9zdGljXG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9yaWdpbiwgb3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIHN0YXRpYyBba0hUVFAyQnVpbGRSZXF1ZXN0XSAob3JpZ2luLCBvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG9wdHMuaGVhZGVyc1xuICAgIG9wdHMgPSB7IC4uLm9wdHMsIGhlYWRlcnM6IG51bGwgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KG9yaWdpbiwgb3B0cywgaGFuZGxlcilcblxuICAgIHJlcXVlc3QuaGVhZGVycyA9IHt9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgYXJyYXkgbXVzdCBiZSBldmVuJylcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwcm9jZXNzSGVhZGVyKHJlcXVlc3QsIGhlYWRlcnNbaV0sIGhlYWRlcnNbaSArIDFdLCB0cnVlKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgcHJvY2Vzc0hlYWRlcihyZXF1ZXN0LCBrZXksIGhlYWRlcnNba2V5XSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdFxuICB9XG5cbiAgc3RhdGljIFtrSFRUUDJDb3B5SGVhZGVyc10gKHJhdykge1xuICAgIGNvbnN0IHJhd0hlYWRlcnMgPSByYXcuc3BsaXQoJ1xcclxcbicpXG4gICAgY29uc3QgaGVhZGVycyA9IHt9XG5cbiAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiByYXdIZWFkZXJzKSB7XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBoZWFkZXIuc3BsaXQoJzogJylcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwKSBjb250aW51ZVxuXG4gICAgICBpZiAoaGVhZGVyc1trZXldKSBoZWFkZXJzW2tleV0gKz0gYCwke3ZhbHVlfWBcbiAgICAgIGVsc2UgaGVhZGVyc1trZXldID0gdmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NIZWFkZXJWYWx1ZSAoa2V5LCB2YWwsIHNraXBBcHBlbmQpIHtcbiAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgfVxuXG4gIHZhbCA9IHZhbCAhPSBudWxsID8gYCR7dmFsfWAgOiAnJ1xuXG4gIGlmIChoZWFkZXJDaGFyUmVnZXguZXhlYyh2YWwpICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICB9XG5cbiAgcmV0dXJuIHNraXBBcHBlbmQgPyB2YWwgOiBgJHtrZXl9OiAke3ZhbH1cXHJcXG5gXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIgKHJlcXVlc3QsIGtleSwgdmFsLCBza2lwQXBwZW5kID0gZmFsc2UpIHtcbiAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gIH0gZWxzZSBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChcbiAgICByZXF1ZXN0Lmhvc3QgPT09IG51bGwgJiZcbiAgICBrZXkubGVuZ3RoID09PSA0ICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdob3N0J1xuICApIHtcbiAgICBpZiAoaGVhZGVyQ2hhclJlZ2V4LmV4ZWModmFsKSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICAgIH1cbiAgICAvLyBDb25zdW1lZCBieSBDbGllbnRcbiAgICByZXF1ZXN0Lmhvc3QgPSB2YWxcbiAgfSBlbHNlIGlmIChcbiAgICByZXF1ZXN0LmNvbnRlbnRMZW5ndGggPT09IG51bGwgJiZcbiAgICBrZXkubGVuZ3RoID09PSAxNCAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1sZW5ndGgnXG4gICkge1xuICAgIHJlcXVlc3QuY29udGVudExlbmd0aCA9IHBhcnNlSW50KHZhbCwgMTApXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmVxdWVzdC5jb250ZW50TGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcicpXG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIHJlcXVlc3QuY29udGVudFR5cGUgPT09IG51bGwgJiZcbiAgICBrZXkubGVuZ3RoID09PSAxMiAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJ1xuICApIHtcbiAgICByZXF1ZXN0LmNvbnRlbnRUeXBlID0gdmFsXG4gICAgaWYgKHNraXBBcHBlbmQpIHJlcXVlc3QuaGVhZGVyc1trZXldID0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsLCBza2lwQXBwZW5kKVxuICAgIGVsc2UgcmVxdWVzdC5oZWFkZXJzICs9IHByb2Nlc3NIZWFkZXJWYWx1ZShrZXksIHZhbClcbiAgfSBlbHNlIGlmIChcbiAgICBrZXkubGVuZ3RoID09PSAxNyAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAndHJhbnNmZXItZW5jb2RpbmcnXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCB0cmFuc2Zlci1lbmNvZGluZyBoZWFkZXInKVxuICB9IGVsc2UgaWYgKFxuICAgIGtleS5sZW5ndGggPT09IDEwICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb25uZWN0aW9uJ1xuICApIHtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsLnRvTG93ZXJDYXNlKCkgOiBudWxsXG4gICAgaWYgKHZhbHVlICE9PSAnY2xvc2UnICYmIHZhbHVlICE9PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0aW9uIGhlYWRlcicpXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgcmVxdWVzdC5yZXNldCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAga2V5Lmxlbmd0aCA9PT0gMTAgJiZcbiAgICBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2tlZXAtYWxpdmUnXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBrZWVwLWFsaXZlIGhlYWRlcicpXG4gIH0gZWxzZSBpZiAoXG4gICAga2V5Lmxlbmd0aCA9PT0gNyAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAndXBncmFkZSdcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVwZ3JhZGUgaGVhZGVyJylcbiAgfSBlbHNlIGlmIChcbiAgICBrZXkubGVuZ3RoID09PSA2ICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdleHBlY3QnXG4gICkge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcignZXhwZWN0IGhlYWRlciBub3Qgc3VwcG9ydGVkJylcbiAgfSBlbHNlIGlmICh0b2tlblJlZ0V4cC5leGVjKGtleSkgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyIGtleScpXG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNraXBBcHBlbmQpIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5oZWFkZXJzW2tleV0pIHJlcXVlc3QuaGVhZGVyc1trZXldICs9IGAsJHtwcm9jZXNzSGVhZGVyVmFsdWUoa2V5LCB2YWxbaV0sIHNraXBBcHBlbmQpfWBcbiAgICAgICAgICBlbHNlIHJlcXVlc3QuaGVhZGVyc1trZXldID0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsW2ldLCBza2lwQXBwZW5kKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcXVlc3QuaGVhZGVycyArPSBwcm9jZXNzSGVhZGVyVmFsdWUoa2V5LCB2YWxbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNraXBBcHBlbmQpIHJlcXVlc3QuaGVhZGVyc1trZXldID0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsLCBza2lwQXBwZW5kKVxuICAgICAgZWxzZSByZXF1ZXN0LmhlYWRlcnMgKz0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/symbols.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

eval("module.exports = {\n  kClose: Symbol('close'),\n  kDestroy: Symbol('destroy'),\n  kDispatch: Symbol('dispatch'),\n  kUrl: Symbol('url'),\n  kWriting: Symbol('writing'),\n  kResuming: Symbol('resuming'),\n  kQueue: Symbol('queue'),\n  kConnect: Symbol('connect'),\n  kConnecting: Symbol('connecting'),\n  kHeadersList: Symbol('headers list'),\n  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),\n  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),\n  kKeepAlive: Symbol('keep alive'),\n  kHeadersTimeout: Symbol('headers timeout'),\n  kBodyTimeout: Symbol('body timeout'),\n  kServerName: Symbol('server name'),\n  kLocalAddress: Symbol('local address'),\n  kHost: Symbol('host'),\n  kNoRef: Symbol('no ref'),\n  kBodyUsed: Symbol('used'),\n  kRunning: Symbol('running'),\n  kBlocking: Symbol('blocking'),\n  kPending: Symbol('pending'),\n  kSize: Symbol('size'),\n  kBusy: Symbol('busy'),\n  kQueued: Symbol('queued'),\n  kFree: Symbol('free'),\n  kConnected: Symbol('connected'),\n  kClosed: Symbol('closed'),\n  kNeedDrain: Symbol('need drain'),\n  kReset: Symbol('reset'),\n  kDestroyed: Symbol.for('nodejs.stream.destroyed'),\n  kMaxHeadersSize: Symbol('max headers size'),\n  kRunningIdx: Symbol('running index'),\n  kPendingIdx: Symbol('pending index'),\n  kError: Symbol('error'),\n  kClients: Symbol('clients'),\n  kClient: Symbol('client'),\n  kParser: Symbol('parser'),\n  kOnDestroyed: Symbol('destroy callbacks'),\n  kPipelining: Symbol('pipelining'),\n  kSocket: Symbol('socket'),\n  kHostHeader: Symbol('host header'),\n  kConnector: Symbol('connector'),\n  kStrictContentLength: Symbol('strict content length'),\n  kMaxRedirections: Symbol('maxRedirections'),\n  kMaxRequests: Symbol('maxRequestsPerClient'),\n  kProxy: Symbol('proxy agent options'),\n  kCounter: Symbol('socket request counter'),\n  kInterceptors: Symbol('dispatch interceptors'),\n  kMaxResponseSize: Symbol('max response size'),\n  kHTTP2Session: Symbol('http2Session'),\n  kHTTP2SessionState: Symbol('http2Session state'),\n  kHTTP2BuildRequest: Symbol('http2 build request'),\n  kHTTP1BuildRequest: Symbol('http1 build request'),\n  kHTTP2CopyHeaders: Symbol('http2 copy headers'),\n  kHTTPConnVersion: Symbol('http connection version')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanM/M2Q3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAga0Nsb3NlOiBTeW1ib2woJ2Nsb3NlJyksXG4gIGtEZXN0cm95OiBTeW1ib2woJ2Rlc3Ryb3knKSxcbiAga0Rpc3BhdGNoOiBTeW1ib2woJ2Rpc3BhdGNoJyksXG4gIGtVcmw6IFN5bWJvbCgndXJsJyksXG4gIGtXcml0aW5nOiBTeW1ib2woJ3dyaXRpbmcnKSxcbiAga1Jlc3VtaW5nOiBTeW1ib2woJ3Jlc3VtaW5nJyksXG4gIGtRdWV1ZTogU3ltYm9sKCdxdWV1ZScpLFxuICBrQ29ubmVjdDogU3ltYm9sKCdjb25uZWN0JyksXG4gIGtDb25uZWN0aW5nOiBTeW1ib2woJ2Nvbm5lY3RpbmcnKSxcbiAga0hlYWRlcnNMaXN0OiBTeW1ib2woJ2hlYWRlcnMgbGlzdCcpLFxuICBrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQ6IFN5bWJvbCgnZGVmYXVsdCBrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZU1heFRpbWVvdXQ6IFN5bWJvbCgnbWF4IGtlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZDogU3ltYm9sKCdrZWVwIGFsaXZlIHRpbWVvdXQgdGhyZXNob2xkJyksXG4gIGtLZWVwQWxpdmVUaW1lb3V0VmFsdWU6IFN5bWJvbCgna2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmU6IFN5bWJvbCgna2VlcCBhbGl2ZScpLFxuICBrSGVhZGVyc1RpbWVvdXQ6IFN5bWJvbCgnaGVhZGVycyB0aW1lb3V0JyksXG4gIGtCb2R5VGltZW91dDogU3ltYm9sKCdib2R5IHRpbWVvdXQnKSxcbiAga1NlcnZlck5hbWU6IFN5bWJvbCgnc2VydmVyIG5hbWUnKSxcbiAga0xvY2FsQWRkcmVzczogU3ltYm9sKCdsb2NhbCBhZGRyZXNzJyksXG4gIGtIb3N0OiBTeW1ib2woJ2hvc3QnKSxcbiAga05vUmVmOiBTeW1ib2woJ25vIHJlZicpLFxuICBrQm9keVVzZWQ6IFN5bWJvbCgndXNlZCcpLFxuICBrUnVubmluZzogU3ltYm9sKCdydW5uaW5nJyksXG4gIGtCbG9ja2luZzogU3ltYm9sKCdibG9ja2luZycpLFxuICBrUGVuZGluZzogU3ltYm9sKCdwZW5kaW5nJyksXG4gIGtTaXplOiBTeW1ib2woJ3NpemUnKSxcbiAga0J1c3k6IFN5bWJvbCgnYnVzeScpLFxuICBrUXVldWVkOiBTeW1ib2woJ3F1ZXVlZCcpLFxuICBrRnJlZTogU3ltYm9sKCdmcmVlJyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJyksXG4gIGtDbG9zZWQ6IFN5bWJvbCgnY2xvc2VkJyksXG4gIGtOZWVkRHJhaW46IFN5bWJvbCgnbmVlZCBkcmFpbicpLFxuICBrUmVzZXQ6IFN5bWJvbCgncmVzZXQnKSxcbiAga0Rlc3Ryb3llZDogU3ltYm9sLmZvcignbm9kZWpzLnN0cmVhbS5kZXN0cm95ZWQnKSxcbiAga01heEhlYWRlcnNTaXplOiBTeW1ib2woJ21heCBoZWFkZXJzIHNpemUnKSxcbiAga1J1bm5pbmdJZHg6IFN5bWJvbCgncnVubmluZyBpbmRleCcpLFxuICBrUGVuZGluZ0lkeDogU3ltYm9sKCdwZW5kaW5nIGluZGV4JyksXG4gIGtFcnJvcjogU3ltYm9sKCdlcnJvcicpLFxuICBrQ2xpZW50czogU3ltYm9sKCdjbGllbnRzJyksXG4gIGtDbGllbnQ6IFN5bWJvbCgnY2xpZW50JyksXG4gIGtQYXJzZXI6IFN5bWJvbCgncGFyc2VyJyksXG4gIGtPbkRlc3Ryb3llZDogU3ltYm9sKCdkZXN0cm95IGNhbGxiYWNrcycpLFxuICBrUGlwZWxpbmluZzogU3ltYm9sKCdwaXBlbGluaW5nJyksXG4gIGtTb2NrZXQ6IFN5bWJvbCgnc29ja2V0JyksXG4gIGtIb3N0SGVhZGVyOiBTeW1ib2woJ2hvc3QgaGVhZGVyJyksXG4gIGtDb25uZWN0b3I6IFN5bWJvbCgnY29ubmVjdG9yJyksXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoOiBTeW1ib2woJ3N0cmljdCBjb250ZW50IGxlbmd0aCcpLFxuICBrTWF4UmVkaXJlY3Rpb25zOiBTeW1ib2woJ21heFJlZGlyZWN0aW9ucycpLFxuICBrTWF4UmVxdWVzdHM6IFN5bWJvbCgnbWF4UmVxdWVzdHNQZXJDbGllbnQnKSxcbiAga1Byb3h5OiBTeW1ib2woJ3Byb3h5IGFnZW50IG9wdGlvbnMnKSxcbiAga0NvdW50ZXI6IFN5bWJvbCgnc29ja2V0IHJlcXVlc3QgY291bnRlcicpLFxuICBrSW50ZXJjZXB0b3JzOiBTeW1ib2woJ2Rpc3BhdGNoIGludGVyY2VwdG9ycycpLFxuICBrTWF4UmVzcG9uc2VTaXplOiBTeW1ib2woJ21heCByZXNwb25zZSBzaXplJyksXG4gIGtIVFRQMlNlc3Npb246IFN5bWJvbCgnaHR0cDJTZXNzaW9uJyksXG4gIGtIVFRQMlNlc3Npb25TdGF0ZTogU3ltYm9sKCdodHRwMlNlc3Npb24gc3RhdGUnKSxcbiAga0hUVFAyQnVpbGRSZXF1ZXN0OiBTeW1ib2woJ2h0dHAyIGJ1aWxkIHJlcXVlc3QnKSxcbiAga0hUVFAxQnVpbGRSZXF1ZXN0OiBTeW1ib2woJ2h0dHAxIGJ1aWxkIHJlcXVlc3QnKSxcbiAga0hUVFAyQ29weUhlYWRlcnM6IFN5bWJvbCgnaHR0cDIgY29weSBoZWFkZXJzJyksXG4gIGtIVFRQQ29ublZlcnNpb246IFN5bWJvbCgnaHR0cCBjb25uZWN0aW9uIHZlcnNpb24nKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/util.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { kDestroyed, kBodyUsed } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { IncomingMessage } = __webpack_require__(/*! http */ \"http\")\nconst stream = __webpack_require__(/*! stream */ \"stream\")\nconst net = __webpack_require__(/*! net */ \"net\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { Blob } = __webpack_require__(/*! buffer */ \"buffer\")\nconst nodeUtil = __webpack_require__(/*! util */ \"util\")\nconst { stringify } = __webpack_require__(/*! querystring */ \"querystring\")\n\nconst [nodeMajor, nodeMinor] = process.versions.node.split('.').map(v => Number(v))\n\nfunction nop () {}\n\nfunction isStream (obj) {\n  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'\n}\n\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike (object) {\n  return (Blob && object instanceof Blob) || (\n    object &&\n    typeof object === 'object' &&\n    (typeof object.stream === 'function' ||\n      typeof object.arrayBuffer === 'function') &&\n    /^(Blob|File)$/.test(object[Symbol.toStringTag])\n  )\n}\n\nfunction buildURL (url, queryParams) {\n  if (url.includes('?') || url.includes('#')) {\n    throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".')\n  }\n\n  const stringified = stringify(queryParams)\n\n  if (stringified) {\n    url += '?' + stringified\n  }\n\n  return url\n}\n\nfunction parseURL (url) {\n  if (typeof url === 'string') {\n    url = new URL(url)\n\n    if (!/^https?:/.test(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    return url\n  }\n\n  if (!url || typeof url !== 'object') {\n    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')\n  }\n\n  if (!/^https?:/.test(url.origin || url.protocol)) {\n    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n  }\n\n  if (!(url instanceof URL)) {\n    if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {\n      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')\n    }\n\n    if (url.path != null && typeof url.path !== 'string') {\n      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')\n    }\n\n    if (url.pathname != null && typeof url.pathname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')\n    }\n\n    if (url.hostname != null && typeof url.hostname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')\n    }\n\n    if (url.origin != null && typeof url.origin !== 'string') {\n      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')\n    }\n\n    const port = url.port != null\n      ? url.port\n      : (url.protocol === 'https:' ? 443 : 80)\n    let origin = url.origin != null\n      ? url.origin\n      : `${url.protocol}//${url.hostname}:${port}`\n    let path = url.path != null\n      ? url.path\n      : `${url.pathname || ''}${url.search || ''}`\n\n    if (origin.endsWith('/')) {\n      origin = origin.substring(0, origin.length - 1)\n    }\n\n    if (path && !path.startsWith('/')) {\n      path = `/${path}`\n    }\n    // new URL(path, origin) is unsafe when `path` contains an absolute URL\n    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n    // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n    // If first parameter is an absolute URL, a given second param will be ignored.\n    url = new URL(origin + path)\n  }\n\n  return url\n}\n\nfunction parseOrigin (url) {\n  url = parseURL(url)\n\n  if (url.pathname !== '/' || url.search || url.hash) {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  return url\n}\n\nfunction getHostname (host) {\n  if (host[0] === '[') {\n    const idx = host.indexOf(']')\n\n    assert(idx !== -1)\n    return host.substr(1, idx - 1)\n  }\n\n  const idx = host.indexOf(':')\n  if (idx === -1) return host\n\n  return host.substr(0, idx)\n}\n\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName (host) {\n  if (!host) {\n    return null\n  }\n\n  assert.strictEqual(typeof host, 'string')\n\n  const servername = getHostname(host)\n  if (net.isIP(servername)) {\n    return ''\n  }\n\n  return servername\n}\n\nfunction deepClone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\nfunction isAsyncIterable (obj) {\n  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')\n}\n\nfunction isIterable (obj) {\n  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))\n}\n\nfunction bodyLength (body) {\n  if (body == null) {\n    return 0\n  } else if (isStream(body)) {\n    const state = body._readableState\n    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)\n      ? state.length\n      : null\n  } else if (isBlobLike(body)) {\n    return body.size != null ? body.size : null\n  } else if (isBuffer(body)) {\n    return body.byteLength\n  }\n\n  return null\n}\n\nfunction isDestroyed (stream) {\n  return !stream || !!(stream.destroyed || stream[kDestroyed])\n}\n\nfunction isReadableAborted (stream) {\n  const state = stream && stream._readableState\n  return isDestroyed(stream) && state && !state.endEmitted\n}\n\nfunction destroy (stream, err) {\n  if (!isStream(stream) || isDestroyed(stream)) {\n    return\n  }\n\n  if (typeof stream.destroy === 'function') {\n    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n      // See: https://github.com/nodejs/node/pull/38505/files\n      stream.socket = null\n    }\n\n    stream.destroy(err)\n  } else if (err) {\n    process.nextTick((stream, err) => {\n      stream.emit('error', err)\n    }, stream, err)\n  }\n\n  if (stream.destroyed !== true) {\n    stream[kDestroyed] = true\n  }\n}\n\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/\nfunction parseKeepAliveTimeout (val) {\n  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR)\n  return m ? parseInt(m[1], 10) * 1000 : null\n}\n\nfunction parseHeaders (headers, obj = {}) {\n  // For H2 support\n  if (!Array.isArray(headers)) return headers\n\n  for (let i = 0; i < headers.length; i += 2) {\n    const key = headers[i].toString().toLowerCase()\n    let val = obj[key]\n\n    if (!val) {\n      if (Array.isArray(headers[i + 1])) {\n        obj[key] = headers[i + 1]\n      } else {\n        obj[key] = headers[i + 1].toString('utf8')\n      }\n    } else {\n      if (!Array.isArray(val)) {\n        val = [val]\n        obj[key] = val\n      }\n      val.push(headers[i + 1].toString('utf8'))\n    }\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if ('content-length' in obj && 'content-disposition' in obj) {\n    obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1')\n  }\n\n  return obj\n}\n\nfunction parseRawHeaders (headers) {\n  const ret = []\n  let hasContentLength = false\n  let contentDispositionIdx = -1\n\n  for (let n = 0; n < headers.length; n += 2) {\n    const key = headers[n + 0].toString()\n    const val = headers[n + 1].toString('utf8')\n\n    if (key.length === 14 && (key === 'content-length' || key.toLowerCase() === 'content-length')) {\n      ret.push(key, val)\n      hasContentLength = true\n    } else if (key.length === 19 && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {\n      contentDispositionIdx = ret.push(key, val) - 1\n    } else {\n      ret.push(key, val)\n    }\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if (hasContentLength && contentDispositionIdx !== -1) {\n    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1')\n  }\n\n  return ret\n}\n\nfunction isBuffer (buffer) {\n  // See, https://github.com/mcollina/undici/pull/319\n  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)\n}\n\nfunction validateHandler (handler, method, upgrade) {\n  if (!handler || typeof handler !== 'object') {\n    throw new InvalidArgumentError('handler must be an object')\n  }\n\n  if (typeof handler.onConnect !== 'function') {\n    throw new InvalidArgumentError('invalid onConnect method')\n  }\n\n  if (typeof handler.onError !== 'function') {\n    throw new InvalidArgumentError('invalid onError method')\n  }\n\n  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {\n    throw new InvalidArgumentError('invalid onBodySent method')\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    if (typeof handler.onUpgrade !== 'function') {\n      throw new InvalidArgumentError('invalid onUpgrade method')\n    }\n  } else {\n    if (typeof handler.onHeaders !== 'function') {\n      throw new InvalidArgumentError('invalid onHeaders method')\n    }\n\n    if (typeof handler.onData !== 'function') {\n      throw new InvalidArgumentError('invalid onData method')\n    }\n\n    if (typeof handler.onComplete !== 'function') {\n      throw new InvalidArgumentError('invalid onComplete method')\n    }\n  }\n}\n\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed (body) {\n  return !!(body && (\n    stream.isDisturbed\n      ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?\n      : body[kBodyUsed] ||\n        body.readableDidRead ||\n        (body._readableState && body._readableState.dataEmitted) ||\n        isReadableAborted(body)\n  ))\n}\n\nfunction isErrored (body) {\n  return !!(body && (\n    stream.isErrored\n      ? stream.isErrored(body)\n      : /state: 'errored'/.test(nodeUtil.inspect(body)\n      )))\n}\n\nfunction isReadable (body) {\n  return !!(body && (\n    stream.isReadable\n      ? stream.isReadable(body)\n      : /state: 'readable'/.test(nodeUtil.inspect(body)\n      )))\n}\n\nfunction getSocketInfo (socket) {\n  return {\n    localAddress: socket.localAddress,\n    localPort: socket.localPort,\n    remoteAddress: socket.remoteAddress,\n    remotePort: socket.remotePort,\n    remoteFamily: socket.remoteFamily,\n    timeout: socket.timeout,\n    bytesWritten: socket.bytesWritten,\n    bytesRead: socket.bytesRead\n  }\n}\n\nasync function * convertIterableToBuffer (iterable) {\n  for await (const chunk of iterable) {\n    yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)\n  }\n}\n\nlet ReadableStream\nfunction ReadableStreamFrom (iterable) {\n  if (!ReadableStream) {\n    ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n  }\n\n  if (ReadableStream.from) {\n    return ReadableStream.from(convertIterableToBuffer(iterable))\n  }\n\n  let iterator\n  return new ReadableStream(\n    {\n      async start () {\n        iterator = iterable[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { done, value } = await iterator.next()\n        if (done) {\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)\n          controller.enqueue(new Uint8Array(buf))\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    },\n    0\n  )\n}\n\n// The chunk should be a FormData instance and contains\n// all the required methods.\nfunction isFormDataLike (object) {\n  return (\n    object &&\n    typeof object === 'object' &&\n    typeof object.append === 'function' &&\n    typeof object.delete === 'function' &&\n    typeof object.get === 'function' &&\n    typeof object.getAll === 'function' &&\n    typeof object.has === 'function' &&\n    typeof object.set === 'function' &&\n    object[Symbol.toStringTag] === 'FormData'\n  )\n}\n\nfunction throwIfAborted (signal) {\n  if (!signal) { return }\n  if (typeof signal.throwIfAborted === 'function') {\n    signal.throwIfAborted()\n  } else {\n    if (signal.aborted) {\n      // DOMException not available < v17.0.0\n      const err = new Error('The operation was aborted')\n      err.name = 'AbortError'\n      throw err\n    }\n  }\n}\n\nlet events\nfunction addAbortListener (signal, listener) {\n  if (typeof Symbol.dispose === 'symbol') {\n    if (!events) {\n      events = __webpack_require__(/*! events */ \"events\")\n    }\n    if (typeof events.addAbortListener === 'function' && 'aborted' in signal) {\n      return events.addAbortListener(signal, listener)\n    }\n  }\n  if ('addEventListener' in signal) {\n    signal.addEventListener('abort', listener, { once: true })\n    return () => signal.removeEventListener('abort', listener)\n  }\n  signal.addListener('abort', listener)\n  return () => signal.removeListener('abort', listener)\n}\n\nconst hasToWellFormed = !!String.prototype.toWellFormed\n\n/**\n * @param {string} val\n */\nfunction toUSVString (val) {\n  if (hasToWellFormed) {\n    return `${val}`.toWellFormed()\n  } else if (nodeUtil.toUSVString) {\n    return nodeUtil.toUSVString(val)\n  }\n\n  return `${val}`\n}\n\nconst kEnumerableProperty = Object.create(null)\nkEnumerableProperty.enumerable = true\n\nmodule.exports = {\n  kEnumerableProperty,\n  nop,\n  isDisturbed,\n  isErrored,\n  isReadable,\n  toUSVString,\n  isReadableAborted,\n  isBlobLike,\n  parseOrigin,\n  parseURL,\n  getServerName,\n  isStream,\n  isIterable,\n  isAsyncIterable,\n  isDestroyed,\n  parseRawHeaders,\n  parseHeaders,\n  parseKeepAliveTimeout,\n  destroy,\n  bodyLength,\n  deepClone,\n  ReadableStreamFrom,\n  isBuffer,\n  validateHandler,\n  getSocketInfo,\n  isFormDataLike,\n  buildURL,\n  throwIfAborted,\n  addAbortListener,\n  nodeMajor,\n  nodeMinor,\n  nodeHasAutoSelectFamily: nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 13)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQyxrRUFBVztBQUNyRCxRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDMUMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsZ0VBQVU7QUFDbkQsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxrQkFBTTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGdDQUFhOztBQUUzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWEsSUFBSSxhQUFhLEdBQUcsS0FBSztBQUNqRDtBQUNBO0FBQ0EsV0FBVyxtQkFBbUIsRUFBRSxpQkFBaUI7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFvQztBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLElBQUk7QUFDSjtBQUNBOztBQUVBLFlBQVksSUFBSTtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS91dGlsLmpzP2E3Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGtEZXN0cm95ZWQsIGtCb2R5VXNlZCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgSW5jb21pbmdNZXNzYWdlIH0gPSByZXF1aXJlKCdodHRwJylcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuY29uc3QgeyBCbG9iIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3Qgbm9kZVV0aWwgPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG5cbmNvbnN0IFtub2RlTWFqb3IsIG5vZGVNaW5vcl0gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKS5tYXAodiA9PiBOdW1iZXIodikpXG5cbmZ1bmN0aW9uIG5vcCAoKSB7fVxuXG5mdW5jdGlvbiBpc1N0cmVhbSAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbidcbn1cblxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvZmV0Y2gtYmxvYi9ibG9iLzhhYjU4N2QzNDA4MGRlOTQxNDBiNTRmMDcxNjg0NTFlN2QwYjY1NWUvaW5kZXguanMjTDIyOS1MMjQxIChNSVQgTGljZW5zZSlcbmZ1bmN0aW9uIGlzQmxvYkxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKEJsb2IgJiYgb2JqZWN0IGluc3RhbmNlb2YgQmxvYikgfHwgKFxuICAgIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgKHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nKSAmJlxuICAgIC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddKVxuICApXG59XG5cbmZ1bmN0aW9uIGJ1aWxkVVJMICh1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gIGlmICh1cmwuaW5jbHVkZXMoJz8nKSB8fCB1cmwuaW5jbHVkZXMoJyMnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkgcGFyYW1zIGNhbm5vdCBiZSBwYXNzZWQgd2hlbiB1cmwgYWxyZWFkeSBjb250YWlucyBcIj9cIiBvciBcIiNcIi4nKVxuICB9XG5cbiAgY29uc3Qgc3RyaW5naWZpZWQgPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMpXG5cbiAgaWYgKHN0cmluZ2lmaWVkKSB7XG4gICAgdXJsICs9ICc/JyArIHN0cmluZ2lmaWVkXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIHBhcnNlVVJMICh1cmwpIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG5cbiAgICBpZiAoIS9eaHR0cHM/Oi8udGVzdCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcHJvdG9jb2w6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJylcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsXG4gIH1cblxuICBpZiAoIXVybCB8fCB0eXBlb2YgdXJsICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkw6IFRoZSBVUkwgYXJndW1lbnQgbXVzdCBiZSBhIG5vbi1udWxsIG9iamVjdC4nKVxuICB9XG5cbiAgaWYgKCEvXmh0dHBzPzovLnRlc3QodXJsLm9yaWdpbiB8fCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICB9XG5cbiAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIGlmICh1cmwucG9ydCAhPSBudWxsICYmIHVybC5wb3J0ICE9PSAnJyAmJiAhTnVtYmVyLmlzRmluaXRlKHBhcnNlSW50KHVybC5wb3J0KSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkw6IHBvcnQgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aCAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcGF0aDogdGhlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLnBhdGhuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwYXRobmFtZTogdGhlIHBhdGhuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLmhvc3RuYW1lICE9IG51bGwgJiYgdHlwZW9mIHVybC5ob3N0bmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgaG9zdG5hbWU6IHRoZSBob3N0bmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5vcmlnaW4gIT0gbnVsbCAmJiB0eXBlb2YgdXJsLm9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgb3JpZ2luOiB0aGUgb3JpZ2luIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQgIT0gbnVsbFxuICAgICAgPyB1cmwucG9ydFxuICAgICAgOiAodXJsLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwKVxuICAgIGxldCBvcmlnaW4gPSB1cmwub3JpZ2luICE9IG51bGxcbiAgICAgID8gdXJsLm9yaWdpblxuICAgICAgOiBgJHt1cmwucHJvdG9jb2x9Ly8ke3VybC5ob3N0bmFtZX06JHtwb3J0fWBcbiAgICBsZXQgcGF0aCA9IHVybC5wYXRoICE9IG51bGxcbiAgICAgID8gdXJsLnBhdGhcbiAgICAgIDogYCR7dXJsLnBhdGhuYW1lIHx8ICcnfSR7dXJsLnNlYXJjaCB8fCAnJ31gXG5cbiAgICBpZiAob3JpZ2luLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgIG9yaWdpbiA9IG9yaWdpbi5zdWJzdHJpbmcoMCwgb3JpZ2luLmxlbmd0aCAtIDEpXG4gICAgfVxuXG4gICAgaWYgKHBhdGggJiYgIXBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICBwYXRoID0gYC8ke3BhdGh9YFxuICAgIH1cbiAgICAvLyBuZXcgVVJMKHBhdGgsIG9yaWdpbikgaXMgdW5zYWZlIHdoZW4gYHBhdGhgIGNvbnRhaW5zIGFuIGFic29sdXRlIFVSTFxuICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9VUkw6XG4gICAgLy8gSWYgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmVsYXRpdmUgVVJMLCBzZWNvbmQgcGFyYW0gaXMgcmVxdWlyZWQsIGFuZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGJhc2UgVVJMLlxuICAgIC8vIElmIGZpcnN0IHBhcmFtZXRlciBpcyBhbiBhYnNvbHV0ZSBVUkwsIGEgZ2l2ZW4gc2Vjb25kIHBhcmFtIHdpbGwgYmUgaWdub3JlZC5cbiAgICB1cmwgPSBuZXcgVVJMKG9yaWdpbiArIHBhdGgpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIHBhcnNlT3JpZ2luICh1cmwpIHtcbiAgdXJsID0gcGFyc2VVUkwodXJsKVxuXG4gIGlmICh1cmwucGF0aG5hbWUgIT09ICcvJyB8fCB1cmwuc2VhcmNoIHx8IHVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVybCcpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGdldEhvc3RuYW1lIChob3N0KSB7XG4gIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICBjb25zdCBpZHggPSBob3N0LmluZGV4T2YoJ10nKVxuXG4gICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG4gICAgcmV0dXJuIGhvc3Quc3Vic3RyKDEsIGlkeCAtIDEpXG4gIH1cblxuICBjb25zdCBpZHggPSBob3N0LmluZGV4T2YoJzonKVxuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIGhvc3RcblxuICByZXR1cm4gaG9zdC5zdWJzdHIoMCwgaWR4KVxufVxuXG4vLyBJUCBhZGRyZXNzZXMgYXJlIG5vdCB2YWxpZCBzZXJ2ZXIgbmFtZXMgcGVyIFJGQzYwNjZcbi8vID4gQ3VycmVudGx5LCB0aGUgb25seSBzZXJ2ZXIgbmFtZXMgc3VwcG9ydGVkIGFyZSBETlMgaG9zdG5hbWVzXG5mdW5jdGlvbiBnZXRTZXJ2ZXJOYW1lIChob3N0KSB7XG4gIGlmICghaG9zdCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGhvc3QsICdzdHJpbmcnKVxuXG4gIGNvbnN0IHNlcnZlcm5hbWUgPSBnZXRIb3N0bmFtZShob3N0KVxuICBpZiAobmV0LmlzSVAoc2VydmVybmFtZSkpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHJldHVybiBzZXJ2ZXJuYW1lXG59XG5cbmZ1bmN0aW9uIGRlZXBDbG9uZSAob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJylcbn1cblxuZnVuY3Rpb24gaXNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiAodHlwZW9mIG9ialtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSlcbn1cblxuZnVuY3Rpb24gYm9keUxlbmd0aCAoYm9keSkge1xuICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDBcbiAgfSBlbHNlIGlmIChpc1N0cmVhbShib2R5KSkge1xuICAgIGNvbnN0IHN0YXRlID0gYm9keS5fcmVhZGFibGVTdGF0ZVxuICAgIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5vYmplY3RNb2RlID09PSBmYWxzZSAmJiBzdGF0ZS5lbmRlZCA9PT0gdHJ1ZSAmJiBOdW1iZXIuaXNGaW5pdGUoc3RhdGUubGVuZ3RoKVxuICAgICAgPyBzdGF0ZS5sZW5ndGhcbiAgICAgIDogbnVsbFxuICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5zaXplICE9IG51bGwgPyBib2R5LnNpemUgOiBudWxsXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0Rlc3Ryb3llZCAoc3RyZWFtKSB7XG4gIHJldHVybiAhc3RyZWFtIHx8ICEhKHN0cmVhbS5kZXN0cm95ZWQgfHwgc3RyZWFtW2tEZXN0cm95ZWRdKVxufVxuXG5mdW5jdGlvbiBpc1JlYWRhYmxlQWJvcnRlZCAoc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICByZXR1cm4gaXNEZXN0cm95ZWQoc3RyZWFtKSAmJiBzdGF0ZSAmJiAhc3RhdGUuZW5kRW1pdHRlZFxufVxuXG5mdW5jdGlvbiBkZXN0cm95IChzdHJlYW0sIGVycikge1xuICBpZiAoIWlzU3RyZWFtKHN0cmVhbSkgfHwgaXNEZXN0cm95ZWQoc3RyZWFtKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RyZWFtKS5jb25zdHJ1Y3RvciA9PT0gSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM4NTA1L2ZpbGVzXG4gICAgICBzdHJlYW0uc29ja2V0ID0gbnVsbFxuICAgIH1cblxuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKChzdHJlYW0sIGVycikgPT4ge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH0sIHN0cmVhbSwgZXJyKVxuICB9XG5cbiAgaWYgKHN0cmVhbS5kZXN0cm95ZWQgIT09IHRydWUpIHtcbiAgICBzdHJlYW1ba0Rlc3Ryb3llZF0gPSB0cnVlXG4gIH1cbn1cblxuY29uc3QgS0VFUEFMSVZFX1RJTUVPVVRfRVhQUiA9IC90aW1lb3V0PShcXGQrKS9cbmZ1bmN0aW9uIHBhcnNlS2VlcEFsaXZlVGltZW91dCAodmFsKSB7XG4gIGNvbnN0IG0gPSB2YWwudG9TdHJpbmcoKS5tYXRjaChLRUVQQUxJVkVfVElNRU9VVF9FWFBSKVxuICByZXR1cm4gbSA/IHBhcnNlSW50KG1bMV0sIDEwKSAqIDEwMDAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyAoaGVhZGVycywgb2JqID0ge30pIHtcbiAgLy8gRm9yIEgyIHN1cHBvcnRcbiAgaWYgKCFBcnJheS5pc0FycmF5KGhlYWRlcnMpKSByZXR1cm4gaGVhZGVyc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGtleSA9IGhlYWRlcnNbaV0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpXG4gICAgbGV0IHZhbCA9IG9ialtrZXldXG5cbiAgICBpZiAoIXZhbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyc1tpICsgMV0pKSB7XG4gICAgICAgIG9ialtrZXldID0gaGVhZGVyc1tpICsgMV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gaGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWwgPSBbdmFsXVxuICAgICAgICBvYmpba2V5XSA9IHZhbFxuICAgICAgfVxuICAgICAgdmFsLnB1c2goaGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICB9XG4gIH1cblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDY1MjhcbiAgaWYgKCdjb250ZW50LWxlbmd0aCcgaW4gb2JqICYmICdjb250ZW50LWRpc3Bvc2l0aW9uJyBpbiBvYmopIHtcbiAgICBvYmpbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSA9IEJ1ZmZlci5mcm9tKG9ialsnY29udGVudC1kaXNwb3NpdGlvbiddKS50b1N0cmluZygnbGF0aW4xJylcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gcGFyc2VSYXdIZWFkZXJzIChoZWFkZXJzKSB7XG4gIGNvbnN0IHJldCA9IFtdXG4gIGxldCBoYXNDb250ZW50TGVuZ3RoID0gZmFsc2VcbiAgbGV0IGNvbnRlbnREaXNwb3NpdGlvbklkeCA9IC0xXG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gaGVhZGVyc1tuICsgMF0udG9TdHJpbmcoKVxuICAgIGNvbnN0IHZhbCA9IGhlYWRlcnNbbiArIDFdLnRvU3RyaW5nKCd1dGY4JylcblxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxNCAmJiAoa2V5ID09PSAnY29udGVudC1sZW5ndGgnIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1sZW5ndGgnKSkge1xuICAgICAgcmV0LnB1c2goa2V5LCB2YWwpXG4gICAgICBoYXNDb250ZW50TGVuZ3RoID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTkgJiYgKGtleSA9PT0gJ2NvbnRlbnQtZGlzcG9zaXRpb24nIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1kaXNwb3NpdGlvbicpKSB7XG4gICAgICBjb250ZW50RGlzcG9zaXRpb25JZHggPSByZXQucHVzaChrZXksIHZhbCkgLSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKGtleSwgdmFsKVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NjUyOFxuICBpZiAoaGFzQ29udGVudExlbmd0aCAmJiBjb250ZW50RGlzcG9zaXRpb25JZHggIT09IC0xKSB7XG4gICAgcmV0W2NvbnRlbnREaXNwb3NpdGlvbklkeF0gPSBCdWZmZXIuZnJvbShyZXRbY29udGVudERpc3Bvc2l0aW9uSWR4XSkudG9TdHJpbmcoJ2xhdGluMScpXG4gIH1cblxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChidWZmZXIpIHtcbiAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbWNvbGxpbmEvdW5kaWNpL3B1bGwvMzE5XG4gIHJldHVybiBidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSGFuZGxlciAoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKSB7XG4gIGlmICghaGFuZGxlciB8fCB0eXBlb2YgaGFuZGxlciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkNvbm5lY3QgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkJvZHlTZW50ICE9PSAnZnVuY3Rpb24nICYmIGhhbmRsZXIub25Cb2R5U2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQm9keVNlbnQgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uVXBncmFkZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uVXBncmFkZSBtZXRob2QnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25IZWFkZXJzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25IZWFkZXJzIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRGF0YSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRGF0YSBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbXBsZXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Db21wbGV0ZSBtZXRob2QnKVxuICAgIH1cbiAgfVxufVxuXG4vLyBBIGJvZHkgaXMgZGlzdHVyYmVkIGlmIGl0IGhhcyBiZWVuIHJlYWQgZnJvbSBhbmQgaXQgY2Fubm90XG4vLyBiZSByZS11c2VkIHdpdGhvdXQgbG9zaW5nIHN0YXRlIG9yIGRhdGEuXG5mdW5jdGlvbiBpc0Rpc3R1cmJlZCAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiAoXG4gICAgc3RyZWFtLmlzRGlzdHVyYmVkXG4gICAgICA/IHN0cmVhbS5pc0Rpc3R1cmJlZChib2R5KSB8fCBib2R5W2tCb2R5VXNlZF0gLy8gVE9ETyAoZml4KTogV2h5IGlzIGJvZHlba0JvZHlVc2VkXSBuZWVkZWQ/XG4gICAgICA6IGJvZHlba0JvZHlVc2VkXSB8fFxuICAgICAgICBib2R5LnJlYWRhYmxlRGlkUmVhZCB8fFxuICAgICAgICAoYm9keS5fcmVhZGFibGVTdGF0ZSAmJiBib2R5Ll9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkKSB8fFxuICAgICAgICBpc1JlYWRhYmxlQWJvcnRlZChib2R5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yZWQgKGJvZHkpIHtcbiAgcmV0dXJuICEhKGJvZHkgJiYgKFxuICAgIHN0cmVhbS5pc0Vycm9yZWRcbiAgICAgID8gc3RyZWFtLmlzRXJyb3JlZChib2R5KVxuICAgICAgOiAvc3RhdGU6ICdlcnJvcmVkJy8udGVzdChub2RlVXRpbC5pbnNwZWN0KGJvZHkpXG4gICAgICApKSlcbn1cblxuZnVuY3Rpb24gaXNSZWFkYWJsZSAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiAoXG4gICAgc3RyZWFtLmlzUmVhZGFibGVcbiAgICAgID8gc3RyZWFtLmlzUmVhZGFibGUoYm9keSlcbiAgICAgIDogL3N0YXRlOiAncmVhZGFibGUnLy50ZXN0KG5vZGVVdGlsLmluc3BlY3QoYm9keSlcbiAgICAgICkpKVxufVxuXG5mdW5jdGlvbiBnZXRTb2NrZXRJbmZvIChzb2NrZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2NhbEFkZHJlc3M6IHNvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgbG9jYWxQb3J0OiBzb2NrZXQubG9jYWxQb3J0LFxuICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgIHJlbW90ZVBvcnQ6IHNvY2tldC5yZW1vdGVQb3J0LFxuICAgIHJlbW90ZUZhbWlseTogc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICB0aW1lb3V0OiBzb2NrZXQudGltZW91dCxcbiAgICBieXRlc1dyaXR0ZW46IHNvY2tldC5ieXRlc1dyaXR0ZW4sXG4gICAgYnl0ZXNSZWFkOiBzb2NrZXQuYnl0ZXNSZWFkXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gKiBjb252ZXJ0SXRlcmFibGVUb0J1ZmZlciAoaXRlcmFibGUpIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYWJsZSkge1xuICAgIHlpZWxkIEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgPyBjaHVuayA6IEJ1ZmZlci5mcm9tKGNodW5rKVxuICB9XG59XG5cbmxldCBSZWFkYWJsZVN0cmVhbVxuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tIChpdGVyYWJsZSkge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW1cbiAgfVxuXG4gIGlmIChSZWFkYWJsZVN0cmVhbS5mcm9tKSB7XG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtLmZyb20oY29udmVydEl0ZXJhYmxlVG9CdWZmZXIoaXRlcmFibGUpKVxuICB9XG5cbiAgbGV0IGl0ZXJhdG9yXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgYXN5bmMgc3RhcnQgKCkge1xuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KClcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgPyB2YWx1ZSA6IEJ1ZmZlci5mcm9tKHZhbHVlKVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmRlc2lyZWRTaXplID4gMFxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAocmVhc29uKSB7XG4gICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpXG4gICAgICB9XG4gICAgfSxcbiAgICAwXG4gIClcbn1cblxuLy8gVGhlIGNodW5rIHNob3VsZCBiZSBhIEZvcm1EYXRhIGluc3RhbmNlIGFuZCBjb250YWluc1xuLy8gYWxsIHRoZSByZXF1aXJlZCBtZXRob2RzLlxuZnVuY3Rpb24gaXNGb3JtRGF0YUxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5hcHBlbmQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZ2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3Quc2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YSdcbiAgKVxufVxuXG5mdW5jdGlvbiB0aHJvd0lmQWJvcnRlZCAoc2lnbmFsKSB7XG4gIGlmICghc2lnbmFsKSB7IHJldHVybiB9XG4gIGlmICh0eXBlb2Ygc2lnbmFsLnRocm93SWZBYm9ydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2lnbmFsLnRocm93SWZBYm9ydGVkKClcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIC8vIERPTUV4Y2VwdGlvbiBub3QgYXZhaWxhYmxlIDwgdjE3LjAuMFxuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkJylcbiAgICAgIGVyci5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxubGV0IGV2ZW50c1xuZnVuY3Rpb24gYWRkQWJvcnRMaXN0ZW5lciAoc2lnbmFsLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIFN5bWJvbC5kaXNwb3NlID09PSAnc3ltYm9sJykge1xuICAgIGlmICghZXZlbnRzKSB7XG4gICAgICBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGV2ZW50cy5hZGRBYm9ydExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmICdhYm9ydGVkJyBpbiBzaWduYWwpIHtcbiAgICAgIHJldHVybiBldmVudHMuYWRkQWJvcnRMaXN0ZW5lcihzaWduYWwsIGxpc3RlbmVyKVxuICAgIH1cbiAgfVxuICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHNpZ25hbCkge1xuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSlcbiAgICByZXR1cm4gKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG4gIH1cbiAgc2lnbmFsLmFkZExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxuICByZXR1cm4gKCkgPT4gc2lnbmFsLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxufVxuXG5jb25zdCBoYXNUb1dlbGxGb3JtZWQgPSAhIVN0cmluZy5wcm90b3R5cGUudG9XZWxsRm9ybWVkXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICovXG5mdW5jdGlvbiB0b1VTVlN0cmluZyAodmFsKSB7XG4gIGlmIChoYXNUb1dlbGxGb3JtZWQpIHtcbiAgICByZXR1cm4gYCR7dmFsfWAudG9XZWxsRm9ybWVkKClcbiAgfSBlbHNlIGlmIChub2RlVXRpbC50b1VTVlN0cmluZykge1xuICAgIHJldHVybiBub2RlVXRpbC50b1VTVlN0cmluZyh2YWwpXG4gIH1cblxuICByZXR1cm4gYCR7dmFsfWBcbn1cblxuY29uc3Qga0VudW1lcmFibGVQcm9wZXJ0eSA9IE9iamVjdC5jcmVhdGUobnVsbClcbmtFbnVtZXJhYmxlUHJvcGVydHkuZW51bWVyYWJsZSA9IHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG5vcCxcbiAgaXNEaXN0dXJiZWQsXG4gIGlzRXJyb3JlZCxcbiAgaXNSZWFkYWJsZSxcbiAgdG9VU1ZTdHJpbmcsXG4gIGlzUmVhZGFibGVBYm9ydGVkLFxuICBpc0Jsb2JMaWtlLFxuICBwYXJzZU9yaWdpbixcbiAgcGFyc2VVUkwsXG4gIGdldFNlcnZlck5hbWUsXG4gIGlzU3RyZWFtLFxuICBpc0l0ZXJhYmxlLFxuICBpc0FzeW5jSXRlcmFibGUsXG4gIGlzRGVzdHJveWVkLFxuICBwYXJzZVJhd0hlYWRlcnMsXG4gIHBhcnNlSGVhZGVycyxcbiAgcGFyc2VLZWVwQWxpdmVUaW1lb3V0LFxuICBkZXN0cm95LFxuICBib2R5TGVuZ3RoLFxuICBkZWVwQ2xvbmUsXG4gIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgaXNCdWZmZXIsXG4gIHZhbGlkYXRlSGFuZGxlcixcbiAgZ2V0U29ja2V0SW5mbyxcbiAgaXNGb3JtRGF0YUxpa2UsXG4gIGJ1aWxkVVJMLFxuICB0aHJvd0lmQWJvcnRlZCxcbiAgYWRkQWJvcnRMaXN0ZW5lcixcbiAgbm9kZU1ham9yLFxuICBub2RlTWlub3IsXG4gIG5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5OiBub2RlTWFqb3IgPiAxOCB8fCAobm9kZU1ham9yID09PSAxOCAmJiBub2RlTWlub3IgPj0gMTMpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher-base.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher-base.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher.js\")\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { kDestroy, kClose, kDispatch, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\n\nconst kDestroyed = Symbol('destroyed')\nconst kClosed = Symbol('closed')\nconst kOnDestroyed = Symbol('onDestroyed')\nconst kOnClosed = Symbol('onClosed')\nconst kInterceptedDispatch = Symbol('Intercepted Dispatch')\n\nclass DispatcherBase extends Dispatcher {\n  constructor () {\n    super()\n\n    this[kDestroyed] = false\n    this[kOnDestroyed] = null\n    this[kClosed] = false\n    this[kOnClosed] = []\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get interceptors () {\n    return this[kInterceptors]\n  }\n\n  set interceptors (newInterceptors) {\n    if (newInterceptors) {\n      for (let i = newInterceptors.length - 1; i >= 0; i--) {\n        const interceptor = this[kInterceptors][i]\n        if (typeof interceptor !== 'function') {\n          throw new InvalidArgumentError('interceptor must be an function')\n        }\n      }\n    }\n\n    this[kInterceptors] = newInterceptors\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null))\n      return\n    }\n\n    if (this[kClosed]) {\n      if (this[kOnClosed]) {\n        this[kOnClosed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    this[kClosed] = true\n    this[kOnClosed].push(callback)\n\n    const onClosed = () => {\n      const callbacks = this[kOnClosed]\n      this[kOnClosed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kClose]()\n      .then(() => this.destroy())\n      .then(() => {\n        queueMicrotask(onClosed)\n      })\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    this[kDestroyed] = true\n    this[kOnDestroyed] = this[kOnDestroyed] || []\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kDestroy](err).then(() => {\n      queueMicrotask(onDestroyed)\n    })\n  }\n\n  [kInterceptedDispatch] (opts, handler) {\n    if (!this[kInterceptors] || this[kInterceptors].length === 0) {\n      this[kInterceptedDispatch] = this[kDispatch]\n      return this[kDispatch](opts, handler)\n    }\n\n    let dispatch = this[kDispatch].bind(this)\n    for (let i = this[kInterceptors].length - 1; i >= 0; i--) {\n      dispatch = this[kInterceptors][i](dispatch)\n    }\n    this[kInterceptedDispatch] = dispatch\n    return dispatch(opts, handler)\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed] || this[kOnDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      return this[kInterceptedDispatch](opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n\n      return false\n    }\n  }\n}\n\nmodule.exports = DispatcherBase\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLWJhc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosbUJBQW1CLG1CQUFPLENBQUMsbUVBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxxRUFBZTtBQUMzQixRQUFRLDZDQUE2QyxFQUFFLG1CQUFPLENBQUMsdUVBQWdCOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci1iYXNlLmpzPzhjZGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXInKVxuY29uc3Qge1xuICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IGtEZXN0cm95LCBrQ2xvc2UsIGtEaXNwYXRjaCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuXG5jb25zdCBrRGVzdHJveWVkID0gU3ltYm9sKCdkZXN0cm95ZWQnKVxuY29uc3Qga0Nsb3NlZCA9IFN5bWJvbCgnY2xvc2VkJylcbmNvbnN0IGtPbkRlc3Ryb3llZCA9IFN5bWJvbCgnb25EZXN0cm95ZWQnKVxuY29uc3Qga09uQ2xvc2VkID0gU3ltYm9sKCdvbkNsb3NlZCcpXG5jb25zdCBrSW50ZXJjZXB0ZWREaXNwYXRjaCA9IFN5bWJvbCgnSW50ZXJjZXB0ZWQgRGlzcGF0Y2gnKVxuXG5jbGFzcyBEaXNwYXRjaGVyQmFzZSBleHRlbmRzIERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trRGVzdHJveWVkXSA9IGZhbHNlXG4gICAgdGhpc1trT25EZXN0cm95ZWRdID0gbnVsbFxuICAgIHRoaXNba0Nsb3NlZF0gPSBmYWxzZVxuICAgIHRoaXNba09uQ2xvc2VkXSA9IFtdXG4gIH1cblxuICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trRGVzdHJveWVkXVxuICB9XG5cbiAgZ2V0IGNsb3NlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Nsb3NlZF1cbiAgfVxuXG4gIGdldCBpbnRlcmNlcHRvcnMgKCkge1xuICAgIHJldHVybiB0aGlzW2tJbnRlcmNlcHRvcnNdXG4gIH1cblxuICBzZXQgaW50ZXJjZXB0b3JzIChuZXdJbnRlcmNlcHRvcnMpIHtcbiAgICBpZiAobmV3SW50ZXJjZXB0b3JzKSB7XG4gICAgICBmb3IgKGxldCBpID0gbmV3SW50ZXJjZXB0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yID0gdGhpc1trSW50ZXJjZXB0b3JzXVtpXVxuICAgICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnRlcmNlcHRvciBtdXN0IGJlIGFuIGZ1bmN0aW9uJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBuZXdJbnRlcmNlcHRvcnNcbiAgfVxuXG4gIGNsb3NlIChjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpLCBudWxsKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICBpZiAodGhpc1trT25DbG9zZWRdKSB7XG4gICAgICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobnVsbCwgbnVsbCkpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzW2tDbG9zZWRdID0gdHJ1ZVxuICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKVxuXG4gICAgY29uc3Qgb25DbG9zZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzW2tPbkNsb3NlZF1cbiAgICAgIHRoaXNba09uQ2xvc2VkXSA9IG51bGxcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXShudWxsLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3VsZCBub3QgZXJyb3IuXG4gICAgdGhpc1trQ2xvc2VdKClcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuZGVzdHJveSgpKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhvbkNsb3NlZClcbiAgICAgIH0pXG4gIH1cblxuICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZXJyXG4gICAgICBlcnIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZXJyID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciBlcnJvciAqLyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRGVzdHJveWVkXSkge1xuICAgICAgaWYgKHRoaXNba09uRGVzdHJveWVkXSkge1xuICAgICAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGVyciA9IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpc1trRGVzdHJveWVkXSA9IHRydWVcbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSB0aGlzW2tPbkRlc3Ryb3llZF0gfHwgW11cbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjaylcblxuICAgIGNvbnN0IG9uRGVzdHJveWVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpc1trT25EZXN0cm95ZWRdXG4gICAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSBudWxsXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0obnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaG91bGQgbm90IGVycm9yLlxuICAgIHRoaXNba0Rlc3Ryb3ldKGVycikudGhlbigoKSA9PiB7XG4gICAgICBxdWV1ZU1pY3JvdGFzayhvbkRlc3Ryb3llZClcbiAgICB9KVxuICB9XG5cbiAgW2tJbnRlcmNlcHRlZERpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghdGhpc1trSW50ZXJjZXB0b3JzXSB8fCB0aGlzW2tJbnRlcmNlcHRvcnNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpc1trSW50ZXJjZXB0ZWREaXNwYXRjaF0gPSB0aGlzW2tEaXNwYXRjaF1cbiAgICAgIHJldHVybiB0aGlzW2tEaXNwYXRjaF0ob3B0cywgaGFuZGxlcilcbiAgICB9XG5cbiAgICBsZXQgZGlzcGF0Y2ggPSB0aGlzW2tEaXNwYXRjaF0uYmluZCh0aGlzKVxuICAgIGZvciAobGV0IGkgPSB0aGlzW2tJbnRlcmNlcHRvcnNdLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBkaXNwYXRjaCA9IHRoaXNba0ludGVyY2VwdG9yc11baV0oZGlzcGF0Y2gpXG4gICAgfVxuICAgIHRoaXNba0ludGVyY2VwdGVkRGlzcGF0Y2hdID0gZGlzcGF0Y2hcbiAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMgbXVzdCBiZSBhbiBvYmplY3QuJylcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0gfHwgdGhpc1trT25EZXN0cm95ZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnRDbG9zZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW2tJbnRlcmNlcHRlZERpc3BhdGNoXShvcHRzLCBoYW5kbGVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaGFuZGxlci5vbkVycm9yKGVycilcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlckJhc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/dispatcher.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\")\n\nclass Dispatcher extends EventEmitter {\n  dispatch () {\n    throw new Error('not implemented')\n  }\n\n  close () {\n    throw new Error('not implemented')\n  }\n\n  destroy () {\n    throw new Error('not implemented')\n  }\n}\n\nmodule.exports = Dispatcher\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFROztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLmpzPzU1ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpXG5cbmNsYXNzIERpc3BhdGNoZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBkaXNwYXRjaCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/body.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/fetch/body.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Busboy = __webpack_require__(/*! @fastify/busboy */ \"(ssr)/./node_modules/@fastify/busboy/lib/main.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/fetch/formdata.js\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { DOMException, structuredClone } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/fetch/constants.js\")\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { isErrored } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { isUint8Array, isArrayBuffer } = __webpack_require__(/*! util/types */ \"util/types\")\nconst { File: UndiciFile } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/undici/lib/fetch/file.js\")\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\n\nlet ReadableStream = globalThis.ReadableStream\n\n/** @type {globalThis['File']} */\nconst File = NativeFile ?? UndiciFile\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n  }\n\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running objects get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream.\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? new TextEncoder().encode(source) : source\n        )\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: undefined\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with objects entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const enc = new TextEncoder()\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = enc.encode(prefix +\n          `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = enc.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    const chunk = enc.encode(`--${boundary}--`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to objects size.\n    length = object.size\n\n    // If objects type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to sources length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: undefined\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let  out1, out2  be the result of teeing bodys stream.\n  const [out1, out2] = body.stream.tee()\n  const out2Clone = structuredClone(out2, { transfer: [out2] })\n  // This, for whatever reasons, unrefs out2Clone which allows\n  // the process to exit by itself.\n  const [, finalClone] = out2Clone.tee()\n\n  // 2. Set bodys stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: finalClone,\n    length: body.length,\n    source: body.source\n  }\n}\n\nasync function * consumeBody (body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body\n    } else {\n      const stream = body.stream\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.')\n      }\n\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.')\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true\n\n      yield * stream\n    }\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is thiss\n      // MIME type.\n      return specConsumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(this)\n\n        if (mimeType === 'failure') {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return specConsumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return specConsumeBody(this, utf8DecodeBytes, instance)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return specConsumeBody(this, parseJSONFromBytes, instance)\n    },\n\n    async formData () {\n      webidl.brandCheck(this, instance)\n\n      throwIfAborted(this[kState])\n\n      const contentType = this.headers.get('Content-Type')\n\n      // If mimeTypes essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {}\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value\n\n        const responseFormData = new FormData()\n\n        let busboy\n\n        try {\n          busboy = new Busboy({\n            headers,\n            preservePath: true\n          })\n        } catch (err) {\n          throw new DOMException(`${err}`, 'AbortError')\n        }\n\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value)\n        })\n        busboy.on('file', (name, value, filename, encoding, mimeType) => {\n          const chunks = []\n\n          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {\n            let base64chunk = ''\n\n            value.on('data', (chunk) => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '')\n\n              const end = base64chunk.length - base64chunk.length % 4\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'))\n\n              base64chunk = base64chunk.slice(end)\n            })\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'))\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          } else {\n            value.on('data', (chunk) => {\n              chunks.push(chunk)\n            })\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          }\n        })\n\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve)\n          busboy.on('error', (err) => reject(new TypeError(err)))\n        })\n\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk)\n        busboy.end()\n        await busboyResolve\n\n        return responseFormData\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeTypes essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries\n        try {\n          let text = ''\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          const textDecoder = new TextDecoder('utf-8', { ignoreBOM: true })\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk')\n            }\n            text += textDecoder.decode(chunk, { stream: true })\n          }\n          text += textDecoder.decode()\n          entries = new URLSearchParams(text)\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), { cause: err })\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData()\n        for (const [name, value] of entries) {\n          formData.append(name, value)\n        }\n        return formData\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve()\n\n        throwIfAborted(this[kState])\n\n        // Otherwise, throw a TypeError.\n        throw webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        })\n      }\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function specConsumeBody (object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance)\n\n  throwIfAborted(object[kState])\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object[kState].body)) {\n    throw new TypeError('Body is unusable')\n  }\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = (error) => promise.reject(error)\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If objects body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(new Uint8Array())\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read objects body given successSteps,\n  //    errorSteps, and objects relevant global object.\n  await fullyReadBody(object[kState].body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable (body) {\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its bodys stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = new TextDecoder().decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */\nfunction bodyMimeType (object) {\n  const { headersList } = object[kState]\n  const contentType = headersList.get('content-type')\n\n  if (contentType === null) {\n    return 'failure'\n  }\n\n  return parseMIMEType(contentType)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9ib2R5LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNkRBQVE7QUFDcEIsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxxRUFBWTtBQUN6QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLG1FQUFXO0FBQ3RDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsaUVBQVU7QUFDckMsUUFBUSxnQ0FBZ0MsRUFBRSxtQkFBTyxDQUFDLHVFQUFhO0FBQy9ELFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuRCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUM1QyxRQUFRLDhCQUE4QixFQUFFLG1CQUFPLENBQUMsOEJBQVk7QUFDNUQsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLDZEQUFRO0FBQzdDLFFBQVEsb0NBQW9DLEVBQUUsbUJBQU8sQ0FBQyxtRUFBVzs7QUFFakU7O0FBRUEsV0FBVyxvQkFBb0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFvQztBQUN6RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxpQkFBaUI7QUFDakI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVywyREFBMkQ7QUFDdEU7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9ib2R5LmpzPzFlNjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1c2JveSA9IHJlcXVpcmUoJ0BmYXN0aWZ5L2J1c2JveScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHtcbiAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICBpc0Jsb2JMaWtlLFxuICBpc1JlYWRhYmxlU3RyZWFtTGlrZSxcbiAgcmVhZGFibGVTdHJlYW1DbG9zZSxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBmdWxseVJlYWRCb2R5XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgRm9ybURhdGEgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBET01FeGNlcHRpb24sIHN0cnVjdHVyZWRDbG9uZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBCbG9iLCBGaWxlOiBOYXRpdmVGaWxlIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBrQm9keVVzZWQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBpc0Vycm9yZWQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGlzVWludDhBcnJheSwgaXNBcnJheUJ1ZmZlciB9ID0gcmVxdWlyZSgndXRpbC90eXBlcycpXG5jb25zdCB7IEZpbGU6IFVuZGljaUZpbGUgfSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCB7IHBhcnNlTUlNRVR5cGUsIHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhVVJMJylcblxubGV0IFJlYWRhYmxlU3RyZWFtID0gZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbVxuXG4vKiogQHR5cGUge2dsb2JhbFRoaXNbJ0ZpbGUnXX0gKi9cbmNvbnN0IEZpbGUgPSBOYXRpdmVGaWxlID8/IFVuZGljaUZpbGVcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuZnVuY3Rpb24gZXh0cmFjdEJvZHkgKG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtL3dlYicpLlJlYWRhYmxlU3RyZWFtXG4gIH1cblxuICAvLyAxLiBMZXQgc3RyZWFtIGJlIG51bGwuXG4gIGxldCBzdHJlYW0gPSBudWxsXG5cbiAgLy8gMi4gSWYgb2JqZWN0IGlzIGEgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCB0aGVuIHNldCBzdHJlYW0gdG8gb2JqZWN0LlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICBzdHJlYW0gPSBvYmplY3RcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKG9iamVjdCkpIHtcbiAgICAvLyAzLiBPdGhlcndpc2UsIGlmIG9iamVjdCBpcyBhIEJsb2Igb2JqZWN0LCBzZXQgc3RyZWFtIHRvIHRoZVxuICAgIC8vICAgIHJlc3VsdCBvZiBydW5uaW5nIG9iamVjdOKAmXMgZ2V0IHN0cmVhbS5cbiAgICBzdHJlYW0gPSBvYmplY3Quc3RyZWFtKClcbiAgfSBlbHNlIHtcbiAgICAvLyA0LiBPdGhlcndpc2UsIHNldCBzdHJlYW0gdG8gYSBuZXcgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCBhbmQgc2V0XG4gICAgLy8gICAgdXAgc3RyZWFtLlxuICAgIHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzb3VyY2UpIDogc291cmNlXG4gICAgICAgIClcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyKSlcbiAgICAgIH0sXG4gICAgICBzdGFydCAoKSB7fSxcbiAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgIH0pXG4gIH1cblxuICAvLyA1LiBBc3NlcnQ6IHN0cmVhbSBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdC5cbiAgYXNzZXJ0KGlzUmVhZGFibGVTdHJlYW1MaWtlKHN0cmVhbSkpXG5cbiAgLy8gNi4gTGV0IGFjdGlvbiBiZSBudWxsLlxuICBsZXQgYWN0aW9uID0gbnVsbFxuXG4gIC8vIDcuIExldCBzb3VyY2UgYmUgbnVsbC5cbiAgbGV0IHNvdXJjZSA9IG51bGxcblxuICAvLyA4LiBMZXQgbGVuZ3RoIGJlIG51bGwuXG4gIGxldCBsZW5ndGggPSBudWxsXG5cbiAgLy8gOS4gTGV0IHR5cGUgYmUgbnVsbC5cbiAgbGV0IHR5cGUgPSBudWxsXG5cbiAgLy8gMTAuIFN3aXRjaCBvbiBvYmplY3Q6XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNldCBzb3VyY2UgdG8gdGhlIFVURi04IGVuY29kaW5nIG9mIG9iamVjdC5cbiAgICAvLyBOb3RlOiBzZXR0aW5nIHNvdXJjZSB0byBhIFVpbnQ4QXJyYXkgaGVyZSBicmVha3Mgc29tZSBtb2NraW5nIGFzc3VtcHRpb25zLlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgLy8gU2V0IHR5cGUgdG8gYHRleHQvcGxhaW47Y2hhcnNldD1VVEYtOGAuXG4gICAgdHlwZSA9ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gVVJMU2VhcmNoUGFyYW1zXG5cbiAgICAvLyBzcGVjIHNheXMgdG8gcnVuIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBvbiBib2R5Lmxpc3RcbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGluIE5vZGUuanMgYXMgYXBhcnQgb2YgYW4gVVJMU2VhcmNoUGFyYW1zIGluc3RhbmNlIHRvU3RyaW5nIG1ldGhvZFxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZTQ2YzY4MGJmMmIyMTFiYmQ1MmNmOTU5Y2ExN2VlOThjN2Y2NTdmNS9saWIvaW50ZXJuYWwvdXJsLmpzI0w0OTBcbiAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZTQ2YzY4MGJmMmIyMTFiYmQ1MmNmOTU5Y2ExN2VlOThjN2Y2NTdmNS9saWIvaW50ZXJuYWwvdXJsLmpzI0wxMTAwXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGUgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIHNlcmlhbGl6ZXIgd2l0aCBvYmplY3TigJlzIGxpc3QuXG4gICAgc291cmNlID0gb2JqZWN0LnRvU3RyaW5nKClcblxuICAgIC8vIFNldCB0eXBlIHRvIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOGAuXG4gICAgdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCdcbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKG9iamVjdCkpIHtcbiAgICAvLyBCdWZmZXJTb3VyY2UvQXJyYXlCdWZmZXJcblxuICAgIC8vIFNldCBzb3VyY2UgdG8gYSBjb3B5IG9mIHRoZSBieXRlcyBoZWxkIGJ5IG9iamVjdC5cbiAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3Quc2xpY2UoKSlcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSkge1xuICAgIC8vIEJ1ZmZlclNvdXJjZS9BcnJheUJ1ZmZlclZpZXdcblxuICAgIC8vIFNldCBzb3VyY2UgdG8gYSBjb3B5IG9mIHRoZSBieXRlcyBoZWxkIGJ5IG9iamVjdC5cbiAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3QuYnVmZmVyLnNsaWNlKG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QuYnl0ZU9mZnNldCArIG9iamVjdC5ieXRlTGVuZ3RoKSlcbiAgfSBlbHNlIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKG9iamVjdCkpIHtcbiAgICBjb25zdCBib3VuZGFyeSA9IGAtLS0tZm9ybWRhdGEtdW5kaWNpLTAke2Ake01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTEpfWAucGFkU3RhcnQoMTEsICcwJyl9YFxuICAgIGNvbnN0IHByZWZpeCA9IGAtLSR7Ym91bmRhcnl9XFxyXFxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhYFxuXG4gICAgLyohIGZvcm1kYXRhLXBvbHlmaWxsLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuICAgIGNvbnN0IGVzY2FwZSA9IChzdHIpID0+XG4gICAgICBzdHIucmVwbGFjZSgvXFxuL2csICclMEEnKS5yZXBsYWNlKC9cXHIvZywgJyUwRCcpLnJlcGxhY2UoL1wiL2csICclMjInKVxuICAgIGNvbnN0IG5vcm1hbGl6ZUxpbmVmZWVkcyA9ICh2YWx1ZSkgPT4gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgJ1xcclxcbicpXG5cbiAgICAvLyBTZXQgYWN0aW9uIHRvIHRoaXMgc3RlcDogcnVuIHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhXG4gICAgLy8gZW5jb2RpbmcgYWxnb3JpdGhtLCB3aXRoIG9iamVjdOKAmXMgZW50cnkgbGlzdCBhbmQgVVRGLTguXG4gICAgLy8gLSBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgYm9keSBpcyBpbW11dGFibGUgYW5kIGNhbid0IGJlIGNoYW5nZWQgYWZ0ZXJ3b3Jkc1xuICAgIC8vIC0gVGhhdCB0aGUgY29udGVudC1sZW5ndGggaXMgY2FsY3VsYXRlZCBpbiBhZHZhbmNlLlxuICAgIC8vIC0gQW5kIHRoYXQgYWxsIHBhcnRzIGFyZSBwcmUtZW5jb2RlZCBhbmQgcmVhZHkgdG8gYmUgc2VudC5cblxuICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpXG4gICAgY29uc3QgYmxvYlBhcnRzID0gW11cbiAgICBjb25zdCBybiA9IG5ldyBVaW50OEFycmF5KFsxMywgMTBdKSAvLyAnXFxyXFxuJ1xuICAgIGxlbmd0aCA9IDBcbiAgICBsZXQgaGFzVW5rbm93blNpemVWYWx1ZSA9IGZhbHNlXG5cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2Ygb2JqZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBjaHVuayA9IGVuYy5lbmNvZGUocHJlZml4ICtcbiAgICAgICAgICBgOyBuYW1lPVwiJHtlc2NhcGUobm9ybWFsaXplTGluZWZlZWRzKG5hbWUpKX1cImAgK1xuICAgICAgICAgIGBcXHJcXG5cXHJcXG4ke25vcm1hbGl6ZUxpbmVmZWVkcyh2YWx1ZSl9XFxyXFxuYClcbiAgICAgICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgICAgIGxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaHVuayA9IGVuYy5lbmNvZGUoYCR7cHJlZml4fTsgbmFtZT1cIiR7ZXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICtcbiAgICAgICAgICAodmFsdWUubmFtZSA/IGA7IGZpbGVuYW1lPVwiJHtlc2NhcGUodmFsdWUubmFtZSl9XCJgIDogJycpICsgJ1xcclxcbicgK1xuICAgICAgICAgIGBDb250ZW50LVR5cGU6ICR7XG4gICAgICAgICAgICB2YWx1ZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgICAgfVxcclxcblxcclxcbmApXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rLCB2YWx1ZSwgcm4pXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aCArIHZhbHVlLnNpemUgKyBybi5ieXRlTGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzVW5rbm93blNpemVWYWx1ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNodW5rID0gZW5jLmVuY29kZShgLS0ke2JvdW5kYXJ5fS0tYClcbiAgICBibG9iUGFydHMucHVzaChjaHVuaylcbiAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgIGlmIChoYXNVbmtub3duU2l6ZVZhbHVlKSB7XG4gICAgICBsZW5ndGggPSBudWxsXG4gICAgfVxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byBvYmplY3QuXG4gICAgc291cmNlID0gb2JqZWN0XG5cbiAgICBhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBibG9iUGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQuc3RyZWFtKSB7XG4gICAgICAgICAgeWllbGQgKiBwYXJ0LnN0cmVhbSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgcGFydFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHR5cGUgdG8gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PWAsXG4gICAgLy8gZm9sbG93ZWQgYnkgdGhlIG11bHRpcGFydC9mb3JtLWRhdGEgYm91bmRhcnkgc3RyaW5nIGdlbmVyYXRlZFxuICAgIC8vIGJ5IHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhIGVuY29kaW5nIGFsZ29yaXRobS5cbiAgICB0eXBlID0gJ211bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PScgKyBib3VuZGFyeVxuICB9IGVsc2UgaWYgKGlzQmxvYkxpa2Uob2JqZWN0KSkge1xuICAgIC8vIEJsb2JcblxuICAgIC8vIFNldCBzb3VyY2UgdG8gb2JqZWN0LlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgLy8gU2V0IGxlbmd0aCB0byBvYmplY3TigJlzIHNpemUuXG4gICAgbGVuZ3RoID0gb2JqZWN0LnNpemVcblxuICAgIC8vIElmIG9iamVjdOKAmXMgdHlwZSBhdHRyaWJ1dGUgaXMgbm90IHRoZSBlbXB0eSBieXRlIHNlcXVlbmNlLCBzZXRcbiAgICAvLyB0eXBlIHRvIGl0cyB2YWx1ZS5cbiAgICBpZiAob2JqZWN0LnR5cGUpIHtcbiAgICAgIHR5cGUgPSBvYmplY3QudHlwZVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIElmIGtlZXBhbGl2ZSBpcyB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChrZWVwYWxpdmUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2tlZXBhbGl2ZScpXG4gICAgfVxuXG4gICAgLy8gSWYgb2JqZWN0IGlzIGRpc3R1cmJlZCBvciBsb2NrZWQsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHV0aWwuaXNEaXN0dXJiZWQob2JqZWN0KSB8fCBvYmplY3QubG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnUmVzcG9uc2UgYm9keSBvYmplY3Qgc2hvdWxkIG5vdCBiZSBkaXN0dXJiZWQgb3IgbG9ja2VkJ1xuICAgICAgKVxuICAgIH1cblxuICAgIHN0cmVhbSA9XG4gICAgICBvYmplY3QgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSA/IG9iamVjdCA6IFJlYWRhYmxlU3RyZWFtRnJvbShvYmplY3QpXG4gIH1cblxuICAvLyAxMS4gSWYgc291cmNlIGlzIGEgYnl0ZSBzZXF1ZW5jZSwgdGhlbiBzZXQgYWN0aW9uIHRvIGFcbiAgLy8gc3RlcCB0aGF0IHJldHVybnMgc291cmNlIGFuZCBsZW5ndGggdG8gc291cmNl4oCZcyBsZW5ndGguXG4gIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyB8fCB1dGlsLmlzQnVmZmVyKHNvdXJjZSkpIHtcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzb3VyY2UpXG4gIH1cblxuICAvLyAxMi4gSWYgYWN0aW9uIGlzIG5vbi1udWxsLCB0aGVuIHJ1biB0aGVzZSBzdGVwcyBpbiBpbiBwYXJhbGxlbDpcbiAgaWYgKGFjdGlvbiAhPSBudWxsKSB7XG4gICAgLy8gUnVuIGFjdGlvbi5cbiAgICBsZXQgaXRlcmF0b3JcbiAgICBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgYXN5bmMgc3RhcnQgKCkge1xuICAgICAgICBpdGVyYXRvciA9IGFjdGlvbihvYmplY3QpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KClcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAvLyBXaGVuIHJ1bm5pbmcgYWN0aW9uIGlzIGRvbmUsIGNsb3NlIHN0cmVhbS5cbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdoZW5ldmVyIG9uZSBvciBtb3JlIGJ5dGVzIGFyZSBhdmFpbGFibGUgYW5kIHN0cmVhbSBpcyBub3QgZXJyb3JlZCxcbiAgICAgICAgICAvLyBlbnF1ZXVlIGEgVWludDhBcnJheSB3cmFwcGluZyBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBhdmFpbGFibGVcbiAgICAgICAgICAvLyBieXRlcyBpbnRvIHN0cmVhbS5cbiAgICAgICAgICBpZiAoIWlzRXJyb3JlZChzdHJlYW0pKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5kZXNpcmVkU2l6ZSA+IDBcbiAgICAgIH0sXG4gICAgICBhc3luYyBjYW5jZWwgKHJlYXNvbikge1xuICAgICAgICBhd2FpdCBpdGVyYXRvci5yZXR1cm4oKVxuICAgICAgfSxcbiAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgIH0pXG4gIH1cblxuICAvLyAxMy4gTGV0IGJvZHkgYmUgYSBib2R5IHdob3NlIHN0cmVhbSBpcyBzdHJlYW0sIHNvdXJjZSBpcyBzb3VyY2UsXG4gIC8vIGFuZCBsZW5ndGggaXMgbGVuZ3RoLlxuICBjb25zdCBib2R5ID0geyBzdHJlYW0sIHNvdXJjZSwgbGVuZ3RoIH1cblxuICAvLyAxNC4gUmV0dXJuIChib2R5LCB0eXBlKS5cbiAgcmV0dXJuIFtib2R5LCB0eXBlXVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keWluaXQtc2FmZWx5LWV4dHJhY3RcbmZ1bmN0aW9uIHNhZmVseUV4dHJhY3RCb2R5IChvYmplY3QsIGtlZXBhbGl2ZSA9IGZhbHNlKSB7XG4gIGlmICghUmVhZGFibGVTdHJlYW0pIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtL3dlYicpLlJlYWRhYmxlU3RyZWFtXG4gIH1cblxuICAvLyBUbyBzYWZlbHkgZXh0cmFjdCBhIGJvZHkgYW5kIGEgYENvbnRlbnQtVHlwZWAgdmFsdWUgZnJvbVxuICAvLyBhIGJ5dGUgc2VxdWVuY2Ugb3IgQm9keUluaXQgb2JqZWN0IG9iamVjdCwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIDEuIElmIG9iamVjdCBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgdGhlbjpcbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgLy8gQXNzZXJ0OiBvYmplY3QgaXMgbmVpdGhlciBkaXN0dXJiZWQgbm9yIGxvY2tlZC5cbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGFzc2VydCghdXRpbC5pc0Rpc3R1cmJlZChvYmplY3QpLCAnVGhlIGJvZHkgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZC4nKVxuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgYXNzZXJ0KCFvYmplY3QubG9ja2VkLCAnVGhlIHN0cmVhbSBpcyBsb2NrZWQuJylcbiAgfVxuXG4gIC8vIDIuIFJldHVybiB0aGUgcmVzdWx0cyBvZiBleHRyYWN0aW5nIG9iamVjdC5cbiAgcmV0dXJuIGV4dHJhY3RCb2R5KG9iamVjdCwga2VlcGFsaXZlKVxufVxuXG5mdW5jdGlvbiBjbG9uZUJvZHkgKGJvZHkpIHtcbiAgLy8gVG8gY2xvbmUgYSBib2R5IGJvZHksIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LWNsb25lXG5cbiAgLy8gMS4gTGV0IMKrIG91dDEsIG91dDIgwrsgYmUgdGhlIHJlc3VsdCBvZiB0ZWVpbmcgYm9keeKAmXMgc3RyZWFtLlxuICBjb25zdCBbb3V0MSwgb3V0Ml0gPSBib2R5LnN0cmVhbS50ZWUoKVxuICBjb25zdCBvdXQyQ2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUob3V0MiwgeyB0cmFuc2ZlcjogW291dDJdIH0pXG4gIC8vIFRoaXMsIGZvciB3aGF0ZXZlciByZWFzb25zLCB1bnJlZnMgb3V0MkNsb25lIHdoaWNoIGFsbG93c1xuICAvLyB0aGUgcHJvY2VzcyB0byBleGl0IGJ5IGl0c2VsZi5cbiAgY29uc3QgWywgZmluYWxDbG9uZV0gPSBvdXQyQ2xvbmUudGVlKClcblxuICAvLyAyLiBTZXQgYm9keeKAmXMgc3RyZWFtIHRvIG91dDEuXG4gIGJvZHkuc3RyZWFtID0gb3V0MVxuXG4gIC8vIDMuIFJldHVybiBhIGJvZHkgd2hvc2Ugc3RyZWFtIGlzIG91dDIgYW5kIG90aGVyIG1lbWJlcnMgYXJlIGNvcGllZCBmcm9tIGJvZHkuXG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBmaW5hbENsb25lLFxuICAgIGxlbmd0aDogYm9keS5sZW5ndGgsXG4gICAgc291cmNlOiBib2R5LnNvdXJjZVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uICogY29uc3VtZUJvZHkgKGJvZHkpIHtcbiAgaWYgKGJvZHkpIHtcbiAgICBpZiAoaXNVaW50OEFycmF5KGJvZHkpKSB7XG4gICAgICB5aWVsZCBib2R5XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGJvZHkuc3RyZWFtXG5cbiAgICAgIGlmICh1dGlsLmlzRGlzdHVyYmVkKHN0cmVhbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGJvZHkgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZC4nKVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RyZWFtLmxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIGxvY2tlZC4nKVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wYXQuXG4gICAgICBzdHJlYW1ba0JvZHlVc2VkXSA9IHRydWVcblxuICAgICAgeWllbGQgKiBzdHJlYW1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dJZkFib3J0ZWQgKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5hYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm9keU1peGluTWV0aG9kcyAoaW5zdGFuY2UpIHtcbiAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICBibG9iICgpIHtcbiAgICAgIC8vIFRoZSBibG9iKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZlxuICAgICAgLy8gcnVubmluZyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXBcbiAgICAgIC8vIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczogcmV0dXJuIGEgQmxvYiB3aG9zZVxuICAgICAgLy8gY29udGVudHMgYXJlIGJ5dGVzIGFuZCB3aG9zZSB0eXBlIGF0dHJpYnV0ZSBpcyB0aGlz4oCZc1xuICAgICAgLy8gTUlNRSB0eXBlLlxuICAgICAgcmV0dXJuIHNwZWNDb25zdW1lQm9keSh0aGlzLCAoYnl0ZXMpID0+IHtcbiAgICAgICAgbGV0IG1pbWVUeXBlID0gYm9keU1pbWVUeXBlKHRoaXMpXG5cbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgICBtaW1lVHlwZSA9ICcnXG4gICAgICAgIH0gZWxzZSBpZiAobWltZVR5cGUpIHtcbiAgICAgICAgICBtaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZShtaW1lVHlwZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBhIEJsb2Igd2hvc2UgY29udGVudHMgYXJlIGJ5dGVzIGFuZCB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAvLyBpcyBtaW1lVHlwZS5cbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtieXRlc10sIHsgdHlwZTogbWltZVR5cGUgfSlcbiAgICAgIH0sIGluc3RhbmNlKVxuICAgIH0sXG5cbiAgICBhcnJheUJ1ZmZlciAoKSB7XG4gICAgICAvLyBUaGUgYXJyYXlCdWZmZXIoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0XG4gICAgICAvLyBvZiBydW5uaW5nIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHRoZSBmb2xsb3dpbmcgc3RlcFxuICAgICAgLy8gZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOiByZXR1cm4gYSBuZXcgQXJyYXlCdWZmZXJcbiAgICAgIC8vIHdob3NlIGNvbnRlbnRzIGFyZSBieXRlcy5cbiAgICAgIHJldHVybiBzcGVjQ29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgdGV4dCAoKSB7XG4gICAgICAvLyBUaGUgdGV4dCgpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgICAgLy8gY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgVVRGLTggZGVjb2RlLlxuICAgICAgcmV0dXJuIHNwZWNDb25zdW1lQm9keSh0aGlzLCB1dGY4RGVjb2RlQnl0ZXMsIGluc3RhbmNlKVxuICAgIH0sXG5cbiAgICBqc29uICgpIHtcbiAgICAgIC8vIFRoZSBqc29uKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICAvLyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCBwYXJzZSBKU09OIGZyb20gYnl0ZXMuXG4gICAgICByZXR1cm4gc3BlY0NvbnN1bWVCb2R5KHRoaXMsIHBhcnNlSlNPTkZyb21CeXRlcywgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIGFzeW5jIGZvcm1EYXRhICgpIHtcbiAgICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIGluc3RhbmNlKVxuXG4gICAgICB0aHJvd0lmQWJvcnRlZCh0aGlzW2tTdGF0ZV0pXG5cbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gdGhpcy5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJylcblxuICAgICAgLy8gSWYgbWltZVR5cGXigJlzIGVzc2VuY2UgaXMgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsIHRoZW46XG4gICAgICBpZiAoL211bHRpcGFydFxcL2Zvcm0tZGF0YS8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuaGVhZGVycykgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuXG4gICAgICAgIGxldCBidXNib3lcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGJ1c2JveSA9IG5ldyBCdXNib3koe1xuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHByZXNlcnZlUGF0aDogdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oYCR7ZXJyfWAsICdBYm9ydEVycm9yJylcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1c2JveS5vbignZmllbGQnLCAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICByZXNwb25zZUZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgICAgfSlcbiAgICAgICAgYnVzYm95Lm9uKCdmaWxlJywgKG5hbWUsIHZhbHVlLCBmaWxlbmFtZSwgZW5jb2RpbmcsIG1pbWVUeXBlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2h1bmtzID0gW11cblxuICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgfHwgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgIGxldCBiYXNlNjRjaHVuayA9ICcnXG5cbiAgICAgICAgICAgIHZhbHVlLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgIGJhc2U2NGNodW5rICs9IGNodW5rLnRvU3RyaW5nKCkucmVwbGFjZSgvW1xcclxcbl0vZ20sICcnKVxuXG4gICAgICAgICAgICAgIGNvbnN0IGVuZCA9IGJhc2U2NGNodW5rLmxlbmd0aCAtIGJhc2U2NGNodW5rLmxlbmd0aCAlIDRcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2goQnVmZmVyLmZyb20oYmFzZTY0Y2h1bmsuc2xpY2UoMCwgZW5kKSwgJ2Jhc2U2NCcpKVxuXG4gICAgICAgICAgICAgIGJhc2U2NGNodW5rID0gYmFzZTY0Y2h1bmsuc2xpY2UoZW5kKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHZhbHVlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKEJ1ZmZlci5mcm9tKGJhc2U2NGNodW5rLCAnYmFzZTY0JykpXG4gICAgICAgICAgICAgIHJlc3BvbnNlRm9ybURhdGEuYXBwZW5kKG5hbWUsIG5ldyBGaWxlKGNodW5rcywgZmlsZW5hbWUsIHsgdHlwZTogbWltZVR5cGUgfSkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuaylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB2YWx1ZS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICByZXNwb25zZUZvcm1EYXRhLmFwcGVuZChuYW1lLCBuZXcgRmlsZShjaHVua3MsIGZpbGVuYW1lLCB7IHR5cGU6IG1pbWVUeXBlIH0pKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgYnVzYm95UmVzb2x2ZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBidXNib3kub24oJ2ZpbmlzaCcsIHJlc29sdmUpXG4gICAgICAgICAgYnVzYm95Lm9uKCdlcnJvcicsIChlcnIpID0+IHJlamVjdChuZXcgVHlwZUVycm9yKGVycikpKVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICh0aGlzLmJvZHkgIT09IG51bGwpIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUJvZHkodGhpc1trU3RhdGVdLmJvZHkpKSBidXNib3kud3JpdGUoY2h1bmspXG4gICAgICAgIGJ1c2JveS5lbmQoKVxuICAgICAgICBhd2FpdCBidXNib3lSZXNvbHZlXG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRm9ybURhdGFcbiAgICAgIH0gZWxzZSBpZiAoL2FwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGlzIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIHRoZW46XG5cbiAgICAgICAgLy8gMS4gTGV0IGVudHJpZXMgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGJ5dGVzLlxuICAgICAgICBsZXQgZW50cmllc1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCB0ZXh0ID0gJydcbiAgICAgICAgICAvLyBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgcGFyc2VyIHdpbGwga2VlcCB0aGUgQk9NLlxuICAgICAgICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmxlbmNvZGVkLXBhcnNlclxuICAgICAgICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgaWdub3JlQk9NOiB0cnVlIH0pXG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQm9keSh0aGlzW2tTdGF0ZV0uYm9keSkpIHtcbiAgICAgICAgICAgIGlmICghaXNVaW50OEFycmF5KGNodW5rKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5IGNodW5rJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgKz0gdGV4dERlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0ICs9IHRleHREZWNvZGVyLmRlY29kZSgpXG4gICAgICAgICAgZW50cmllcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModGV4dClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IFVuY2xlYXIgd2hlbiBuZXcgVVJMU2VhcmNoUGFyYW1zIGNhbiBmYWlsIG9uIGEgc3RyaW5nLlxuICAgICAgICAgIC8vIDIuIElmIGVudHJpZXMgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBUeXBlRXJyb3IoKSwgeyBjYXVzZTogZXJyIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBSZXR1cm4gYSBuZXcgRm9ybURhdGEgb2JqZWN0IHdob3NlIGVudHJpZXMgYXJlIGVudHJpZXMuXG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1EYXRhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXYWl0IGEgdGljayBiZWZvcmUgY2hlY2tpbmcgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhIFR5cGVFcnJvciBjYW4gYmUgdGhyb3duIHdoZW4gYW4gQWJvcnRFcnJvciBzaG91bGQuXG4gICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpXG5cbiAgICAgICAgdGhyb3dJZkFib3J0ZWQodGhpc1trU3RhdGVdKVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6IGAke2luc3RhbmNlLm5hbWV9LmZvcm1EYXRhYCxcbiAgICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IHBhcnNlIGNvbnRlbnQgYXMgRm9ybURhdGEuJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXRob2RzXG59XG5cbmZ1bmN0aW9uIG1peGluQm9keSAocHJvdG90eXBlKSB7XG4gIE9iamVjdC5hc3NpZ24ocHJvdG90eXBlLnByb3RvdHlwZSwgYm9keU1peGluTWV0aG9kcyhwcm90b3R5cGUpKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqIEBwYXJhbSB7UmVzcG9uc2V8UmVxdWVzdH0gb2JqZWN0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdW5rbm93bn0gY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfFJlcXVlc3R9IGluc3RhbmNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNwZWNDb25zdW1lQm9keSAob2JqZWN0LCBjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUsIGluc3RhbmNlKSB7XG4gIHdlYmlkbC5icmFuZENoZWNrKG9iamVjdCwgaW5zdGFuY2UpXG5cbiAgdGhyb3dJZkFib3J0ZWQob2JqZWN0W2tTdGF0ZV0pXG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIHVudXNhYmxlLCB0aGVuIHJldHVybiBhIHByb21pc2UgcmVqZWN0ZWRcbiAgLy8gICAgd2l0aCBhIFR5cGVFcnJvci5cbiAgaWYgKGJvZHlVbnVzYWJsZShvYmplY3Rba1N0YXRlXS5ib2R5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgaXMgdW51c2FibGUnKVxuICB9XG5cbiAgLy8gMi4gTGV0IHByb21pc2UgYmUgYSBuZXcgcHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgLy8gMy4gTGV0IGVycm9yU3RlcHMgZ2l2ZW4gZXJyb3IgYmUgdG8gcmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgY29uc3QgZXJyb3JTdGVwcyA9IChlcnJvcikgPT4gcHJvbWlzZS5yZWplY3QoZXJyb3IpXG5cbiAgLy8gNC4gTGV0IHN1Y2Nlc3NTdGVwcyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgZGF0YSBiZSB0byByZXNvbHZlXG4gIC8vICAgIHByb21pc2Ugd2l0aCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gIC8vICAgIHdpdGggZGF0YS4gSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIHRoZW4gcnVuIGVycm9yU3RlcHNcbiAgLy8gICAgd2l0aCB0aGF0IGV4Y2VwdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gKGRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKGNvbnZlcnRCeXRlc1RvSlNWYWx1ZShkYXRhKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvclN0ZXBzKGUpXG4gICAgfVxuICB9XG5cbiAgLy8gNS4gSWYgb2JqZWN04oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcnVuIHN1Y2Nlc3NTdGVwcyB3aXRoIGFuXG4gIC8vICAgIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIGlmIChvYmplY3Rba1N0YXRlXS5ib2R5ID09IG51bGwpIHtcbiAgICBzdWNjZXNzU3RlcHMobmV3IFVpbnQ4QXJyYXkoKSlcbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvLyA2LiBPdGhlcndpc2UsIGZ1bGx5IHJlYWQgb2JqZWN04oCZcyBib2R5IGdpdmVuIHN1Y2Nlc3NTdGVwcyxcbiAgLy8gICAgZXJyb3JTdGVwcywgYW5kIG9iamVjdOKAmXMgcmVsZXZhbnQgZ2xvYmFsIG9iamVjdC5cbiAgYXdhaXQgZnVsbHlSZWFkQm9keShvYmplY3Rba1N0YXRlXS5ib2R5LCBzdWNjZXNzU3RlcHMsIGVycm9yU3RlcHMpXG5cbiAgLy8gNy4gUmV0dXJuIHByb21pc2UuXG4gIHJldHVybiBwcm9taXNlLnByb21pc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHktdW51c2FibGVcbmZ1bmN0aW9uIGJvZHlVbnVzYWJsZSAoYm9keSkge1xuICAvLyBBbiBvYmplY3QgaW5jbHVkaW5nIHRoZSBCb2R5IGludGVyZmFjZSBtaXhpbiBpc1xuICAvLyBzYWlkIHRvIGJlIHVudXNhYmxlIGlmIGl0cyBib2R5IGlzIG5vbi1udWxsIGFuZFxuICAvLyBpdHMgYm9keeKAmXMgc3RyZWFtIGlzIGRpc3R1cmJlZCBvciBsb2NrZWQuXG4gIHJldHVybiBib2R5ICE9IG51bGwgJiYgKGJvZHkuc3RyZWFtLmxvY2tlZCB8fCB1dGlsLmlzRGlzdHVyYmVkKGJvZHkuc3RyZWFtKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyN1dGYtOC1kZWNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAqL1xuZnVuY3Rpb24gdXRmOERlY29kZUJ5dGVzIChidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIDEuIExldCBidWZmZXIgYmUgdGhlIHJlc3VsdCBvZiBwZWVraW5nIHRocmVlIGJ5dGVzIGZyb21cbiAgLy8gICAgaW9RdWV1ZSwgY29udmVydGVkIHRvIGEgYnl0ZSBzZXF1ZW5jZS5cblxuICAvLyAyLiBJZiBidWZmZXIgaXMgMHhFRiAweEJCIDB4QkYsIHRoZW4gcmVhZCB0aHJlZVxuICAvLyAgICBieXRlcyBmcm9tIGlvUXVldWUuIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICBpZiAoYnVmZmVyWzBdID09PSAweEVGICYmIGJ1ZmZlclsxXSA9PT0gMHhCQiAmJiBidWZmZXJbMl0gPT09IDB4QkYpIHtcbiAgICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkoMylcbiAgfVxuXG4gIC8vIDMuIFByb2Nlc3MgYSBxdWV1ZSB3aXRoIGFuIGluc3RhbmNlIG9mIFVURi044oCZc1xuICAvLyAgICBkZWNvZGVyLCBpb1F1ZXVlLCBvdXRwdXQsIGFuZCBcInJlcGxhY2VtZW50XCIuXG4gIGNvbnN0IG91dHB1dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmZXIpXG5cbiAgLy8gNC4gUmV0dXJuIG91dHB1dC5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3BhcnNlLWpzb24tYnl0ZXMtdG8tYS1qYXZhc2NyaXB0LXZhbHVlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTkZyb21CeXRlcyAoYnl0ZXMpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UodXRmOERlY29kZUJ5dGVzKGJ5dGVzKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktbWltZS10eXBlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9yZXNwb25zZScpLlJlc3BvbnNlfGltcG9ydCgnLi9yZXF1ZXN0JykuUmVxdWVzdH0gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGJvZHlNaW1lVHlwZSAob2JqZWN0KSB7XG4gIGNvbnN0IHsgaGVhZGVyc0xpc3QgfSA9IG9iamVjdFtrU3RhdGVdXG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVyc0xpc3QuZ2V0KCdjb250ZW50LXR5cGUnKVxuXG4gIGlmIChjb250ZW50VHlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIHJldHVybiBwYXJzZU1JTUVUeXBlKGNvbnRlbnRUeXBlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXh0cmFjdEJvZHksXG4gIHNhZmVseUV4dHJhY3RCb2R5LFxuICBjbG9uZUJvZHksXG4gIG1peGluQm9keVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/body.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/fetch/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { MessageChannel, receiveMessageOnPort } = __webpack_require__(/*! worker_threads */ \"worker_threads\")\n\nconst corsSafeListedMethods = ['GET', 'HEAD', 'POST']\n\nconst nullBodyStatus = [101, 204, 205, 304]\n\nconst redirectStatus = [301, 302, 303, 307, 308]\n\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',\n  '10080'\n]\n\n// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\nconst referrerPolicy = [\n  '',\n  'no-referrer',\n  'no-referrer-when-downgrade',\n  'same-origin',\n  'origin',\n  'strict-origin',\n  'origin-when-cross-origin',\n  'strict-origin-when-cross-origin',\n  'unsafe-url'\n]\n\nconst requestRedirect = ['follow', 'manual', 'error']\n\nconst safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE']\n\nconst requestMode = ['navigate', 'same-origin', 'no-cors', 'cors']\n\nconst requestCredentials = ['omit', 'same-origin', 'include']\n\nconst requestCache = [\n  'default',\n  'no-store',\n  'reload',\n  'no-cache',\n  'force-cache',\n  'only-if-cached'\n]\n\n// https://fetch.spec.whatwg.org/#request-body-header-name\nconst requestBodyHeader = [\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  // See https://github.com/nodejs/undici/issues/2021\n  // 'Content-Length' is a forbidden header name, which is typically\n  // removed in the Headers implementation. However, undici doesn't\n  // filter out headers, so we add it here.\n  'content-length'\n]\n\n// https://fetch.spec.whatwg.org/#enumdef-requestduplex\nconst requestDuplex = [\n  'half'\n]\n\n// http://fetch.spec.whatwg.org/#forbidden-method\nconst forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK']\n\nconst subresource = [\n  'audio',\n  'audioworklet',\n  'font',\n  'image',\n  'manifest',\n  'paintworklet',\n  'script',\n  'style',\n  'track',\n  'video',\n  'xslt',\n  ''\n]\n\n/** @type {globalThis['DOMException']} */\nconst DOMException = globalThis.DOMException ?? (() => {\n  // DOMException was only made a global in Node v17.0.0,\n  // but fetch supports >= v16.8.\n  try {\n    atob('~')\n  } catch (err) {\n    return Object.getPrototypeOf(err).constructor\n  }\n})()\n\nlet channel\n\n/** @type {globalThis['structuredClone']} */\nconst structuredClone =\n  globalThis.structuredClone ??\n  // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js\n  // structuredClone was added in v17.0.0, but fetch supports v16.8\n  function structuredClone (value, options = undefined) {\n    if (arguments.length === 0) {\n      throw new TypeError('missing argument')\n    }\n\n    if (!channel) {\n      channel = new MessageChannel()\n    }\n    channel.port1.unref()\n    channel.port2.unref()\n    channel.port1.postMessage(value, options?.transfer)\n    return receiveMessageOnPort(channel.port2).message\n  }\n\nmodule.exports = {\n  DOMException,\n  structuredClone,\n  subresource,\n  forbiddenMethods,\n  requestBodyHeader,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  redirectStatus,\n  corsSafeListedMethods,\n  nullBodyStatus,\n  safeMethods,\n  badPorts,\n  requestDuplex\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSx1Q0FBdUMsRUFBRSxtQkFBTyxDQUFDLHNDQUFnQjs7QUFFekU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvY29uc3RhbnRzLmpzPzhlODMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgTWVzc2FnZUNoYW5uZWwsIHJlY2VpdmVNZXNzYWdlT25Qb3J0IH0gPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpXG5cbmNvbnN0IGNvcnNTYWZlTGlzdGVkTWV0aG9kcyA9IFsnR0VUJywgJ0hFQUQnLCAnUE9TVCddXG5cbmNvbnN0IG51bGxCb2R5U3RhdHVzID0gWzEwMSwgMjA0LCAyMDUsIDMwNF1cblxuY29uc3QgcmVkaXJlY3RTdGF0dXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNibG9jay1iYWQtcG9ydFxuY29uc3QgYmFkUG9ydHMgPSBbXG4gICcxJywgJzcnLCAnOScsICcxMScsICcxMycsICcxNScsICcxNycsICcxOScsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNScsICczNycsICc0MicsICc0MycsICc1MycsICc2OScsICc3NycsICc3OScsXG4gICc4NycsICc5NScsICcxMDEnLCAnMTAyJywgJzEwMycsICcxMDQnLCAnMTA5JywgJzExMCcsICcxMTEnLCAnMTEzJywgJzExNScsICcxMTcnLCAnMTE5JywgJzEyMycsICcxMzUnLCAnMTM3JyxcbiAgJzEzOScsICcxNDMnLCAnMTYxJywgJzE3OScsICczODknLCAnNDI3JywgJzQ2NScsICc1MTInLCAnNTEzJywgJzUxNCcsICc1MTUnLCAnNTI2JywgJzUzMCcsICc1MzEnLCAnNTMyJyxcbiAgJzU0MCcsICc1NDgnLCAnNTU0JywgJzU1NicsICc1NjMnLCAnNTg3JywgJzYwMScsICc2MzYnLCAnOTg5JywgJzk5MCcsICc5OTMnLCAnOTk1JywgJzE3MTknLCAnMTcyMCcsICcxNzIzJyxcbiAgJzIwNDknLCAnMzY1OScsICc0MDQ1JywgJzUwNjAnLCAnNTA2MScsICc2MDAwJywgJzY1NjYnLCAnNjY2NScsICc2NjY2JywgJzY2NjcnLCAnNjY2OCcsICc2NjY5JywgJzY2OTcnLFxuICAnMTAwODAnXG5dXG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY2llc1xuY29uc3QgcmVmZXJyZXJQb2xpY3kgPSBbXG4gICcnLFxuICAnbm8tcmVmZXJyZXInLFxuICAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnLFxuICAnc2FtZS1vcmlnaW4nLFxuICAnb3JpZ2luJyxcbiAgJ3N0cmljdC1vcmlnaW4nLFxuICAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcbiAgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLFxuICAndW5zYWZlLXVybCdcbl1cblxuY29uc3QgcmVxdWVzdFJlZGlyZWN0ID0gWydmb2xsb3cnLCAnbWFudWFsJywgJ2Vycm9yJ11cblxuY29uc3Qgc2FmZU1ldGhvZHMgPSBbJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnVFJBQ0UnXVxuXG5jb25zdCByZXF1ZXN0TW9kZSA9IFsnbmF2aWdhdGUnLCAnc2FtZS1vcmlnaW4nLCAnbm8tY29ycycsICdjb3JzJ11cblxuY29uc3QgcmVxdWVzdENyZWRlbnRpYWxzID0gWydvbWl0JywgJ3NhbWUtb3JpZ2luJywgJ2luY2x1ZGUnXVxuXG5jb25zdCByZXF1ZXN0Q2FjaGUgPSBbXG4gICdkZWZhdWx0JyxcbiAgJ25vLXN0b3JlJyxcbiAgJ3JlbG9hZCcsXG4gICduby1jYWNoZScsXG4gICdmb3JjZS1jYWNoZScsXG4gICdvbmx5LWlmLWNhY2hlZCdcbl1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtYm9keS1oZWFkZXItbmFtZVxuY29uc3QgcmVxdWVzdEJvZHlIZWFkZXIgPSBbXG4gICdjb250ZW50LWVuY29kaW5nJyxcbiAgJ2NvbnRlbnQtbGFuZ3VhZ2UnLFxuICAnY29udGVudC1sb2NhdGlvbicsXG4gICdjb250ZW50LXR5cGUnLFxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwMjFcbiAgLy8gJ0NvbnRlbnQtTGVuZ3RoJyBpcyBhIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgd2hpY2ggaXMgdHlwaWNhbGx5XG4gIC8vIHJlbW92ZWQgaW4gdGhlIEhlYWRlcnMgaW1wbGVtZW50YXRpb24uIEhvd2V2ZXIsIHVuZGljaSBkb2Vzbid0XG4gIC8vIGZpbHRlciBvdXQgaGVhZGVycywgc28gd2UgYWRkIGl0IGhlcmUuXG4gICdjb250ZW50LWxlbmd0aCdcbl1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2VudW1kZWYtcmVxdWVzdGR1cGxleFxuY29uc3QgcmVxdWVzdER1cGxleCA9IFtcbiAgJ2hhbGYnXG5dXG5cbi8vIGh0dHA6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZvcmJpZGRlbi1tZXRob2RcbmNvbnN0IGZvcmJpZGRlbk1ldGhvZHMgPSBbJ0NPTk5FQ1QnLCAnVFJBQ0UnLCAnVFJBQ0snXVxuXG5jb25zdCBzdWJyZXNvdXJjZSA9IFtcbiAgJ2F1ZGlvJyxcbiAgJ2F1ZGlvd29ya2xldCcsXG4gICdmb250JyxcbiAgJ2ltYWdlJyxcbiAgJ21hbmlmZXN0JyxcbiAgJ3BhaW50d29ya2xldCcsXG4gICdzY3JpcHQnLFxuICAnc3R5bGUnLFxuICAndHJhY2snLFxuICAndmlkZW8nLFxuICAneHNsdCcsXG4gICcnXG5dXG5cbi8qKiBAdHlwZSB7Z2xvYmFsVGhpc1snRE9NRXhjZXB0aW9uJ119ICovXG5jb25zdCBET01FeGNlcHRpb24gPSBnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbiA/PyAoKCkgPT4ge1xuICAvLyBET01FeGNlcHRpb24gd2FzIG9ubHkgbWFkZSBhIGdsb2JhbCBpbiBOb2RlIHYxNy4wLjAsXG4gIC8vIGJ1dCBmZXRjaCBzdXBwb3J0cyA+PSB2MTYuOC5cbiAgdHJ5IHtcbiAgICBhdG9iKCd+JylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpLmNvbnN0cnVjdG9yXG4gIH1cbn0pKClcblxubGV0IGNoYW5uZWxcblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydzdHJ1Y3R1cmVkQ2xvbmUnXX0gKi9cbmNvbnN0IHN0cnVjdHVyZWRDbG9uZSA9XG4gIGdsb2JhbFRoaXMuc3RydWN0dXJlZENsb25lID8/XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IyN2FlMjRkY2M0MjUxYmFkNzI2ZDlkODRiYWY2NzhkMWY3MDdmZWQvbGliL2ludGVybmFsL3N0cnVjdHVyZWRfY2xvbmUuanNcbiAgLy8gc3RydWN0dXJlZENsb25lIHdhcyBhZGRlZCBpbiB2MTcuMC4wLCBidXQgZmV0Y2ggc3VwcG9ydHMgdjE2LjhcbiAgZnVuY3Rpb24gc3RydWN0dXJlZENsb25lICh2YWx1ZSwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50JylcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKVxuICAgIH1cbiAgICBjaGFubmVsLnBvcnQxLnVucmVmKClcbiAgICBjaGFubmVsLnBvcnQyLnVucmVmKClcbiAgICBjaGFubmVsLnBvcnQxLnBvc3RNZXNzYWdlKHZhbHVlLCBvcHRpb25zPy50cmFuc2ZlcilcbiAgICByZXR1cm4gcmVjZWl2ZU1lc3NhZ2VPblBvcnQoY2hhbm5lbC5wb3J0MikubWVzc2FnZVxuICB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBET01FeGNlcHRpb24sXG4gIHN0cnVjdHVyZWRDbG9uZSxcbiAgc3VicmVzb3VyY2UsXG4gIGZvcmJpZGRlbk1ldGhvZHMsXG4gIHJlcXVlc3RCb2R5SGVhZGVyLFxuICByZWZlcnJlclBvbGljeSxcbiAgcmVxdWVzdFJlZGlyZWN0LFxuICByZXF1ZXN0TW9kZSxcbiAgcmVxdWVzdENyZWRlbnRpYWxzLFxuICByZXF1ZXN0Q2FjaGUsXG4gIHJlZGlyZWN0U3RhdHVzLFxuICBjb3JzU2FmZUxpc3RlZE1ldGhvZHMsXG4gIG51bGxCb2R5U3RhdHVzLFxuICBzYWZlTWV0aG9kcyxcbiAgYmFkUG9ydHMsXG4gIHJlcXVlc3REdXBsZXhcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/dataURL.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/fetch/dataURL.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\")\nconst { atob } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { isomorphicDecode } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\n\nconst encoder = new TextEncoder()\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/\nconst HTTP_WHITESPACE_REGEX = /(\\u000A|\\u000D|\\u0009|\\u0020)/ // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /[\\u0009|\\u0020-\\u007E|\\u0080-\\u00FF]/ // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURLs scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(\n    ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = removeASCIIWhitespace(mimeType, true, true)\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  const href = url.href\n\n  if (!excludeFragment) {\n    return href\n  }\n\n  const hash = href.lastIndexOf('#')\n  if (hash === -1) {\n    return href\n  }\n  return href.slice(0, hash)\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesnt point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePointsFast (char, input, position) {\n  const idx = input.indexOf(char, position.position)\n  const start = position.position\n\n  if (idx === -1) {\n    position.position = input.length\n    return input.slice(start)\n  }\n\n  position.position = idx\n  return input.slice(start, position.position)\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = []\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte)\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))\n    ) {\n      output.push(0x25)\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])\n      const bytePoint = Number.parseInt(nextTwoBytes, 16)\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint)\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.from(output)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true)\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast(\n    '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(\n    ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true)\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure'\n  }\n\n  const typeLowercase = type.toLowerCase()\n  const subtypeLowercase = subtype.toLowerCase()\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      char => HTTP_WHITESPACE_REGEX.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true)\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeTypes parameters[parameterName] does not exist\n    // then set mimeTypes parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&\n      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, '')  // eslint-disable-line\n\n  // 2. If datas code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '')\n  }\n\n  // 3. If datas code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure'\n  }\n\n  const binary = atob(data)\n  const bytes = new Uint8Array(binary.length)\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte)\n  }\n\n  return bytes\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { parameters, essence } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeTypes\n  //    type, U+002F (/), and mimeTypes subtype.\n  let serialization = essence\n\n  // 2. For each name  value of mimeTypes parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} char\n */\nfunction isHTTPWhiteSpace (char) {\n  return char === '\\r' || char === '\\n' || char === '\\t' || char === ' '\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n */\nfunction removeHTTPWhitespace (str, leading = true, trailing = true) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);\n  }\n\n  if (trailing) {\n    for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);\n  }\n\n  return str.slice(lead, trail + 1)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {string} char\n */\nfunction isASCIIWhitespace (char) {\n  return char === '\\r' || char === '\\n' || char === '\\t' || char === '\\f' || char === ' '\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n */\nfunction removeASCIIWhitespace (str, leading = true, trailing = true) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);\n  }\n\n  if (trailing) {\n    for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);\n  }\n\n  return str.slice(lead, trail + 1)\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9kYXRhVVJMLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyw2REFBUTs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLFFBQVEsU0FBUyxHQUFHO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVcsUUFBUTtBQUNuQixh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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsdUJBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrREFBa0Q7QUFDN0Q7O0FBRUE7QUFDQSxXQUFXLDJDQUEyQztBQUN0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtREFBbUQ7QUFDOUQ7O0FBRUE7QUFDQSxXQUFXLDRDQUE0QztBQUN2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZGF0YVVSTC5qcz85MzRmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGF0b2IgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IGlzb21vcnBoaWNEZWNvZGUgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXRva2VuLWNvZGUtcG9pbnRcbiAqL1xuY29uc3QgSFRUUF9UT0tFTl9DT0RFUE9JTlRTID0gL15bISMkJSYnKistLl5ffH5BLVphLXowLTldKyQvXG5jb25zdCBIVFRQX1dISVRFU1BBQ0VfUkVHRVggPSAvKFxcdTAwMEF8XFx1MDAwRHxcXHUwMDA5fFxcdTAwMjApLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXF1b3RlZC1zdHJpbmctdG9rZW4tY29kZS1wb2ludFxuICovXG5jb25zdCBIVFRQX1FVT1RFRF9TVFJJTkdfVE9LRU5TID0gL1tcXHUwMDA5fFxcdTAwMjAtXFx1MDA3RXxcXHUwMDgwLVxcdTAwRkZdLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkYXRhLXVybC1wcm9jZXNzb3Jcbi8qKiBAcGFyYW0ge1VSTH0gZGF0YVVSTCAqL1xuZnVuY3Rpb24gZGF0YVVSTFByb2Nlc3NvciAoZGF0YVVSTCkge1xuICAvLyAxLiBBc3NlcnQ6IGRhdGFVUkzigJlzIHNjaGVtZSBpcyBcImRhdGFcIi5cbiAgYXNzZXJ0KGRhdGFVUkwucHJvdG9jb2wgPT09ICdkYXRhOicpXG5cbiAgLy8gMi4gTGV0IGlucHV0IGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGUgVVJMXG4gIC8vIHNlcmlhbGl6ZXIgb24gZGF0YVVSTCB3aXRoIGV4Y2x1ZGUgZnJhZ21lbnRcbiAgLy8gc2V0IHRvIHRydWUuXG4gIGxldCBpbnB1dCA9IFVSTFNlcmlhbGl6ZXIoZGF0YVVSTCwgdHJ1ZSlcblxuICAvLyAzLiBSZW1vdmUgdGhlIGxlYWRpbmcgXCJkYXRhOlwiIHN0cmluZyBmcm9tIGlucHV0LlxuICBpbnB1dCA9IGlucHV0LnNsaWNlKDUpXG5cbiAgLy8gNC4gTGV0IHBvc2l0aW9uIHBvaW50IGF0IHRoZSBzdGFydCBvZiBpbnB1dC5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyA1LiBMZXQgbWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGFcbiAgLy8gc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IGVxdWFsXG4gIC8vIHRvIFUrMDAyQyAoLCksIGdpdmVuIHBvc2l0aW9uLlxuICBsZXQgbWltZVR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAnLCcsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDYuIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIEFTQ0lJIHdoaXRlc3BhY2VcbiAgLy8gZnJvbSBtaW1lVHlwZS5cbiAgLy8gVW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IHdlIG5lZWQgdG8gc3RvcmUgdGhlXG4gIC8vIGxlbmd0aCBiZWNhdXNlIGlmIHRoZSBtaW1ldHlwZSBoYXMgc3BhY2VzIHJlbW92ZWQsXG4gIC8vIHRoZSB3cm9uZyBhbW91bnQgd2lsbCBiZSBzbGljZWQgZnJvbSB0aGUgaW5wdXQgaW5cbiAgLy8gc3RlcCAjOVxuICBjb25zdCBtaW1lVHlwZUxlbmd0aCA9IG1pbWVUeXBlLmxlbmd0aFxuICBtaW1lVHlwZSA9IHJlbW92ZUFTQ0lJV2hpdGVzcGFjZShtaW1lVHlwZSwgdHJ1ZSwgdHJ1ZSlcblxuICAvLyA3LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW5cbiAgLy8gcmV0dXJuIGZhaWx1cmVcbiAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDguIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDkuIExldCBlbmNvZGVkQm9keSBiZSB0aGUgcmVtYWluZGVyIG9mIGlucHV0LlxuICBjb25zdCBlbmNvZGVkQm9keSA9IGlucHV0LnNsaWNlKG1pbWVUeXBlTGVuZ3RoICsgMSlcblxuICAvLyAxMC4gTGV0IGJvZHkgYmUgdGhlIHBlcmNlbnQtZGVjb2Rpbmcgb2YgZW5jb2RlZEJvZHkuXG4gIGxldCBib2R5ID0gc3RyaW5nUGVyY2VudERlY29kZShlbmNvZGVkQm9keSlcblxuICAvLyAxMS4gSWYgbWltZVR5cGUgZW5kcyB3aXRoIFUrMDAzQiAoOyksIGZvbGxvd2VkIGJ5XG4gIC8vIHplcm8gb3IgbW9yZSBVKzAwMjAgU1BBQ0UsIGZvbGxvd2VkIGJ5IGFuIEFTQ0lJXG4gIC8vIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIFwiYmFzZTY0XCIsIHRoZW46XG4gIGlmICgvOyhcXHUwMDIwKXswLH1iYXNlNjQkL2kudGVzdChtaW1lVHlwZSkpIHtcbiAgICAvLyAxLiBMZXQgc3RyaW5nQm9keSBiZSB0aGUgaXNvbW9ycGhpYyBkZWNvZGUgb2YgYm9keS5cbiAgICBjb25zdCBzdHJpbmdCb2R5ID0gaXNvbW9ycGhpY0RlY29kZShib2R5KVxuXG4gICAgLy8gMi4gU2V0IGJvZHkgdG8gdGhlIGZvcmdpdmluZy1iYXNlNjQgZGVjb2RlIG9mXG4gICAgLy8gc3RyaW5nQm9keS5cbiAgICBib2R5ID0gZm9yZ2l2aW5nQmFzZTY0KHN0cmluZ0JvZHkpXG5cbiAgICAvLyAzLiBJZiBib2R5IGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKGJvZHkgPT09ICdmYWlsdXJlJykge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH1cblxuICAgIC8vIDQuIFJlbW92ZSB0aGUgbGFzdCA2IGNvZGUgcG9pbnRzIGZyb20gbWltZVR5cGUuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5zbGljZSgwLCAtNilcblxuICAgIC8vIDUuIFJlbW92ZSB0cmFpbGluZyBVKzAwMjAgU1BBQ0UgY29kZSBwb2ludHMgZnJvbSBtaW1lVHlwZSxcbiAgICAvLyBpZiBhbnkuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC8oXFx1MDAyMCkrJC8sICcnKVxuXG4gICAgLy8gNi4gUmVtb3ZlIHRoZSBsYXN0IFUrMDAzQiAoOykgY29kZSBwb2ludCBmcm9tIG1pbWVUeXBlLlxuICAgIG1pbWVUeXBlID0gbWltZVR5cGUuc2xpY2UoMCwgLTEpXG4gIH1cblxuICAvLyAxMi4gSWYgbWltZVR5cGUgc3RhcnRzIHdpdGggVSswMDNCICg7KSwgdGhlbiBwcmVwZW5kXG4gIC8vIFwidGV4dC9wbGFpblwiIHRvIG1pbWVUeXBlLlxuICBpZiAobWltZVR5cGUuc3RhcnRzV2l0aCgnOycpKSB7XG4gICAgbWltZVR5cGUgPSAndGV4dC9wbGFpbicgKyBtaW1lVHlwZVxuICB9XG5cbiAgLy8gMTMuIExldCBtaW1lVHlwZVJlY29yZCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmdcbiAgLy8gbWltZVR5cGUuXG4gIGxldCBtaW1lVHlwZVJlY29yZCA9IHBhcnNlTUlNRVR5cGUobWltZVR5cGUpXG5cbiAgLy8gMTQuIElmIG1pbWVUeXBlUmVjb3JkIGlzIGZhaWx1cmUsIHRoZW4gc2V0XG4gIC8vIG1pbWVUeXBlUmVjb3JkIHRvIHRleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSS5cbiAgaWYgKG1pbWVUeXBlUmVjb3JkID09PSAnZmFpbHVyZScpIHtcbiAgICBtaW1lVHlwZVJlY29yZCA9IHBhcnNlTUlNRVR5cGUoJ3RleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSScpXG4gIH1cblxuICAvLyAxNS4gUmV0dXJuIGEgbmV3IGRhdGE6IFVSTCBzdHJ1Y3Qgd2hvc2UgTUlNRVxuICAvLyB0eXBlIGlzIG1pbWVUeXBlUmVjb3JkIGFuZCBib2R5IGlzIGJvZHkuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkYXRhLXVybC1zdHJ1Y3RcbiAgcmV0dXJuIHsgbWltZVR5cGU6IG1pbWVUeXBlUmVjb3JkLCBib2R5IH1cbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXVybC1zZXJpYWxpemVyXG4vKipcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhjbHVkZUZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIFVSTFNlcmlhbGl6ZXIgKHVybCwgZXhjbHVkZUZyYWdtZW50ID0gZmFsc2UpIHtcbiAgY29uc3QgaHJlZiA9IHVybC5ocmVmXG5cbiAgaWYgKCFleGNsdWRlRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gaHJlZlxuICB9XG5cbiAgY29uc3QgaGFzaCA9IGhyZWYubGFzdEluZGV4T2YoJyMnKVxuICBpZiAoaGFzaCA9PT0gLTEpIHtcbiAgICByZXR1cm4gaHJlZlxuICB9XG4gIHJldHVybiBocmVmLnNsaWNlKDAsIGhhc2gpXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjb2xsZWN0LWEtc2VxdWVuY2Utb2YtY29kZS1wb2ludHNcbi8qKlxuICogQHBhcmFtIHsoY2hhcjogc3RyaW5nKSA9PiBib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyAoY29uZGl0aW9uLCBpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgcmVzdWx0ID0gJydcblxuICAvLyAyLiBXaGlsZSBwb3NpdGlvbiBkb2VzbuKAmXQgcG9pbnQgcGFzdCB0aGUgZW5kIG9mIGlucHV0IGFuZCB0aGVcbiAgLy8gY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgbWVldHMgdGhlIGNvbmRpdGlvbiBjb25kaXRpb246XG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCAmJiBjb25kaXRpb24oaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dKSkge1xuICAgIC8vIDEuIEFwcGVuZCB0aGF0IGNvZGUgcG9pbnQgdG8gdGhlIGVuZCBvZiByZXN1bHQuXG4gICAgcmVzdWx0ICs9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgLy8gMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgfVxuXG4gIC8vIDMuIFJldHVybiByZXN1bHQuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBBIGZhc3RlciBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzIHRoYXQgb25seSB3b3JrcyB3aGVuIGNvbXBhcmluZyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCAoY2hhciwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGlkeCA9IGlucHV0LmluZGV4T2YoY2hhciwgcG9zaXRpb24ucG9zaXRpb24pXG4gIGNvbnN0IHN0YXJ0ID0gcG9zaXRpb24ucG9zaXRpb25cblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHBvc2l0aW9uLnBvc2l0aW9uID0gaW5wdXQubGVuZ3RoXG4gICAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0KVxuICB9XG5cbiAgcG9zaXRpb24ucG9zaXRpb24gPSBpZHhcbiAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbi5wb3NpdGlvbilcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNzdHJpbmctcGVyY2VudC1kZWNvZGVcbi8qKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgKi9cbmZ1bmN0aW9uIHN0cmluZ1BlcmNlbnREZWNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIExldCBieXRlcyBiZSB0aGUgVVRGLTggZW5jb2Rpbmcgb2YgaW5wdXQuXG4gIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoaW5wdXQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBwZXJjZW50LWRlY29kaW5nIG9mIGJ5dGVzLlxuICByZXR1cm4gcGVyY2VudERlY29kZShieXRlcylcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNwZXJjZW50LWRlY29kZVxuLyoqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXQgKi9cbmZ1bmN0aW9uIHBlcmNlbnREZWNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgLyoqIEB0eXBlIHtudW1iZXJbXX0gKi9cbiAgY29uc3Qgb3V0cHV0ID0gW11cblxuICAvLyAyLiBGb3IgZWFjaCBieXRlIGJ5dGUgaW4gaW5wdXQ6XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBieXRlID0gaW5wdXRbaV1cblxuICAgIC8vIDEuIElmIGJ5dGUgaXMgbm90IDB4MjUgKCUpLCB0aGVuIGFwcGVuZCBieXRlIHRvIG91dHB1dC5cbiAgICBpZiAoYnl0ZSAhPT0gMHgyNSkge1xuICAgICAgb3V0cHV0LnB1c2goYnl0ZSlcblxuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgYnl0ZSBpcyAweDI1ICglKSBhbmQgdGhlIG5leHQgdHdvIGJ5dGVzXG4gICAgLy8gYWZ0ZXIgYnl0ZSBpbiBpbnB1dCBhcmUgbm90IGluIHRoZSByYW5nZXNcbiAgICAvLyAweDMwICgwKSB0byAweDM5ICg5KSwgMHg0MSAoQSkgdG8gMHg0NiAoRiksXG4gICAgLy8gYW5kIDB4NjEgKGEpIHRvIDB4NjYgKGYpLCBhbGwgaW5jbHVzaXZlLCBhcHBlbmQgYnl0ZVxuICAgIC8vIHRvIG91dHB1dC5cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYnl0ZSA9PT0gMHgyNSAmJlxuICAgICAgIS9eWzAtOUEtRmEtZl17Mn0kL2kudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0W2kgKyAxXSwgaW5wdXRbaSArIDJdKSlcbiAgICApIHtcbiAgICAgIG91dHB1dC5wdXNoKDB4MjUpXG5cbiAgICAvLyAzLiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIExldCBieXRlUG9pbnQgYmUgdGhlIHR3byBieXRlcyBhZnRlciBieXRlIGluIGlucHV0LFxuICAgICAgLy8gZGVjb2RlZCwgYW5kIHRoZW4gaW50ZXJwcmV0ZWQgYXMgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICAgICAgY29uc3QgbmV4dFR3b0J5dGVzID0gU3RyaW5nLmZyb21DaGFyQ29kZShpbnB1dFtpICsgMV0sIGlucHV0W2kgKyAyXSlcbiAgICAgIGNvbnN0IGJ5dGVQb2ludCA9IE51bWJlci5wYXJzZUludChuZXh0VHdvQnl0ZXMsIDE2KVxuXG4gICAgICAvLyAyLiBBcHBlbmQgYSBieXRlIHdob3NlIHZhbHVlIGlzIGJ5dGVQb2ludCB0byBvdXRwdXQuXG4gICAgICBvdXRwdXQucHVzaChieXRlUG9pbnQpXG5cbiAgICAgIC8vIDMuIFNraXAgdGhlIG5leHQgdHdvIGJ5dGVzIGluIGlucHV0LlxuICAgICAgaSArPSAyXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIG91dHB1dC5cbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShvdXRwdXQpXG59XG5cbi8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jcGFyc2UtYS1taW1lLXR5cGVcbi8qKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgKi9cbmZ1bmN0aW9uIHBhcnNlTUlNRVR5cGUgKGlucHV0KSB7XG4gIC8vIDEuIFJlbW92ZSBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlXG4gIC8vIGZyb20gaW5wdXQuXG4gIGlucHV0ID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2UoaW5wdXQsIHRydWUsIHRydWUpXG5cbiAgLy8gMi4gTGV0IHBvc2l0aW9uIGJlIGEgcG9zaXRpb24gdmFyaWFibGUgZm9yIGlucHV0LFxuICAvLyBpbml0aWFsbHkgcG9pbnRpbmcgYXQgdGhlIHN0YXJ0IG9mIGlucHV0LlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIDMuIExldCB0eXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlXG4gIC8vIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwMkYgKC8pIGZyb21cbiAgLy8gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICBjb25zdCB0eXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgJy8nLFxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA0LiBJZiB0eXBlIGlzIHRoZSBlbXB0eSBzdHJpbmcgb3IgZG9lcyBub3Qgc29sZWx5XG4gIC8vIGNvbnRhaW4gSFRUUCB0b2tlbiBjb2RlIHBvaW50cywgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXRva2VuLWNvZGUtcG9pbnRcbiAgaWYgKHR5cGUubGVuZ3RoID09PSAwIHx8ICFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdCh0eXBlKSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDUuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiByZXR1cm5cbiAgLy8gZmFpbHVyZVxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPiBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA2LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuIChUaGlzIHNraXBzIHBhc3QgVSswMDJGICgvKS4pXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyA3LiBMZXQgc3VidHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZlxuICAvLyBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDNCICg7KSBmcm9tIGlucHV0LCBnaXZlblxuICAvLyBwb3NpdGlvbi5cbiAgbGV0IHN1YnR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAnOycsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDguIFJlbW92ZSBhbnkgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlIGZyb20gc3VidHlwZS5cbiAgc3VidHlwZSA9IHJlbW92ZUhUVFBXaGl0ZXNwYWNlKHN1YnR5cGUsIGZhbHNlLCB0cnVlKVxuXG4gIC8vIDkuIElmIHN1YnR5cGUgaXMgdGhlIGVtcHR5IHN0cmluZyBvciBkb2VzIG5vdCBzb2xlbHlcbiAgLy8gY29udGFpbiBIVFRQIHRva2VuIGNvZGUgcG9pbnRzLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoc3VidHlwZS5sZW5ndGggPT09IDAgfHwgIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgY29uc3QgdHlwZUxvd2VyY2FzZSA9IHR5cGUudG9Mb3dlckNhc2UoKVxuICBjb25zdCBzdWJ0eXBlTG93ZXJjYXNlID0gc3VidHlwZS50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gMTAuIExldCBtaW1lVHlwZSBiZSBhIG5ldyBNSU1FIHR5cGUgcmVjb3JkIHdob3NlIHR5cGVcbiAgLy8gaXMgdHlwZSwgaW4gQVNDSUkgbG93ZXJjYXNlLCBhbmQgc3VidHlwZSBpcyBzdWJ0eXBlLFxuICAvLyBpbiBBU0NJSSBsb3dlcmNhc2UuXG4gIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jbWltZS10eXBlXG4gIGNvbnN0IG1pbWVUeXBlID0ge1xuICAgIHR5cGU6IHR5cGVMb3dlcmNhc2UsXG4gICAgc3VidHlwZTogc3VidHlwZUxvd2VyY2FzZSxcbiAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgcGFyYW1ldGVyczogbmV3IE1hcCgpLFxuICAgIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jbWltZS10eXBlLWVzc2VuY2VcbiAgICBlc3NlbmNlOiBgJHt0eXBlTG93ZXJjYXNlfS8ke3N1YnR5cGVMb3dlcmNhc2V9YFxuICB9XG5cbiAgLy8gMTEuIFdoaWxlIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQ6XG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgIC8vIDEuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwM0IgKDspLilcbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyAyLiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUFxuICAgIC8vIHdoaXRlc3BhY2UgZnJvbSBpbnB1dCBnaXZlbiBwb3NpdGlvbi5cbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtd2hpdGVzcGFjZVxuICAgICAgY2hhciA9PiBIVFRQX1dISVRFU1BBQ0VfUkVHRVgudGVzdChjaGFyKSxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyAzLiBMZXQgcGFyYW1ldGVyTmFtZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYVxuICAgIC8vIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspXG4gICAgLy8gb3IgVSswMDNEICg9KSBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgICBsZXQgcGFyYW1ldGVyTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gJzsnICYmIGNoYXIgIT09ICc9JyxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyA0LiBTZXQgcGFyYW1ldGVyTmFtZSB0byBwYXJhbWV0ZXJOYW1lLCBpbiBBU0NJSVxuICAgIC8vIGxvd2VyY2FzZS5cbiAgICBwYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyA1LiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuOlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgLy8gMS4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzXG4gICAgICAvLyBVKzAwM0IgKDspLCB0aGVuIGNvbnRpbnVlLlxuICAgICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJzsnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwM0QgKD0pLilcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgICB9XG5cbiAgICAvLyA2LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gYnJlYWsuXG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIDcuIExldCBwYXJhbWV0ZXJWYWx1ZSBiZSBudWxsLlxuICAgIGxldCBwYXJhbWV0ZXJWYWx1ZSA9IG51bGxcblxuICAgIC8vIDguIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpc1xuICAgIC8vIFUrMDAyMiAoXCIpLCB0aGVuOlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICdcIicpIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGFuIEhUVFAgcXVvdGVkIHN0cmluZyBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvblxuICAgICAgLy8gYW5kIHRoZSBleHRyYWN0LXZhbHVlIGZsYWcuXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcoaW5wdXQsIHBvc2l0aW9uLCB0cnVlKVxuXG4gICAgICAvLyAyLiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90XG4gICAgICAvLyBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAgICc7JyxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICApXG5cbiAgICAvLyA5LiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAgIC8vIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICAgJzsnLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIClcblxuICAgICAgLy8gMi4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBwYXJhbWV0ZXJWYWx1ZS5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2UocGFyYW1ldGVyVmFsdWUsIGZhbHNlLCB0cnVlKVxuXG4gICAgICAvLyAzLiBJZiBwYXJhbWV0ZXJWYWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIGNvbnRpbnVlLlxuICAgICAgaWYgKHBhcmFtZXRlclZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEwLiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZVxuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBzb2xlbHkgY29udGFpbnMgSFRUUCB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gcGFyYW1ldGVyVmFsdWUgc29sZWx5IGNvbnRhaW5zIEhUVFAgcXVvdGVkLXN0cmluZyB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gZG9lcyBub3QgZXhpc3RcbiAgICAvLyB0aGVuIHNldCBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSB0byBwYXJhbWV0ZXJWYWx1ZS5cbiAgICBpZiAoXG4gICAgICBwYXJhbWV0ZXJOYW1lLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QocGFyYW1ldGVyTmFtZSkgJiZcbiAgICAgIChwYXJhbWV0ZXJWYWx1ZS5sZW5ndGggPT09IDAgfHwgSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUy50ZXN0KHBhcmFtZXRlclZhbHVlKSkgJiZcbiAgICAgICFtaW1lVHlwZS5wYXJhbWV0ZXJzLmhhcyhwYXJhbWV0ZXJOYW1lKVxuICAgICkge1xuICAgICAgbWltZVR5cGUucGFyYW1ldGVycy5zZXQocGFyYW1ldGVyTmFtZSwgcGFyYW1ldGVyVmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNmb3JnaXZpbmctYmFzZTY0LWRlY29kZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICovXG5mdW5jdGlvbiBmb3JnaXZpbmdCYXNlNjQgKGRhdGEpIHtcbiAgLy8gMS4gUmVtb3ZlIGFsbCBBU0NJSSB3aGl0ZXNwYWNlIGZyb20gZGF0YS5cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvW1xcdTAwMDlcXHUwMDBBXFx1MDAwQ1xcdTAwMERcXHUwMDIwXS9nLCAnJykgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvLyAyLiBJZiBkYXRh4oCZcyBjb2RlIHBvaW50IGxlbmd0aCBkaXZpZGVzIGJ5IDQgbGVhdmluZ1xuICAvLyBubyByZW1haW5kZXIsIHRoZW46XG4gIGlmIChkYXRhLmxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAvLyAxLiBJZiBkYXRhIGVuZHMgd2l0aCBvbmUgb3IgdHdvIFUrMDAzRCAoPSkgY29kZSBwb2ludHMsXG4gICAgLy8gdGhlbiByZW1vdmUgdGhlbSBmcm9tIGRhdGEuXG4gICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvPT89JC8sICcnKVxuICB9XG5cbiAgLy8gMy4gSWYgZGF0YeKAmXMgY29kZSBwb2ludCBsZW5ndGggZGl2aWRlcyBieSA0IGxlYXZpbmdcbiAgLy8gYSByZW1haW5kZXIgb2YgMSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKGRhdGEubGVuZ3RoICUgNCA9PT0gMSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDQuIElmIGRhdGEgY29udGFpbnMgYSBjb2RlIHBvaW50IHRoYXQgaXMgbm90IG9uZSBvZlxuICAvLyAgVSswMDJCICgrKVxuICAvLyAgVSswMDJGICgvKVxuICAvLyAgQVNDSUkgYWxwaGFudW1lcmljXG4gIC8vIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmICgvW14rLzAtOUEtWmEtel0vLnRlc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCBiaW5hcnkgPSBhdG9iKGRhdGEpXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aClcblxuICBmb3IgKGxldCBieXRlID0gMDsgYnl0ZSA8IGJpbmFyeS5sZW5ndGg7IGJ5dGUrKykge1xuICAgIGJ5dGVzW2J5dGVdID0gYmluYXJ5LmNoYXJDb2RlQXQoYnl0ZSlcbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29sbGVjdC1hbi1odHRwLXF1b3RlZC1zdHJpbmdcbi8vIHRlc3RzOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZXhhbXBsZS1odHRwLXF1b3RlZC1zdHJpbmdcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFuP30gZXh0cmFjdFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcgKGlucHV0LCBwb3NpdGlvbiwgZXh0cmFjdFZhbHVlKSB7XG4gIC8vIDEuIExldCBwb3NpdGlvblN0YXJ0IGJlIHBvc2l0aW9uLlxuICBjb25zdCBwb3NpdGlvblN0YXJ0ID0gcG9zaXRpb24ucG9zaXRpb25cblxuICAvLyAyLiBMZXQgdmFsdWUgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgbGV0IHZhbHVlID0gJydcblxuICAvLyAzLiBBc3NlcnQ6IHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dFxuICAvLyBpcyBVKzAwMjIgKFwiKS5cbiAgYXNzZXJ0KGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJ1wiJylcblxuICAvLyA0LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyA1LiBXaGlsZSB0cnVlOlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIDEuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50c1xuICAgIC8vIHRoYXQgYXJlIG5vdCBVKzAwMjIgKFwiKSBvciBVKzAwNUMgKFxcKSBmcm9tIGlucHV0LCBnaXZlblxuICAgIC8vIHBvc2l0aW9uLCB0byB2YWx1ZS5cbiAgICB2YWx1ZSArPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09ICdcIicgJiYgY2hhciAhPT0gJ1xcXFwnLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBicmVhay5cbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIDMuIExldCBxdW90ZU9yQmFja3NsYXNoIGJlIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpblxuICAgIC8vIGlucHV0LlxuICAgIGNvbnN0IHF1b3RlT3JCYWNrc2xhc2ggPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl1cblxuICAgIC8vIDQuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyA1LiBJZiBxdW90ZU9yQmFja3NsYXNoIGlzIFUrMDA1QyAoXFwpLCB0aGVuOlxuICAgIGlmIChxdW90ZU9yQmFja3NsYXNoID09PSAnXFxcXCcpIHtcbiAgICAgIC8vIDEuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBhcHBlbmRcbiAgICAgIC8vIFUrMDA1QyAoXFwpIHRvIHZhbHVlIGFuZCBicmVhay5cbiAgICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgKz0gJ1xcXFwnXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFwcGVuZCB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgdG8gdmFsdWUuXG4gICAgICB2YWx1ZSArPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl1cblxuICAgICAgLy8gMy4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gICAgLy8gNi4gT3RoZXJ3aXNlOlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAxLiBBc3NlcnQ6IHF1b3RlT3JCYWNrc2xhc2ggaXMgVSswMDIyIChcIikuXG4gICAgICBhc3NlcnQocXVvdGVPckJhY2tzbGFzaCA9PT0gJ1wiJylcblxuICAgICAgLy8gMi4gQnJlYWsuXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIDYuIElmIHRoZSBleHRyYWN0LXZhbHVlIGZsYWcgaXMgc2V0LCB0aGVuIHJldHVybiB2YWx1ZS5cbiAgaWYgKGV4dHJhY3RWYWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gNy4gUmV0dXJuIHRoZSBjb2RlIHBvaW50cyBmcm9tIHBvc2l0aW9uU3RhcnQgdG8gcG9zaXRpb24sXG4gIC8vIGluY2x1c2l2ZSwgd2l0aGluIGlucHV0LlxuICByZXR1cm4gaW5wdXQuc2xpY2UocG9zaXRpb25TdGFydCwgcG9zaXRpb24ucG9zaXRpb24pXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI3NlcmlhbGl6ZS1hLW1pbWUtdHlwZVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVBTWltZVR5cGUgKG1pbWVUeXBlKSB7XG4gIGFzc2VydChtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnKVxuICBjb25zdCB7IHBhcmFtZXRlcnMsIGVzc2VuY2UgfSA9IG1pbWVUeXBlXG5cbiAgLy8gMS4gTGV0IHNlcmlhbGl6YXRpb24gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgbWltZVR5cGXigJlzXG4gIC8vICAgIHR5cGUsIFUrMDAyRiAoLyksIGFuZCBtaW1lVHlwZeKAmXMgc3VidHlwZS5cbiAgbGV0IHNlcmlhbGl6YXRpb24gPSBlc3NlbmNlXG5cbiAgLy8gMi4gRm9yIGVhY2ggbmFtZSDihpIgdmFsdWUgb2YgbWltZVR5cGXigJlzIHBhcmFtZXRlcnM6XG4gIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgcGFyYW1ldGVycy5lbnRyaWVzKCkpIHtcbiAgICAvLyAxLiBBcHBlbmQgVSswMDNCICg7KSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gJzsnXG5cbiAgICAvLyAyLiBBcHBlbmQgbmFtZSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gbmFtZVxuXG4gICAgLy8gMy4gQXBwZW5kIFUrMDAzRCAoPSkgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9ICc9J1xuXG4gICAgLy8gNC4gSWYgdmFsdWUgZG9lcyBub3Qgc29sZWx5IGNvbnRhaW4gSFRUUCB0b2tlbiBjb2RlXG4gICAgLy8gICAgcG9pbnRzIG9yIHZhbHVlIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW46XG4gICAgaWYgKCFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdCh2YWx1ZSkpIHtcbiAgICAgIC8vIDEuIFByZWNlZGUgZWFjaCBvY2N1cmVuY2Ugb2YgVSswMDIyIChcIikgb3JcbiAgICAgIC8vICAgIFUrMDA1QyAoXFwpIGluIHZhbHVlIHdpdGggVSswMDVDIChcXCkuXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXFxcfFwiKS9nLCAnXFxcXCQxJylcblxuICAgICAgLy8gMi4gUHJlcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlID0gJ1wiJyArIHZhbHVlXG5cbiAgICAgIC8vIDMuIEFwcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlICs9ICdcIidcbiAgICB9XG5cbiAgICAvLyA1LiBBcHBlbmQgdmFsdWUgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9IHZhbHVlXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gc2VyaWFsaXphdGlvbi5cbiAgcmV0dXJuIHNlcmlhbGl6YXRpb25cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzSFRUUFdoaXRlU3BhY2UgKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIgPT09ICdcXHInIHx8IGNoYXIgPT09ICdcXG4nIHx8IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJ1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtd2hpdGVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiByZW1vdmVIVFRQV2hpdGVzcGFjZSAoc3RyLCBsZWFkaW5nID0gdHJ1ZSwgdHJhaWxpbmcgPSB0cnVlKSB7XG4gIGxldCBsZWFkID0gMFxuICBsZXQgdHJhaWwgPSBzdHIubGVuZ3RoIC0gMVxuXG4gIGlmIChsZWFkaW5nKSB7XG4gICAgZm9yICg7IGxlYWQgPCBzdHIubGVuZ3RoICYmIGlzSFRUUFdoaXRlU3BhY2Uoc3RyW2xlYWRdKTsgbGVhZCsrKTtcbiAgfVxuXG4gIGlmICh0cmFpbGluZykge1xuICAgIGZvciAoOyB0cmFpbCA+IDAgJiYgaXNIVFRQV2hpdGVTcGFjZShzdHJbdHJhaWxdKTsgdHJhaWwtLSk7XG4gIH1cblxuICByZXR1cm4gc3RyLnNsaWNlKGxlYWQsIHRyYWlsICsgMSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICovXG5mdW5jdGlvbiBpc0FTQ0lJV2hpdGVzcGFjZSAoY2hhcikge1xuICByZXR1cm4gY2hhciA9PT0gJ1xccicgfHwgY2hhciA9PT0gJ1xcbicgfHwgY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJ1xcZicgfHwgY2hhciA9PT0gJyAnXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtbGVhZGluZy1hbmQtdHJhaWxpbmctYXNjaWktd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiByZW1vdmVBU0NJSVdoaXRlc3BhY2UgKHN0ciwgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSkge1xuICBsZXQgbGVhZCA9IDBcbiAgbGV0IHRyYWlsID0gc3RyLmxlbmd0aCAtIDFcblxuICBpZiAobGVhZGluZykge1xuICAgIGZvciAoOyBsZWFkIDwgc3RyLmxlbmd0aCAmJiBpc0FTQ0lJV2hpdGVzcGFjZShzdHJbbGVhZF0pOyBsZWFkKyspO1xuICB9XG5cbiAgaWYgKHRyYWlsaW5nKSB7XG4gICAgZm9yICg7IHRyYWlsID4gMCAmJiBpc0FTQ0lJV2hpdGVzcGFjZShzdHJbdHJhaWxdKTsgdHJhaWwtLSk7XG4gIH1cblxuICByZXR1cm4gc3RyLnNsaWNlKGxlYWQsIHRyYWlsICsgMSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRhdGFVUkxQcm9jZXNzb3IsXG4gIFVSTFNlcmlhbGl6ZXIsXG4gIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMsXG4gIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0LFxuICBzdHJpbmdQZXJjZW50RGVjb2RlLFxuICBwYXJzZU1JTUVUeXBlLFxuICBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLFxuICBzZXJpYWxpemVBTWltZVR5cGVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/dataURL.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/file.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/fetch/file.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { types } = __webpack_require__(/*! util */ \"util\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/fetch/symbols.js\")\nconst { isBlobLike } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\nclass File extends Blob {\n  constructor (fileBits, fileName, options = {}) {\n    // The File constructor is invoked with two or three parameters, depending\n    // on whether the optional dictionary parameter is used. When the File()\n    // constructor is invoked, user agents must run the following steps:\n    webidl.argumentLengthCheck(arguments, 2, { header: 'File constructor' })\n\n    fileBits = webidl.converters['sequence<BlobPart>'](fileBits)\n    fileName = webidl.converters.USVString(fileName)\n    options = webidl.converters.FilePropertyBag(options)\n\n    // 1. Let bytes be the result of processing blob parts given fileBits and\n    // options.\n    // Note: Blob handles this for us\n\n    // 2. Let n be the fileName argument to the constructor.\n    const n = fileName\n\n    // 3. Process FilePropertyBag dictionary argument by running the following\n    // substeps:\n\n    //    1. If the type member is provided and is not the empty string, let t\n    //    be set to the type dictionary member. If t contains any characters\n    //    outside the range U+0020 to U+007E, then set t to the empty string\n    //    and return from these substeps.\n    //    2. Convert every character in t to ASCII lowercase.\n    let t = options.type\n    let d\n\n    // eslint-disable-next-line no-labels\n    substep: {\n      if (t) {\n        t = parseMIMEType(t)\n\n        if (t === 'failure') {\n          t = ''\n          // eslint-disable-next-line no-labels\n          break substep\n        }\n\n        t = serializeAMimeType(t).toLowerCase()\n      }\n\n      //    3. If the lastModified member is provided, let d be set to the\n      //    lastModified dictionary member. If it is not provided, set d to the\n      //    current date and time represented as the number of milliseconds since\n      //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n      d = options.lastModified\n    }\n\n    // 4. Return a new File object F such that:\n    // F refers to the bytes byte sequence.\n    // F.size is set to the number of total bytes in bytes.\n    // F.name is set to n.\n    // F.type is set to t.\n    // F.lastModified is set to d.\n\n    super(processBlobParts(fileBits, options), { type: t })\n    this[kState] = {\n      name: n,\n      lastModified: d,\n      type: t\n    }\n  }\n\n  get name () {\n    webidl.brandCheck(this, File)\n\n    return this[kState].name\n  }\n\n  get lastModified () {\n    webidl.brandCheck(this, File)\n\n    return this[kState].lastModified\n  }\n\n  get type () {\n    webidl.brandCheck(this, File)\n\n    return this[kState].type\n  }\n}\n\nclass FileLike {\n  constructor (blobLike, fileName, options = {}) {\n    // TODO: argument idl type check\n\n    // The File constructor is invoked with two or three parameters, depending\n    // on whether the optional dictionary parameter is used. When the File()\n    // constructor is invoked, user agents must run the following steps:\n\n    // 1. Let bytes be the result of processing blob parts given fileBits and\n    // options.\n\n    // 2. Let n be the fileName argument to the constructor.\n    const n = fileName\n\n    // 3. Process FilePropertyBag dictionary argument by running the following\n    // substeps:\n\n    //    1. If the type member is provided and is not the empty string, let t\n    //    be set to the type dictionary member. If t contains any characters\n    //    outside the range U+0020 to U+007E, then set t to the empty string\n    //    and return from these substeps.\n    //    TODO\n    const t = options.type\n\n    //    2. Convert every character in t to ASCII lowercase.\n    //    TODO\n\n    //    3. If the lastModified member is provided, let d be set to the\n    //    lastModified dictionary member. If it is not provided, set d to the\n    //    current date and time represented as the number of milliseconds since\n    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n    const d = options.lastModified ?? Date.now()\n\n    // 4. Return a new File object F such that:\n    // F refers to the bytes byte sequence.\n    // F.size is set to the number of total bytes in bytes.\n    // F.name is set to n.\n    // F.type is set to t.\n    // F.lastModified is set to d.\n\n    this[kState] = {\n      blobLike,\n      name: n,\n      type: t,\n      lastModified: d\n    }\n  }\n\n  stream (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.stream(...args)\n  }\n\n  arrayBuffer (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.arrayBuffer(...args)\n  }\n\n  slice (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.slice(...args)\n  }\n\n  text (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.text(...args)\n  }\n\n  get size () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.size\n  }\n\n  get type () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.type\n  }\n\n  get name () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].name\n  }\n\n  get lastModified () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n}\n\nObject.defineProperties(File.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'File',\n    configurable: true\n  },\n  name: kEnumerableProperty,\n  lastModified: kEnumerableProperty\n})\n\nwebidl.converters.Blob = webidl.interfaceConverter(Blob)\n\nwebidl.converters.BlobPart = function (V, opts) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (\n      ArrayBuffer.isView(V) ||\n      types.isAnyArrayBuffer(V)\n    ) {\n      return webidl.converters.BufferSource(V, opts)\n    }\n  }\n\n  return webidl.converters.USVString(V, opts)\n}\n\nwebidl.converters['sequence<BlobPart>'] = webidl.sequenceConverter(\n  webidl.converters.BlobPart\n)\n\n// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag\nwebidl.converters.FilePropertyBag = webidl.dictionaryConverter([\n  {\n    key: 'lastModified',\n    converter: webidl.converters['long long'],\n    get defaultValue () {\n      return Date.now()\n    }\n  },\n  {\n    key: 'type',\n    converter: webidl.converters.DOMString,\n    defaultValue: ''\n  },\n  {\n    key: 'endings',\n    converter: (value) => {\n      value = webidl.converters.DOMString(value)\n      value = value.toLowerCase()\n\n      if (value !== 'native') {\n        value = 'transparent'\n      }\n\n      return value\n    },\n    defaultValue: 'transparent'\n  }\n])\n\n/**\n * @see https://www.w3.org/TR/FileAPI/#process-blob-parts\n * @param {(NodeJS.TypedArray|Blob|string)[]} parts\n * @param {{ type: string, endings: string }} options\n */\nfunction processBlobParts (parts, options) {\n  // 1. Let bytes be an empty sequence of bytes.\n  /** @type {NodeJS.TypedArray[]} */\n  const bytes = []\n\n  // 2. For each element in parts:\n  for (const element of parts) {\n    // 1. If element is a USVString, run the following substeps:\n    if (typeof element === 'string') {\n      // 1. Let s be element.\n      let s = element\n\n      // 2. If the endings member of options is \"native\", set s\n      //    to the result of converting line endings to native\n      //    of element.\n      if (options.endings === 'native') {\n        s = convertLineEndingsNative(s)\n      }\n\n      // 3. Append the result of UTF-8 encoding s to bytes.\n      bytes.push(new TextEncoder().encode(s))\n    } else if (\n      types.isAnyArrayBuffer(element) ||\n      types.isTypedArray(element)\n    ) {\n      // 2. If element is a BufferSource, get a copy of the\n      //    bytes held by the buffer source, and append those\n      //    bytes to bytes.\n      if (!element.buffer) { // ArrayBuffer\n        bytes.push(new Uint8Array(element))\n      } else {\n        bytes.push(\n          new Uint8Array(element.buffer, element.byteOffset, element.byteLength)\n        )\n      }\n    } else if (isBlobLike(element)) {\n      // 3. If element is a Blob, append the bytes it represents\n      //    to bytes.\n      bytes.push(element)\n    }\n  }\n\n  // 3. Return bytes.\n  return bytes\n}\n\n/**\n * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native\n * @param {string} s\n */\nfunction convertLineEndingsNative (s) {\n  // 1. Let native line ending be be the code point U+000A LF.\n  let nativeLineEnding = '\\n'\n\n  // 2. If the underlying platforms conventions are to\n  //    represent newlines as a carriage return and line feed\n  //    sequence, set native line ending to the code point\n  //    U+000D CR followed by the code point U+000A LF.\n  if (process.platform === 'win32') {\n    nativeLineEnding = '\\r\\n'\n  }\n\n  return s.replace(/\\r?\\n/g, nativeLineEnding)\n}\n\n// If this function is moved to ./util.js, some tools (such as\n// rollup) will warn about circular dependencies. See:\n// https://github.com/nodejs/undici/issues/1629\nfunction isFileLike (object) {\n  return (\n    (NativeFile && object instanceof NativeFile) ||\n    object instanceof File || (\n      object &&\n      (typeof object.stream === 'function' ||\n      typeof object.arrayBuffer === 'function') &&\n      object[Symbol.toStringTag] === 'File'\n    )\n  )\n}\n\nmodule.exports = { File, FileLike, isFileLike }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9maWxlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuRCxRQUFRLFFBQVEsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ2hDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsbUVBQVc7QUFDdEMsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyw2REFBUTtBQUN2QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLGlFQUFVO0FBQ3JDLFFBQVEsb0NBQW9DLEVBQUUsbUJBQU8sQ0FBQyxtRUFBVztBQUNqRSxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsa0VBQWM7O0FBRXREO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0QkFBNEI7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxhQUFhLGlDQUFpQztBQUM5QztBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2ZpbGUuanM/MzE0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCbG9iLCBGaWxlOiBOYXRpdmVGaWxlIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCB7IGtTdGF0ZSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgaXNCbG9iTGlrZSB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IHBhcnNlTUlNRVR5cGUsIHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhVVJMJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuY2xhc3MgRmlsZSBleHRlbmRzIEJsb2Ige1xuICBjb25zdHJ1Y3RvciAoZmlsZUJpdHMsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBUaGUgRmlsZSBjb25zdHJ1Y3RvciBpcyBpbnZva2VkIHdpdGggdHdvIG9yIHRocmVlIHBhcmFtZXRlcnMsIGRlcGVuZGluZ1xuICAgIC8vIG9uIHdoZXRoZXIgdGhlIG9wdGlvbmFsIGRpY3Rpb25hcnkgcGFyYW1ldGVyIGlzIHVzZWQuIFdoZW4gdGhlIEZpbGUoKVxuICAgIC8vIGNvbnN0cnVjdG9yIGlzIGludm9rZWQsIHVzZXIgYWdlbnRzIG11c3QgcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ0ZpbGUgY29uc3RydWN0b3InIH0pXG5cbiAgICBmaWxlQml0cyA9IHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCbG9iUGFydD4nXShmaWxlQml0cylcbiAgICBmaWxlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlTmFtZSlcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuRmlsZVByb3BlcnR5QmFnKG9wdGlvbnMpXG5cbiAgICAvLyAxLiBMZXQgYnl0ZXMgYmUgdGhlIHJlc3VsdCBvZiBwcm9jZXNzaW5nIGJsb2IgcGFydHMgZ2l2ZW4gZmlsZUJpdHMgYW5kXG4gICAgLy8gb3B0aW9ucy5cbiAgICAvLyBOb3RlOiBCbG9iIGhhbmRsZXMgdGhpcyBmb3IgdXNcblxuICAgIC8vIDIuIExldCBuIGJlIHRoZSBmaWxlTmFtZSBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgY29uc3QgbiA9IGZpbGVOYW1lXG5cbiAgICAvLyAzLiBQcm9jZXNzIEZpbGVQcm9wZXJ0eUJhZyBkaWN0aW9uYXJ5IGFyZ3VtZW50IGJ5IHJ1bm5pbmcgdGhlIGZvbGxvd2luZ1xuICAgIC8vIHN1YnN0ZXBzOlxuXG4gICAgLy8gICAgMS4gSWYgdGhlIHR5cGUgbWVtYmVyIGlzIHByb3ZpZGVkIGFuZCBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IHRcbiAgICAvLyAgICBiZSBzZXQgdG8gdGhlIHR5cGUgZGljdGlvbmFyeSBtZW1iZXIuIElmIHQgY29udGFpbnMgYW55IGNoYXJhY3RlcnNcbiAgICAvLyAgICBvdXRzaWRlIHRoZSByYW5nZSBVKzAwMjAgdG8gVSswMDdFLCB0aGVuIHNldCB0IHRvIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAvLyAgICBhbmQgcmV0dXJuIGZyb20gdGhlc2Ugc3Vic3RlcHMuXG4gICAgLy8gICAgMi4gQ29udmVydCBldmVyeSBjaGFyYWN0ZXIgaW4gdCB0byBBU0NJSSBsb3dlcmNhc2UuXG4gICAgbGV0IHQgPSBvcHRpb25zLnR5cGVcbiAgICBsZXQgZFxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgIHN1YnN0ZXA6IHtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHQgPSBwYXJzZU1JTUVUeXBlKHQpXG5cbiAgICAgICAgaWYgKHQgPT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIHQgPSAnJ1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICBicmVhayBzdWJzdGVwXG4gICAgICAgIH1cblxuICAgICAgICB0ID0gc2VyaWFsaXplQU1pbWVUeXBlKHQpLnRvTG93ZXJDYXNlKClcbiAgICAgIH1cblxuICAgICAgLy8gICAgMy4gSWYgdGhlIGxhc3RNb2RpZmllZCBtZW1iZXIgaXMgcHJvdmlkZWQsIGxldCBkIGJlIHNldCB0byB0aGVcbiAgICAgIC8vICAgIGxhc3RNb2RpZmllZCBkaWN0aW9uYXJ5IG1lbWJlci4gSWYgaXQgaXMgbm90IHByb3ZpZGVkLCBzZXQgZCB0byB0aGVcbiAgICAgIC8vICAgIGN1cnJlbnQgZGF0ZSBhbmQgdGltZSByZXByZXNlbnRlZCBhcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZVxuICAgICAgLy8gICAgdGhlIFVuaXggRXBvY2ggKHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIERhdGUubm93KCkgW0VDTUEtMjYyXSkuXG4gICAgICBkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWRcbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4gYSBuZXcgRmlsZSBvYmplY3QgRiBzdWNoIHRoYXQ6XG4gICAgLy8gRiByZWZlcnMgdG8gdGhlIGJ5dGVzIGJ5dGUgc2VxdWVuY2UuXG4gICAgLy8gRi5zaXplIGlzIHNldCB0byB0aGUgbnVtYmVyIG9mIHRvdGFsIGJ5dGVzIGluIGJ5dGVzLlxuICAgIC8vIEYubmFtZSBpcyBzZXQgdG8gbi5cbiAgICAvLyBGLnR5cGUgaXMgc2V0IHRvIHQuXG4gICAgLy8gRi5sYXN0TW9kaWZpZWQgaXMgc2V0IHRvIGQuXG5cbiAgICBzdXBlcihwcm9jZXNzQmxvYlBhcnRzKGZpbGVCaXRzLCBvcHRpb25zKSwgeyB0eXBlOiB0IH0pXG4gICAgdGhpc1trU3RhdGVdID0ge1xuICAgICAgbmFtZTogbixcbiAgICAgIGxhc3RNb2RpZmllZDogZCxcbiAgICAgIHR5cGU6IHRcbiAgICB9XG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubmFtZVxuICB9XG5cbiAgZ2V0IGxhc3RNb2RpZmllZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubGFzdE1vZGlmaWVkXG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udHlwZVxuICB9XG59XG5cbmNsYXNzIEZpbGVMaWtlIHtcbiAgY29uc3RydWN0b3IgKGJsb2JMaWtlLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gVE9ETzogYXJndW1lbnQgaWRsIHR5cGUgY2hlY2tcblxuICAgIC8vIFRoZSBGaWxlIGNvbnN0cnVjdG9yIGlzIGludm9rZWQgd2l0aCB0d28gb3IgdGhyZWUgcGFyYW1ldGVycywgZGVwZW5kaW5nXG4gICAgLy8gb24gd2hldGhlciB0aGUgb3B0aW9uYWwgZGljdGlvbmFyeSBwYXJhbWV0ZXIgaXMgdXNlZC4gV2hlbiB0aGUgRmlsZSgpXG4gICAgLy8gY29uc3RydWN0b3IgaXMgaW52b2tlZCwgdXNlciBhZ2VudHMgbXVzdCBydW4gdGhlIGZvbGxvd2luZyBzdGVwczpcblxuICAgIC8vIDEuIExldCBieXRlcyBiZSB0aGUgcmVzdWx0IG9mIHByb2Nlc3NpbmcgYmxvYiBwYXJ0cyBnaXZlbiBmaWxlQml0cyBhbmRcbiAgICAvLyBvcHRpb25zLlxuXG4gICAgLy8gMi4gTGV0IG4gYmUgdGhlIGZpbGVOYW1lIGFyZ3VtZW50IHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdCBuID0gZmlsZU5hbWVcblxuICAgIC8vIDMuIFByb2Nlc3MgRmlsZVByb3BlcnR5QmFnIGRpY3Rpb25hcnkgYXJndW1lbnQgYnkgcnVubmluZyB0aGUgZm9sbG93aW5nXG4gICAgLy8gc3Vic3RlcHM6XG5cbiAgICAvLyAgICAxLiBJZiB0aGUgdHlwZSBtZW1iZXIgaXMgcHJvdmlkZWQgYW5kIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgdFxuICAgIC8vICAgIGJlIHNldCB0byB0aGUgdHlwZSBkaWN0aW9uYXJ5IG1lbWJlci4gSWYgdCBjb250YWlucyBhbnkgY2hhcmFjdGVyc1xuICAgIC8vICAgIG91dHNpZGUgdGhlIHJhbmdlIFUrMDAyMCB0byBVKzAwN0UsIHRoZW4gc2V0IHQgdG8gdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vICAgIGFuZCByZXR1cm4gZnJvbSB0aGVzZSBzdWJzdGVwcy5cbiAgICAvLyAgICBUT0RPXG4gICAgY29uc3QgdCA9IG9wdGlvbnMudHlwZVxuXG4gICAgLy8gICAgMi4gQ29udmVydCBldmVyeSBjaGFyYWN0ZXIgaW4gdCB0byBBU0NJSSBsb3dlcmNhc2UuXG4gICAgLy8gICAgVE9ET1xuXG4gICAgLy8gICAgMy4gSWYgdGhlIGxhc3RNb2RpZmllZCBtZW1iZXIgaXMgcHJvdmlkZWQsIGxldCBkIGJlIHNldCB0byB0aGVcbiAgICAvLyAgICBsYXN0TW9kaWZpZWQgZGljdGlvbmFyeSBtZW1iZXIuIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgc2V0IGQgdG8gdGhlXG4gICAgLy8gICAgY3VycmVudCBkYXRlIGFuZCB0aW1lIHJlcHJlc2VudGVkIGFzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlXG4gICAgLy8gICAgdGhlIFVuaXggRXBvY2ggKHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIERhdGUubm93KCkgW0VDTUEtMjYyXSkuXG4gICAgY29uc3QgZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID8/IERhdGUubm93KClcblxuICAgIC8vIDQuIFJldHVybiBhIG5ldyBGaWxlIG9iamVjdCBGIHN1Y2ggdGhhdDpcbiAgICAvLyBGIHJlZmVycyB0byB0aGUgYnl0ZXMgYnl0ZSBzZXF1ZW5jZS5cbiAgICAvLyBGLnNpemUgaXMgc2V0IHRvIHRoZSBudW1iZXIgb2YgdG90YWwgYnl0ZXMgaW4gYnl0ZXMuXG4gICAgLy8gRi5uYW1lIGlzIHNldCB0byBuLlxuICAgIC8vIEYudHlwZSBpcyBzZXQgdG8gdC5cbiAgICAvLyBGLmxhc3RNb2RpZmllZCBpcyBzZXQgdG8gZC5cblxuICAgIHRoaXNba1N0YXRlXSA9IHtcbiAgICAgIGJsb2JMaWtlLFxuICAgICAgbmFtZTogbixcbiAgICAgIHR5cGU6IHQsXG4gICAgICBsYXN0TW9kaWZpZWQ6IGRcbiAgICB9XG4gIH1cblxuICBzdHJlYW0gKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc3RyZWFtKC4uLmFyZ3MpXG4gIH1cblxuICBhcnJheUJ1ZmZlciAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5hcnJheUJ1ZmZlciguLi5hcmdzKVxuICB9XG5cbiAgc2xpY2UgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc2xpY2UoLi4uYXJncylcbiAgfVxuXG4gIHRleHQgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UudGV4dCguLi5hcmdzKVxuICB9XG5cbiAgZ2V0IHNpemUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zaXplXG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnR5cGVcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubmFtZVxuICB9XG5cbiAgZ2V0IGxhc3RNb2RpZmllZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxhc3RNb2RpZmllZFxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0ZpbGUnXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmlsZS5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0ZpbGUnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBuYW1lOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsYXN0TW9kaWZpZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkJsb2IgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKEJsb2IpXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkJsb2JQYXJ0ID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnKSB7XG4gICAgaWYgKGlzQmxvYkxpa2UoVikpIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyhWKSB8fFxuICAgICAgdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKVxuICAgICkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWLCBvcHRzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoViwgb3B0cylcbn1cblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPEJsb2JQYXJ0PiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5CbG9iUGFydFxuKVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvRmlsZUFQSS8jZGZuLUZpbGVQcm9wZXJ0eUJhZ1xud2ViaWRsLmNvbnZlcnRlcnMuRmlsZVByb3BlcnR5QmFnID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnbGFzdE1vZGlmaWVkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWydsb25nIGxvbmcnXSxcbiAgICBnZXQgZGVmYXVsdFZhbHVlICgpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpXG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiAndHlwZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnZW5kaW5ncycsXG4gICAgY29udmVydGVyOiAodmFsdWUpID0+IHtcbiAgICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHZhbHVlKVxuICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gJ25hdGl2ZScpIHtcbiAgICAgICAgdmFsdWUgPSAndHJhbnNwYXJlbnQnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlOiAndHJhbnNwYXJlbnQnXG4gIH1cbl0pXG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRmlsZUFQSS8jcHJvY2Vzcy1ibG9iLXBhcnRzXG4gKiBAcGFyYW0geyhOb2RlSlMuVHlwZWRBcnJheXxCbG9ifHN0cmluZylbXX0gcGFydHNcbiAqIEBwYXJhbSB7eyB0eXBlOiBzdHJpbmcsIGVuZGluZ3M6IHN0cmluZyB9fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NCbG9iUGFydHMgKHBhcnRzLCBvcHRpb25zKSB7XG4gIC8vIDEuIExldCBieXRlcyBiZSBhbiBlbXB0eSBzZXF1ZW5jZSBvZiBieXRlcy5cbiAgLyoqIEB0eXBlIHtOb2RlSlMuVHlwZWRBcnJheVtdfSAqL1xuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgLy8gMi4gRm9yIGVhY2ggZWxlbWVudCBpbiBwYXJ0czpcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIHBhcnRzKSB7XG4gICAgLy8gMS4gSWYgZWxlbWVudCBpcyBhIFVTVlN0cmluZywgcnVuIHRoZSBmb2xsb3dpbmcgc3Vic3RlcHM6XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gMS4gTGV0IHMgYmUgZWxlbWVudC5cbiAgICAgIGxldCBzID0gZWxlbWVudFxuXG4gICAgICAvLyAyLiBJZiB0aGUgZW5kaW5ncyBtZW1iZXIgb2Ygb3B0aW9ucyBpcyBcIm5hdGl2ZVwiLCBzZXQgc1xuICAgICAgLy8gICAgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGxpbmUgZW5kaW5ncyB0byBuYXRpdmVcbiAgICAgIC8vICAgIG9mIGVsZW1lbnQuXG4gICAgICBpZiAob3B0aW9ucy5lbmRpbmdzID09PSAnbmF0aXZlJykge1xuICAgICAgICBzID0gY29udmVydExpbmVFbmRpbmdzTmF0aXZlKHMpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIFVURi04IGVuY29kaW5nIHMgdG8gYnl0ZXMuXG4gICAgICBieXRlcy5wdXNoKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKSlcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihlbGVtZW50KSB8fFxuICAgICAgdHlwZXMuaXNUeXBlZEFycmF5KGVsZW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyAyLiBJZiBlbGVtZW50IGlzIGEgQnVmZmVyU291cmNlLCBnZXQgYSBjb3B5IG9mIHRoZVxuICAgICAgLy8gICAgYnl0ZXMgaGVsZCBieSB0aGUgYnVmZmVyIHNvdXJjZSwgYW5kIGFwcGVuZCB0aG9zZVxuICAgICAgLy8gICAgYnl0ZXMgdG8gYnl0ZXMuXG4gICAgICBpZiAoIWVsZW1lbnQuYnVmZmVyKSB7IC8vIEFycmF5QnVmZmVyXG4gICAgICAgIGJ5dGVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoZWxlbWVudCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBieXRlcy5wdXNoKFxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGVsZW1lbnQuYnVmZmVyLCBlbGVtZW50LmJ5dGVPZmZzZXQsIGVsZW1lbnQuYnl0ZUxlbmd0aClcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShlbGVtZW50KSkge1xuICAgICAgLy8gMy4gSWYgZWxlbWVudCBpcyBhIEJsb2IsIGFwcGVuZCB0aGUgYnl0ZXMgaXQgcmVwcmVzZW50c1xuICAgICAgLy8gICAgdG8gYnl0ZXMuXG4gICAgICBieXRlcy5wdXNoKGVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGJ5dGVzLlxuICByZXR1cm4gYnl0ZXNcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9GaWxlQVBJLyNjb252ZXJ0LWxpbmUtZW5kaW5ncy10by1uYXRpdmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRMaW5lRW5kaW5nc05hdGl2ZSAocykge1xuICAvLyAxLiBMZXQgbmF0aXZlIGxpbmUgZW5kaW5nIGJlIGJlIHRoZSBjb2RlIHBvaW50IFUrMDAwQSBMRi5cbiAgbGV0IG5hdGl2ZUxpbmVFbmRpbmcgPSAnXFxuJ1xuXG4gIC8vIDIuIElmIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3Jt4oCZcyBjb252ZW50aW9ucyBhcmUgdG9cbiAgLy8gICAgcmVwcmVzZW50IG5ld2xpbmVzIGFzIGEgY2FycmlhZ2UgcmV0dXJuIGFuZCBsaW5lIGZlZWRcbiAgLy8gICAgc2VxdWVuY2UsIHNldCBuYXRpdmUgbGluZSBlbmRpbmcgdG8gdGhlIGNvZGUgcG9pbnRcbiAgLy8gICAgVSswMDBEIENSIGZvbGxvd2VkIGJ5IHRoZSBjb2RlIHBvaW50IFUrMDAwQSBMRi5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBuYXRpdmVMaW5lRW5kaW5nID0gJ1xcclxcbidcbiAgfVxuXG4gIHJldHVybiBzLnJlcGxhY2UoL1xccj9cXG4vZywgbmF0aXZlTGluZUVuZGluZylcbn1cblxuLy8gSWYgdGhpcyBmdW5jdGlvbiBpcyBtb3ZlZCB0byAuL3V0aWwuanMsIHNvbWUgdG9vbHMgKHN1Y2ggYXNcbi8vIHJvbGx1cCkgd2lsbCB3YXJuIGFib3V0IGNpcmN1bGFyIGRlcGVuZGVuY2llcy4gU2VlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE2MjlcbmZ1bmN0aW9uIGlzRmlsZUxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIChOYXRpdmVGaWxlICYmIG9iamVjdCBpbnN0YW5jZW9mIE5hdGl2ZUZpbGUpIHx8XG4gICAgb2JqZWN0IGluc3RhbmNlb2YgRmlsZSB8fCAoXG4gICAgICBvYmplY3QgJiZcbiAgICAgICh0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIG9iamVjdC5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgIG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRmlsZSdcbiAgICApXG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEZpbGUsIEZpbGVMaWtlLCBpc0ZpbGVMaWtlIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/formdata.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/fetch/formdata.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isBlobLike, toUSVString, makeIterator } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/fetch/symbols.js\")\nconst { File: UndiciFile, FileLike, isFileLike } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/undici/lib/fetch/file.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\")\n\n/** @type {globalThis['File']} */\nconst File = NativeFile ?? UndiciFile\n\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n  constructor (form) {\n    if (form !== undefined) {\n      throw webidl.errors.conversionFailed({\n        prefix: 'FormData constructor',\n        argument: 'Argument 1',\n        types: ['undefined']\n      })\n    }\n\n    this[kState] = []\n  }\n\n  append (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.append' })\n\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\n        \"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name)\n    value = isBlobLike(value)\n      ? webidl.converters.Blob(value, { strict: false })\n      : webidl.converters.USVString(value)\n    filename = arguments.length === 3\n      ? webidl.converters.USVString(filename)\n      : undefined\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to thiss entry list.\n    this[kState].push(entry)\n  }\n\n  delete (name) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.delete' })\n\n    name = webidl.converters.USVString(name)\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from thiss entry list.\n    this[kState] = this[kState].filter(entry => entry.name !== name)\n  }\n\n  get (name) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.get' })\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in thiss entry list,\n    // then return null.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // thiss entry list.\n    return this[kState][idx].value\n  }\n\n  getAll (name) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.getAll' })\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in thiss entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from thiss entry list.\n    return this[kState]\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (name) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.has' })\n\n    name = webidl.converters.USVString(name)\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in thiss entry list; otherwise false.\n    return this[kState].findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.set' })\n\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\n        \"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name)\n    value = isBlobLike(value)\n      ? webidl.converters.Blob(value, { strict: false })\n      : webidl.converters.USVString(value)\n    filename = arguments.length === 3\n      ? toUSVString(filename)\n      : undefined\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in thiss entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this[kState] = [\n        ...this[kState].slice(0, idx),\n        entry,\n        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to thiss entry list.\n      this[kState].push(entry)\n    }\n  }\n\n  entries () {\n    webidl.brandCheck(this, FormData)\n\n    return makeIterator(\n      () => this[kState].map(pair => [pair.name, pair.value]),\n      'FormData',\n      'key+value'\n    )\n  }\n\n  keys () {\n    webidl.brandCheck(this, FormData)\n\n    return makeIterator(\n      () => this[kState].map(pair => [pair.name, pair.value]),\n      'FormData',\n      'key'\n    )\n  }\n\n  values () {\n    webidl.brandCheck(this, FormData)\n\n    return makeIterator(\n      () => this[kState].map(pair => [pair.name, pair.value]),\n      'FormData',\n      'value'\n    )\n  }\n\n  /**\n   * @param {(value: string, key: string, self: FormData) => void} callbackFn\n   * @param {unknown} thisArg\n   */\n  forEach (callbackFn, thisArg = globalThis) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.forEach' })\n\n    if (typeof callbackFn !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.\"\n      )\n    }\n\n    for (const [key, value] of this) {\n      callbackFn.apply(thisArg, [value, key, this])\n    }\n  }\n}\n\nFormData.prototype[Symbol.iterator] = FormData.prototype.entries\n\nObject.defineProperties(FormData.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'FormData',\n    configurable: true\n  }\n})\n\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */\nfunction makeEntry (name, value, filename) {\n  // 1. Set name to the result of converting name into a scalar value string.\n  // \"To convert a string into a scalar value string, replace any surrogates\n  //  with U+FFFD.\"\n  // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end\n  name = Buffer.from(name).toString('utf8')\n\n  // 2. If value is a string, then set value to the result of converting\n  //    value into a scalar value string.\n  if (typeof value === 'string') {\n    value = Buffer.from(value).toString('utf8')\n  } else {\n    // 3. Otherwise:\n\n    // 1. If value is not a File object, then set value to a new File object,\n    //    representing the same bytes, whose name attribute value is \"blob\"\n    if (!isFileLike(value)) {\n      value = value instanceof Blob\n        ? new File([value], 'blob', { type: value.type })\n        : new FileLike(value, 'blob', { type: value.type })\n    }\n\n    // 2. If filename is given, then set value to a new File object,\n    //    representing the same bytes, whose name attribute is filename.\n    if (filename !== undefined) {\n      /** @type {FilePropertyBag} */\n      const options = {\n        type: value.type,\n        lastModified: value.lastModified\n      }\n\n      value = (NativeFile && value instanceof NativeFile) || value instanceof UndiciFile\n        ? new File([value], filename, options)\n        : new FileLike(value, filename, options)\n    }\n  }\n\n  // 4. Return an entry whose name is name and whose value is value.\n  return { name, value }\n}\n\nmodule.exports = { FormData }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9mb3JtZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHdDQUF3QyxFQUFFLG1CQUFPLENBQUMsNkRBQVE7QUFDbEUsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxtRUFBVztBQUN0QyxRQUFRLHlDQUF5QyxFQUFFLG1CQUFPLENBQUMsNkRBQVE7QUFDbkUsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxpRUFBVTtBQUNyQyxRQUFRLHlCQUF5QixFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRW5ELFdBQVcsb0JBQW9CO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQywyQkFBMkI7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQywyQkFBMkI7O0FBRTFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLHdCQUF3Qjs7QUFFdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLDJCQUEyQjs7QUFFMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyx3QkFBd0I7O0FBRXZFOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0Msd0JBQXdCOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsc0RBQXNEO0FBQ25FLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLDRCQUE0Qjs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RCx3Q0FBd0Msa0JBQWtCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9mb3JtZGF0YS5qcz9hZTk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGlzQmxvYkxpa2UsIHRvVVNWU3RyaW5nLCBtYWtlSXRlcmF0b3IgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGtTdGF0ZSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgRmlsZTogVW5kaWNpRmlsZSwgRmlsZUxpa2UsIGlzRmlsZUxpa2UgfSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBCbG9iLCBGaWxlOiBOYXRpdmVGaWxlIH0gPSByZXF1aXJlKCdidWZmZXInKVxuXG4vKiogQHR5cGUge2dsb2JhbFRoaXNbJ0ZpbGUnXX0gKi9cbmNvbnN0IEZpbGUgPSBOYXRpdmVGaWxlID8/IFVuZGljaUZpbGVcblxuLy8gaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyNmb3JtZGF0YVxuY2xhc3MgRm9ybURhdGEge1xuICBjb25zdHJ1Y3RvciAoZm9ybSkge1xuICAgIGlmIChmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgIHByZWZpeDogJ0Zvcm1EYXRhIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgICAgdHlwZXM6IFsndW5kZWZpbmVkJ11cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpc1trU3RhdGVdID0gW11cbiAgfVxuXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnRm9ybURhdGEuYXBwZW5kJyB9KVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdhcHBlbmQnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJ1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IHZhbHVlIGJlIHZhbHVlIGlmIGdpdmVuOyBvdGhlcndpc2UgYmxvYlZhbHVlLlxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuICAgIHZhbHVlID0gaXNCbG9iTGlrZSh2YWx1ZSlcbiAgICAgID8gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYih2YWx1ZSwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgICA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSlcbiAgICBmaWxlbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDNcbiAgICAgID8gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKGZpbGVuYW1lKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIC8vIDIuIExldCBlbnRyeSBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGVudHJ5IHdpdGhcbiAgICAvLyBuYW1lLCB2YWx1ZSwgYW5kIGZpbGVuYW1lIGlmIGdpdmVuLlxuICAgIGNvbnN0IGVudHJ5ID0gbWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSlcblxuICAgIC8vIDMuIEFwcGVuZCBlbnRyeSB0byB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHRoaXNba1N0YXRlXS5wdXNoKGVudHJ5KVxuICB9XG5cbiAgZGVsZXRlIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRm9ybURhdGEuZGVsZXRlJyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgLy8gVGhlIGRlbGV0ZShuYW1lKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJlbW92ZSBhbGwgZW50cmllcyB3aG9zZSBuYW1lXG4gICAgLy8gaXMgbmFtZSBmcm9tIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgdGhpc1trU3RhdGVdID0gdGhpc1trU3RhdGVdLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5uYW1lICE9PSBuYW1lKVxuICB9XG5cbiAgZ2V0IChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRm9ybURhdGEuZ2V0JyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gbnVsbC5cbiAgICBjb25zdCBpZHggPSB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgZnJvbVxuICAgIC8vIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXVtpZHhdLnZhbHVlXG4gIH1cblxuICBnZXRBbGwgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGb3JtRGF0YS5nZXRBbGwnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICAvLyAxLiBJZiB0aGVyZSBpcyBubyBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgaW4gdGhpc+KAmXMgZW50cnkgbGlzdCxcbiAgICAvLyB0aGVuIHJldHVybiB0aGUgZW1wdHkgbGlzdC5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlcyBvZiBhbGwgZW50cmllcyB3aG9zZSBuYW1lIGlzIG5hbWUsIGluIG9yZGVyLFxuICAgIC8vIGZyb20gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdXG4gICAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICAgIC5tYXAoKGVudHJ5KSA9PiBlbnRyeS52YWx1ZSlcbiAgfVxuXG4gIGhhcyAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0Zvcm1EYXRhLmhhcycgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcblxuICAgIC8vIFRoZSBoYXMobmFtZSkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhbiBlbnRyeVxuICAgIC8vIHdob3NlIG5hbWUgaXMgbmFtZSBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKSAhPT0gLTFcbiAgfVxuXG4gIHNldCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnRm9ybURhdGEuc2V0JyB9KVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdzZXQnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJ1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVGhlIHNldChuYW1lLCB2YWx1ZSkgYW5kIHNldChuYW1lLCBibG9iVmFsdWUsIGZpbGVuYW1lKSBtZXRob2Qgc3RlcHNcbiAgICAvLyBhcmU6XG5cbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgdmFsdWUgaWYgZ2l2ZW47IG90aGVyd2lzZSBibG9iVmFsdWUuXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG4gICAgdmFsdWUgPSBpc0Jsb2JMaWtlKHZhbHVlKVxuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSlcbiAgICAgIDogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHZhbHVlKVxuICAgIGZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgPyB0b1VTVlN0cmluZyhmaWxlbmFtZSlcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAvLyAyLiBMZXQgZW50cnkgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBlbnRyeSB3aXRoIG5hbWUsIHZhbHVlLCBhbmRcbiAgICAvLyBmaWxlbmFtZSBpZiBnaXZlbi5cbiAgICBjb25zdCBlbnRyeSA9IG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpXG5cbiAgICAvLyAzLiBJZiB0aGVyZSBhcmUgZW50cmllcyBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0IHdob3NlIG5hbWUgaXMgbmFtZSwgdGhlblxuICAgIC8vIHJlcGxhY2UgdGhlIGZpcnN0IHN1Y2ggZW50cnkgd2l0aCBlbnRyeSBhbmQgcmVtb3ZlIHRoZSBvdGhlcnMuXG4gICAgY29uc3QgaWR4ID0gdGhpc1trU3RhdGVdLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpXG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgIHRoaXNba1N0YXRlXSA9IFtcbiAgICAgICAgLi4udGhpc1trU3RhdGVdLnNsaWNlKDAsIGlkeCksXG4gICAgICAgIGVudHJ5LFxuICAgICAgICAuLi50aGlzW2tTdGF0ZV0uc2xpY2UoaWR4ICsgMSkuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkubmFtZSAhPT0gbmFtZSlcbiAgICAgIF1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBhcHBlbmQgZW50cnkgdG8gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICAgIHRoaXNba1N0YXRlXS5wdXNoKGVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIGVudHJpZXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICgpID0+IHRoaXNba1N0YXRlXS5tYXAocGFpciA9PiBbcGFpci5uYW1lLCBwYWlyLnZhbHVlXSksXG4gICAgICAnRm9ybURhdGEnLFxuICAgICAgJ2tleSt2YWx1ZSdcbiAgICApXG4gIH1cblxuICBrZXlzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAoKSA9PiB0aGlzW2tTdGF0ZV0ubWFwKHBhaXIgPT4gW3BhaXIubmFtZSwgcGFpci52YWx1ZV0pLFxuICAgICAgJ0Zvcm1EYXRhJyxcbiAgICAgICdrZXknXG4gICAgKVxuICB9XG5cbiAgdmFsdWVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAoKSA9PiB0aGlzW2tTdGF0ZV0ubWFwKHBhaXIgPT4gW3BhaXIubmFtZSwgcGFpci52YWx1ZV0pLFxuICAgICAgJ0Zvcm1EYXRhJyxcbiAgICAgICd2YWx1ZSdcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsodmFsdWU6IHN0cmluZywga2V5OiBzdHJpbmcsIHNlbGY6IEZvcm1EYXRhKSA9PiB2b2lkfSBjYWxsYmFja0ZuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gdGhpc0FyZ1xuICAgKi9cbiAgZm9yRWFjaCAoY2FsbGJhY2tGbiwgdGhpc0FyZyA9IGdsb2JhbFRoaXMpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGb3JtRGF0YS5mb3JFYWNoJyB9KVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja0ZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnRnVuY3Rpb24nLlwiXG4gICAgICApXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgY2FsbGJhY2tGbi5hcHBseSh0aGlzQXJnLCBbdmFsdWUsIGtleSwgdGhpc10pXG4gICAgfVxuICB9XG59XG5cbkZvcm1EYXRhLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gRm9ybURhdGEucHJvdG90eXBlLmVudHJpZXNcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRm9ybURhdGEucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdGb3JtRGF0YScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjcmVhdGUtYW4tZW50cnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ3xCbG9ifSB2YWx1ZVxuICogQHBhcmFtIHs/c3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gbWFrZUVudHJ5IChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpIHtcbiAgLy8gMS4gU2V0IG5hbWUgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIG5hbWUgaW50byBhIHNjYWxhciB2YWx1ZSBzdHJpbmcuXG4gIC8vIFwiVG8gY29udmVydCBhIHN0cmluZyBpbnRvIGEgc2NhbGFyIHZhbHVlIHN0cmluZywgcmVwbGFjZSBhbnkgc3Vycm9nYXRlc1xuICAvLyAgd2l0aCBVK0ZGRkQuXCJcbiAgLy8gc2VlOiBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjE4LngvZG9jcy9hcGkvYnVmZmVyLmh0bWwjYnVmdG9zdHJpbmdlbmNvZGluZy1zdGFydC1lbmRcbiAgbmFtZSA9IEJ1ZmZlci5mcm9tKG5hbWUpLnRvU3RyaW5nKCd1dGY4JylcblxuICAvLyAyLiBJZiB2YWx1ZSBpcyBhIHN0cmluZywgdGhlbiBzZXQgdmFsdWUgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nXG4gIC8vICAgIHZhbHVlIGludG8gYSBzY2FsYXIgdmFsdWUgc3RyaW5nLlxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCd1dGY4JylcbiAgfSBlbHNlIHtcbiAgICAvLyAzLiBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBJZiB2YWx1ZSBpcyBub3QgYSBGaWxlIG9iamVjdCwgdGhlbiBzZXQgdmFsdWUgdG8gYSBuZXcgRmlsZSBvYmplY3QsXG4gICAgLy8gICAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGJ5dGVzLCB3aG9zZSBuYW1lIGF0dHJpYnV0ZSB2YWx1ZSBpcyBcImJsb2JcIlxuICAgIGlmICghaXNGaWxlTGlrZSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9iXG4gICAgICAgID8gbmV3IEZpbGUoW3ZhbHVlXSwgJ2Jsb2InLCB7IHR5cGU6IHZhbHVlLnR5cGUgfSlcbiAgICAgICAgOiBuZXcgRmlsZUxpa2UodmFsdWUsICdibG9iJywgeyB0eXBlOiB2YWx1ZS50eXBlIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgZmlsZW5hbWUgaXMgZ2l2ZW4sIHRoZW4gc2V0IHZhbHVlIHRvIGEgbmV3IEZpbGUgb2JqZWN0LFxuICAgIC8vICAgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBieXRlcywgd2hvc2UgbmFtZSBhdHRyaWJ1dGUgaXMgZmlsZW5hbWUuXG4gICAgaWYgKGZpbGVuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKiBAdHlwZSB7RmlsZVByb3BlcnR5QmFnfSAqL1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgbGFzdE1vZGlmaWVkOiB2YWx1ZS5sYXN0TW9kaWZpZWRcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSAoTmF0aXZlRmlsZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIE5hdGl2ZUZpbGUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVW5kaWNpRmlsZVxuICAgICAgICA/IG5ldyBGaWxlKFt2YWx1ZV0sIGZpbGVuYW1lLCBvcHRpb25zKVxuICAgICAgICA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgZmlsZW5hbWUsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIGFuIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBhbmQgd2hvc2UgdmFsdWUgaXMgdmFsdWUuXG4gIHJldHVybiB7IG5hbWUsIHZhbHVlIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEZvcm1EYXRhIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/formdata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/global.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/fetch/global.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for('undici.globalOrigin.1')\n\nfunction getGlobalOrigin () {\n  return globalThis[globalOrigin]\n}\n\nfunction setGlobalOrigin (newOrigin) {\n  if (newOrigin === undefined) {\n    Object.defineProperty(globalThis, globalOrigin, {\n      value: undefined,\n      writable: true,\n      enumerable: false,\n      configurable: false\n    })\n\n    return\n  }\n\n  const parsedURL = new URL(newOrigin)\n\n  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {\n    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)\n  }\n\n  Object.defineProperty(globalThis, globalOrigin, {\n    value: parsedURL,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nmodule.exports = {\n  getGlobalOrigin,\n  setGlobalOrigin\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdFQUF3RSxtQkFBbUI7QUFDM0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2dsb2JhbC5qcz9jZWY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBJbiBjYXNlIG9mIGJyZWFraW5nIGNoYW5nZXMsIGluY3JlYXNlIHRoZSB2ZXJzaW9uXG4vLyBudW1iZXIgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsT3JpZ2luID0gU3ltYm9sLmZvcigndW5kaWNpLmdsb2JhbE9yaWdpbi4xJylcblxuZnVuY3Rpb24gZ2V0R2xvYmFsT3JpZ2luICgpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXNbZ2xvYmFsT3JpZ2luXVxufVxuXG5mdW5jdGlvbiBzZXRHbG9iYWxPcmlnaW4gKG5ld09yaWdpbikge1xuICBpZiAobmV3T3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsT3JpZ2luLCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KVxuXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgVVJMKG5ld09yaWdpbilcblxuICBpZiAocGFyc2VkVVJMLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVSTC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBPbmx5IGh0dHAgJiBodHRwcyB1cmxzIGFyZSBhbGxvd2VkLCByZWNlaXZlZCAke3BhcnNlZFVSTC5wcm90b2NvbH1gKVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbE9yaWdpbiwge1xuICAgIHZhbHVlOiBwYXJzZWRVUkwsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0R2xvYmFsT3JpZ2luLFxuICBzZXRHbG9iYWxPcmlnaW5cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/headers.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/fetch/headers.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { kGuard } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/fetch/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst {\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nconst kHeadersMap = Symbol('headers map')\nconst kHeadersSortedMap = Symbol('headers map sorted')\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n\n  // Trimming the end with `.replace()` and a RegExp is typically subject to\n  // ReDoS. This is safer and faster.\n  let i = potentialValue.length\n  while (/[\\r\\n\\t ]/.test(potentialValue.charAt(--i)));\n  return potentialValue.slice(0, i + 1).replace(/^[\\r\\n\\t ]+/, '')\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (const header of object) {\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (headers first item, headers second item) to headers.\n      headers.append(header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key  value in object,\n    //    append (key, value) to headers\n    for (const [key, value] of Object.entries(object)) {\n      headers.append(key, value)\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this[kHeadersMap] = new Map(init[kHeadersMap])\n      this[kHeadersSortedMap] = init[kHeadersSortedMap]\n      this.cookies = init.cookies\n    } else {\n      this[kHeadersMap] = new Map(init)\n      this[kHeadersSortedMap] = null\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#header-list-contains\n  contains (name) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n    name = name.toLowerCase()\n\n    return this[kHeadersMap].has(name)\n  }\n\n  clear () {\n    this[kHeadersMap].clear()\n    this[kHeadersSortedMap] = null\n    this.cookies = null\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-append\n  append (name, value) {\n    this[kHeadersSortedMap] = null\n\n    // 1. If list contains name, then set name to the first such\n    //    headers name.\n    const lowercaseName = name.toLowerCase()\n    const exists = this[kHeadersMap].get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this[kHeadersMap].set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this[kHeadersMap].set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies ??= []\n      this.cookies.push(value)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-set\n  set (name, value) {\n    this[kHeadersSortedMap] = null\n    const lowercaseName = name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    return this[kHeadersMap].set(lowercaseName, { name, value })\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-delete\n  delete (name) {\n    this[kHeadersSortedMap] = null\n\n    name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    return this[kHeadersMap].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-get\n  get (name) {\n    // 1. If list does not contain name, then return null.\n    if (!this.contains(name)) {\n      return null\n    }\n\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return this[kHeadersMap].get(name.toLowerCase())?.value ?? null\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const [name, { value }] of this[kHeadersMap]) {\n      yield [name, value]\n    }\n  }\n\n  get entries () {\n    const headers = {}\n\n    if (this[kHeadersMap].size) {\n      for (const { name, value } of this[kHeadersMap].values()) {\n        headers[name] = value\n      }\n    }\n\n    return headers\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  constructor (init = undefined) {\n    this[kHeadersList] = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set thiss guard to \"none\".\n    this[kGuard] = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init)\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.append',\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.append',\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If headerss guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if headerss guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // 5. Otherwise, if headerss guard is \"request-no-cors\":\n      // TODO\n    }\n\n    // 6. Otherwise, if headerss guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n\n    // 7. Append (name, value) to headerss header list.\n    // 8. If headerss guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from headers\n    return this[kHeadersList].append(name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If thiss guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if thiss guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if thiss guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if thiss guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 6. If thiss header list does not contain name, then\n    //    return.\n    if (!this[kHeadersList].contains(name)) {\n      return\n    }\n\n    // 7. Delete name from thiss header list.\n    // 8. If thiss guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    return this[kHeadersList].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.get',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from thiss header\n    //    list.\n    return this[kHeadersList].get(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.has',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if thiss header list contains name;\n    //    otherwise false.\n    return this[kHeadersList].contains(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If thiss guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if thiss guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if thiss guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if thiss guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 7. Set (name, value) in thiss header list.\n    // 8. If thiss guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    return this[kHeadersList].set(name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If thiss header list does not contain `Set-Cookie`, then return  .\n    // 2. Return the values of all headers in thiss header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this[kHeadersList].cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n  get [kHeadersSortedMap] () {\n    if (this[kHeadersList][kHeadersSortedMap]) {\n      return this[kHeadersList][kHeadersSortedMap]\n    }\n\n    // 1. Let headers be an empty list of headers with the key being the name\n    //    and value the value.\n    const headers = []\n\n    // 2. Let names be the result of convert header names to a sorted-lowercase\n    //    set with all the names of the headers in list.\n    const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1)\n    const cookies = this[kHeadersList].cookies\n\n    // 3. For each name of names:\n    for (const [name, value] of names) {\n      // 1. If name is `set-cookie`, then:\n      if (name === 'set-cookie') {\n        // 1. Let values be a list of all values of headers in list whose name\n        //    is a byte-case-insensitive match for name, in order.\n\n        // 2. For each value of values:\n        // 1. Append (name, value) to headers.\n        for (const value of cookies) {\n          headers.push([name, value])\n        }\n      } else {\n        // 2. Otherwise:\n\n        // 1. Let value be the result of getting name from list.\n\n        // 2. Assert: value is non-null.\n        assert(value !== null)\n\n        // 3. Append (name, value) to headers.\n        headers.push([name, value])\n      }\n    }\n\n    this[kHeadersList][kHeadersSortedMap] = headers\n\n    // 4. Return headers.\n    return headers\n  }\n\n  keys () {\n    webidl.brandCheck(this, Headers)\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key'\n    )\n  }\n\n  values () {\n    webidl.brandCheck(this, Headers)\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'value'\n    )\n  }\n\n  entries () {\n    webidl.brandCheck(this, Headers)\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key+value'\n    )\n  }\n\n  /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */\n  forEach (callbackFn, thisArg = globalThis) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.forEach' })\n\n    if (typeof callbackFn !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n      )\n    }\n\n    for (const [key, value] of this) {\n      callbackFn.apply(thisArg, [value, key, this])\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    webidl.brandCheck(this, Headers)\n\n    return this[kHeadersList]\n  }\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty,\n  [Symbol.iterator]: { enumerable: false },\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  }\n})\n\nwebidl.converters.HeadersInit = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (V[Symbol.iterator]) {\n      return webidl.converters['sequence<sequence<ByteString>>'](V)\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9oZWFkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVZOztBQUVaLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQ2xELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsbUVBQVc7QUFDdEMsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLGtFQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNkRBQVE7QUFDcEIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxpRUFBVTtBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsY0FBYztBQUNuRixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsRUFBRSxVQUFVLEVBQUUsTUFBTTtBQUNuRCxPQUFPO0FBQ1AsTUFBTTtBQUNOLDZDQUE2QyxhQUFhO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQywwQkFBMEI7O0FBRXpFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQywwQkFBMEI7O0FBRXpFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyx1QkFBdUI7O0FBRXRFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLHVCQUF1Qjs7QUFFdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsdUJBQXVCOztBQUV0RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFEQUFxRDtBQUNsRSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBLCtDQUErQywyQkFBMkI7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaGVhZGVycy5qcz9lMDE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9FdGhhbi1BcnJvd29vZC91bmRpY2ktZmV0Y2hcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBrR3VhcmQgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7XG4gIG1ha2VJdGVyYXRvcixcbiAgaXNWYWxpZEhlYWRlck5hbWUsXG4gIGlzVmFsaWRIZWFkZXJWYWx1ZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuY29uc3Qga0hlYWRlcnNNYXAgPSBTeW1ib2woJ2hlYWRlcnMgbWFwJylcbmNvbnN0IGtIZWFkZXJzU29ydGVkTWFwID0gU3ltYm9sKCdoZWFkZXJzIG1hcCBzb3J0ZWQnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLXZhbHVlLW5vcm1hbGl6ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGhlYWRlclZhbHVlTm9ybWFsaXplIChwb3RlbnRpYWxWYWx1ZSkge1xuICAvLyAgVG8gbm9ybWFsaXplIGEgYnl0ZSBzZXF1ZW5jZSBwb3RlbnRpYWxWYWx1ZSwgcmVtb3ZlXG4gIC8vICBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlIGJ5dGVzIGZyb21cbiAgLy8gIHBvdGVudGlhbFZhbHVlLlxuXG4gIC8vIFRyaW1taW5nIHRoZSBlbmQgd2l0aCBgLnJlcGxhY2UoKWAgYW5kIGEgUmVnRXhwIGlzIHR5cGljYWxseSBzdWJqZWN0IHRvXG4gIC8vIFJlRG9TLiBUaGlzIGlzIHNhZmVyIGFuZCBmYXN0ZXIuXG4gIGxldCBpID0gcG90ZW50aWFsVmFsdWUubGVuZ3RoXG4gIHdoaWxlICgvW1xcclxcblxcdCBdLy50ZXN0KHBvdGVudGlhbFZhbHVlLmNoYXJBdCgtLWkpKSk7XG4gIHJldHVybiBwb3RlbnRpYWxWYWx1ZS5zbGljZSgwLCBpICsgMSkucmVwbGFjZSgvXltcXHJcXG5cXHQgXSsvLCAnJylcbn1cblxuZnVuY3Rpb24gZmlsbCAoaGVhZGVycywgb2JqZWN0KSB7XG4gIC8vIFRvIGZpbGwgYSBIZWFkZXJzIG9iamVjdCBoZWFkZXJzIHdpdGggYSBnaXZlbiBvYmplY3Qgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIGEgc2VxdWVuY2UsIHRoZW4gZm9yIGVhY2ggaGVhZGVyIGluIG9iamVjdDpcbiAgLy8gTm90ZTogd2ViaWRsIGNvbnZlcnNpb24gdG8gYXJyYXkgaGFzIGFscmVhZHkgYmVlbiBkb25lLlxuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgZm9yIChjb25zdCBoZWFkZXIgb2Ygb2JqZWN0KSB7XG4gICAgICAvLyAxLiBJZiBoZWFkZXIgZG9lcyBub3QgY29udGFpbiBleGFjdGx5IHR3byBpdGVtcywgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChoZWFkZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgICBtZXNzYWdlOiBgZXhwZWN0ZWQgbmFtZS92YWx1ZSBwYWlyIHRvIGJlIGxlbmd0aCAyLCBmb3VuZCAke2hlYWRlci5sZW5ndGh9LmBcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQXBwZW5kIChoZWFkZXLigJlzIGZpcnN0IGl0ZW0sIGhlYWRlcuKAmXMgc2Vjb25kIGl0ZW0pIHRvIGhlYWRlcnMuXG4gICAgICBoZWFkZXJzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgLy8gTm90ZTogbnVsbCBzaG91bGQgdGhyb3dcblxuICAgIC8vIDIuIE90aGVyd2lzZSwgb2JqZWN0IGlzIGEgcmVjb3JkLCB0aGVuIGZvciBlYWNoIGtleSDihpIgdmFsdWUgaW4gb2JqZWN0LFxuICAgIC8vICAgIGFwcGVuZCAoa2V5LCB2YWx1ZSkgdG8gaGVhZGVyc1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXg6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICB0eXBlczogWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nLCAncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J11cbiAgICB9KVxuICB9XG59XG5cbmNsYXNzIEhlYWRlcnNMaXN0IHtcbiAgLyoqIEB0eXBlIHtbc3RyaW5nLCBzdHJpbmddW118bnVsbH0gKi9cbiAgY29va2llcyA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAoaW5pdCkge1xuICAgIGlmIChpbml0IGluc3RhbmNlb2YgSGVhZGVyc0xpc3QpIHtcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdID0gbmV3IE1hcChpbml0W2tIZWFkZXJzTWFwXSlcbiAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gaW5pdFtrSGVhZGVyc1NvcnRlZE1hcF1cbiAgICAgIHRoaXMuY29va2llcyA9IGluaXQuY29va2llc1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXSA9IG5ldyBNYXAoaW5pdClcbiAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbGlzdC1jb250YWluc1xuICBjb250YWlucyAobmFtZSkge1xuICAgIC8vIEEgaGVhZGVyIGxpc3QgbGlzdCBjb250YWlucyBhIGhlYWRlciBuYW1lIG5hbWUgaWYgbGlzdFxuICAgIC8vIGNvbnRhaW5zIGEgaGVhZGVyIHdob3NlIG5hbWUgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmVcbiAgICAvLyBtYXRjaCBmb3IgbmFtZS5cbiAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uaGFzKG5hbWUpXG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpc1trSGVhZGVyc01hcF0uY2xlYXIoKVxuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIHRoaXMuY29va2llcyA9IG51bGxcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWFwcGVuZFxuICBhcHBlbmQgKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG5cbiAgICAvLyAxLiBJZiBsaXN0IGNvbnRhaW5zIG5hbWUsIHRoZW4gc2V0IG5hbWUgdG8gdGhlIGZpcnN0IHN1Y2hcbiAgICAvLyAgICBoZWFkZXLigJlzIG5hbWUuXG4gICAgY29uc3QgbG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgIGNvbnN0IGV4aXN0cyA9IHRoaXNba0hlYWRlcnNNYXBdLmdldChsb3dlcmNhc2VOYW1lKVxuXG4gICAgLy8gMi4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gbGlzdC5cbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICBjb25zdCBkZWxpbWl0ZXIgPSBsb3dlcmNhc2VOYW1lID09PSAnY29va2llJyA/ICc7ICcgOiAnLCAnXG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXS5zZXQobG93ZXJjYXNlTmFtZSwge1xuICAgICAgICBuYW1lOiBleGlzdHMubmFtZSxcbiAgICAgICAgdmFsdWU6IGAke2V4aXN0cy52YWx1ZX0ke2RlbGltaXRlcn0ke3ZhbHVlfWBcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChsb3dlcmNhc2VOYW1lLCB7IG5hbWUsIHZhbHVlIH0pXG4gICAgfVxuXG4gICAgaWYgKGxvd2VyY2FzZU5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgdGhpcy5jb29raWVzID8/PSBbXVxuICAgICAgdGhpcy5jb29raWVzLnB1c2godmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc2V0XG4gIHNldCAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcbiAgICBjb25zdCBsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZiAobG93ZXJjYXNlTmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICB0aGlzLmNvb2tpZXMgPSBbdmFsdWVdXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgbGlzdCBjb250YWlucyBuYW1lLCB0aGVuIHNldCB0aGUgdmFsdWUgb2ZcbiAgICAvLyAgICB0aGUgZmlyc3Qgc3VjaCBoZWFkZXIgdG8gdmFsdWUgYW5kIHJlbW92ZSB0aGVcbiAgICAvLyAgICBvdGhlcnMuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBhcHBlbmQgaGVhZGVyIChuYW1lLCB2YWx1ZSkgdG8gbGlzdC5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uc2V0KGxvd2VyY2FzZU5hbWUsIHsgbmFtZSwgdmFsdWUgfSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWRlbGV0ZVxuICBkZWxldGUgKG5hbWUpIHtcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcblxuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChuYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA9IG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uZGVsZXRlKG5hbWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1nZXRcbiAgZ2V0IChuYW1lKSB7XG4gICAgLy8gMS4gSWYgbGlzdCBkb2VzIG5vdCBjb250YWluIG5hbWUsIHRoZW4gcmV0dXJuIG51bGwuXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5zKG5hbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIGxpc3Qgd2hvc2UgbmFtZVxuICAgIC8vICAgIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBuYW1lLFxuICAgIC8vICAgIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgMHgyQyAweDIwLCBpbiBvcmRlci5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uZ2V0KG5hbWUudG9Mb3dlckNhc2UoKSk/LnZhbHVlID8/IG51bGxcbiAgfVxuXG4gICogW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIC8vIHVzZSB0aGUgbG93ZXJjYXNlZCBuYW1lXG4gICAgZm9yIChjb25zdCBbbmFtZSwgeyB2YWx1ZSB9XSBvZiB0aGlzW2tIZWFkZXJzTWFwXSkge1xuICAgICAgeWllbGQgW25hbWUsIHZhbHVlXVxuICAgIH1cbiAgfVxuXG4gIGdldCBlbnRyaWVzICgpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge31cblxuICAgIGlmICh0aGlzW2tIZWFkZXJzTWFwXS5zaXplKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdmFsdWUgfSBvZiB0aGlzW2tIZWFkZXJzTWFwXS52YWx1ZXMoKSkge1xuICAgICAgICBoZWFkZXJzW25hbWVdID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXJzLWNsYXNzXG5jbGFzcyBIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IgKGluaXQgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzW2tIZWFkZXJzTGlzdF0gPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgLy8gVGhlIG5ldyBIZWFkZXJzKGluaXQpIGNvbnN0cnVjdG9yIHN0ZXBzIGFyZTpcblxuICAgIC8vIDEuIFNldCB0aGlz4oCZcyBndWFyZCB0byBcIm5vbmVcIi5cbiAgICB0aGlzW2tHdWFyZF0gPSAnbm9uZSdcblxuICAgIC8vIDIuIElmIGluaXQgaXMgZ2l2ZW4sIHRoZW4gZmlsbCB0aGlzIHdpdGggaW5pdC5cbiAgICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQoaW5pdClcbiAgICAgIGZpbGwodGhpcywgaW5pdClcbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtYXBwZW5kXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ0hlYWRlcnMuYXBwZW5kJyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSlcbiAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcodmFsdWUpXG5cbiAgICAvLyAxLiBOb3JtYWxpemUgdmFsdWUuXG4gICAgdmFsdWUgPSBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSh2YWx1ZSlcblxuICAgIC8vIDIuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUgb3IgdmFsdWUgaXMgbm90IGFcbiAgICAvLyAgICBoZWFkZXIgdmFsdWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXg6ICdIZWFkZXJzLmFwcGVuZCcsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5hcHBlbmQnLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciB2YWx1ZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyA0LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdFwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiBoZWFkZXIgbmFtZXNcbiAgICBpZiAodGhpc1trR3VhcmRdID09PSAnaW1tdXRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgICB9IGVsc2UgaWYgKHRoaXNba0d1YXJkXSA9PT0gJ3JlcXVlc3Qtbm8tY29ycycpIHtcbiAgICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIjpcbiAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICAvLyA2LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG5cbiAgICAvLyA3LiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSBoZWFkZXJzXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XS5hcHBlbmQobmFtZSwgdmFsdWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZGVsZXRlXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnSGVhZGVycy5kZWxldGUnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuZGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyAzLiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdFwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyA0LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIG5hbWVcbiAgICAvLyAgICBpcyBub3QgYSBuby1DT1JTLXNhZmVsaXN0ZWQgcmVxdWVzdC1oZWFkZXIgbmFtZSwgYW5kXG4gICAgLy8gICAgbmFtZSBpcyBub3QgYSBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdC1oZWFkZXIgbmFtZSxcbiAgICAvLyAgICByZXR1cm4uXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlc3BvbnNlXCIgYW5kIG5hbWUgaXNcbiAgICAvLyAgICBhIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICAgIGlmICh0aGlzW2tHdWFyZF0gPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH0gZWxzZSBpZiAodGhpc1trR3VhcmRdID09PSAncmVxdWVzdC1uby1jb3JzJykge1xuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIDYuIElmIHRoaXPigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gbmFtZSwgdGhlblxuICAgIC8vICAgIHJldHVybi5cbiAgICBpZiAoIXRoaXNba0hlYWRlcnNMaXN0XS5jb250YWlucyhuYW1lKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gNy4gRGVsZXRlIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGlzLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF0uZGVsZXRlKG5hbWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZ2V0XG4gIGdldCAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnSGVhZGVycy5nZXQnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuZ2V0JyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBuYW1lIGZyb20gdGhpc+KAmXMgaGVhZGVyXG4gICAgLy8gICAgbGlzdC5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLmdldChuYW1lKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWhhc1xuICBoYXMgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0hlYWRlcnMuaGFzJyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSlcblxuICAgIC8vIDEuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXg6ICdIZWFkZXJzLmhhcycsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0cnVlIGlmIHRoaXPigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIG5hbWU7XG4gICAgLy8gICAgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF0uY29udGFpbnMobmFtZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1zZXRcbiAgc2V0IChuYW1lLCB2YWx1ZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnSGVhZGVycy5zZXQnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSlcblxuICAgIC8vIDEuIE5vcm1hbGl6ZSB2YWx1ZS5cbiAgICB2YWx1ZSA9IGhlYWRlclZhbHVlTm9ybWFsaXplKHZhbHVlKVxuXG4gICAgLy8gMi4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSBvciB2YWx1ZSBpcyBub3QgYVxuICAgIC8vICAgIGhlYWRlciB2YWx1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuc2V0JyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXg6ICdIZWFkZXJzLnNldCcsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIHZhbHVlJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAzLiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcImltbXV0YWJsZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIDQuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiBhbmRcbiAgICAvLyAgICBuYW1lL3ZhbHVlIGlzIG5vdCBhIG5vLUNPUlMtc2FmZWxpc3RlZCByZXF1ZXN0LWhlYWRlcixcbiAgICAvLyAgICByZXR1cm4uXG4gICAgLy8gNi4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlc3BvbnNlXCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICAgIGlmICh0aGlzW2tHdWFyZF0gPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH0gZWxzZSBpZiAodGhpc1trR3VhcmRdID09PSAncmVxdWVzdC1uby1jb3JzJykge1xuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIDcuIFNldCAobmFtZSwgdmFsdWUpIGluIHRoaXPigJlzIGhlYWRlciBsaXN0LlxuICAgIC8vIDguIElmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gICAgLy8gICAgcHJpdmlsZWdlZCBuby1DT1JTIHJlcXVlc3QgaGVhZGVycyBmcm9tIHRoaXNcbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLnNldChuYW1lLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1nZXRzZXRjb29raWVcbiAgZ2V0U2V0Q29va2llICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgLy8gMS4gSWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgU2V0LUNvb2tpZWAsIHRoZW4gcmV0dXJuIMKrIMK7LlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIHRoaXPigJlzIGhlYWRlciBsaXN0IHdob3NlIG5hbWUgaXNcbiAgICAvLyAgICBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYFNldC1Db29raWVgLCBpbiBvcmRlci5cblxuICAgIGNvbnN0IGxpc3QgPSB0aGlzW2tIZWFkZXJzTGlzdF0uY29va2llc1xuXG4gICAgaWYgKGxpc3QpIHtcbiAgICAgIHJldHVybiBbLi4ubGlzdF1cbiAgICB9XG5cbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNvcnQtYW5kLWNvbWJpbmVcbiAgZ2V0IFtrSGVhZGVyc1NvcnRlZE1hcF0gKCkge1xuICAgIGlmICh0aGlzW2tIZWFkZXJzTGlzdF1ba0hlYWRlcnNTb3J0ZWRNYXBdKSB7XG4gICAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdW2tIZWFkZXJzU29ydGVkTWFwXVxuICAgIH1cblxuICAgIC8vIDEuIExldCBoZWFkZXJzIGJlIGFuIGVtcHR5IGxpc3Qgb2YgaGVhZGVycyB3aXRoIHRoZSBrZXkgYmVpbmcgdGhlIG5hbWVcbiAgICAvLyAgICBhbmQgdmFsdWUgdGhlIHZhbHVlLlxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXVxuXG4gICAgLy8gMi4gTGV0IG5hbWVzIGJlIHRoZSByZXN1bHQgb2YgY29udmVydCBoZWFkZXIgbmFtZXMgdG8gYSBzb3J0ZWQtbG93ZXJjYXNlXG4gICAgLy8gICAgc2V0IHdpdGggYWxsIHRoZSBuYW1lcyBvZiB0aGUgaGVhZGVycyBpbiBsaXN0LlxuICAgIGNvbnN0IG5hbWVzID0gWy4uLnRoaXNba0hlYWRlcnNMaXN0XV0uc29ydCgoYSwgYikgPT4gYVswXSA8IGJbMF0gPyAtMSA6IDEpXG4gICAgY29uc3QgY29va2llcyA9IHRoaXNba0hlYWRlcnNMaXN0XS5jb29raWVzXG5cbiAgICAvLyAzLiBGb3IgZWFjaCBuYW1lIG9mIG5hbWVzOlxuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBuYW1lcykge1xuICAgICAgLy8gMS4gSWYgbmFtZSBpcyBgc2V0LWNvb2tpZWAsIHRoZW46XG4gICAgICBpZiAobmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIC8vIDEuIExldCB2YWx1ZXMgYmUgYSBsaXN0IG9mIGFsbCB2YWx1ZXMgb2YgaGVhZGVycyBpbiBsaXN0IHdob3NlIG5hbWVcbiAgICAgICAgLy8gICAgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIG5hbWUsIGluIG9yZGVyLlxuXG4gICAgICAgIC8vIDIuIEZvciBlYWNoIHZhbHVlIG9mIHZhbHVlczpcbiAgICAgICAgLy8gMS4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVycy5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBjb29raWVzKSB7XG4gICAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDIuIE90aGVyd2lzZTpcblxuICAgICAgICAvLyAxLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSBsaXN0LlxuXG4gICAgICAgIC8vIDIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gbnVsbClcblxuICAgICAgICAvLyAzLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJzLlxuICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tIZWFkZXJzTGlzdF1ba0hlYWRlcnNTb3J0ZWRNYXBdID0gaGVhZGVyc1xuXG4gICAgLy8gNC4gUmV0dXJuIGhlYWRlcnMuXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIGtleXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKFxuICAgICAgKCkgPT4gWy4uLnRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdLnZhbHVlcygpXSxcbiAgICAgICdIZWFkZXJzJyxcbiAgICAgICdrZXknXG4gICAgKVxuICB9XG5cbiAgdmFsdWVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICgpID0+IFsuLi50aGlzW2tIZWFkZXJzU29ydGVkTWFwXS52YWx1ZXMoKV0sXG4gICAgICAnSGVhZGVycycsXG4gICAgICAndmFsdWUnXG4gICAgKVxuICB9XG5cbiAgZW50cmllcyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAoKSA9PiBbLi4udGhpc1trSGVhZGVyc1NvcnRlZE1hcF0udmFsdWVzKCldLFxuICAgICAgJ0hlYWRlcnMnLFxuICAgICAgJ2tleSt2YWx1ZSdcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsodmFsdWU6IHN0cmluZywga2V5OiBzdHJpbmcsIHNlbGY6IEhlYWRlcnMpID0+IHZvaWR9IGNhbGxiYWNrRm5cbiAgICogQHBhcmFtIHt1bmtub3dufSB0aGlzQXJnXG4gICAqL1xuICBmb3JFYWNoIChjYWxsYmFja0ZuLCB0aGlzQXJnID0gZ2xvYmFsVGhpcykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnSGVhZGVycy5mb3JFYWNoJyB9KVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja0ZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnSGVhZGVycyc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdGdW5jdGlvbicuXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICBjYWxsYmFja0ZuLmFwcGx5KHRoaXNBcmcsIFt2YWx1ZSwga2V5LCB0aGlzXSlcbiAgICB9XG4gIH1cblxuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdXG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVhZGVycy5wcm90b3R5cGUsIHtcbiAgYXBwZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGFzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldFNldENvb2tpZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2V5czoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdmFsdWVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlbnRyaWVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBmb3JFYWNoOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLml0ZXJhdG9yXTogeyBlbnVtZXJhYmxlOiBmYWxzZSB9LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnSGVhZGVycycsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0ID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnKSB7XG4gICAgaWYgKFZbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nXShWKVxuICAgIH1cblxuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1sncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J10oVilcbiAgfVxuXG4gIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgcHJlZml4OiAnSGVhZGVycyBjb25zdHJ1Y3RvcicsXG4gICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICB0eXBlczogWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nLCAncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J11cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZpbGwsXG4gIEhlYWRlcnMsXG4gIEhlYWRlcnNMaXN0XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/headers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/index.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/fetch/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst {\n  Response,\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse\n} = __webpack_require__(/*! ./response */ \"(ssr)/./node_modules/undici/lib/fetch/response.js\")\nconst { Headers } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/fetch/headers.js\")\nconst { Request, makeRequest } = __webpack_require__(/*! ./request */ \"(ssr)/./node_modules/undici/lib/fetch/request.js\")\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\")\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/fetch/symbols.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { safelyExtractBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/fetch/body.js\")\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  safeMethods,\n  requestBodyHeader,\n  subresource,\n  DOMException\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/fetch/constants.js\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst { Readable, pipeline } = __webpack_require__(/*! stream */ \"stream\")\nconst { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { dataURLProcessor, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\nconst { TransformStream } = __webpack_require__(/*! stream/web */ \"stream/web\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(ssr)/./node_modules/undici/lib/global.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! http */ \"http\")\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\nlet ReadableStream = globalThis.ReadableStream\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n    // 2 terminated listeners get added per request,\n    // but only 1 gets removed. If there are 20 redirects,\n    // 21 listeners will be added.\n    // See https://github.com/nodejs/undici/issues/1711\n    // TODO (fix): Find and fix root cause for leaked listener.\n    this.setMaxListeners(21)\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort (error) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    // 1. Set controllers state to \"aborted\".\n    this.state = 'aborted'\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError')\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controllers serialized abort reason to serializedError.\n    this.serializedAbortReason = error\n\n    this.connection?.destroy(error)\n    this.emit('terminated', error)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch (input, init = {}) {\n  webidl.argumentLengthCheck(arguments, 1, { header: 'globalThis.fetch' })\n\n  // 1. Let p be a new promise.\n  const p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObjects request.\n  const request = requestObject[kState]\n\n  // 4. If requestObjects signals aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObjects signals abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be requests clients global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // requests service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be thiss relevant Realm.\n  const relevantRealm = null\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObjects signal:\n  addAbortListener(\n    requestObject.signal,\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Assert: controller is non-null.\n      assert(controller != null)\n\n      // 3. Abort controller with requestObjects signals abort reason.\n      controller.abort(requestObject.signal.reason)\n\n      // 4. Abort the fetch() call with p, request, responseObject,\n      //    and requestObjects signals abort reason.\n      abortFetch(p, request, responseObject, requestObject.signal.reason)\n    }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  const handleFetchDone = (response) =>\n    finalizeAndReportTiming(response, 'fetch')\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return Promise.resolve()\n    }\n\n    // 2. If responses aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controllers serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason)\n      return Promise.resolve()\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(\n        Object.assign(new TypeError('fetch failed'), { cause: response.error })\n      )\n      return Promise.resolve()\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new Response()\n    responseObject[kState] = response\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = response.headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject)\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: init.dispatcher ?? getGlobalDispatcher() // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If responses URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be responses URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be responses timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be responses cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURLs scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If responses timing allow passed flag is not set, then:\n  if (!timingInfo.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfos end time to the coarsened shared current time\n  // given globals relevant settings objects cross-origin isolated\n  // capability.\n  // TODO: given globals relevant settings objects cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set responses timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction markResourceTiming (timingInfo, originalURL, initiatorType, globalThis, cacheState) {\n  if (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2)) {\n    performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject, error) {\n  // Note: AbortSignal.reason was added in node v17.2.0\n  // which would give us an undefined error to reject with.\n  // Remove this once node v16 is no longer supported.\n  if (!error) {\n    error = new DOMException('The operation was aborted.', 'AbortError')\n  }\n\n  // 1. Reject promise with error.\n  p.reject(error)\n\n  // 2. If requests body is not null and is readable, then cancel requests\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 4. Let response be responseObjects response.\n  const response = responseObject[kState]\n\n  // 5. If responses body is not null and is readable, then error responses\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher // undici\n}) {\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If requests client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to requests clients global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to requests clients cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currenTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If requests body is a byte sequence, then set requests body to\n  //    requests body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If requests window is \"client\", then set requests window to requests\n  // client, if requests clients global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If requests origin is \"client\", then set requests origin to requests\n  // clients origin.\n  if (request.origin === 'client') {\n    // TODO: What if request.client is null?\n    request.origin = request.client?.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If requests policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If requests client is non-null, then set requests policy\n    // container to a clone of requests clients policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set requests policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If requests header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept')) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on requests destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to requests header list.\n    request.headersList.append('accept', value)\n  }\n\n  // 13. If requests header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // requests header list.\n  if (!request.headersList.contains('accept-language')) {\n    request.headersList.append('accept-language', '*')\n  }\n\n  // 14. If requests priority is null, then use requests initiator and\n  // destination appropriately in setting requests priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresource.includes(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams)\n    .catch(err => {\n      fetchParams.controller.terminate(err)\n    })\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If requests local-URLs-only flag is set and requests current URL is\n  // not local, then set response to a network error.\n  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If requests referrer policy is the empty string, then set requests\n  // referrer policy to requests policy containers referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If requests referrer is not \"no-referrer\", then set requests\n  // referrer to the result of invoking determine requests referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set requests current URLs scheme to \"https\" if all of the following\n  // conditions are true:\n  // - requests current URLs scheme is \"http\"\n  // - requests current URLs host is a domain\n  // - Matching requests current URLs host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request)\n\n      if (\n        // - requests current URLs origin is same origin with requests origin,\n        //   and requests response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // requests current URLs scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - requests mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set requests response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // requests mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // requests mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If requests redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set requests response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // requests current URLs scheme is not an HTTP(S) scheme\n      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - requests use-CORS-preflight flag is set\n      // - requests unsafe-request flag is set and either requests method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   requests header list is not empty\n      //    1. Set requests response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set requests response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch(fetchParams)\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If requests response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and responses header list.\n      // TODO\n      // 2. If requests credentials mode is not \"include\" and headerNames\n      // contains `*`, then set responses CORS-exposed header-name list to\n      // all unique header names in responses header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // responses CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on requests response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and responses internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponses URL list is empty, then set it to a clone of\n  // requests URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If requests timing allow failed flag is unset, then set\n  // internalResponses timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If responses type is \"opaque\", internalResponses status is 206,\n  // internalResponses range-requested flag is set, and requests header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.contains('range')\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either requests method is\n  // `HEAD` or `CONNECT`, or internalResponses status is a null body status,\n  // set internalResponses body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    fetchParams.controller.dump = true\n  }\n\n  // 20. If requests integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale(fetchParams, makeNetworkError(reason))\n\n    // 2. If requests response tainting is \"opaque\", or responses body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match requests integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set responses body to bytes as a body.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n\n    // 4. Fully read responses body given processBody and processBodyError.\n    await fullyReadBody(response.body, processBody, processBodyError)\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch (fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams))\n  }\n\n  // 2. Let request be fetchParamss request.\n  const { request } = fetchParams\n\n  const { protocol: scheme } = requestCurrentURL(request)\n\n  // 3. Switch on requests current URLs scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If requests current URLs path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,\n      // and body is the empty byte sequence as a body.\n\n      // Otherwise, return a network error.\n      return Promise.resolve(makeNetworkError('about scheme is not supported'))\n    }\n    case 'blob:': {\n      if (!resolveObjectURL) {\n        resolveObjectURL = (__webpack_require__(/*! buffer */ \"buffer\").resolveObjectURL)\n      }\n\n      // 1. Let blobURLEntry be requests current URLs blob URL entry.\n      const blobURLEntry = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (blobURLEntry.search.length !== 0) {\n        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))\n      }\n\n      const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString())\n\n      // 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys\n      //    object is not a Blob object, then return a network error.\n      if (request.method !== 'GET' || !isBlobLike(blobURLEntryObject)) {\n        return Promise.resolve(makeNetworkError('invalid method'))\n      }\n\n      // 3. Let bodyWithType be the result of safely extracting blobURLEntrys object.\n      const bodyWithType = safelyExtractBody(blobURLEntryObject)\n\n      // 4. Let body be bodyWithTypes body.\n      const body = bodyWithType[0]\n\n      // 5. Let length be bodys length, serialized and isomorphic encoded.\n      const length = isomorphicEncode(`${body.length}`)\n\n      // 6. Let type be bodyWithTypes type if it is non-null; otherwise the empty byte sequence.\n      const type = bodyWithType[1] ?? ''\n\n      // 7. Return a new response whose status message is `OK`, header list is\n      //     (`Content-Length`, length), (`Content-Type`, type) , and body is body.\n      const response = makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-length', { name: 'Content-Length', value: length }],\n          ['content-type', { name: 'Content-Type', value: type }]\n        ]\n      })\n\n      response.body = body\n\n      return Promise.resolve(response)\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on requests current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n      }\n\n      // 3. Let mimeType be dataURLStructs MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is  (`Content-Type`, mimeType) ,\n      //    and body is dataURLStructs body as a body.\n      return Promise.resolve(makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', { name: 'Content-Type', value: mimeType }]\n        ],\n        body: safelyExtractBody(dataURLStruct.body)[0]\n      }))\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return Promise.resolve(makeNetworkError('not implemented... yet...'))\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return Promise.resolve(makeNetworkError('unknown scheme'))\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParamss requests done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParamss process response done is not null, then queue a fetch\n  // task to run fetchParamss process response done given response, with\n  // fetchParamss task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  // 1. If response is a network error, then:\n  if (response.type === 'error') {\n    // 1. Set responses URL list to  fetchParamss requests URL list[0] .\n    response.urlList = [fetchParams.request.urlList[0]]\n\n    // 2. Set responses timing info to the result of creating an opaque timing\n    // info for fetchParamss timing info.\n    response.timingInfo = createOpaqueTimingInfo({\n      startTime: fetchParams.timingInfo.startTime\n    })\n  }\n\n  // 2. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Set fetchParamss requests done flag.\n    fetchParams.request.done = true\n\n    // If fetchParamss process response end-of-body is not null,\n    // then queue a fetch task to run fetchParamss process response\n    // end-of-body given response with fetchParamss task destination.\n    if (fetchParams.processResponseEndOfBody != null) {\n      queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n    }\n  }\n\n  // 3. If fetchParamss process response is non-null, then queue a fetch task\n  // to run fetchParamss process response given response, with fetchParamss\n  // task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => fetchParams.processResponse(response))\n  }\n\n  // 4. If responses body is null, then run processResponseEndOfBody.\n  if (response.body == null) {\n    processResponseEndOfBody()\n  } else {\n  // 5. Otherwise:\n\n    // 1. Let transformStream be a new a TransformStream.\n\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,\n    // enqueues chunk in transformStream.\n    const identityTransformAlgorithm = (chunk, controller) => {\n      controller.enqueue(chunk)\n    }\n\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm\n    // and flushAlgorithm set to processResponseEndOfBody.\n    const transformStream = new TransformStream({\n      start () {},\n      transform: identityTransformAlgorithm,\n      flush: processResponseEndOfBody\n    }, {\n      size () {\n        return 1\n      }\n    }, {\n      size () {\n        return 1\n      }\n    })\n\n    // 4. Set responses body to the result of piping responses body through transformStream.\n    response.body = { stream: response.body.stream.pipeThrough(transformStream) }\n  }\n\n  // 6. If fetchParamss process response consume body is non-null, then:\n  if (fetchParams.processResponseConsumeBody != null) {\n    // 1. Let processBody given nullOrBytes be this step: run fetchParamss\n    // process response consume body given response and nullOrBytes.\n    const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes)\n\n    // 2. Let processBodyError be this step: run fetchParamss process\n    // response consume body given response and failure.\n    const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure)\n\n    // 3. If responses body is null, then queue a fetch task to run processBody\n    // given null, with fetchParamss task destination.\n    if (response.body == null) {\n      queueMicrotask(() => processBody(null))\n    } else {\n      // 4. Otherwise, fully read responses body given processBody, processBodyError,\n      // and fetchParamss task destination.\n      return fullyReadBody(response.body, processBody, processBodyError)\n    }\n    return Promise.resolve()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParamss timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If requests service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If requests redirect mode is \"follow\", then set requests\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If requests response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // requests timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either requests response tainting or responses type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // requests origin, requests client, requests destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponses status is a redirect status, then:\n  if (redirectStatus.includes(actualResponse.status)) {\n    // 1. If actualResponses status is not 303, requests body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy()\n    }\n\n    // 2. Switch on requests redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set responses timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and responses internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponses location URL given requests current\n  // URLs fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err))\n  }\n\n  // 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))\n  }\n\n  // 7. If requests redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'))\n  }\n\n  // 8. Increase requests redirect count by 1.\n  request.redirectCount += 1\n\n  // 9. If requests mode is \"cors\", locationURL includes credentials, and\n  // requests origin is not same origin with locationURLs origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))\n  }\n\n  // 10. If requests response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return Promise.resolve(makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    ))\n  }\n\n  // 11. If actualResponses status is not 303, requests body is non-null,\n  // and requests bodys source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return Promise.resolve(makeNetworkError())\n  }\n\n  // 12. If one of the following is true\n  // - actualResponses status is 301 or 302 and requests method is `POST`\n  // - actualResponses status is 303 and requests method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !['GET', 'HEAD'].includes(request.method))\n  ) {\n    // then:\n    // 1. Set requests method to `GET` and requests body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // requests header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If requests current URLs origin is not same origin with locationURLs\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from requests header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization')\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie')\n    request.headersList.delete('host')\n  }\n\n  // 14. If requests body is non-null, then set requests body to the first return\n  // value of safely extracting requests bodys source.\n  if (request.body != null) {\n    assert(request.body.source != null)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 15. Let timingInfo be fetchParamss timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 16. Set timingInfos redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParamss cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 17. If timingInfos redirect start time is 0, then set timingInfos\n  //  redirect start time to timingInfos start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 18. Append locationURL to requests URL list.\n  request.urlList.push(locationURL)\n\n  // 19. Invoke set requests referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If requests window is \"no-window\" and requests redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = makeRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParamss request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequests bodys length, if httpRequests\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequests body is null and httpRequests method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequests header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequests header list.\n\n  //    10. If contentLength is non-null and httpRequests keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequests referrer is a URL, then append\n  //    `Referer`/httpRequests referrer, serialized and isomorphic encoded,\n  //     to httpRequests header list.\n  if (httpRequest.referrer instanceof URL) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href))\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequests header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequests header list.\n  if (!httpRequest.headersList.contains('user-agent')) {\n    httpRequest.headersList.append('user-agent', typeof esbuildDetection === 'undefined' ? 'undici' : 'node')\n  }\n\n  //    15. If httpRequests cache mode is \"default\" and httpRequests header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequests cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.contains('if-modified-since') ||\n      httpRequest.headersList.contains('if-none-match') ||\n      httpRequest.headersList.contains('if-unmodified-since') ||\n      httpRequest.headersList.contains('if-match') ||\n      httpRequest.headersList.contains('if-range'))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequests cache mode is \"no-cache\", httpRequests prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequests header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequests header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.contains('cache-control')\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0')\n  }\n\n  //    17. If httpRequests cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequests header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequests header list.\n    if (!httpRequest.headersList.contains('pragma')) {\n      httpRequest.headersList.append('pragma', 'no-cache')\n    }\n\n    // 2. If httpRequests header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequests header list.\n    if (!httpRequest.headersList.contains('cache-control')) {\n      httpRequest.headersList.append('cache-control', 'no-cache')\n    }\n  }\n\n  //    18. If httpRequests header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequests header list.\n  if (httpRequest.headersList.contains('range')) {\n    httpRequest.headersList.append('accept-encoding', 'identity')\n  }\n\n  //    19. Modify httpRequests header list per HTTP. Do not append a given\n  //    header if httpRequests header list contains that headers name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding')) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate')\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate')\n    }\n  }\n\n  httpRequest.headersList.delete('host')\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequests header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If theres a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequests cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequests cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequests cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.mode === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequests method is unsafe and forwardResponses status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethods.includes(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponses status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set responses URL list to a clone of httpRequests URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequests header list contains `Range`, then set responses\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range')) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set responses request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If responses status is 401, httpRequests response tainting is not\n  // \"cors\", includeCredentials is true, and requests window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If responses status is 407, then:\n  if (response.status === 407) {\n    // 1. If requests window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in requests window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // responses status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // requests body is null, or requests body is non-null and requests bodys source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n      }\n    }\n  }\n\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParamss timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set requests cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on requests mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given requests current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, requests current URLs origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfos final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connections\n  //    timing info, timingInfos post-redirect start time, and fetchParamss\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, requests body is non-null,\n  //    and requests bodys source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to requests header list.\n\n  //    4. Set timingInfos final network-request start time to the coarsened\n  //    shared current time given fetchParamss cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If requests body is non-null, and requests bodys source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of requests body in that buffer. If the user agent reads from\n  //        requests body beyond that buffers size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfos final network-response start time to the coarsened\n  //        shared current time given fetchParamss cross-origin isolated capability,\n  //        immediately after the user agents HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfos final network-response start time above.\n\n  //    - If requests header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If requests window is an environment settings object, make the\n  //        dialog available in requests window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit requests body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParamss process request end-of-body is\n  // non-null, then queue a fetch task given fetchParamss process request\n  // end-of-body and fetchParamss task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParamss process request body is non-null, then run\n      // fetchParamss process request body given bytess length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParamss process request end-of-body is non-null,\n      // then run fetchParamss process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParamss controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read requests body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParamss task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    // socket is only provided for websockets\n    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })\n\n    if (socket) {\n      response = makeResponse({ status, statusText, headersList, socket })\n    } else {\n      const iterator = body[Symbol.asyncIterator]()\n      fetchParams.controller.next = () => iterator.next()\n\n      response = makeResponse({ status, statusText, headersList })\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = () => {\n    fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss\n  // controller with reason, given reason.\n  const cancelAlgorithm = (reason) => {\n    fetchParams.controller.abort(reason)\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with pullAlgorithm set to pullAlgorithm,\n  // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n  // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n  if (!ReadableStream) {\n    ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n  }\n\n  const stream = new ReadableStream(\n    {\n      async start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      async pull (controller) {\n        await pullAlgorithm(controller)\n      },\n      async cancel (reason) {\n        await cancelAlgorithm(reason)\n      }\n    },\n    {\n      highWaterMark: 0,\n      size () {\n        return 1\n      }\n    }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set responses body to a new body whose stream is stream.\n  response.body = { stream }\n\n  //    2. If response is not a network error and requests cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in responses header list, if any, and requests current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  fetchParams.controller.on('terminated', onAborted)\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      let isFailure\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for responses message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller)\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfos decoded body size by bytess length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParamss controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      fetchParams.controller.controller.enqueue(new Uint8Array(bytes))\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesnt need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (!fetchParams.controller.controller.desiredSize) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set responses aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParamss\n      //    controllers serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          fetchParams.controller.serializedAbortReason\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  async function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    /** @type {import('../..').Agent} */\n    const agent = fetchParams.controller.dispatcher\n\n    return new Promise((resolve, reject) => agent.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,\n        headers: request.headersList.entries,\n        maxRedirections: 0,\n        upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n        },\n\n        onHeaders (status, headersList, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          let codings = []\n          let location = ''\n\n          const headers = new Headers()\n\n          // For H2, the headers are a plain JS object\n          // We distinguish between them and iterate accordingly\n          if (Array.isArray(headersList)) {\n            for (let n = 0; n < headersList.length; n += 2) {\n              const key = headersList[n + 0].toString('latin1')\n              const val = headersList[n + 1].toString('latin1')\n              if (key.toLowerCase() === 'content-encoding') {\n                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                // \"All content-coding values are case-insensitive...\"\n                codings = val.toLowerCase().split(',').map((x) => x.trim())\n              } else if (key.toLowerCase() === 'location') {\n                location = val\n              }\n\n              headers.append(key, val)\n            }\n          } else {\n            const keys = Object.keys(headersList)\n            for (const key of keys) {\n              const val = headersList[key]\n              if (key.toLowerCase() === 'content-encoding') {\n                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                // \"All content-coding values are case-insensitive...\"\n                codings = val.toLowerCase().split(',').map((x) => x.trim()).reverse()\n              } else if (key.toLowerCase() === 'location') {\n                location = val\n              }\n\n              headers.append(key, val)\n            }\n          }\n\n          this.body = new Readable({ read: resume })\n\n          const decoders = []\n\n          const willFollow = request.redirect === 'follow' &&\n            location &&\n            redirectStatus.includes(status)\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            for (const coding of codings) {\n              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n              if (coding === 'x-gzip' || coding === 'gzip') {\n                decoders.push(zlib.createGunzip({\n                  // Be less strict when decoding compressed responses, since sometimes\n                  // servers send slightly invalid responses that are still accepted\n                  // by common browsers.\n                  // Always using Z_SYNC_FLUSH is what cURL does.\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'deflate') {\n                decoders.push(zlib.createInflate())\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress())\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          resolve({\n            status,\n            statusText,\n            headersList: headers[kHeadersList],\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, () => { })\n              : this.body.on('error', () => {})\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from responses\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and responses header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfos encoded body size by bytess length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        },\n\n        onUpgrade (status, headersList, socket) {\n          if (status !== 101) {\n            return\n          }\n\n          const headers = new Headers()\n\n          for (let n = 0; n < headersList.length; n += 2) {\n            const key = headersList[n + 0].toString('latin1')\n            const val = headersList[n + 1].toString('latin1')\n\n            headers.append(key, val)\n          }\n\n          resolve({\n            status,\n            statusText: STATUS_CODES[status],\n            headersList: headers[kHeadersList],\n            socket\n          })\n\n          return true\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxxRUFBWTtBQUN4QixRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLG1FQUFXO0FBQ3ZDLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxtRUFBVztBQUNwRCxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDZEQUFRO0FBQ3BCLFFBQVEsbUNBQW1DLEVBQUUsbUJBQU8sQ0FBQyxtRUFBVztBQUNoRSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLDZEQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsdUVBQWE7QUFDekIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDbEQsV0FBVyxtQkFBTyxDQUFDLHNCQUFRO0FBQzNCLFFBQVEscUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQyxRQUFRLGdFQUFnRSxFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDaEcsUUFBUSx1Q0FBdUMsRUFBRSxtQkFBTyxDQUFDLG1FQUFXO0FBQ3BFLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyw4QkFBWTtBQUNoRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsNERBQVc7QUFDbkQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxpRUFBVTtBQUNyQyxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLGtCQUFNOztBQUV2QyxXQUFXLG1DQUFtQztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDZDQUE2Qyw0QkFBNEI7O0FBRXpFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx1QkFBdUI7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEU7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFVBQVU7O0FBRXBCLFVBQVUsbUJBQW1COztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFrQztBQUM3RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsWUFBWTs7QUFFckQsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUNBQXVDO0FBQ3RFLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtFQUFrRTtBQUNs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QUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxjQUFjOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsOENBQThDO0FBQzlDLFdBQVc7O0FBRVg7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaW5kZXguanM/N2NhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vRXRoYW4tQXJyb3dvb2QvdW5kaWNpLWZldGNoXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIFJlc3BvbnNlLFxuICBtYWtlTmV0d29ya0Vycm9yLFxuICBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IsXG4gIGZpbHRlclJlc3BvbnNlLFxuICBtYWtlUmVzcG9uc2Vcbn0gPSByZXF1aXJlKCcuL3Jlc3BvbnNlJylcbmNvbnN0IHsgSGVhZGVycyB9ID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcbmNvbnN0IHsgUmVxdWVzdCwgbWFrZVJlcXVlc3QgfSA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpXG5jb25zdCB7XG4gIGJ5dGVzTWF0Y2gsXG4gIG1ha2VQb2xpY3lDb250YWluZXIsXG4gIGNsb25lUG9saWN5Q29udGFpbmVyLFxuICByZXF1ZXN0QmFkUG9ydCxcbiAgVEFPQ2hlY2ssXG4gIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIsXG4gIHJlc3BvbnNlTG9jYXRpb25VUkwsXG4gIHJlcXVlc3RDdXJyZW50VVJMLFxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8sXG4gIGFwcGVuZEZldGNoTWV0YWRhdGEsXG4gIGNvcnNDaGVjayxcbiAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrLFxuICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBpc0Jsb2JMaWtlLFxuICBzYW1lT3JpZ2luLFxuICBpc0NhbmNlbGxlZCxcbiAgaXNBYm9ydGVkLFxuICBpc0Vycm9yTGlrZSxcbiAgZnVsbHlSZWFkQm9keSxcbiAgcmVhZGFibGVTdHJlYW1DbG9zZSxcbiAgaXNvbW9ycGhpY0VuY29kZSxcbiAgdXJsSXNMb2NhbCxcbiAgdXJsSXNIdHRwSHR0cHNTY2hlbWUsXG4gIHVybEhhc0h0dHBzU2NoZW1lXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga1N0YXRlLCBrSGVhZGVycywga0d1YXJkLCBrUmVhbG0gfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBzYWZlbHlFeHRyYWN0Qm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHtcbiAgcmVkaXJlY3RTdGF0dXMsXG4gIG51bGxCb2R5U3RhdHVzLFxuICBzYWZlTWV0aG9kcyxcbiAgcmVxdWVzdEJvZHlIZWFkZXIsXG4gIHN1YnJlc291cmNlLFxuICBET01FeGNlcHRpb25cbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IHsgUmVhZGFibGUsIHBpcGVsaW5lIH0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgeyBhZGRBYm9ydExpc3RlbmVyLCBpc0Vycm9yZWQsIGlzUmVhZGFibGUsIG5vZGVNYWpvciwgbm9kZU1pbm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBkYXRhVVJMUHJvY2Vzc29yLCBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YVVSTCcpXG5jb25zdCB7IFRyYW5zZm9ybVN0cmVhbSB9ID0gcmVxdWlyZSgnc3RyZWFtL3dlYicpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uL2dsb2JhbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBTVEFUVVNfQ09ERVMgfSA9IHJlcXVpcmUoJ2h0dHAnKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnYnVmZmVyJykucmVzb2x2ZU9iamVjdFVSTH0gKi9cbmxldCByZXNvbHZlT2JqZWN0VVJMXG5sZXQgUmVhZGFibGVTdHJlYW0gPSBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtXG5cbmNsYXNzIEZldGNoIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAoZGlzcGF0Y2hlcikge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXJcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsXG4gICAgdGhpcy5kdW1wID0gZmFsc2VcbiAgICB0aGlzLnN0YXRlID0gJ29uZ29pbmcnXG4gICAgLy8gMiB0ZXJtaW5hdGVkIGxpc3RlbmVycyBnZXQgYWRkZWQgcGVyIHJlcXVlc3QsXG4gICAgLy8gYnV0IG9ubHkgMSBnZXRzIHJlbW92ZWQuIElmIHRoZXJlIGFyZSAyMCByZWRpcmVjdHMsXG4gICAgLy8gMjEgbGlzdGVuZXJzIHdpbGwgYmUgYWRkZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNzExXG4gICAgLy8gVE9ETyAoZml4KTogRmluZCBhbmQgZml4IHJvb3QgY2F1c2UgZm9yIGxlYWtlZCBsaXN0ZW5lci5cbiAgICB0aGlzLnNldE1heExpc3RlbmVycygyMSlcbiAgfVxuXG4gIHRlcm1pbmF0ZSAocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdvbmdvaW5nJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9ICd0ZXJtaW5hdGVkJ1xuICAgIHRoaXMuY29ubmVjdGlvbj8uZGVzdHJveShyZWFzb24pXG4gICAgdGhpcy5lbWl0KCd0ZXJtaW5hdGVkJywgcmVhc29uKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoLWNvbnRyb2xsZXItYWJvcnRcbiAgYWJvcnQgKGVycm9yKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdvbmdvaW5nJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMS4gU2V0IGNvbnRyb2xsZXLigJlzIHN0YXRlIHRvIFwiYWJvcnRlZFwiLlxuICAgIHRoaXMuc3RhdGUgPSAnYWJvcnRlZCdcblxuICAgIC8vIDIuIExldCBmYWxsYmFja0Vycm9yIGJlIGFuIFwiQWJvcnRFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAvLyAzLiBTZXQgZXJyb3IgdG8gZmFsbGJhY2tFcnJvciBpZiBpdCBpcyBub3QgZ2l2ZW4uXG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgZXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA0LiBMZXQgc2VyaWFsaXplZEVycm9yIGJlIFN0cnVjdHVyZWRTZXJpYWxpemUoZXJyb3IpLlxuICAgIC8vICAgIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCBjYXRjaCBpdCwgYW5kIGxldFxuICAgIC8vICAgIHNlcmlhbGl6ZWRFcnJvciBiZSBTdHJ1Y3R1cmVkU2VyaWFsaXplKGZhbGxiYWNrRXJyb3IpLlxuXG4gICAgLy8gNS4gU2V0IGNvbnRyb2xsZXLigJlzIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIHRvIHNlcmlhbGl6ZWRFcnJvci5cbiAgICB0aGlzLnNlcmlhbGl6ZWRBYm9ydFJlYXNvbiA9IGVycm9yXG5cbiAgICB0aGlzLmNvbm5lY3Rpb24/LmRlc3Ryb3koZXJyb3IpXG4gICAgdGhpcy5lbWl0KCd0ZXJtaW5hdGVkJywgZXJyb3IpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoLW1ldGhvZFxuZnVuY3Rpb24gZmV0Y2ggKGlucHV0LCBpbml0ID0ge30pIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ2dsb2JhbFRoaXMuZmV0Y2gnIH0pXG5cbiAgLy8gMS4gTGV0IHAgYmUgYSBuZXcgcHJvbWlzZS5cbiAgY29uc3QgcCA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgLy8gMi4gTGV0IHJlcXVlc3RPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgaW5pdGlhbCB2YWx1ZSBvZlxuICAvLyBSZXF1ZXN0IGFzIGNvbnN0cnVjdG9yIHdpdGggaW5wdXQgYW5kIGluaXQgYXMgYXJndW1lbnRzLiBJZiB0aGlzIHRocm93c1xuICAvLyBhbiBleGNlcHRpb24sIHJlamVjdCBwIHdpdGggaXQgYW5kIHJldHVybiBwLlxuICBsZXQgcmVxdWVzdE9iamVjdFxuXG4gIHRyeSB7XG4gICAgcmVxdWVzdE9iamVjdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICB9IGNhdGNoIChlKSB7XG4gICAgcC5yZWplY3QoZSlcbiAgICByZXR1cm4gcC5wcm9taXNlXG4gIH1cblxuICAvLyAzLiBMZXQgcmVxdWVzdCBiZSByZXF1ZXN0T2JqZWN04oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdE9iamVjdFtrU3RhdGVdXG5cbiAgLy8gNC4gSWYgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydGVkIGZsYWcgaXMgc2V0LCB0aGVuOlxuICBpZiAocmVxdWVzdE9iamVjdC5zaWduYWwuYWJvcnRlZCkge1xuICAgIC8vIDEuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCBudWxsLCBhbmRcbiAgICAvLyAgICByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIG51bGwsIHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcblxuICAgIC8vIDIuIFJldHVybiBwLlxuICAgIHJldHVybiBwLnByb21pc2VcbiAgfVxuXG4gIC8vIDUuIExldCBnbG9iYWxPYmplY3QgYmUgcmVxdWVzdOKAmXMgY2xpZW504oCZcyBnbG9iYWwgb2JqZWN0LlxuICBjb25zdCBnbG9iYWxPYmplY3QgPSByZXF1ZXN0LmNsaWVudC5nbG9iYWxPYmplY3RcblxuICAvLyA2LiBJZiBnbG9iYWxPYmplY3QgaXMgYSBTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGUgb2JqZWN0LCB0aGVuIHNldFxuICAvLyByZXF1ZXN04oCZcyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSB0byBcIm5vbmVcIi5cbiAgaWYgKGdsb2JhbE9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGUnKSB7XG4gICAgcmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9ICdub25lJ1xuICB9XG5cbiAgLy8gNy4gTGV0IHJlc3BvbnNlT2JqZWN0IGJlIG51bGwuXG4gIGxldCByZXNwb25zZU9iamVjdCA9IG51bGxcblxuICAvLyA4LiBMZXQgcmVsZXZhbnRSZWFsbSBiZSB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IG51bGxcblxuICAvLyA5LiBMZXQgbG9jYWxseUFib3J0ZWQgYmUgZmFsc2UuXG4gIGxldCBsb2NhbGx5QWJvcnRlZCA9IGZhbHNlXG5cbiAgLy8gMTAuIExldCBjb250cm9sbGVyIGJlIG51bGwuXG4gIGxldCBjb250cm9sbGVyID0gbnVsbFxuXG4gIC8vIDExLiBBZGQgdGhlIGZvbGxvd2luZyBhYm9ydCBzdGVwcyB0byByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWw6XG4gIGFkZEFib3J0TGlzdGVuZXIoXG4gICAgcmVxdWVzdE9iamVjdC5zaWduYWwsXG4gICAgKCkgPT4ge1xuICAgICAgLy8gMS4gU2V0IGxvY2FsbHlBYm9ydGVkIHRvIHRydWUuXG4gICAgICBsb2NhbGx5QWJvcnRlZCA9IHRydWVcblxuICAgICAgLy8gMi4gQXNzZXJ0OiBjb250cm9sbGVyIGlzIG5vbi1udWxsLlxuICAgICAgYXNzZXJ0KGNvbnRyb2xsZXIgIT0gbnVsbClcblxuICAgICAgLy8gMy4gQWJvcnQgY29udHJvbGxlciB3aXRoIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgICAgY29udHJvbGxlci5hYm9ydChyZXF1ZXN0T2JqZWN0LnNpZ25hbC5yZWFzb24pXG5cbiAgICAgIC8vIDQuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCxcbiAgICAgIC8vICAgIGFuZCByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcbiAgICB9XG4gIClcblxuICAvLyAxMi4gTGV0IGhhbmRsZUZldGNoRG9uZSBnaXZlbiByZXNwb25zZSByZXNwb25zZSBiZSB0byBmaW5hbGl6ZSBhbmRcbiAgLy8gcmVwb3J0IHRpbWluZyB3aXRoIHJlc3BvbnNlLCBnbG9iYWxPYmplY3QsIGFuZCBcImZldGNoXCIuXG4gIGNvbnN0IGhhbmRsZUZldGNoRG9uZSA9IChyZXNwb25zZSkgPT5cbiAgICBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyhyZXNwb25zZSwgJ2ZldGNoJylcblxuICAvLyAxMy4gU2V0IGNvbnRyb2xsZXIgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGZldGNoIGdpdmVuIHJlcXVlc3QsXG4gIC8vIHdpdGggcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IHNldCB0byBoYW5kbGVGZXRjaERvbmUsIGFuZCBwcm9jZXNzUmVzcG9uc2VcbiAgLy8gZ2l2ZW4gcmVzcG9uc2UgYmVpbmcgdGhlc2Ugc3Vic3RlcHM6XG5cbiAgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgLy8gMS4gSWYgbG9jYWxseUFib3J0ZWQgaXMgdHJ1ZSwgdGVybWluYXRlIHRoZXNlIHN1YnN0ZXBzLlxuICAgIGlmIChsb2NhbGx5QWJvcnRlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgcmVzcG9uc2XigJlzIGFib3J0ZWQgZmxhZyBpcyBzZXQsIHRoZW46XG4gICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgIC8vIDEuIExldCBkZXNlcmlhbGl6ZWRFcnJvciBiZSB0aGUgcmVzdWx0IG9mIGRlc2VyaWFsaXplIGEgc2VyaWFsaXplZFxuICAgICAgLy8gICAgYWJvcnQgcmVhc29uIGdpdmVuIGNvbnRyb2xsZXLigJlzIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGFuZFxuICAgICAgLy8gICAgcmVsZXZhbnRSZWFsbS5cblxuICAgICAgLy8gMi4gQWJvcnQgdGhlIGZldGNoKCkgY2FsbCB3aXRoIHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LCBhbmRcbiAgICAgIC8vICAgIGRlc2VyaWFsaXplZEVycm9yLlxuXG4gICAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LCBjb250cm9sbGVyLnNlcmlhbGl6ZWRBYm9ydFJlYXNvbilcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIC8vIDMuIElmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiByZWplY3QgcCB3aXRoIGEgVHlwZUVycm9yXG4gICAgLy8gYW5kIHRlcm1pbmF0ZSB0aGVzZSBzdWJzdGVwcy5cbiAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgcC5yZWplY3QoXG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3IFR5cGVFcnJvcignZmV0Y2ggZmFpbGVkJyksIHsgY2F1c2U6IHJlc3BvbnNlLmVycm9yIH0pXG4gICAgICApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICAvLyA0LiBTZXQgcmVzcG9uc2VPYmplY3QgdG8gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCxcbiAgICAvLyBnaXZlbiByZXNwb25zZSwgXCJpbW11dGFibGVcIiwgYW5kIHJlbGV2YW50UmVhbG0uXG4gICAgcmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UoKVxuICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0gPSByZXNwb25zZVxuICAgIHJlc3BvbnNlT2JqZWN0W2tSZWFsbV0gPSByZWxldmFudFJlYWxtXG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSByZXNwb25zZS5oZWFkZXJzTGlzdFxuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gJ2ltbXV0YWJsZSdcbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cblxuICAgIC8vIDUuIFJlc29sdmUgcCB3aXRoIHJlc3BvbnNlT2JqZWN0LlxuICAgIHAucmVzb2x2ZShyZXNwb25zZU9iamVjdClcbiAgfVxuXG4gIGNvbnRyb2xsZXIgPSBmZXRjaGluZyh7XG4gICAgcmVxdWVzdCxcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHk6IGhhbmRsZUZldGNoRG9uZSxcbiAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgZGlzcGF0Y2hlcjogaW5pdC5kaXNwYXRjaGVyID8/IGdldEdsb2JhbERpc3BhdGNoZXIoKSAvLyB1bmRpY2lcbiAgfSlcblxuICAvLyAxNC4gUmV0dXJuIHAuXG4gIHJldHVybiBwLnByb21pc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZpbmFsaXplLWFuZC1yZXBvcnQtdGltaW5nXG5mdW5jdGlvbiBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyAocmVzcG9uc2UsIGluaXRpYXRvclR5cGUgPSAnb3RoZXInKSB7XG4gIC8vIDEuIElmIHJlc3BvbnNlIGlzIGFuIGFib3J0ZWQgbmV0d29yayBlcnJvciwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InICYmIHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIElmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBudWxsIG9yIGVtcHR5LCB0aGVuIHJldHVybi5cbiAgaWYgKCFyZXNwb25zZS51cmxMaXN0Py5sZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDMuIExldCBvcmlnaW5hbFVSTCBiZSByZXNwb25zZeKAmXMgVVJMIGxpc3RbMF0uXG4gIGNvbnN0IG9yaWdpbmFsVVJMID0gcmVzcG9uc2UudXJsTGlzdFswXVxuXG4gIC8vIDQuIExldCB0aW1pbmdJbmZvIGJlIHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mby5cbiAgbGV0IHRpbWluZ0luZm8gPSByZXNwb25zZS50aW1pbmdJbmZvXG5cbiAgLy8gNS4gTGV0IGNhY2hlU3RhdGUgYmUgcmVzcG9uc2XigJlzIGNhY2hlIHN0YXRlLlxuICBsZXQgY2FjaGVTdGF0ZSA9IHJlc3BvbnNlLmNhY2hlU3RhdGVcblxuICAvLyA2LiBJZiBvcmlnaW5hbFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZSwgdGhlbiByZXR1cm4uXG4gIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUob3JpZ2luYWxVUkwpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA3LiBJZiB0aW1pbmdJbmZvIGlzIG51bGwsIHRoZW4gcmV0dXJuLlxuICBpZiAodGltaW5nSW5mbyA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gOC4gSWYgcmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZyBpcyBub3Qgc2V0LCB0aGVuOlxuICBpZiAoIXRpbWluZ0luZm8udGltaW5nQWxsb3dQYXNzZWQpIHtcbiAgICAvLyAgMS4gU2V0IHRpbWluZ0luZm8gdG8gYSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIG9wYXF1ZSB0aW1pbmcgaW5mbyBmb3IgdGltaW5nSW5mby5cbiAgICB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgICBzdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lXG4gICAgfSlcblxuICAgIC8vICAyLiBTZXQgY2FjaGVTdGF0ZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIGNhY2hlU3RhdGUgPSAnJ1xuICB9XG5cbiAgLy8gOS4gU2V0IHRpbWluZ0luZm/igJlzIGVuZCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZVxuICAvLyBnaXZlbiBnbG9iYWzigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHkuXG4gIC8vIFRPRE86IGdpdmVuIGdsb2JhbOKAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eT9cbiAgdGltaW5nSW5mby5lbmRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoKVxuXG4gIC8vIDEwLiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRpbWluZ0luZm8uXG4gIHJlc3BvbnNlLnRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG5cbiAgLy8gMTEuIE1hcmsgcmVzb3VyY2UgdGltaW5nIGZvciB0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTCwgaW5pdGlhdG9yVHlwZSxcbiAgLy8gZ2xvYmFsLCBhbmQgY2FjaGVTdGF0ZS5cbiAgbWFya1Jlc291cmNlVGltaW5nKFxuICAgIHRpbWluZ0luZm8sXG4gICAgb3JpZ2luYWxVUkwsXG4gICAgaW5pdGlhdG9yVHlwZSxcbiAgICBnbG9iYWxUaGlzLFxuICAgIGNhY2hlU3RhdGVcbiAgKVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vcmVzb3VyY2UtdGltaW5nLyNkZm4tbWFyay1yZXNvdXJjZS10aW1pbmdcbmZ1bmN0aW9uIG1hcmtSZXNvdXJjZVRpbWluZyAodGltaW5nSW5mbywgb3JpZ2luYWxVUkwsIGluaXRpYXRvclR5cGUsIGdsb2JhbFRoaXMsIGNhY2hlU3RhdGUpIHtcbiAgaWYgKG5vZGVNYWpvciA+IDE4IHx8IChub2RlTWFqb3IgPT09IDE4ICYmIG5vZGVNaW5vciA+PSAyKSkge1xuICAgIHBlcmZvcm1hbmNlLm1hcmtSZXNvdXJjZVRpbWluZyh0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTC5ocmVmLCBpbml0aWF0b3JUeXBlLCBnbG9iYWxUaGlzLCBjYWNoZVN0YXRlKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhYm9ydC1mZXRjaFxuZnVuY3Rpb24gYWJvcnRGZXRjaCAocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGVycm9yKSB7XG4gIC8vIE5vdGU6IEFib3J0U2lnbmFsLnJlYXNvbiB3YXMgYWRkZWQgaW4gbm9kZSB2MTcuMi4wXG4gIC8vIHdoaWNoIHdvdWxkIGdpdmUgdXMgYW4gdW5kZWZpbmVkIGVycm9yIHRvIHJlamVjdCB3aXRoLlxuICAvLyBSZW1vdmUgdGhpcyBvbmNlIG5vZGUgdjE2IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXG4gIGlmICghZXJyb3IpIHtcbiAgICBlcnJvciA9IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICB9XG5cbiAgLy8gMS4gUmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgcC5yZWplY3QoZXJyb3IpXG5cbiAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub3QgbnVsbCBhbmQgaXMgcmVhZGFibGUsIHRoZW4gY2FuY2VsIHJlcXVlc3TigJlzXG4gIC8vIGJvZHkgd2l0aCBlcnJvci5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsICYmIGlzUmVhZGFibGUocmVxdWVzdC5ib2R5Py5zdHJlYW0pKSB7XG4gICAgcmVxdWVzdC5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgcmVzcG9uc2VPYmplY3QgaXMgbnVsbCwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZU9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNlLlxuICBjb25zdCByZXNwb25zZSA9IHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV1cblxuICAvLyA1LiBJZiByZXNwb25zZeKAmXMgYm9keSBpcyBub3QgbnVsbCBhbmQgaXMgcmVhZGFibGUsIHRoZW4gZXJyb3IgcmVzcG9uc2XigJlzXG4gIC8vIGJvZHkgd2l0aCBlcnJvci5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCAmJiBpc1JlYWRhYmxlKHJlc3BvbnNlLmJvZHk/LnN0cmVhbSkpIHtcbiAgICByZXNwb25zZS5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaGluZ1xuZnVuY3Rpb24gZmV0Y2hpbmcgKHtcbiAgcmVxdWVzdCxcbiAgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICBwcm9jZXNzUmVzcG9uc2UsXG4gIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gIHVzZVBhcmFsbGVsUXVldWUgPSBmYWxzZSxcbiAgZGlzcGF0Y2hlciAvLyB1bmRpY2lcbn0pIHtcbiAgLy8gMS4gTGV0IHRhc2tEZXN0aW5hdGlvbiBiZSBudWxsLlxuICBsZXQgdGFza0Rlc3RpbmF0aW9uID0gbnVsbFxuXG4gIC8vIDIuIExldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSBiZSBmYWxzZS5cbiAgbGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID0gZmFsc2VcblxuICAvLyAzLiBJZiByZXF1ZXN04oCZcyBjbGllbnQgaXMgbm9uLW51bGwsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgLy8gMS4gU2V0IHRhc2tEZXN0aW5hdGlvbiB0byByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gICAgdGFza0Rlc3RpbmF0aW9uID0gcmVxdWVzdC5jbGllbnQuZ2xvYmFsT2JqZWN0XG5cbiAgICAvLyAyLiBTZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgdG8gcmVxdWVzdOKAmXMgY2xpZW504oCZcyBjcm9zcy1vcmlnaW5cbiAgICAvLyBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50LmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA0LiBJZiB1c2VQYXJhbGxlbFF1ZXVlIGlzIHRydWUsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0byB0aGUgcmVzdWx0IG9mXG4gIC8vIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gTGV0IHRpbWluZ0luZm8gYmUgYSBuZXcgZmV0Y2ggdGltaW5nIGluZm8gd2hvc2Ugc3RhcnQgdGltZSBhbmRcbiAgLy8gcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIGFyZSB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW5cbiAgLy8gY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkuXG4gIGNvbnN0IGN1cnJlblRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbiAgY29uc3QgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgIHN0YXJ0VGltZTogY3VycmVuVGltZVxuICB9KVxuXG4gIC8vIDYuIExldCBmZXRjaFBhcmFtcyBiZSBhIG5ldyBmZXRjaCBwYXJhbXMgd2hvc2VcbiAgLy8gcmVxdWVzdCBpcyByZXF1ZXN0LFxuICAvLyB0aW1pbmcgaW5mbyBpcyB0aW1pbmdJbmZvLFxuICAvLyBwcm9jZXNzIHJlcXVlc3QgYm9keSBjaHVuayBsZW5ndGggaXMgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIC8vIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpcyBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBpcyBwcm9jZXNzUmVzcG9uc2UsXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgY29uc3VtZSBib2R5IGlzIHByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5LFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGlzIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgLy8gdGFzayBkZXN0aW5hdGlvbiBpcyB0YXNrRGVzdGluYXRpb24sXG4gIC8vIGFuZCBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSBpcyBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eS5cbiAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgY29udHJvbGxlcjogbmV3IEZldGNoKGRpc3BhdGNoZXIpLFxuICAgIHJlcXVlc3QsXG4gICAgdGltaW5nSW5mbyxcbiAgICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgICBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAgIHRhc2tEZXN0aW5hdGlvbixcbiAgICBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eVxuICB9XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGJvZHkgdG9cbiAgLy8gICAgcmVxdWVzdOKAmXMgYm9keSBhcyBhIGJvZHkuXG4gIC8vIE5PVEU6IFNpbmNlIGZldGNoaW5nIGlzIG9ubHkgY2FsbGVkIGZyb20gZmV0Y2gsIGJvZHkgc2hvdWxkIGFscmVhZHkgYmVcbiAgLy8gZXh0cmFjdGVkLlxuICBhc3NlcnQoIXJlcXVlc3QuYm9keSB8fCByZXF1ZXN0LmJvZHkuc3RyZWFtKVxuXG4gIC8vIDguIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcImNsaWVudFwiLCB0aGVuIHNldCByZXF1ZXN04oCZcyB3aW5kb3cgdG8gcmVxdWVzdOKAmXNcbiAgLy8gY2xpZW50LCBpZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QgaXMgYSBXaW5kb3cgb2JqZWN0OyBvdGhlcndpc2VcbiAgLy8gXCJuby13aW5kb3dcIi5cbiAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnY2xpZW50Jykge1xuICAgIC8vIFRPRE86IFdoYXQgaWYgcmVxdWVzdC5jbGllbnQgaXMgbnVsbD9cbiAgICByZXF1ZXN0LndpbmRvdyA9XG4gICAgICByZXF1ZXN0LmNsaWVudD8uZ2xvYmFsT2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ1dpbmRvdydcbiAgICAgICAgPyByZXF1ZXN0LmNsaWVudFxuICAgICAgICA6ICduby13aW5kb3cnXG4gIH1cblxuICAvLyA5LiBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgXCJjbGllbnRcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIHJlcXVlc3TigJlzXG4gIC8vIGNsaWVudOKAmXMgb3JpZ2luLlxuICBpZiAocmVxdWVzdC5vcmlnaW4gPT09ICdjbGllbnQnKSB7XG4gICAgLy8gVE9ETzogV2hhdCBpZiByZXF1ZXN0LmNsaWVudCBpcyBudWxsP1xuICAgIHJlcXVlc3Qub3JpZ2luID0gcmVxdWVzdC5jbGllbnQ/Lm9yaWdpblxuICB9XG5cbiAgLy8gMTAuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIFRPRE9cblxuICAvLyAxMS4gSWYgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciBpcyBcImNsaWVudFwiLCB0aGVuOlxuICBpZiAocmVxdWVzdC5wb2xpY3lDb250YWluZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgY2xpZW50IGlzIG5vbi1udWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBwb2xpY3lcbiAgICAvLyBjb250YWluZXIgdG8gYSBjbG9uZSBvZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIHBvbGljeSBjb250YWluZXIuIFtIVE1MXVxuICAgIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9IGNsb25lUG9saWN5Q29udGFpbmVyKFxuICAgICAgICByZXF1ZXN0LmNsaWVudC5wb2xpY3lDb250YWluZXJcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciB0byBhIG5ldyBwb2xpY3lcbiAgICAgIC8vIGNvbnRhaW5lci5cbiAgICAgIHJlcXVlc3QucG9saWN5Q29udGFpbmVyID0gbWFrZVBvbGljeUNvbnRhaW5lcigpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdGAsIHRoZW46XG4gIGlmICghcmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0JykpIHtcbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgYCovKmAuXG4gICAgY29uc3QgdmFsdWUgPSAnKi8qJ1xuXG4gICAgLy8gMi4gQSB1c2VyIGFnZW50IHNob3VsZCBzZXQgdmFsdWUgdG8gdGhlIGZpcnN0IG1hdGNoaW5nIHN0YXRlbWVudCwgaWZcbiAgICAvLyBhbnksIHN3aXRjaGluZyBvbiByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbjpcbiAgICAvLyBcImRvY3VtZW50XCJcbiAgICAvLyBcImZyYW1lXCJcbiAgICAvLyBcImlmcmFtZVwiXG4gICAgLy8gYHRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LCovKjtxPTAuOGBcbiAgICAvLyBcImltYWdlXCJcbiAgICAvLyBgaW1hZ2UvcG5nLGltYWdlL3N2Zyt4bWwsaW1hZ2UvKjtxPTAuOCwqLyo7cT0wLjVgXG4gICAgLy8gXCJzdHlsZVwiXG4gICAgLy8gYHRleHQvY3NzLCovKjtxPTAuMWBcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAzLiBBcHBlbmQgYEFjY2VwdGAvdmFsdWUgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdCcsIHZhbHVlKVxuICB9XG5cbiAgLy8gMTMuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdC1MYW5ndWFnZWAsIHRoZW5cbiAgLy8gdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgQWNjZXB0LUxhbmd1YWdlYC9hbiBhcHByb3ByaWF0ZSB2YWx1ZSB0b1xuICAvLyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtbGFuZ3VhZ2UnKSkge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtbGFuZ3VhZ2UnLCAnKicpXG4gIH1cblxuICAvLyAxNC4gSWYgcmVxdWVzdOKAmXMgcHJpb3JpdHkgaXMgbnVsbCwgdGhlbiB1c2UgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIGFuZFxuICAvLyBkZXN0aW5hdGlvbiBhcHByb3ByaWF0ZWx5IGluIHNldHRpbmcgcmVxdWVzdOKAmXMgcHJpb3JpdHkgdG8gYVxuICAvLyB1c2VyLWFnZW50LWRlZmluZWQgb2JqZWN0LlxuICBpZiAocmVxdWVzdC5wcmlvcml0eSA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE1LiBJZiByZXF1ZXN0IGlzIGEgc3VicmVzb3VyY2UgcmVxdWVzdCwgdGhlbjpcbiAgaWYgKHN1YnJlc291cmNlLmluY2x1ZGVzKHJlcXVlc3QuZGVzdGluYXRpb24pKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gMTYuIFJ1biBtYWluIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICBtYWluRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShlcnIpXG4gICAgfSlcblxuICAvLyAxNy4gUmV0dXJuIGZldGNoUGFyYW0ncyBjb250cm9sbGVyXG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1haW4tZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIG1haW5GZXRjaCAoZmV0Y2hQYXJhbXMsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gMy4gSWYgcmVxdWVzdOKAmXMgbG9jYWwtVVJMcy1vbmx5IGZsYWcgaXMgc2V0IGFuZCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTCBpc1xuICAvLyBub3QgbG9jYWwsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKHJlcXVlc3QubG9jYWxVUkxzT25seSAmJiAhdXJsSXNMb2NhbChyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ2xvY2FsIFVSTHMgb25seScpXG4gIH1cblxuICAvLyA0LiBSdW4gcmVwb3J0IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHZpb2xhdGlvbnMgZm9yIHJlcXVlc3QuXG4gIC8vIFRPRE9cblxuICAvLyA1LiBVcGdyYWRlIHJlcXVlc3QgdG8gYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIGlmIGFwcHJvcHJpYXRlLlxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwocmVxdWVzdClcblxuICAvLyA2LiBJZiBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBhIGJhZCBwb3J0LCBzaG91bGQgZmV0Y2hpbmcgcmVxdWVzdFxuICAvLyBiZSBibG9ja2VkIGFzIG1peGVkIGNvbnRlbnQsIG9yIHNob3VsZCByZXF1ZXN0IGJlIGJsb2NrZWQgYnkgQ29udGVudFxuICAvLyBTZWN1cml0eSBQb2xpY3kgcmV0dXJucyBibG9ja2VkLCB0aGVuIHNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChyZXF1ZXN0QmFkUG9ydChyZXF1ZXN0KSA9PT0gJ2Jsb2NrZWQnKSB7XG4gICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCdiYWQgcG9ydCcpXG4gIH1cbiAgLy8gVE9ETzogc2hvdWxkIGZldGNoaW5nIHJlcXVlc3QgYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50P1xuICAvLyBUT0RPOiBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5P1xuXG4gIC8vIDcuIElmIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlciBwb2xpY3kgdG8gcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lcuKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICBpZiAocmVxdWVzdC5yZWZlcnJlclBvbGljeSA9PT0gJycpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gcmVxdWVzdC5wb2xpY3lDb250YWluZXIucmVmZXJyZXJQb2xpY3lcbiAgfVxuXG4gIC8vIDguIElmIHJlcXVlc3TigJlzIHJlZmVycmVyIGlzIG5vdCBcIm5vLXJlZmVycmVyXCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzXG4gIC8vIHJlZmVycmVyIHRvIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgZGV0ZXJtaW5lIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICBpZiAocmVxdWVzdC5yZWZlcnJlciAhPT0gJ25vLXJlZmVycmVyJykge1xuICAgIHJlcXVlc3QucmVmZXJyZXIgPSBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyKHJlcXVlc3QpXG4gIH1cblxuICAvLyA5LiBTZXQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSB0byBcImh0dHBzXCIgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBhcmUgdHJ1ZTpcbiAgLy8gLSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIFwiaHR0cFwiXG4gIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGhvc3QgaXMgYSBkb21haW5cbiAgLy8gLSBNYXRjaGluZyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgaG9zdCBwZXIgS25vd24gSFNUUyBIb3N0IERvbWFpbiBOYW1lXG4gIC8vICAgTWF0Y2hpbmcgcmVzdWx0cyBpbiBlaXRoZXIgYSBzdXBlcmRvbWFpbiBtYXRjaCB3aXRoIGFuIGFzc2VydGVkXG4gIC8vICAgaW5jbHVkZVN1YkRvbWFpbnMgZGlyZWN0aXZlIG9yIGEgY29uZ3J1ZW50IG1hdGNoICh3aXRoIG9yIHdpdGhvdXQgYW5cbiAgLy8gICBhc3NlcnRlZCBpbmNsdWRlU3ViRG9tYWlucyBkaXJlY3RpdmUpLiBbSFNUU11cbiAgLy8gVE9ET1xuXG4gIC8vIDEwLiBJZiByZWN1cnNpdmUgaXMgZmFsc2UsIHRoZW4gcnVuIHRoZSByZW1haW5pbmcgc3RlcHMgaW4gcGFyYWxsZWwuXG4gIC8vIFRPRE9cblxuICAvLyAxMS4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gIC8vIHRoZSBzdGVwcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBmaXJzdCBtYXRjaGluZyBzdGF0ZW1lbnQ6XG4gIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgIHJlc3BvbnNlID0gYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICBpZiAoXG4gICAgICAgIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbiBpcyBzYW1lIG9yaWdpbiB3aXRoIHJlcXVlc3TigJlzIG9yaWdpbixcbiAgICAgICAgLy8gICBhbmQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJiYXNpY1wiXG4gICAgICAgIChzYW1lT3JpZ2luKGN1cnJlbnRVUkwsIHJlcXVlc3QudXJsKSAmJiByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdiYXNpYycpIHx8XG4gICAgICAgIC8vIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgXCJkYXRhXCJcbiAgICAgICAgKGN1cnJlbnRVUkwucHJvdG9jb2wgPT09ICdkYXRhOicpIHx8XG4gICAgICAgIC8vIC0gcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5hdmlnYXRlXCIgb3IgXCJ3ZWJzb2NrZXRcIlxuICAgICAgICAocmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnIHx8IHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpXG4gICAgICApIHtcbiAgICAgICAgLy8gMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiYmFzaWNcIi5cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ2Jhc2ljJ1xuXG4gICAgICAgIC8vIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgc2NoZW1lIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgICAgICByZXR1cm4gYXdhaXQgc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJzYW1lLW9yaWdpblwiXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnc2FtZS1vcmlnaW4nKSB7XG4gICAgICAgIC8vIDEuIFJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdyZXF1ZXN0IG1vZGUgY2Fubm90IGJlIFwic2FtZS1vcmlnaW5cIicpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuby1jb3JzXCJcbiAgICAgIGlmIChyZXF1ZXN0Lm1vZGUgPT09ICduby1jb3JzJykge1xuICAgICAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzIG5vdCBcImZvbGxvd1wiLCB0aGVuIHJldHVybiBhIG5ldHdvcmtcbiAgICAgICAgLy8gZXJyb3IuXG4gICAgICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ICE9PSAnZm9sbG93Jykge1xuICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFxuICAgICAgICAgICAgJ3JlZGlyZWN0IG1vZGUgY2Fubm90IGJlIFwiZm9sbG93XCIgZm9yIFwibm8tY29yc1wiIHJlcXVlc3QnXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwib3BhcXVlXCIuXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdvcGFxdWUnXG5cbiAgICAgICAgLy8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBzY2hlbWUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgICAgIHJldHVybiBhd2FpdCBzY2hlbWVGZXRjaChmZXRjaFBhcmFtcylcbiAgICAgIH1cblxuICAgICAgLy8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWVcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgICAgIC8vIFJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdVUkwgc2NoZW1lIG11c3QgYmUgYSBIVFRQKFMpIHNjaGVtZScpXG4gICAgICB9XG5cbiAgICAgIC8vIC0gcmVxdWVzdOKAmXMgdXNlLUNPUlMtcHJlZmxpZ2h0IGZsYWcgaXMgc2V0XG4gICAgICAvLyAtIHJlcXVlc3TigJlzIHVuc2FmZS1yZXF1ZXN0IGZsYWcgaXMgc2V0IGFuZCBlaXRoZXIgcmVxdWVzdOKAmXMgbWV0aG9kIGlzXG4gICAgICAvLyAgIG5vdCBhIENPUlMtc2FmZWxpc3RlZCBtZXRob2Qgb3IgQ09SUy11bnNhZmUgcmVxdWVzdC1oZWFkZXIgbmFtZXMgd2l0aFxuICAgICAgLy8gICByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBpcyBub3QgZW1wdHlcbiAgICAgIC8vICAgIDEuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcImNvcnNcIi5cbiAgICAgIC8vICAgIDIuIExldCBjb3JzV2l0aFByZWZsaWdodFJlc3BvbnNlIGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQIGZldGNoXG4gICAgICAvLyAgICBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgdHJ1ZS5cbiAgICAgIC8vICAgIDMuIElmIGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIGNsZWFyIGNhY2hlXG4gICAgICAvLyAgICBlbnRyaWVzIHVzaW5nIHJlcXVlc3QuXG4gICAgICAvLyAgICA0LiBSZXR1cm4gY29yc1dpdGhQcmVmbGlnaHRSZXNwb25zZS5cbiAgICAgIC8vIFRPRE9cblxuICAgICAgLy8gT3RoZXJ3aXNlXG4gICAgICAvLyAgICAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJjb3JzXCIuXG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnY29ycydcblxuICAgICAgLy8gICAgMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgICAgcmV0dXJuIGF3YWl0IGh0dHBGZXRjaChmZXRjaFBhcmFtcylcbiAgICB9KSgpXG4gIH1cblxuICAvLyAxMi4gSWYgcmVjdXJzaXZlIGlzIHRydWUsIHRoZW4gcmV0dXJuIHJlc3BvbnNlLlxuICBpZiAocmVjdXJzaXZlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvLyAxMy4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgcmVzcG9uc2UgaXMgbm90IGEgZmlsdGVyZWRcbiAgLy8gcmVzcG9uc2UsIHRoZW46XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDAgJiYgIXJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UpIHtcbiAgICAvLyBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiwgdGhlbjpcbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycpIHtcbiAgICAgIC8vIDEuIExldCBoZWFkZXJOYW1lcyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzXG4gICAgICAvLyBnaXZlbiBgQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnNgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAvLyBUT0RPXG4gICAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlIGlzIG5vdCBcImluY2x1ZGVcIiBhbmQgaGVhZGVyTmFtZXNcbiAgICAgIC8vIGNvbnRhaW5zIGAqYCwgdGhlbiBzZXQgcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0IHRvXG4gICAgICAvLyBhbGwgdW5pcXVlIGhlYWRlciBuYW1lcyBpbiByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAvLyBUT0RPXG4gICAgICAvLyAzLiBPdGhlcndpc2UsIGlmIGhlYWRlck5hbWVzIGlzIG5vdCBudWxsIG9yIGZhaWx1cmUsIHRoZW4gc2V0XG4gICAgICAvLyByZXNwb25zZeKAmXMgQ09SUy1leHBvc2VkIGhlYWRlci1uYW1lIGxpc3QgdG8gaGVhZGVyTmFtZXMuXG4gICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgLy8gU2V0IHJlc3BvbnNlIHRvIHRoZSBmb2xsb3dpbmcgZmlsdGVyZWQgcmVzcG9uc2Ugd2l0aCByZXNwb25zZSBhcyBpdHNcbiAgICAvLyBpbnRlcm5hbCByZXNwb25zZSwgZGVwZW5kaW5nIG9uIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nOlxuICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdiYXNpYycpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdiYXNpYycpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJykge1xuICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgJ2NvcnMnKVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnb3BhcXVlJykge1xuICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgJ29wYXF1ZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSlcbiAgICB9XG4gIH1cblxuICAvLyAxNC4gTGV0IGludGVybmFsUmVzcG9uc2UgYmUgcmVzcG9uc2UsIGlmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvcixcbiAgLy8gYW5kIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZSBvdGhlcndpc2UuXG4gIGxldCBpbnRlcm5hbFJlc3BvbnNlID1cbiAgICByZXNwb25zZS5zdGF0dXMgPT09IDAgPyByZXNwb25zZSA6IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2VcblxuICAvLyAxNS4gSWYgaW50ZXJuYWxSZXNwb25zZeKAmXMgVVJMIGxpc3QgaXMgZW1wdHksIHRoZW4gc2V0IGl0IHRvIGEgY2xvbmUgb2ZcbiAgLy8gcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gIGlmIChpbnRlcm5hbFJlc3BvbnNlLnVybExpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgaW50ZXJuYWxSZXNwb25zZS51cmxMaXN0LnB1c2goLi4ucmVxdWVzdC51cmxMaXN0KVxuICB9XG5cbiAgLy8gMTYuIElmIHJlcXVlc3TigJlzIHRpbWluZyBhbGxvdyBmYWlsZWQgZmxhZyBpcyB1bnNldCwgdGhlbiBzZXRcbiAgLy8gaW50ZXJuYWxSZXNwb25zZeKAmXMgdGltaW5nIGFsbG93IHBhc3NlZCBmbGFnLlxuICBpZiAoIXJlcXVlc3QudGltaW5nQWxsb3dGYWlsZWQpIHtcbiAgICByZXNwb25zZS50aW1pbmdBbGxvd1Bhc3NlZCA9IHRydWVcbiAgfVxuXG4gIC8vIDE3LiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCBhbnkgb2YgdGhlIGZvbGxvd2luZyByZXR1cm5zXG4gIC8vIGJsb2NrZWRcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudFxuICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50IFNlY3VyaXR5IFBvbGljeVxuICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBkdWUgdG8gaXRzIE1JTUUgdHlwZVxuICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBkdWUgdG8gbm9zbmlmZlxuICAvLyBUT0RPXG5cbiAgLy8gMTguIElmIHJlc3BvbnNl4oCZcyB0eXBlIGlzIFwib3BhcXVlXCIsIGludGVybmFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyAyMDYsXG4gIC8vIGludGVybmFsUmVzcG9uc2XigJlzIHJhbmdlLXJlcXVlc3RlZCBmbGFnIGlzIHNldCwgYW5kIHJlcXVlc3TigJlzIGhlYWRlclxuICAvLyBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFJhbmdlYCwgdGhlbiBzZXQgcmVzcG9uc2UgYW5kIGludGVybmFsUmVzcG9uc2VcbiAgLy8gdG8gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgcmVzcG9uc2UudHlwZSA9PT0gJ29wYXF1ZScgJiZcbiAgICBpbnRlcm5hbFJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2ICYmXG4gICAgaW50ZXJuYWxSZXNwb25zZS5yYW5nZVJlcXVlc3RlZCAmJlxuICAgICFyZXF1ZXN0LmhlYWRlcnMuY29udGFpbnMoJ3JhbmdlJylcbiAgKSB7XG4gICAgcmVzcG9uc2UgPSBpbnRlcm5hbFJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcigpXG4gIH1cblxuICAvLyAxOS4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgZWl0aGVyIHJlcXVlc3TigJlzIG1ldGhvZCBpc1xuICAvLyBgSEVBRGAgb3IgYENPTk5FQ1RgLCBvciBpbnRlcm5hbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYSBudWxsIGJvZHkgc3RhdHVzLFxuICAvLyBzZXQgaW50ZXJuYWxSZXNwb25zZeKAmXMgYm9keSB0byBudWxsIGFuZCBkaXNyZWdhcmQgYW55IGVucXVldWluZyB0b3dhcmRcbiAgLy8gaXQgKGlmIGFueSkuXG4gIGlmIChcbiAgICByZXNwb25zZS5zdGF0dXMgIT09IDAgJiZcbiAgICAocmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJyB8fFxuICAgICAgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJyB8fFxuICAgICAgbnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMoaW50ZXJuYWxSZXNwb25zZS5zdGF0dXMpKVxuICApIHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlLmJvZHkgPSBudWxsXG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kdW1wID0gdHJ1ZVxuICB9XG5cbiAgLy8gMjAuIElmIHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbjpcbiAgaWYgKHJlcXVlc3QuaW50ZWdyaXR5KSB7XG4gICAgLy8gMS4gTGV0IHByb2Nlc3NCb2R5RXJyb3IgYmUgdGhpcyBzdGVwOiBydW4gZmV0Y2ggZmluYWxlIGdpdmVuIGZldGNoUGFyYW1zXG4gICAgLy8gYW5kIGEgbmV0d29yayBlcnJvci5cbiAgICBjb25zdCBwcm9jZXNzQm9keUVycm9yID0gKHJlYXNvbikgPT5cbiAgICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCBtYWtlTmV0d29ya0Vycm9yKHJlYXNvbikpXG5cbiAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcIm9wYXF1ZVwiLCBvciByZXNwb25zZeKAmXMgYm9keSBpcyBudWxsLFxuICAgIC8vIHRoZW4gcnVuIHByb2Nlc3NCb2R5RXJyb3IgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdvcGFxdWUnIHx8IHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzc0JvZHlFcnJvcihyZXNwb25zZS5lcnJvcilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDMuIExldCBwcm9jZXNzQm9keSBnaXZlbiBieXRlcyBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzQm9keSA9IChieXRlcykgPT4ge1xuICAgICAgLy8gMS4gSWYgYnl0ZXMgZG8gbm90IG1hdGNoIHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YSxcbiAgICAgIC8vIHRoZW4gcnVuIHByb2Nlc3NCb2R5RXJyb3IgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLiBbU1JJXVxuICAgICAgaWYgKCFieXRlc01hdGNoKGJ5dGVzLCByZXF1ZXN0LmludGVncml0eSkpIHtcbiAgICAgICAgcHJvY2Vzc0JvZHlFcnJvcignaW50ZWdyaXR5IG1pc21hdGNoJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBieXRlcyBhcyBhIGJvZHkuXG4gICAgICByZXNwb25zZS5ib2R5ID0gc2FmZWx5RXh0cmFjdEJvZHkoYnl0ZXMpWzBdXG5cbiAgICAgIC8vIDMuIFJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLlxuICAgICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIDQuIEZ1bGx5IHJlYWQgcmVzcG9uc2XigJlzIGJvZHkgZ2l2ZW4gcHJvY2Vzc0JvZHkgYW5kIHByb2Nlc3NCb2R5RXJyb3IuXG4gICAgYXdhaXQgZnVsbHlSZWFkQm9keShyZXNwb25zZS5ib2R5LCBwcm9jZXNzQm9keSwgcHJvY2Vzc0JvZHlFcnJvcilcbiAgfSBlbHNlIHtcbiAgICAvLyAyMS4gT3RoZXJ3aXNlLCBydW4gZmV0Y2ggZmluYWxlIGdpdmVuIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZS5cbiAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtc2NoZW1lLWZldGNoXG4vLyBnaXZlbiBhIGZldGNoIHBhcmFtcyBmZXRjaFBhcmFtc1xuZnVuY3Rpb24gc2NoZW1lRmV0Y2ggKGZldGNoUGFyYW1zKSB7XG4gIC8vIE5vdGU6IHNpbmNlIHRoZSBjb25uZWN0aW9uIGlzIGRlc3Ryb3llZCBvbiByZWRpcmVjdCwgd2hpY2ggc2V0cyBmZXRjaFBhcmFtcyB0byBhXG4gIC8vIGNhbmNlbGxlZCBzdGF0ZSwgd2UgZG8gbm90IHdhbnQgdGhpcyBjb25kaXRpb24gdG8gdHJpZ2dlciAqdW5sZXNzKiB0aGVyZSBoYXZlIGJlZW5cbiAgLy8gbm8gcmVkaXJlY3RzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE3NzZcbiAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSAmJiBmZXRjaFBhcmFtcy5yZXF1ZXN0LnJlZGlyZWN0Q291bnQgPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcykpXG4gIH1cblxuICAvLyAyLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgeyByZXF1ZXN0IH0gPSBmZXRjaFBhcmFtc1xuXG4gIGNvbnN0IHsgcHJvdG9jb2w6IHNjaGVtZSB9ID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAzLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBhbmQgcnVuIHRoZSBhc3NvY2lhdGVkIHN0ZXBzOlxuICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgIGNhc2UgJ2Fib3V0Oic6IHtcbiAgICAgIC8vIElmIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBwYXRoIGlzIHRoZSBzdHJpbmcgXCJibGFua1wiLCB0aGVuIHJldHVybiBhIG5ldyByZXNwb25zZVxuICAgICAgLy8gd2hvc2Ugc3RhdHVzIG1lc3NhZ2UgaXMgYE9LYCwgaGVhZGVyIGxpc3QgaXMgwqsgKGBDb250ZW50LVR5cGVgLCBgdGV4dC9odG1sO2NoYXJzZXQ9dXRmLThgKSDCuyxcbiAgICAgIC8vIGFuZCBib2R5IGlzIHRoZSBlbXB0eSBieXRlIHNlcXVlbmNlIGFzIGEgYm9keS5cblxuICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdhYm91dCBzY2hlbWUgaXMgbm90IHN1cHBvcnRlZCcpKVxuICAgIH1cbiAgICBjYXNlICdibG9iOic6IHtcbiAgICAgIGlmICghcmVzb2x2ZU9iamVjdFVSTCkge1xuICAgICAgICByZXNvbHZlT2JqZWN0VVJMID0gcmVxdWlyZSgnYnVmZmVyJykucmVzb2x2ZU9iamVjdFVSTFxuICAgICAgfVxuXG4gICAgICAvLyAxLiBMZXQgYmxvYlVSTEVudHJ5IGJlIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBibG9iIFVSTCBlbnRyeS5cbiAgICAgIGNvbnN0IGJsb2JVUkxFbnRyeSA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWItcGxhdGZvcm0tdGVzdHMvd3B0L2Jsb2IvN2IwZWJhY2NjNjJiNTY2YTE5NjUzOTZlNWJlN2JiMmJjMDZmODQxZi9GaWxlQVBJL3VybC9yZXNvdXJjZXMvZmV0Y2gtdGVzdHMuanMjTDUyLUw1NlxuICAgICAgLy8gQnVmZmVyLnJlc29sdmVPYmplY3RVUkwgZG9lcyBub3QgaWdub3JlIFVSTCBxdWVyaWVzLlxuICAgICAgaWYgKGJsb2JVUkxFbnRyeS5zZWFyY2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS4nKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmxvYlVSTEVudHJ5T2JqZWN0ID0gcmVzb2x2ZU9iamVjdFVSTChibG9iVVJMRW50cnkudG9TdHJpbmcoKSlcblxuICAgICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5vdCBgR0VUYCwgYmxvYlVSTEVudHJ5IGlzIG51bGwsIG9yIGJsb2JVUkxFbnRyeeKAmXNcbiAgICAgIC8vICAgIG9iamVjdCBpcyBub3QgYSBCbG9iIG9iamVjdCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnR0VUJyB8fCAhaXNCbG9iTGlrZShibG9iVVJMRW50cnlPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignaW52YWxpZCBtZXRob2QnKSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gTGV0IGJvZHlXaXRoVHlwZSBiZSB0aGUgcmVzdWx0IG9mIHNhZmVseSBleHRyYWN0aW5nIGJsb2JVUkxFbnRyeeKAmXMgb2JqZWN0LlxuICAgICAgY29uc3QgYm9keVdpdGhUeXBlID0gc2FmZWx5RXh0cmFjdEJvZHkoYmxvYlVSTEVudHJ5T2JqZWN0KVxuXG4gICAgICAvLyA0LiBMZXQgYm9keSBiZSBib2R5V2l0aFR5cGXigJlzIGJvZHkuXG4gICAgICBjb25zdCBib2R5ID0gYm9keVdpdGhUeXBlWzBdXG5cbiAgICAgIC8vIDUuIExldCBsZW5ndGggYmUgYm9keeKAmXMgbGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgICBjb25zdCBsZW5ndGggPSBpc29tb3JwaGljRW5jb2RlKGAke2JvZHkubGVuZ3RofWApXG5cbiAgICAgIC8vIDYuIExldCB0eXBlIGJlIGJvZHlXaXRoVHlwZeKAmXMgdHlwZSBpZiBpdCBpcyBub24tbnVsbDsgb3RoZXJ3aXNlIHRoZSBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICAgICAgY29uc3QgdHlwZSA9IGJvZHlXaXRoVHlwZVsxXSA/PyAnJ1xuXG4gICAgICAvLyA3LiBSZXR1cm4gYSBuZXcgcmVzcG9uc2Ugd2hvc2Ugc3RhdHVzIG1lc3NhZ2UgaXMgYE9LYCwgaGVhZGVyIGxpc3QgaXNcbiAgICAgIC8vICAgIMKrIChgQ29udGVudC1MZW5ndGhgLCBsZW5ndGgpLCAoYENvbnRlbnQtVHlwZWAsIHR5cGUpIMK7LCBhbmQgYm9keSBpcyBib2R5LlxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBtYWtlUmVzcG9uc2Uoe1xuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzTGlzdDogW1xuICAgICAgICAgIFsnY29udGVudC1sZW5ndGgnLCB7IG5hbWU6ICdDb250ZW50LUxlbmd0aCcsIHZhbHVlOiBsZW5ndGggfV0sXG4gICAgICAgICAgWydjb250ZW50LXR5cGUnLCB7IG5hbWU6ICdDb250ZW50LVR5cGUnLCB2YWx1ZTogdHlwZSB9XVxuICAgICAgICBdXG4gICAgICB9KVxuXG4gICAgICByZXNwb25zZS5ib2R5ID0gYm9keVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICAgIH1cbiAgICBjYXNlICdkYXRhOic6IHtcbiAgICAgIC8vIDEuIExldCBkYXRhVVJMU3RydWN0IGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGVcbiAgICAgIC8vICAgIGRhdGE6IFVSTCBwcm9jZXNzb3Igb24gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcbiAgICAgIGNvbnN0IGRhdGFVUkxTdHJ1Y3QgPSBkYXRhVVJMUHJvY2Vzc29yKGN1cnJlbnRVUkwpXG5cbiAgICAgIC8vIDIuIElmIGRhdGFVUkxTdHJ1Y3QgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYVxuICAgICAgLy8gICAgbmV0d29yayBlcnJvci5cbiAgICAgIGlmIChkYXRhVVJMU3RydWN0ID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdmYWlsZWQgdG8gZmV0Y2ggdGhlIGRhdGEgVVJMJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIExldCBtaW1lVHlwZSBiZSBkYXRhVVJMU3RydWN04oCZcyBNSU1FIHR5cGUsIHNlcmlhbGl6ZWQuXG4gICAgICBjb25zdCBtaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZShkYXRhVVJMU3RydWN0Lm1pbWVUeXBlKVxuXG4gICAgICAvLyA0LiBSZXR1cm4gYSByZXNwb25zZSB3aG9zZSBzdGF0dXMgbWVzc2FnZSBpcyBgT0tgLFxuICAgICAgLy8gICAgaGVhZGVyIGxpc3QgaXMgwqsgKGBDb250ZW50LVR5cGVgLCBtaW1lVHlwZSkgwrssXG4gICAgICAvLyAgICBhbmQgYm9keSBpcyBkYXRhVVJMU3RydWN04oCZcyBib2R5IGFzIGEgYm9keS5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZVJlc3BvbnNlKHtcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyc0xpc3Q6IFtcbiAgICAgICAgICBbJ2NvbnRlbnQtdHlwZScsIHsgbmFtZTogJ0NvbnRlbnQtVHlwZScsIHZhbHVlOiBtaW1lVHlwZSB9XVxuICAgICAgICBdLFxuICAgICAgICBib2R5OiBzYWZlbHlFeHRyYWN0Qm9keShkYXRhVVJMU3RydWN0LmJvZHkpWzBdXG4gICAgICB9KSlcbiAgICB9XG4gICAgY2FzZSAnZmlsZTonOiB7XG4gICAgICAvLyBGb3Igbm93LCB1bmZvcnR1bmF0ZSBhcyBpdCBpcywgZmlsZSBVUkxzIGFyZSBsZWZ0IGFzIGFuIGV4ZXJjaXNlIGZvciB0aGUgcmVhZGVyLlxuICAgICAgLy8gV2hlbiBpbiBkb3VidCwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignbm90IGltcGxlbWVudGVkLi4uIHlldC4uLicpKVxuICAgIH1cbiAgICBjYXNlICdodHRwOic6XG4gICAgY2FzZSAnaHR0cHM6Jzoge1xuICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuXG4gICAgICByZXR1cm4gaHR0cEZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgICAuY2F0Y2goKGVycikgPT4gbWFrZU5ldHdvcmtFcnJvcihlcnIpKVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ3Vua25vd24gc2NoZW1lJykpXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmaW5hbGl6ZS1yZXNwb25zZVxuZnVuY3Rpb24gZmluYWxpemVSZXNwb25zZSAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIFNldCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgZG9uZSBmbGFnLlxuICBmZXRjaFBhcmFtcy5yZXF1ZXN0LmRvbmUgPSB0cnVlXG5cbiAgLy8gMiwgSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZG9uZSBpcyBub3QgbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoXG4gIC8vIHRhc2sgdG8gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGRvbmUgZ2l2ZW4gcmVzcG9uc2UsIHdpdGhcbiAgLy8gZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lICE9IG51bGwpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lKHJlc3BvbnNlKSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtZmluYWxlXG5mdW5jdGlvbiBmZXRjaEZpbmFsZSAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIElmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAvLyAxLiBTZXQgcmVzcG9uc2XigJlzIFVSTCBsaXN0IHRvIMKrIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBVUkwgbGlzdFswXSDCuy5cbiAgICByZXNwb25zZS51cmxMaXN0ID0gW2ZldGNoUGFyYW1zLnJlcXVlc3QudXJsTGlzdFswXV1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZeKAmXMgdGltaW5nIGluZm8gdG8gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBvcGFxdWUgdGltaW5nXG4gICAgLy8gaW5mbyBmb3IgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICAgIHJlc3BvbnNlLnRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHtcbiAgICAgIHN0YXJ0VGltZTogZmV0Y2hQYXJhbXMudGltaW5nSW5mby5zdGFydFRpbWVcbiAgICB9KVxuICB9XG5cbiAgLy8gMi4gTGV0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSBiZSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICBjb25zdCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgPSAoKSA9PiB7XG4gICAgLy8gMS4gU2V0IGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBkb25lIGZsYWcuXG4gICAgZmV0Y2hQYXJhbXMucmVxdWVzdC5kb25lID0gdHJ1ZVxuXG4gICAgLy8gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZW5kLW9mLWJvZHkgaXMgbm90IG51bGwsXG4gICAgLy8gdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlXG4gICAgLy8gZW5kLW9mLWJvZHkgZ2l2ZW4gcmVzcG9uc2Ugd2l0aCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5ICE9IG51bGwpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keShyZXNwb25zZSkpXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgaXMgbm9uLW51bGwsIHRoZW4gcXVldWUgYSBmZXRjaCB0YXNrXG4gIC8vIHRvIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBnaXZlbiByZXNwb25zZSwgd2l0aCBmZXRjaFBhcmFtc+KAmXNcbiAgLy8gdGFzayBkZXN0aW5hdGlvbi5cbiAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8vIDQuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcnVuIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keS5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSgpXG4gIH0gZWxzZSB7XG4gIC8vIDUuIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIExldCB0cmFuc2Zvcm1TdHJlYW0gYmUgYSBuZXcgYSBUcmFuc2Zvcm1TdHJlYW0uXG5cbiAgICAvLyAyLiBMZXQgaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG0gYmUgYW4gYWxnb3JpdGhtIHdoaWNoLCBnaXZlbiBjaHVuayxcbiAgICAvLyBlbnF1ZXVlcyBjaHVuayBpbiB0cmFuc2Zvcm1TdHJlYW0uXG4gICAgY29uc3QgaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG0gPSAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICB9XG5cbiAgICAvLyAzLiBTZXQgdXAgdHJhbnNmb3JtU3RyZWFtIHdpdGggdHJhbnNmb3JtQWxnb3JpdGhtIHNldCB0byBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobVxuICAgIC8vIGFuZCBmbHVzaEFsZ29yaXRobSBzZXQgdG8gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LlxuICAgIGNvbnN0IHRyYW5zZm9ybVN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgc3RhcnQgKCkge30sXG4gICAgICB0cmFuc2Zvcm06IGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtLFxuICAgICAgZmx1c2g6IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVxuICAgIH0sIHtcbiAgICAgIHNpemUgKCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpemUgKCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyA0LiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gdGhlIHJlc3VsdCBvZiBwaXBpbmcgcmVzcG9uc2XigJlzIGJvZHkgdGhyb3VnaCB0cmFuc2Zvcm1TdHJlYW0uXG4gICAgcmVzcG9uc2UuYm9keSA9IHsgc3RyZWFtOiByZXNwb25zZS5ib2R5LnN0cmVhbS5waXBlVGhyb3VnaCh0cmFuc2Zvcm1TdHJlYW0pIH1cbiAgfVxuXG4gIC8vIDYuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGNvbnN1bWUgYm9keSBpcyBub24tbnVsbCwgdGhlbjpcbiAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5ICE9IG51bGwpIHtcbiAgICAvLyAxLiBMZXQgcHJvY2Vzc0JvZHkgZ2l2ZW4gbnVsbE9yQnl0ZXMgYmUgdGhpcyBzdGVwOiBydW4gZmV0Y2hQYXJhbXPigJlzXG4gICAgLy8gcHJvY2VzcyByZXNwb25zZSBjb25zdW1lIGJvZHkgZ2l2ZW4gcmVzcG9uc2UgYW5kIG51bGxPckJ5dGVzLlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5ID0gKG51bGxPckJ5dGVzKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keShyZXNwb25zZSwgbnVsbE9yQnl0ZXMpXG5cbiAgICAvLyAyLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBiZSB0aGlzIHN0ZXA6IHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2Vzc1xuICAgIC8vIHJlc3BvbnNlIGNvbnN1bWUgYm9keSBnaXZlbiByZXNwb25zZSBhbmQgZmFpbHVyZS5cbiAgICBjb25zdCBwcm9jZXNzQm9keUVycm9yID0gKGZhaWx1cmUpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5KHJlc3BvbnNlLCBmYWlsdXJlKVxuXG4gICAgLy8gMy4gSWYgcmVzcG9uc2XigJlzIGJvZHkgaXMgbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5XG4gICAgLy8gZ2l2ZW4gbnVsbCwgd2l0aCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBwcm9jZXNzQm9keShudWxsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBmdWxseSByZWFkIHJlc3BvbnNl4oCZcyBib2R5IGdpdmVuIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yLFxuICAgICAgLy8gYW5kIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICAgICAgcmV0dXJuIGZ1bGx5UmVhZEJvZHkocmVzcG9uc2UuYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwRmV0Y2ggKGZldGNoUGFyYW1zKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gMy4gTGV0IGFjdHVhbFJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCBhY3R1YWxSZXNwb25zZSA9IG51bGxcblxuICAvLyA0LiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gNS4gSWYgcmVxdWVzdOKAmXMgc2VydmljZS13b3JrZXJzIG1vZGUgaXMgXCJhbGxcIiwgdGhlbjpcbiAgaWYgKHJlcXVlc3Quc2VydmljZVdvcmtlcnMgPT09ICdhbGwnKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gNi4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgLy8gMS4gSWYgbWFrZUNPUlNQcmVmbGlnaHQgaXMgdHJ1ZSBhbmQgb25lIG9mIHRoZXNlIGNvbmRpdGlvbnMgaXMgdHJ1ZTpcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzIFwiZm9sbG93XCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzXG4gICAgLy8gc2VydmljZS13b3JrZXJzIG1vZGUgdG8gXCJub25lXCIuXG4gICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdmb2xsb3cnKSB7XG4gICAgICByZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID0gJ25vbmUnXG4gICAgfVxuXG4gICAgLy8gMy4gU2V0IHJlc3BvbnNlIGFuZCBhY3R1YWxSZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgYWN0dWFsUmVzcG9uc2UgPSByZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKGZldGNoUGFyYW1zKVxuXG4gICAgLy8gNC4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIgYW5kIGEgQ09SUyBjaGVja1xuICAgIC8vIGZvciByZXF1ZXN0IGFuZCByZXNwb25zZSByZXR1cm5zIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICBpZiAoXG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyAmJlxuICAgICAgY29yc0NoZWNrKHJlcXVlc3QsIHJlc3BvbnNlKSA9PT0gJ2ZhaWx1cmUnXG4gICAgKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignY29ycyBmYWlsdXJlJylcbiAgICB9XG5cbiAgICAvLyA1LiBJZiB0aGUgVEFPIGNoZWNrIGZvciByZXF1ZXN0IGFuZCByZXNwb25zZSByZXR1cm5zIGZhaWx1cmUsIHRoZW4gc2V0XG4gICAgLy8gcmVxdWVzdOKAmXMgdGltaW5nIGFsbG93IGZhaWxlZCBmbGFnLlxuICAgIGlmIChUQU9DaGVjayhyZXF1ZXN0LCByZXNwb25zZSkgPT09ICdmYWlsdXJlJykge1xuICAgICAgcmVxdWVzdC50aW1pbmdBbGxvd0ZhaWxlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyA3LiBJZiBlaXRoZXIgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgb3IgcmVzcG9uc2XigJlzIHR5cGVcbiAgLy8gaXMgXCJvcGFxdWVcIiwgYW5kIHRoZSBjcm9zcy1vcmlnaW4gcmVzb3VyY2UgcG9saWN5IGNoZWNrIHdpdGhcbiAgLy8gcmVxdWVzdOKAmXMgb3JpZ2luLCByZXF1ZXN04oCZcyBjbGllbnQsIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uLFxuICAvLyBhbmQgYWN0dWFsUmVzcG9uc2UgcmV0dXJucyBibG9ja2VkLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnb3BhcXVlJyB8fCByZXNwb25zZS50eXBlID09PSAnb3BhcXVlJykgJiZcbiAgICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2soXG4gICAgICByZXF1ZXN0Lm9yaWdpbixcbiAgICAgIHJlcXVlc3QuY2xpZW50LFxuICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbixcbiAgICAgIGFjdHVhbFJlc3BvbnNlXG4gICAgKSA9PT0gJ2Jsb2NrZWQnXG4gICkge1xuICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdibG9ja2VkJylcbiAgfVxuXG4gIC8vIDguIElmIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYSByZWRpcmVjdCBzdGF0dXMsIHRoZW46XG4gIGlmIChyZWRpcmVjdFN0YXR1cy5pbmNsdWRlcyhhY3R1YWxSZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgLy8gMS4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgMzAzLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vdCBudWxsLFxuICAgIC8vIGFuZCB0aGUgY29ubmVjdGlvbiB1c2VzIEhUVFAvMiwgdGhlbiB1c2VyIGFnZW50cyBtYXksIGFuZCBhcmUgZXZlblxuICAgIC8vIGVuY291cmFnZWQgdG8sIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8xMjg4XG4gICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgIT09ICdtYW51YWwnKSB7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLy8gMi4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGU6XG4gICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdlcnJvcicpIHtcbiAgICAgIC8vIFNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ3VuZXhwZWN0ZWQgcmVkaXJlY3QnKVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ21hbnVhbCcpIHtcbiAgICAgIC8vIFNldCByZXNwb25zZSB0byBhbiBvcGFxdWUtcmVkaXJlY3QgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgaW50ZXJuYWxcbiAgICAgIC8vIHJlc3BvbnNlIGlzIGFjdHVhbFJlc3BvbnNlLlxuICAgICAgLy8gTk9URShzcGVjKTogT24gdGhlIHdlYiB0aGlzIHdvdWxkIHJldHVybiBhbiBgb3BhcXVlcmVkaXJlY3RgIHJlc3BvbnNlLFxuICAgICAgLy8gYnV0IHRoYXQgZG9lc24ndCBtYWtlIHNlbnNlIHNlcnZlciBzaWRlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xMTkzLlxuICAgICAgcmVzcG9uc2UgPSBhY3R1YWxSZXNwb25zZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycpIHtcbiAgICAgIC8vIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1yZWRpcmVjdCBmZXRjaCBnaXZlblxuICAgICAgLy8gZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLlxuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBodHRwUmVkaXJlY3RGZXRjaChmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSlcbiAgICB9XG4gIH1cblxuICAvLyA5LiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRpbWluZ0luZm8uXG4gIHJlc3BvbnNlLnRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG5cbiAgLy8gMTAuIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXJlZGlyZWN0LWZldGNoXG5mdW5jdGlvbiBodHRwUmVkaXJlY3RGZXRjaCAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCBhY3R1YWxSZXNwb25zZSBiZSByZXNwb25zZSwgaWYgcmVzcG9uc2UgaXMgbm90IGEgZmlsdGVyZWQgcmVzcG9uc2UsXG4gIC8vIGFuZCByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2Ugb3RoZXJ3aXNlLlxuICBjb25zdCBhY3R1YWxSZXNwb25zZSA9IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2VcbiAgICA/IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2VcbiAgICA6IHJlc3BvbnNlXG5cbiAgLy8gMy4gTGV0IGxvY2F0aW9uVVJMIGJlIGFjdHVhbFJlc3BvbnNl4oCZcyBsb2NhdGlvbiBVUkwgZ2l2ZW4gcmVxdWVzdOKAmXMgY3VycmVudFxuICAvLyBVUkzigJlzIGZyYWdtZW50LlxuICBsZXQgbG9jYXRpb25VUkxcblxuICB0cnkge1xuICAgIGxvY2F0aW9uVVJMID0gcmVzcG9uc2VMb2NhdGlvblVSTChcbiAgICAgIGFjdHVhbFJlc3BvbnNlLFxuICAgICAgcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkuaGFzaFxuICAgIClcblxuICAgIC8vIDQuIElmIGxvY2F0aW9uVVJMIGlzIG51bGwsIHRoZW4gcmV0dXJuIHJlc3BvbnNlLlxuICAgIGlmIChsb2NhdGlvblVSTCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIDUuIElmIGxvY2F0aW9uVVJMIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoZXJyKSlcbiAgfVxuXG4gIC8vIDYuIElmIGxvY2F0aW9uVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lLCB0aGVuIHJldHVybiBhIG5ldHdvcmtcbiAgLy8gZXJyb3IuXG4gIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUobG9jYXRpb25VUkwpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdVUkwgc2NoZW1lIG11c3QgYmUgYSBIVFRQKFMpIHNjaGVtZScpKVxuICB9XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgY291bnQgaXMgMjAsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKHJlcXVlc3QucmVkaXJlY3RDb3VudCA9PT0gMjApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ3JlZGlyZWN0IGNvdW50IGV4Y2VlZGVkJykpXG4gIH1cblxuICAvLyA4LiBJbmNyZWFzZSByZXF1ZXN04oCZcyByZWRpcmVjdCBjb3VudCBieSAxLlxuICByZXF1ZXN0LnJlZGlyZWN0Q291bnQgKz0gMVxuXG4gIC8vIDkuIElmIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJjb3JzXCIsIGxvY2F0aW9uVVJMIGluY2x1ZGVzIGNyZWRlbnRpYWxzLCBhbmRcbiAgLy8gcmVxdWVzdOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIGxvY2F0aW9uVVJM4oCZcyBvcmlnaW4sIHRoZW4gcmV0dXJuXG4gIC8vICBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXF1ZXN0Lm1vZGUgPT09ICdjb3JzJyAmJlxuICAgIChsb2NhdGlvblVSTC51c2VybmFtZSB8fCBsb2NhdGlvblVSTC5wYXNzd29yZCkgJiZcbiAgICAhc2FtZU9yaWdpbihyZXF1ZXN0LCBsb2NhdGlvblVSTClcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdjcm9zcyBvcmlnaW4gbm90IGFsbG93ZWQgZm9yIHJlcXVlc3QgbW9kZSBcImNvcnNcIicpKVxuICB9XG5cbiAgLy8gMTAuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIGFuZCBsb2NhdGlvblVSTCBpbmNsdWRlc1xuICAvLyBjcmVkZW50aWFscywgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgJiZcbiAgICAobG9jYXRpb25VUkwudXNlcm5hbWUgfHwgbG9jYXRpb25VUkwucGFzc3dvcmQpXG4gICkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcihcbiAgICAgICdVUkwgY2Fubm90IGNvbnRhaW4gY3JlZGVudGlhbHMgZm9yIHJlcXVlc3QgbW9kZSBcImNvcnNcIidcbiAgICApKVxuICB9XG5cbiAgLy8gMTEuIElmIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IDMwMywgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCxcbiAgLy8gYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICBhY3R1YWxSZXNwb25zZS5zdGF0dXMgIT09IDMwMyAmJlxuICAgIHJlcXVlc3QuYm9keSAhPSBudWxsICYmXG4gICAgcmVxdWVzdC5ib2R5LnNvdXJjZSA9PSBudWxsXG4gICkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigpKVxuICB9XG5cbiAgLy8gMTIuIElmIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWVcbiAgLy8gLSBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwMSBvciAzMDIgYW5kIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBgUE9TVGBcbiAgLy8gLSBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwMyBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5vdCBgR0VUYCBvciBgSEVBRGBcbiAgaWYgKFxuICAgIChbMzAxLCAzMDJdLmluY2x1ZGVzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykgfHxcbiAgICAoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzID09PSAzMDMgJiZcbiAgICAgICFbJ0dFVCcsICdIRUFEJ10uaW5jbHVkZXMocmVxdWVzdC5tZXRob2QpKVxuICApIHtcbiAgICAvLyB0aGVuOlxuICAgIC8vIDEuIFNldCByZXF1ZXN04oCZcyBtZXRob2QgdG8gYEdFVGAgYW5kIHJlcXVlc3TigJlzIGJvZHkgdG8gbnVsbC5cbiAgICByZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnXG4gICAgcmVxdWVzdC5ib2R5ID0gbnVsbFxuXG4gICAgLy8gMi4gRm9yIGVhY2ggaGVhZGVyTmFtZSBvZiByZXF1ZXN0LWJvZHktaGVhZGVyIG5hbWUsIGRlbGV0ZSBoZWFkZXJOYW1lIGZyb21cbiAgICAvLyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICBmb3IgKGNvbnN0IGhlYWRlck5hbWUgb2YgcmVxdWVzdEJvZHlIZWFkZXIpIHtcbiAgICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKGhlYWRlck5hbWUpXG4gICAgfVxuICB9XG5cbiAgLy8gMTMuIElmIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggbG9jYXRpb25VUkzigJlzXG4gIC8vICAgICBvcmlnaW4sIHRoZW4gZm9yIGVhY2ggaGVhZGVyTmFtZSBvZiBDT1JTIG5vbi13aWxkY2FyZCByZXF1ZXN0LWhlYWRlciBuYW1lLFxuICAvLyAgICAgZGVsZXRlIGhlYWRlck5hbWUgZnJvbSByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFzYW1lT3JpZ2luKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpLCBsb2NhdGlvblVSTCkpIHtcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29ycy1ub24td2lsZGNhcmQtcmVxdWVzdC1oZWFkZXItbmFtZVxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdhdXRob3JpemF0aW9uJylcblxuICAgIC8vIFwiQ29va2llXCIgYW5kIFwiSG9zdFwiIGFyZSBmb3JiaWRkZW4gcmVxdWVzdC1oZWFkZXJzLCB3aGljaCB1bmRpY2kgZG9lc24ndCBpbXBsZW1lbnQuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2Nvb2tpZScpXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2hvc3QnKVxuICB9XG5cbiAgLy8gMTQuIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGJvZHkgdG8gdGhlIGZpcnN0IHJldHVyblxuICAvLyB2YWx1ZSBvZiBzYWZlbHkgZXh0cmFjdGluZyByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UuXG4gIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIGFzc2VydChyZXF1ZXN0LmJvZHkuc291cmNlICE9IG51bGwpXG4gICAgcmVxdWVzdC5ib2R5ID0gc2FmZWx5RXh0cmFjdEJvZHkocmVxdWVzdC5ib2R5LnNvdXJjZSlbMF1cbiAgfVxuXG4gIC8vIDE1LiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gMTYuIFNldCB0aW1pbmdJbmZv4oCZcyByZWRpcmVjdCBlbmQgdGltZSBhbmQgcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIHRvIHRoZVxuICAvLyBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHkuXG4gIHRpbWluZ0luZm8ucmVkaXJlY3RFbmRUaW1lID0gdGltaW5nSW5mby5wb3N0UmVkaXJlY3RTdGFydFRpbWUgPVxuICAgIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuXG4gIC8vIDE3LiBJZiB0aW1pbmdJbmZv4oCZcyByZWRpcmVjdCBzdGFydCB0aW1lIGlzIDAsIHRoZW4gc2V0IHRpbWluZ0luZm/igJlzXG4gIC8vICByZWRpcmVjdCBzdGFydCB0aW1lIHRvIHRpbWluZ0luZm/igJlzIHN0YXJ0IHRpbWUuXG4gIGlmICh0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID09PSAwKSB7XG4gICAgdGltaW5nSW5mby5yZWRpcmVjdFN0YXJ0VGltZSA9IHRpbWluZ0luZm8uc3RhcnRUaW1lXG4gIH1cblxuICAvLyAxOC4gQXBwZW5kIGxvY2F0aW9uVVJMIHRvIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICByZXF1ZXN0LnVybExpc3QucHVzaChsb2NhdGlvblVSTClcblxuICAvLyAxOS4gSW52b2tlIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgb24gcmVkaXJlY3Qgb24gcmVxdWVzdCBhbmRcbiAgLy8gYWN0dWFsUmVzcG9uc2UuXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QocmVxdWVzdCwgYWN0dWFsUmVzcG9uc2UpXG5cbiAgLy8gMjAuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgbWFpbiBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgdHJ1ZS5cbiAgcmV0dXJuIG1haW5GZXRjaChmZXRjaFBhcmFtcywgdHJ1ZSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtbmV0d29yay1vci1jYWNoZS1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2ggKFxuICBmZXRjaFBhcmFtcyxcbiAgaXNBdXRoZW50aWNhdGlvbkZldGNoID0gZmFsc2UsXG4gIGlzTmV3Q29ubmVjdGlvbkZldGNoID0gZmFsc2Vcbikge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgaHR0cEZldGNoUGFyYW1zIGJlIG51bGwuXG4gIGxldCBodHRwRmV0Y2hQYXJhbXMgPSBudWxsXG5cbiAgLy8gMy4gTGV0IGh0dHBSZXF1ZXN0IGJlIG51bGwuXG4gIGxldCBodHRwUmVxdWVzdCA9IG51bGxcblxuICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDUuIExldCBzdG9yZWRSZXNwb25zZSBiZSBudWxsLlxuICAvLyBUT0RPOiBjYWNoZVxuXG4gIC8vIDYuIExldCBodHRwQ2FjaGUgYmUgbnVsbC5cbiAgY29uc3QgaHR0cENhY2hlID0gbnVsbFxuXG4gIC8vIDcuIExldCB0aGUgcmV2YWxpZGF0aW5nRmxhZyBiZSB1bnNldC5cbiAgY29uc3QgcmV2YWxpZGF0aW5nRmxhZyA9IGZhbHNlXG5cbiAgLy8gOC4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcIm5vLXdpbmRvd1wiIGFuZCByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzXG4gIC8vICAgIFwiZXJyb3JcIiwgdGhlbiBzZXQgaHR0cEZldGNoUGFyYW1zIHRvIGZldGNoUGFyYW1zIGFuZCBodHRwUmVxdWVzdCB0b1xuICAvLyAgICByZXF1ZXN0LlxuICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICduby13aW5kb3cnICYmIHJlcXVlc3QucmVkaXJlY3QgPT09ICdlcnJvcicpIHtcbiAgICBodHRwRmV0Y2hQYXJhbXMgPSBmZXRjaFBhcmFtc1xuICAgIGh0dHBSZXF1ZXN0ID0gcmVxdWVzdFxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFNldCBodHRwUmVxdWVzdCB0byBhIGNsb25lIG9mIHJlcXVlc3QuXG4gICAgaHR0cFJlcXVlc3QgPSBtYWtlUmVxdWVzdChyZXF1ZXN0KVxuXG4gICAgLy8gMi4gU2V0IGh0dHBGZXRjaFBhcmFtcyB0byBhIGNvcHkgb2YgZmV0Y2hQYXJhbXMuXG4gICAgaHR0cEZldGNoUGFyYW1zID0geyAuLi5mZXRjaFBhcmFtcyB9XG5cbiAgICAvLyAzLiBTZXQgaHR0cEZldGNoUGFyYW1z4oCZcyByZXF1ZXN0IHRvIGh0dHBSZXF1ZXN0LlxuICAgIGh0dHBGZXRjaFBhcmFtcy5yZXF1ZXN0ID0gaHR0cFJlcXVlc3RcbiAgfVxuXG4gIC8vICAgIDMuIExldCBpbmNsdWRlQ3JlZGVudGlhbHMgYmUgdHJ1ZSBpZiBvbmUgb2ZcbiAgY29uc3QgaW5jbHVkZUNyZWRlbnRpYWxzID1cbiAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScgfHxcbiAgICAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ3NhbWUtb3JpZ2luJyAmJlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKVxuXG4gIC8vICAgIDQuIExldCBjb250ZW50TGVuZ3RoIGJlIGh0dHBSZXF1ZXN04oCZcyBib2R54oCZcyBsZW5ndGgsIGlmIGh0dHBSZXF1ZXN04oCZc1xuICAvLyAgICBib2R5IGlzIG5vbi1udWxsOyBvdGhlcndpc2UgbnVsbC5cbiAgY29uc3QgY29udGVudExlbmd0aCA9IGh0dHBSZXF1ZXN0LmJvZHkgPyBodHRwUmVxdWVzdC5ib2R5Lmxlbmd0aCA6IG51bGxcblxuICAvLyAgICA1LiBMZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGJlIG51bGwuXG4gIGxldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBudWxsXG5cbiAgLy8gICAgNi4gSWYgaHR0cFJlcXVlc3TigJlzIGJvZHkgaXMgbnVsbCBhbmQgaHR0cFJlcXVlc3TigJlzIG1ldGhvZCBpcyBgUE9TVGAgb3JcbiAgLy8gICAgYFBVVGAsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0byBgMGAuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5ib2R5ID09IG51bGwgJiZcbiAgICBbJ1BPU1QnLCAnUFVUJ10uaW5jbHVkZXMoaHR0cFJlcXVlc3QubWV0aG9kKVxuICApIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSAnMCdcbiAgfVxuXG4gIC8vICAgIDcuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0b1xuICAvLyAgICBjb250ZW50TGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBpc29tb3JwaGljRW5jb2RlKGAke2NvbnRlbnRMZW5ndGh9YClcbiAgfVxuXG4gIC8vICAgIDguIElmIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBpcyBub24tbnVsbCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYENvbnRlbnQtTGVuZ3RoYC9jb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0LlxuICBpZiAoY29udGVudExlbmd0aEhlYWRlclZhbHVlICE9IG51bGwpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtbGVuZ3RoJywgY29udGVudExlbmd0aEhlYWRlclZhbHVlKVxuICB9XG5cbiAgLy8gICAgOS4gSWYgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGlzIG5vbi1udWxsLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtTGVuZ3RoYCxcbiAgLy8gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlKSB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG5cbiAgLy8gICAgMTAuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwgYW5kIGh0dHBSZXF1ZXN04oCZcyBrZWVwYWxpdmUgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbjpcbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBodHRwUmVxdWVzdC5rZWVwYWxpdmUpIHtcbiAgICAvLyBOT1RFOiBrZWVwYWxpdmUgaXMgYSBub29wIG91dHNpZGUgb2YgYnJvd3NlciBjb250ZXh0LlxuICB9XG5cbiAgLy8gICAgMTEuIElmIGh0dHBSZXF1ZXN04oCZcyByZWZlcnJlciBpcyBhIFVSTCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYFJlZmVyZXJgL2h0dHBSZXF1ZXN04oCZcyByZWZlcnJlciwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLFxuICAvLyAgICAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoaHR0cFJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3JlZmVyZXInLCBpc29tb3JwaGljRW5jb2RlKGh0dHBSZXF1ZXN0LnJlZmVycmVyLmhyZWYpKVxuICB9XG5cbiAgLy8gICAgMTIuIEFwcGVuZCBhIHJlcXVlc3QgYE9yaWdpbmAgaGVhZGVyIGZvciBodHRwUmVxdWVzdC5cbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcihodHRwUmVxdWVzdClcblxuICAvLyAgICAxMy4gQXBwZW5kIHRoZSBGZXRjaCBtZXRhZGF0YSBoZWFkZXJzIGZvciBodHRwUmVxdWVzdC4gW0ZFVENILU1FVEFEQVRBXVxuICBhcHBlbmRGZXRjaE1ldGFkYXRhKGh0dHBSZXF1ZXN0KVxuXG4gIC8vICAgIDE0LiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgVXNlci1BZ2VudGAsIHRoZW5cbiAgLy8gICAgdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgVXNlci1BZ2VudGAvZGVmYXVsdCBgVXNlci1BZ2VudGAgdmFsdWUgdG9cbiAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd1c2VyLWFnZW50JykpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3VzZXItYWdlbnQnLCB0eXBlb2YgZXNidWlsZERldGVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kaWNpJyA6ICdub2RlJylcbiAgfVxuXG4gIC8vICAgIDE1LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcImRlZmF1bHRcIiBhbmQgaHR0cFJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0IGNvbnRhaW5zIGBJZi1Nb2RpZmllZC1TaW5jZWAsIGBJZi1Ob25lLU1hdGNoYCxcbiAgLy8gICAgYElmLVVubW9kaWZpZWQtU2luY2VgLCBgSWYtTWF0Y2hgLCBvciBgSWYtUmFuZ2VgLCB0aGVuIHNldFxuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBcIm5vLXN0b3JlXCIuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ2RlZmF1bHQnICYmXG4gICAgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1tb2RpZmllZC1zaW5jZScpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbm9uZS1tYXRjaCcpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtdW5tb2RpZmllZC1zaW5jZScpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbWF0Y2gnKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLXJhbmdlJykpXG4gICkge1xuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gICAgMTYuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwibm8tY2FjaGVcIiwgaHR0cFJlcXVlc3TigJlzIHByZXZlbnRcbiAgLy8gICAgbm8tY2FjaGUgY2FjaGUtY29udHJvbCBoZWFkZXIgbW9kaWZpY2F0aW9uIGZsYWcgaXMgdW5zZXQsIGFuZFxuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQ2FjaGUtQ29udHJvbGAsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBDYWNoZS1Db250cm9sYC9gbWF4LWFnZT0wYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ25vLWNhY2hlJyAmJlxuICAgICFodHRwUmVxdWVzdC5wcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiAmJlxuICAgICFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnY2FjaGUtY29udHJvbCcpXG4gICkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnY2FjaGUtY29udHJvbCcsICdtYXgtYWdlPTAnKVxuICB9XG5cbiAgLy8gICAgMTcuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiBvciBcInJlbG9hZFwiLCB0aGVuOlxuICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgPT09ICduby1zdG9yZScgfHwgaHR0cFJlcXVlc3QuY2FjaGUgPT09ICdyZWxvYWQnKSB7XG4gICAgLy8gMS4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFByYWdtYWAsIHRoZW4gYXBwZW5kXG4gICAgLy8gYFByYWdtYWAvYG5vLWNhY2hlYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncHJhZ21hJykpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgncHJhZ21hJywgJ25vLWNhY2hlJylcbiAgICB9XG5cbiAgICAvLyAyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQ2FjaGUtQ29udHJvbGAsXG4gICAgLy8gdGhlbiBhcHBlbmQgYENhY2hlLUNvbnRyb2xgL2Buby1jYWNoZWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2NhY2hlLWNvbnRyb2wnKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjYWNoZS1jb250cm9sJywgJ25vLWNhY2hlJylcbiAgICB9XG4gIH1cblxuICAvLyAgICAxOC4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIGBSYW5nZWAsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBBY2NlcHQtRW5jb2RpbmdgL2BpZGVudGl0eWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJykpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdpZGVudGl0eScpXG4gIH1cblxuICAvLyAgICAxOS4gTW9kaWZ5IGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBwZXIgSFRUUC4gRG8gbm90IGFwcGVuZCBhIGdpdmVuXG4gIC8vICAgIGhlYWRlciBpZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgdGhhdCBoZWFkZXLigJlzIG5hbWUuXG4gIC8vICAgIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyODUjaXNzdWVjb21tZW50LTg5NjU2MDEyOVxuICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtZW5jb2RpbmcnKSkge1xuICAgIGlmICh1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChodHRwUmVxdWVzdCkpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdiciwgZ3ppcCwgZGVmbGF0ZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2d6aXAsIGRlZmxhdGUnKVxuICAgIH1cbiAgfVxuXG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnaG9zdCcpXG5cbiAgLy8gICAgMjAuIElmIGluY2x1ZGVDcmVkZW50aWFscyBpcyB0cnVlLCB0aGVuOlxuICBpZiAoaW5jbHVkZUNyZWRlbnRpYWxzKSB7XG4gICAgLy8gMS4gSWYgdGhlIHVzZXIgYWdlbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gYmxvY2sgY29va2llcyBmb3IgaHR0cFJlcXVlc3RcbiAgICAvLyAoc2VlIHNlY3Rpb24gNyBvZiBbQ09PS0lFU10pLCB0aGVuOlxuICAgIC8vIFRPRE86IGNyZWRlbnRpYWxzXG4gICAgLy8gMi4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEF1dGhvcml6YXRpb25gLCB0aGVuOlxuICAgIC8vIFRPRE86IGNyZWRlbnRpYWxzXG4gIH1cblxuICAvLyAgICAyMS4gSWYgdGhlcmXigJlzIGEgcHJveHktYXV0aGVudGljYXRpb24gZW50cnksIHVzZSBpdCBhcyBhcHByb3ByaWF0ZS5cbiAgLy8gICAgVE9ETzogcHJveHktYXV0aGVudGljYXRpb25cblxuICAvLyAgICAyMi4gU2V0IGh0dHBDYWNoZSB0byB0aGUgcmVzdWx0IG9mIGRldGVybWluaW5nIHRoZSBIVFRQIGNhY2hlXG4gIC8vICAgIHBhcnRpdGlvbiwgZ2l2ZW4gaHR0cFJlcXVlc3QuXG4gIC8vICAgIFRPRE86IGNhY2hlXG5cbiAgLy8gICAgMjMuIElmIGh0dHBDYWNoZSBpcyBudWxsLCB0aGVuIHNldCBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0b1xuICAvLyAgICBcIm5vLXN0b3JlXCIuXG4gIGlmIChodHRwQ2FjaGUgPT0gbnVsbCkge1xuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gICAgMjQuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIG5laXRoZXIgXCJuby1zdG9yZVwiIG5vciBcInJlbG9hZFwiLFxuICAvLyAgICB0aGVuOlxuICBpZiAoaHR0cFJlcXVlc3QubW9kZSAhPT0gJ25vLXN0b3JlJyAmJiBodHRwUmVxdWVzdC5tb2RlICE9PSAncmVsb2FkJykge1xuICAgIC8vIFRPRE86IGNhY2hlXG4gIH1cblxuICAvLyA5LiBJZiBhYm9ydGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gIC8vIFRPRE9cblxuICAvLyAxMC4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAvLyAxLiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm9ubHktaWYtY2FjaGVkXCIsIHRoZW4gcmV0dXJuIGFcbiAgICAvLyBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChodHRwUmVxdWVzdC5tb2RlID09PSAnb25seS1pZi1jYWNoZWQnKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignb25seSBpZiBjYWNoZWQnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBmb3J3YXJkUmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yayBmZXRjaFxuICAgIC8vIGdpdmVuIGh0dHBGZXRjaFBhcmFtcywgaW5jbHVkZUNyZWRlbnRpYWxzLCBhbmQgaXNOZXdDb25uZWN0aW9uRmV0Y2guXG4gICAgY29uc3QgZm9yd2FyZFJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtGZXRjaChcbiAgICAgIGh0dHBGZXRjaFBhcmFtcyxcbiAgICAgIGluY2x1ZGVDcmVkZW50aWFscyxcbiAgICAgIGlzTmV3Q29ubmVjdGlvbkZldGNoXG4gICAgKVxuXG4gICAgLy8gMy4gSWYgaHR0cFJlcXVlc3TigJlzIG1ldGhvZCBpcyB1bnNhZmUgYW5kIGZvcndhcmRSZXNwb25zZeKAmXMgc3RhdHVzIGlzXG4gICAgLy8gaW4gdGhlIHJhbmdlIDIwMCB0byAzOTksIGluY2x1c2l2ZSwgaW52YWxpZGF0ZSBhcHByb3ByaWF0ZSBzdG9yZWRcbiAgICAvLyByZXNwb25zZXMgaW4gaHR0cENhY2hlLCBhcyBwZXIgdGhlIFwiSW52YWxpZGF0aW9uXCIgY2hhcHRlciBvZiBIVFRQXG4gICAgLy8gQ2FjaGluZywgYW5kIHNldCBzdG9yZWRSZXNwb25zZSB0byBudWxsLiBbSFRUUC1DQUNISU5HXVxuICAgIGlmIChcbiAgICAgICFzYWZlTWV0aG9kcy5pbmNsdWRlcyhodHRwUmVxdWVzdC5tZXRob2QpICYmXG4gICAgICBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJlxuICAgICAgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA8PSAzOTlcbiAgICApIHtcbiAgICAgIC8vIFRPRE86IGNhY2hlXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgdGhlIHJldmFsaWRhdGluZ0ZsYWcgaXMgc2V0IGFuZCBmb3J3YXJkUmVzcG9uc2XigJlzIHN0YXR1cyBpcyAzMDQsXG4gICAgLy8gdGhlbjpcbiAgICBpZiAocmV2YWxpZGF0aW5nRmxhZyAmJiBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIC8vIFRPRE86IGNhY2hlXG4gICAgfVxuXG4gICAgLy8gNS4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgLy8gMS4gU2V0IHJlc3BvbnNlIHRvIGZvcndhcmRSZXNwb25zZS5cbiAgICAgIHJlc3BvbnNlID0gZm9yd2FyZFJlc3BvbnNlXG5cbiAgICAgIC8vIDIuIFN0b3JlIGh0dHBSZXF1ZXN0IGFuZCBmb3J3YXJkUmVzcG9uc2UgaW4gaHR0cENhY2hlLCBhcyBwZXIgdGhlXG4gICAgICAvLyBcIlN0b3JpbmcgUmVzcG9uc2VzIGluIENhY2hlc1wiIGNoYXB0ZXIgb2YgSFRUUCBDYWNoaW5nLiBbSFRUUC1DQUNISU5HXVxuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG4gIH1cblxuICAvLyAxMS4gU2V0IHJlc3BvbnNl4oCZcyBVUkwgbGlzdCB0byBhIGNsb25lIG9mIGh0dHBSZXF1ZXN04oCZcyBVUkwgbGlzdC5cbiAgcmVzcG9uc2UudXJsTGlzdCA9IFsuLi5odHRwUmVxdWVzdC51cmxMaXN0XVxuXG4gIC8vIDEyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFJhbmdlYCwgdGhlbiBzZXQgcmVzcG9uc2XigJlzXG4gIC8vIHJhbmdlLXJlcXVlc3RlZCBmbGFnLlxuICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJykpIHtcbiAgICByZXNwb25zZS5yYW5nZVJlcXVlc3RlZCA9IHRydWVcbiAgfVxuXG4gIC8vIDEzLiBTZXQgcmVzcG9uc2XigJlzIHJlcXVlc3QtaW5jbHVkZXMtY3JlZGVudGlhbHMgdG8gaW5jbHVkZUNyZWRlbnRpYWxzLlxuICByZXNwb25zZS5yZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscyA9IGluY2x1ZGVDcmVkZW50aWFsc1xuXG4gIC8vIDE0LiBJZiByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQwMSwgaHR0cFJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIG5vdFxuICAvLyBcImNvcnNcIiwgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUsIGFuZCByZXF1ZXN04oCZcyB3aW5kb3cgaXMgYW4gZW52aXJvbm1lbnRcbiAgLy8gc2V0dGluZ3Mgb2JqZWN0LCB0aGVuOlxuICAvLyBUT0RPXG5cbiAgLy8gMTUuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDA3LCB0aGVuOlxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDcpIHtcbiAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgXCJuby13aW5kb3dcIiwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChyZXF1ZXN0LndpbmRvdyA9PT0gJ25vLXdpbmRvdycpIHtcbiAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKClcbiAgICB9XG5cbiAgICAvLyAyLiA/Pz9cblxuICAgIC8vIDMuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcylcbiAgICB9XG5cbiAgICAvLyA0LiBQcm9tcHQgdGhlIGVuZCB1c2VyIGFzIGFwcHJvcHJpYXRlIGluIHJlcXVlc3TigJlzIHdpbmRvdyBhbmQgc3RvcmVcbiAgICAvLyB0aGUgcmVzdWx0IGFzIGEgcHJveHktYXV0aGVudGljYXRpb24gZW50cnkuIFtIVFRQLUFVVEhdXG4gICAgLy8gVE9ETzogSW52b2tlIHNvbWUga2luZCBvZiBjYWxsYmFjaz9cblxuICAgIC8vIDUuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIGdpdmVuXG4gICAgLy8gZmV0Y2hQYXJhbXMuXG4gICAgLy8gVE9ET1xuICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdwcm94eSBhdXRoZW50aWNhdGlvbiByZXF1aXJlZCcpXG4gIH1cblxuICAvLyAxNi4gSWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgYXJlIHRydWVcbiAgaWYgKFxuICAgIC8vIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDIxXG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSA0MjEgJiZcbiAgICAvLyBpc05ld0Nvbm5lY3Rpb25GZXRjaCBpcyBmYWxzZVxuICAgICFpc05ld0Nvbm5lY3Rpb25GZXRjaCAmJlxuICAgIC8vIHJlcXVlc3TigJlzIGJvZHkgaXMgbnVsbCwgb3IgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG5vbi1udWxsXG4gICAgKHJlcXVlc3QuYm9keSA9PSBudWxsIHx8IHJlcXVlc3QuYm9keS5zb3VyY2UgIT0gbnVsbClcbiAgKSB7XG4gICAgLy8gdGhlbjpcblxuICAgIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcylcbiAgICB9XG5cbiAgICAvLyAyLiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yay1vci1jYWNoZVxuICAgIC8vIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLCBpc0F1dGhlbnRpY2F0aW9uRmV0Y2gsIGFuZCB0cnVlLlxuXG4gICAgLy8gVE9ETyAoc3BlYyk6IFRoZSBzcGVjIGRvZXNuJ3Qgc3BlY2lmeSB0aGlzIGJ1dCB3ZSBuZWVkIHRvIGNhbmNlbFxuICAgIC8vIHRoZSBhY3RpdmUgcmVzcG9uc2UgYmVmb3JlIHdlIGNhbiBzdGFydCBhIG5ldyBvbmUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMTI5M1xuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcblxuICAgIHJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2goXG4gICAgICBmZXRjaFBhcmFtcyxcbiAgICAgIGlzQXV0aGVudGljYXRpb25GZXRjaCxcbiAgICAgIHRydWVcbiAgICApXG4gIH1cblxuICAvLyAxNy4gSWYgaXNBdXRoZW50aWNhdGlvbkZldGNoIGlzIHRydWUsIHRoZW4gY3JlYXRlIGFuIGF1dGhlbnRpY2F0aW9uIGVudHJ5XG4gIGlmIChpc0F1dGhlbnRpY2F0aW9uRmV0Y2gpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyAxOC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtbmV0d29yay1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cE5ldHdvcmtGZXRjaCAoXG4gIGZldGNoUGFyYW1zLFxuICBpbmNsdWRlQ3JlZGVudGlhbHMgPSBmYWxzZSxcbiAgZm9yY2VOZXdDb25uZWN0aW9uID0gZmFsc2Vcbikge1xuICBhc3NlcnQoIWZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbiB8fCBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveWVkKVxuXG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbiA9IHtcbiAgICBhYm9ydDogbnVsbCxcbiAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgIGRlc3Ryb3kgKGVycikge1xuICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgICAgICAgdGhpcy5hYm9ydD8uKGVyciA/PyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJykpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCByZXNwb25zZSA9IG51bGxcblxuICAvLyAzLiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gNC4gTGV0IGh0dHBDYWNoZSBiZSB0aGUgcmVzdWx0IG9mIGRldGVybWluaW5nIHRoZSBIVFRQIGNhY2hlIHBhcnRpdGlvbixcbiAgLy8gZ2l2ZW4gcmVxdWVzdC5cbiAgLy8gVE9ETzogY2FjaGVcbiAgY29uc3QgaHR0cENhY2hlID0gbnVsbFxuXG4gIC8vIDUuIElmIGh0dHBDYWNoZSBpcyBudWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIFwibm8tc3RvcmVcIi5cbiAgaWYgKGh0dHBDYWNoZSA9PSBudWxsKSB7XG4gICAgcmVxdWVzdC5jYWNoZSA9ICduby1zdG9yZSdcbiAgfVxuXG4gIC8vIDYuIExldCBuZXR3b3JrUGFydGl0aW9uS2V5IGJlIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIG5ldHdvcmtcbiAgLy8gcGFydGl0aW9uIGtleSBnaXZlbiByZXF1ZXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gNy4gTGV0IG5ld0Nvbm5lY3Rpb24gYmUgXCJ5ZXNcIiBpZiBmb3JjZU5ld0Nvbm5lY3Rpb24gaXMgdHJ1ZTsgb3RoZXJ3aXNlXG4gIC8vIFwibm9cIi5cbiAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IGZvcmNlTmV3Q29ubmVjdGlvbiA/ICd5ZXMnIDogJ25vJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLy8gOC4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIG1vZGU6XG4gIGlmIChyZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgLy8gTGV0IGNvbm5lY3Rpb24gYmUgdGhlIHJlc3VsdCBvZiBvYnRhaW5pbmcgYSBXZWJTb2NrZXQgY29ubmVjdGlvbixcbiAgICAvLyBnaXZlbiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgICAvLyBUT0RPXG4gIH0gZWxzZSB7XG4gICAgLy8gTGV0IGNvbm5lY3Rpb24gYmUgdGhlIHJlc3VsdCBvZiBvYnRhaW5pbmcgYSBjb25uZWN0aW9uLCBnaXZlblxuICAgIC8vIG5ldHdvcmtQYXJ0aXRpb25LZXksIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4sXG4gICAgLy8gaW5jbHVkZUNyZWRlbnRpYWxzLCBhbmQgZm9yY2VOZXdDb25uZWN0aW9uLlxuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDkuIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gdGhlIG9uZ29pbmcgZmV0Y2ggaXMgdGVybWluYXRlZDpcblxuICAvLyAgICAxLiBJZiBjb25uZWN0aW9uIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cblxuICAvLyAgICAyLiBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgY29ubmVjdGlvbiB0aW1pbmcgaW5mbyB0byB0aGUgcmVzdWx0IG9mXG4gIC8vICAgIGNhbGxpbmcgY2xhbXAgYW5kIGNvYXJzZW4gY29ubmVjdGlvbiB0aW1pbmcgaW5mbyB3aXRoIGNvbm5lY3Rpb27igJlzXG4gIC8vICAgIHRpbWluZyBpbmZvLCB0aW1pbmdJbmZv4oCZcyBwb3N0LXJlZGlyZWN0IHN0YXJ0IHRpbWUsIGFuZCBmZXRjaFBhcmFtc+KAmXNcbiAgLy8gICAgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHkuXG5cbiAgLy8gICAgMy4gSWYgY29ubmVjdGlvbiBpcyBub3QgYW4gSFRUUC8yIGNvbm5lY3Rpb24sIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsXG4gIC8vICAgIGFuZCByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UgaXMgbnVsbCwgdGhlbiBhcHBlbmQgKGBUcmFuc2Zlci1FbmNvZGluZ2AsXG4gIC8vICAgIGBjaHVua2VkYCkgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG5cbiAgLy8gICAgNC4gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVxdWVzdCBzdGFydCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWRcbiAgLy8gICAgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vICAgIGNhcGFiaWxpdHkuXG5cbiAgLy8gICAgNS4gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgbWFraW5nIGFuIEhUVFAgcmVxdWVzdCBvdmVyIGNvbm5lY3Rpb25cbiAgLy8gICAgdXNpbmcgcmVxdWVzdCB3aXRoIHRoZSBmb2xsb3dpbmcgY2F2ZWF0czpcblxuICAvLyAgICAgICAgLSBGb2xsb3cgdGhlIHJlbGV2YW50IHJlcXVpcmVtZW50cyBmcm9tIEhUVFAuIFtIVFRQXSBbSFRUUC1TRU1BTlRJQ1NdXG4gIC8vICAgICAgICBbSFRUUC1DT05EXSBbSFRUUC1DQUNISU5HXSBbSFRUUC1BVVRIXVxuXG4gIC8vICAgICAgICAtIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsIGFuZCByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UgaXMgbnVsbCxcbiAgLy8gICAgICAgIHRoZW4gdGhlIHVzZXIgYWdlbnQgbWF5IGhhdmUgYSBidWZmZXIgb2YgdXAgdG8gNjQga2liaWJ5dGVzIGFuZCBzdG9yZVxuICAvLyAgICAgICAgYSBwYXJ0IG9mIHJlcXVlc3TigJlzIGJvZHkgaW4gdGhhdCBidWZmZXIuIElmIHRoZSB1c2VyIGFnZW50IHJlYWRzIGZyb21cbiAgLy8gICAgICAgIHJlcXVlc3TigJlzIGJvZHkgYmV5b25kIHRoYXQgYnVmZmVy4oCZcyBzaXplIGFuZCB0aGUgdXNlciBhZ2VudCBuZWVkcyB0b1xuICAvLyAgICAgICAgcmVzZW5kIHJlcXVlc3QsIHRoZW4gaW5zdGVhZCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vICAgICAgICAtIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlc3BvbnNlIHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZFxuICAvLyAgICAgICAgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHksXG4gIC8vICAgICAgICBpbW1lZGlhdGVseSBhZnRlciB0aGUgdXNlciBhZ2VudOKAmXMgSFRUUCBwYXJzZXIgcmVjZWl2ZXMgdGhlIGZpcnN0IGJ5dGVcbiAgLy8gICAgICAgIG9mIHRoZSByZXNwb25zZSAoZS5nLiwgZnJhbWUgaGVhZGVyIGJ5dGVzIGZvciBIVFRQLzIgb3IgcmVzcG9uc2Ugc3RhdHVzXG4gIC8vICAgICAgICBsaW5lIGZvciBIVFRQLzEueCkuXG5cbiAgLy8gICAgICAgIC0gV2FpdCB1bnRpbCBhbGwgdGhlIGhlYWRlcnMgYXJlIHRyYW5zbWl0dGVkLlxuXG4gIC8vICAgICAgICAtIEFueSByZXNwb25zZXMgd2hvc2Ugc3RhdHVzIGlzIGluIHRoZSByYW5nZSAxMDAgdG8gMTk5LCBpbmNsdXNpdmUsXG4gIC8vICAgICAgICBhbmQgaXMgbm90IDEwMSwgYXJlIHRvIGJlIGlnbm9yZWQsIGV4Y2VwdCBmb3IgdGhlIHB1cnBvc2VzIG9mIHNldHRpbmdcbiAgLy8gICAgICAgIHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVzcG9uc2Ugc3RhcnQgdGltZSBhYm92ZS5cblxuICAvLyAgICAtIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIGBUcmFuc2Zlci1FbmNvZGluZ2AvYGNodW5rZWRgIGFuZFxuICAvLyAgICByZXNwb25zZSBpcyB0cmFuc2ZlcnJlZCB2aWEgSFRUUC8xLjAgb3Igb2xkZXIsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAvLyAgICBlcnJvci5cblxuICAvLyAgICAtIElmIHRoZSBIVFRQIHJlcXVlc3QgcmVzdWx0cyBpbiBhIFRMUyBjbGllbnQgY2VydGlmaWNhdGUgZGlhbG9nLCB0aGVuOlxuXG4gIC8vICAgICAgICAxLiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgYW4gZW52aXJvbm1lbnQgc2V0dGluZ3Mgb2JqZWN0LCBtYWtlIHRoZVxuICAvLyAgICAgICAgZGlhbG9nIGF2YWlsYWJsZSBpbiByZXF1ZXN04oCZcyB3aW5kb3cuXG5cbiAgLy8gICAgICAgIDIuIE90aGVyd2lzZSwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cblxuICAvLyBUbyB0cmFuc21pdCByZXF1ZXN04oCZcyBib2R5IGJvZHksIHJ1biB0aGVzZSBzdGVwczpcbiAgbGV0IHJlcXVlc3RCb2R5ID0gbnVsbFxuICAvLyAxLiBJZiBib2R5IGlzIG51bGwgYW5kIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkgaXNcbiAgLy8gbm9uLW51bGwsIHRoZW4gcXVldWUgYSBmZXRjaCB0YXNrIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3RcbiAgLy8gZW5kLW9mLWJvZHkgYW5kIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICBpZiAocmVxdWVzdC5ib2R5ID09IG51bGwgJiYgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSgpKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiBib2R5IGlzIG5vbi1udWxsOlxuXG4gICAgLy8gICAgMS4gTGV0IHByb2Nlc3NCb2R5Q2h1bmsgZ2l2ZW4gYnl0ZXMgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0JvZHlDaHVuayA9IGFzeW5jIGZ1bmN0aW9uICogKGJ5dGVzKSB7XG4gICAgICAvLyAxLiBJZiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gUnVuIHRoaXMgc3RlcCBpbiBwYXJhbGxlbDogdHJhbnNtaXQgYnl0ZXMuXG4gICAgICB5aWVsZCBieXRlc1xuXG4gICAgICAvLyAzLiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gcnVuXG4gICAgICAvLyBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGJvZHkgZ2l2ZW4gYnl0ZXPigJlzIGxlbmd0aC5cbiAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoPy4oYnl0ZXMuYnl0ZUxlbmd0aClcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgcHJvY2Vzc0VuZE9mQm9keSBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzRW5kT2ZCb2R5ID0gKCkgPT4ge1xuICAgICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5IGlzIG5vbi1udWxsLFxuICAgICAgLy8gdGhlbiBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keS5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IHByb2Nlc3NCb2R5RXJyb3IgZ2l2ZW4gZSBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzQm9keUVycm9yID0gKGUpID0+IHtcbiAgICAgIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgZSBpcyBhbiBcIkFib3J0RXJyb3JcIiBET01FeGNlcHRpb24sIHRoZW4gYWJvcnQgZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXIuXG4gICAgICBpZiAoZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5hYm9ydCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIEluY3JlbWVudGFsbHkgcmVhZCByZXF1ZXN04oCZcyBib2R5IGdpdmVuIHByb2Nlc3NCb2R5Q2h1bmssIHByb2Nlc3NFbmRPZkJvZHksXG4gICAgLy8gcHJvY2Vzc0JvZHlFcnJvciwgYW5kIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICAgIHJlcXVlc3RCb2R5ID0gKGFzeW5jIGZ1bmN0aW9uICogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBieXRlcyBvZiByZXF1ZXN0LmJvZHkuc3RyZWFtKSB7XG4gICAgICAgICAgeWllbGQgKiBwcm9jZXNzQm9keUNodW5rKGJ5dGVzKVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NFbmRPZkJvZHkoKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHByb2Nlc3NCb2R5RXJyb3IoZXJyKVxuICAgICAgfVxuICAgIH0pKClcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gc29ja2V0IGlzIG9ubHkgcHJvdmlkZWQgZm9yIHdlYnNvY2tldHNcbiAgICBjb25zdCB7IGJvZHksIHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QsIHNvY2tldCB9ID0gYXdhaXQgZGlzcGF0Y2goeyBib2R5OiByZXF1ZXN0Qm9keSB9KVxuXG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgcmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyBzdGF0dXMsIHN0YXR1c1RleHQsIGhlYWRlcnNMaXN0LCBzb2NrZXQgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSBib2R5W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm5leHQgPSAoKSA9PiBpdGVyYXRvci5uZXh0KClcblxuICAgICAgcmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyBzdGF0dXMsIHN0YXR1c1RleHQsIGhlYWRlcnNMaXN0IH0pXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyAxMC4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgICBpZiAoZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgLy8gMS4gSWYgY29ubmVjdGlvbiB1c2VzIEhUVFAvMiwgdGhlbiB0cmFuc21pdCBhbiBSU1RfU1RSRUFNIGZyYW1lLlxuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKVxuXG4gICAgICAvLyAyLiBSZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgICAgcmV0dXJuIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcywgZXJyKVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKGVycilcbiAgfVxuXG4gIC8vIDExLiBMZXQgcHVsbEFsZ29yaXRobSBiZSBhbiBhY3Rpb24gdGhhdCByZXN1bWVzIHRoZSBvbmdvaW5nIGZldGNoXG4gIC8vIGlmIGl0IGlzIHN1c3BlbmRlZC5cbiAgY29uc3QgcHVsbEFsZ29yaXRobSA9ICgpID0+IHtcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlc3VtZSgpXG4gIH1cblxuICAvLyAxMi4gTGV0IGNhbmNlbEFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gdGhhdCBhYm9ydHMgZmV0Y2hQYXJhbXPigJlzXG4gIC8vIGNvbnRyb2xsZXIgd2l0aCByZWFzb24sIGdpdmVuIHJlYXNvbi5cbiAgY29uc3QgY2FuY2VsQWxnb3JpdGhtID0gKHJlYXNvbikgPT4ge1xuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuYWJvcnQocmVhc29uKVxuICB9XG5cbiAgLy8gMTMuIExldCBoaWdoV2F0ZXJNYXJrIGJlIGEgbm9uLW5lZ2F0aXZlLCBub24tTmFOIG51bWJlciwgY2hvc2VuIGJ5XG4gIC8vIHRoZSB1c2VyIGFnZW50LlxuICAvLyBUT0RPXG5cbiAgLy8gMTQuIExldCBzaXplQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB0aGF0IGFjY2VwdHMgYSBjaHVuayBvYmplY3RcbiAgLy8gYW5kIHJldHVybnMgYSBub24tbmVnYXRpdmUsIG5vbi1OYU4sIG5vbi1pbmZpbml0ZSBudW1iZXIsIGNob3NlbiBieSB0aGUgdXNlciBhZ2VudC5cbiAgLy8gVE9ET1xuXG4gIC8vIDE1LiBMZXQgc3RyZWFtIGJlIGEgbmV3IFJlYWRhYmxlU3RyZWFtLlxuICAvLyAxNi4gU2V0IHVwIHN0cmVhbSB3aXRoIHB1bGxBbGdvcml0aG0gc2V0IHRvIHB1bGxBbGdvcml0aG0sXG4gIC8vIGNhbmNlbEFsZ29yaXRobSBzZXQgdG8gY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrIHNldCB0b1xuICAvLyBoaWdoV2F0ZXJNYXJrLCBhbmQgc2l6ZUFsZ29yaXRobSBzZXQgdG8gc2l6ZUFsZ29yaXRobS5cbiAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtL3dlYicpLlJlYWRhYmxlU3RyZWFtXG4gIH1cblxuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgYXN5bmMgc3RhcnQgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyID0gY29udHJvbGxlclxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgYXdhaXQgcHVsbEFsZ29yaXRobShjb250cm9sbGVyKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAocmVhc29uKSB7XG4gICAgICAgIGF3YWl0IGNhbmNlbEFsZ29yaXRobShyZWFzb24pXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBoaWdoV2F0ZXJNYXJrOiAwLFxuICAgICAgc2l6ZSAoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgfVxuICApXG5cbiAgLy8gMTcuIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gdGhlIG9uZ29pbmcgZmV0Y2ggaXMgdGVybWluYXRlZDpcblxuICAvLyAgICAxLiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gYSBuZXcgYm9keSB3aG9zZSBzdHJlYW0gaXMgc3RyZWFtLlxuICByZXNwb25zZS5ib2R5ID0geyBzdHJlYW0gfVxuXG4gIC8vICAgIDIuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXNcbiAgLy8gICAgbm90IFwibm8tc3RvcmVcIiwgdGhlbiB1cGRhdGUgcmVzcG9uc2UgaW4gaHR0cENhY2hlIGZvciByZXF1ZXN0LlxuICAvLyAgICBUT0RPXG5cbiAgLy8gICAgMy4gSWYgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUgYW5kIHRoZSB1c2VyIGFnZW50IGlzIG5vdCBjb25maWd1cmVkXG4gIC8vICAgIHRvIGJsb2NrIGNvb2tpZXMgZm9yIHJlcXVlc3QgKHNlZSBzZWN0aW9uIDcgb2YgW0NPT0tJRVNdKSwgdGhlbiBydW4gdGhlXG4gIC8vICAgIFwic2V0LWNvb2tpZS1zdHJpbmdcIiBwYXJzaW5nIGFsZ29yaXRobSAoc2VlIHNlY3Rpb24gNS4yIG9mIFtDT09LSUVTXSkgb25cbiAgLy8gICAgdGhlIHZhbHVlIG9mIGVhY2ggaGVhZGVyIHdob3NlIG5hbWUgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gIC8vICAgIGBTZXQtQ29va2llYCBpbiByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QsIGlmIGFueSwgYW5kIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAvLyAgICBUT0RPXG5cbiAgLy8gMTguIElmIGFib3J0ZWQsIHRoZW46XG4gIC8vIFRPRE9cblxuICAvLyAxOS4gUnVuIHRoZXNlIHN0ZXBzIGluIHBhcmFsbGVsOlxuXG4gIC8vICAgIDEuIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQ6XG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub24oJ3Rlcm1pbmF0ZWQnLCBvbkFib3J0ZWQpXG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVzdW1lID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIDEuIFdoaWxlIHRydWVcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gMS0zLiBTZWUgb25EYXRhLi4uXG5cbiAgICAgIC8vIDQuIFNldCBieXRlcyB0byB0aGUgcmVzdWx0IG9mIGhhbmRsaW5nIGNvbnRlbnQgY29kaW5ncyBnaXZlblxuICAgICAgLy8gY29kaW5ncyBhbmQgYnl0ZXMuXG4gICAgICBsZXQgYnl0ZXNcbiAgICAgIGxldCBpc0ZhaWx1cmVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIubmV4dCgpXG5cbiAgICAgICAgaWYgKGlzQWJvcnRlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgYnl0ZXMgPSBkb25lID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5lbmRlZCAmJiAhdGltaW5nSW5mby5lbmNvZGVkQm9keVNpemUpIHtcbiAgICAgICAgICAvLyB6bGliIGRvZXNuJ3QgbGlrZSBlbXB0eSBzdHJlYW1zLlxuICAgICAgICAgIGJ5dGVzID0gdW5kZWZpbmVkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZXMgPSBlcnJcblxuICAgICAgICAgIC8vIGVyciBtYXkgYmUgcHJvcGFnYXRlZCBmcm9tIHRoZSByZXN1bHQgb2YgY2FsbGluZyByZWFkYWJsZXN0cmVhbS5jYW5jZWwsXG4gICAgICAgICAgLy8gd2hpY2ggbWlnaHQgbm90IGJlIGFuIGVycm9yLiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjAwOVxuICAgICAgICAgIGlzRmFpbHVyZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYnl0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyAyLiBPdGhlcndpc2UsIGlmIHRoZSBieXRlcyB0cmFuc21pc3Npb24gZm9yIHJlc3BvbnNl4oCZcyBtZXNzYWdlXG4gICAgICAgIC8vIGJvZHkgaXMgZG9uZSBub3JtYWxseSBhbmQgc3RyZWFtIGlzIHJlYWRhYmxlLCB0aGVuIGNsb3NlXG4gICAgICAgIC8vIHN0cmVhbSwgZmluYWxpemUgcmVzcG9uc2UgZm9yIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZSwgYW5kXG4gICAgICAgIC8vIGFib3J0IHRoZXNlIGluLXBhcmFsbGVsIHN0ZXBzLlxuICAgICAgICByZWFkYWJsZVN0cmVhbUNsb3NlKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlcilcblxuICAgICAgICBmaW5hbGl6ZVJlc3BvbnNlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNS4gSW5jcmVhc2UgdGltaW5nSW5mb+KAmXMgZGVjb2RlZCBib2R5IHNpemUgYnkgYnl0ZXPigJlzIGxlbmd0aC5cbiAgICAgIHRpbWluZ0luZm8uZGVjb2RlZEJvZHlTaXplICs9IGJ5dGVzPy5ieXRlTGVuZ3RoID8/IDBcblxuICAgICAgLy8gNi4gSWYgYnl0ZXMgaXMgZmFpbHVyZSwgdGhlbiB0ZXJtaW5hdGUgZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXIuXG4gICAgICBpZiAoaXNGYWlsdXJlKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGJ5dGVzKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNy4gRW5xdWV1ZSBhIFVpbnQ4QXJyYXkgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyBieXRlc1xuICAgICAgLy8gaW50byBzdHJlYW0uXG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShieXRlcykpXG5cbiAgICAgIC8vIDguIElmIHN0cmVhbSBpcyBlcnJvcmVkLCB0aGVuIHRlcm1pbmF0ZSB0aGUgb25nb2luZyBmZXRjaC5cbiAgICAgIGlmIChpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA5LiBJZiBzdHJlYW0gZG9lc27igJl0IG5lZWQgbW9yZSBkYXRhIGFzayB0aGUgdXNlciBhZ2VudCB0byBzdXNwZW5kXG4gICAgICAvLyB0aGUgb25nb2luZyBmZXRjaC5cbiAgICAgIGlmICghZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmRlc2lyZWRTaXplKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vICAgIDIuIElmIGFib3J0ZWQsIHRoZW46XG4gIGZ1bmN0aW9uIG9uQWJvcnRlZCAocmVhc29uKSB7XG4gICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXMgaXMgYWJvcnRlZCwgdGhlbjpcbiAgICBpZiAoaXNBYm9ydGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgLy8gMS4gU2V0IHJlc3BvbnNl4oCZcyBhYm9ydGVkIGZsYWcuXG4gICAgICByZXNwb25zZS5hYm9ydGVkID0gdHJ1ZVxuXG4gICAgICAvLyAyLiBJZiBzdHJlYW0gaXMgcmVhZGFibGUsIHRoZW4gZXJyb3Igc3RyZWFtIHdpdGggdGhlIHJlc3VsdCBvZlxuICAgICAgLy8gICAgZGVzZXJpYWxpemUgYSBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiBnaXZlbiBmZXRjaFBhcmFtc+KAmXNcbiAgICAgIC8vICAgIGNvbnRyb2xsZXLigJlzIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGFuZCBhblxuICAgICAgLy8gICAgaW1wbGVtZW50YXRpb24tZGVmaW5lZCByZWFsbS5cbiAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKFxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuc2VyaWFsaXplZEFib3J0UmVhc29uXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBzdHJlYW0gaXMgcmVhZGFibGUsIGVycm9yIHN0cmVhbSB3aXRoIGEgVHlwZUVycm9yLlxuICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3IobmV3IFR5cGVFcnJvcigndGVybWluYXRlZCcsIHtcbiAgICAgICAgICBjYXVzZTogaXNFcnJvckxpa2UocmVhc29uKSA/IHJlYXNvbiA6IHVuZGVmaW5lZFxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJZiBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCB0aGUgdXNlciBhZ2VudCBzaG91bGQgY2xvc2UgY29ubmVjdGlvbiB1bmxlc3MgaXQgd291bGQgYmUgYmFkIGZvciBwZXJmb3JtYW5jZSB0byBkbyBzby5cbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG4gIH1cblxuICAvLyAyMC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2VcblxuICBhc3luYyBmdW5jdGlvbiBkaXNwYXRjaCAoeyBib2R5IH0pIHtcbiAgICBjb25zdCB1cmwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi8uLicpLkFnZW50fSAqL1xuICAgIGNvbnN0IGFnZW50ID0gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kaXNwYXRjaGVyXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWdlbnQuZGlzcGF0Y2goXG4gICAgICB7XG4gICAgICAgIHBhdGg6IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2gsXG4gICAgICAgIG9yaWdpbjogdXJsLm9yaWdpbixcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgYm9keTogZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kaXNwYXRjaGVyLmlzTW9ja0FjdGl2ZSA/IHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmJvZHkuc291cmNlIDogYm9keSxcbiAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzTGlzdC5lbnRyaWVzLFxuICAgICAgICBtYXhSZWRpcmVjdGlvbnM6IDAsXG4gICAgICAgIHVwZ3JhZGU6IHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcgPyAnd2Vic29ja2V0JyA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYm9keTogbnVsbCxcbiAgICAgICAgYWJvcnQ6IG51bGwsXG5cbiAgICAgICAgb25Db25uZWN0IChhYm9ydCkge1xuICAgICAgICAgIC8vIFRPRE8gKGZpeCk6IERvIHdlIG5lZWQgY29ubmVjdGlvbiBoZXJlP1xuICAgICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbiB9ID0gZmV0Y2hQYXJhbXMuY29udHJvbGxlclxuXG4gICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICBhYm9ydChuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJykpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub24oJ3Rlcm1pbmF0ZWQnLCBhYm9ydClcbiAgICAgICAgICAgIHRoaXMuYWJvcnQgPSBjb25uZWN0aW9uLmFib3J0ID0gYWJvcnRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25IZWFkZXJzIChzdGF0dXMsIGhlYWRlcnNMaXN0LCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICAgICAgICBpZiAoc3RhdHVzIDwgMjAwKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgY29kaW5ncyA9IFtdXG4gICAgICAgICAgbGV0IGxvY2F0aW9uID0gJydcblxuICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG5cbiAgICAgICAgICAvLyBGb3IgSDIsIHRoZSBoZWFkZXJzIGFyZSBhIHBsYWluIEpTIG9iamVjdFxuICAgICAgICAgIC8vIFdlIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlbSBhbmQgaXRlcmF0ZSBhY2NvcmRpbmdseVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnNMaXN0KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzTGlzdC5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgICBjb25zdCBrZXkgPSBoZWFkZXJzTGlzdFtuICsgMF0udG9TdHJpbmcoJ2xhdGluMScpXG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGhlYWRlcnNMaXN0W24gKyAxXS50b1N0cmluZygnbGF0aW4xJylcbiAgICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1lbmNvZGluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMSNzZWN0aW9uLTMuMS4yLjFcbiAgICAgICAgICAgICAgICAvLyBcIkFsbCBjb250ZW50LWNvZGluZyB2YWx1ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUuLi5cIlxuICAgICAgICAgICAgICAgIGNvZGluZ3MgPSB2YWwudG9Mb3dlckNhc2UoKS5zcGxpdCgnLCcpLm1hcCgoeCkgPT4geC50cmltKCkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdsb2NhdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHZhbFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzTGlzdClcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gaGVhZGVyc0xpc3Rba2V5XVxuICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LWVuY29kaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tMy4xLjIuMVxuICAgICAgICAgICAgICAgIC8vIFwiQWxsIGNvbnRlbnQtY29kaW5nIHZhbHVlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZS4uLlwiXG4gICAgICAgICAgICAgICAgY29kaW5ncyA9IHZhbC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJykubWFwKCh4KSA9PiB4LnRyaW0oKSkucmV2ZXJzZSgpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdsb2NhdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHZhbFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5ID0gbmV3IFJlYWRhYmxlKHsgcmVhZDogcmVzdW1lIH0pXG5cbiAgICAgICAgICBjb25zdCBkZWNvZGVycyA9IFtdXG5cbiAgICAgICAgICBjb25zdCB3aWxsRm9sbG93ID0gcmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycgJiZcbiAgICAgICAgICAgIGxvY2F0aW9uICYmXG4gICAgICAgICAgICByZWRpcmVjdFN0YXR1cy5pbmNsdWRlcyhzdGF0dXMpXG5cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ29udGVudC1FbmNvZGluZ1xuICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnQ09OTkVDVCcgJiYgIW51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHN0YXR1cykgJiYgIXdpbGxGb2xsb3cpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29kaW5nIG9mIGNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTIuaHRtbCNzZWN0aW9uLTcuMlxuICAgICAgICAgICAgICBpZiAoY29kaW5nID09PSAneC1nemlwJyB8fCBjb2RpbmcgPT09ICdnemlwJykge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVHdW56aXAoe1xuICAgICAgICAgICAgICAgICAgLy8gQmUgbGVzcyBzdHJpY3Qgd2hlbiBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2Ugc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgICAvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcbiAgICAgICAgICAgICAgICAgIC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cbiAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG4gICAgICAgICAgICAgICAgICBmbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNILFxuICAgICAgICAgICAgICAgICAgZmluaXNoRmx1c2g6IHpsaWIuY29uc3RhbnRzLlpfU1lOQ19GTFVTSFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGluZyA9PT0gJ2RlZmxhdGUnKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUluZmxhdGUoKSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09ICdicicpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLmxlbmd0aCA9IDBcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyc0xpc3Q6IGhlYWRlcnNba0hlYWRlcnNMaXN0XSxcbiAgICAgICAgICAgIGJvZHk6IGRlY29kZXJzLmxlbmd0aFxuICAgICAgICAgICAgICA/IHBpcGVsaW5lKHRoaXMuYm9keSwgLi4uZGVjb2RlcnMsICgpID0+IHsgfSlcbiAgICAgICAgICAgICAgOiB0aGlzLmJvZHkub24oJ2Vycm9yJywgKCkgPT4ge30pXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EYXRhIChjaHVuaykge1xuICAgICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDEuIElmIG9uZSBvciBtb3JlIGJ5dGVzIGhhdmUgYmVlbiB0cmFuc21pdHRlZCBmcm9tIHJlc3BvbnNl4oCZc1xuICAgICAgICAgIC8vIG1lc3NhZ2UgYm9keSwgdGhlbjpcblxuICAgICAgICAgIC8vICAxLiBMZXQgYnl0ZXMgYmUgdGhlIHRyYW5zbWl0dGVkIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IGJ5dGVzID0gY2h1bmtcblxuICAgICAgICAgIC8vICAyLiBMZXQgY29kaW5ncyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzXG4gICAgICAgICAgLy8gIGdpdmVuIGBDb250ZW50LUVuY29kaW5nYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgICAgIC8vICBTZWUgcHVsbEFsZ29yaXRobS5cblxuICAgICAgICAgIC8vICAzLiBJbmNyZWFzZSB0aW1pbmdJbmZv4oCZcyBlbmNvZGVkIGJvZHkgc2l6ZSBieSBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgICAgIHRpbWluZ0luZm8uZW5jb2RlZEJvZHlTaXplICs9IGJ5dGVzLmJ5dGVMZW5ndGhcblxuICAgICAgICAgIC8vICA0LiBTZWUgcHVsbEFsZ29yaXRobS4uLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wdXNoKGJ5dGVzKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ29tcGxldGUgKCkge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIHRoaXMuYWJvcnQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5lbmRlZCA9IHRydWVcblxuICAgICAgICAgIHRoaXMuYm9keS5wdXNoKG51bGwpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FcnJvciAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vZmYoJ3Rlcm1pbmF0ZWQnLCB0aGlzLmFib3J0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keT8uZGVzdHJveShlcnJvcilcblxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGVycm9yKVxuXG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uVXBncmFkZSAoc3RhdHVzLCBoZWFkZXJzTGlzdCwgc29ja2V0KSB7XG4gICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMTAxKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuXG4gICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzTGlzdC5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyc0xpc3RbbiArIDBdLnRvU3RyaW5nKCdsYXRpbjEnKVxuICAgICAgICAgICAgY29uc3QgdmFsID0gaGVhZGVyc0xpc3RbbiArIDFdLnRvU3RyaW5nKCdsYXRpbjEnKVxuXG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFNUQVRVU19DT0RFU1tzdGF0dXNdLFxuICAgICAgICAgICAgaGVhZGVyc0xpc3Q6IGhlYWRlcnNba0hlYWRlcnNMaXN0XSxcbiAgICAgICAgICAgIHNvY2tldFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmV0Y2gsXG4gIEZldGNoLFxuICBmZXRjaGluZyxcbiAgZmluYWxpemVBbmRSZXBvcnRUaW1pbmdcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/request.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/fetch/request.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* globals AbortController */\n\n\n\nconst { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/fetch/body.js\")\nconst { Headers, fill: fillHeaders, HeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/fetch/headers.js\")\nconst { FinalizationRegistry } = __webpack_require__(/*! ../compat/dispatcher-weakref */ \"(ssr)/./node_modules/undici/lib/compat/dispatcher-weakref.js\")()\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst {\n  isValidHTTPToken,\n  sameOrigin,\n  normalizeMethod,\n  makePolicyContainer\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\nconst {\n  forbiddenMethods,\n  corsSafeListedMethods,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  requestDuplex\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/fetch/constants.js\")\nconst { kEnumerableProperty } = util\nconst { kHeaders, kSignal, kState, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(ssr)/./node_modules/undici/lib/fetch/global.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__(/*! events */ \"events\")\n\nlet TransformStream = globalThis.TransformStream\n\nconst kInit = Symbol('init')\nconst kAbortController = Symbol('abortController')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (input, init = {}) {\n    if (input === kInit) {\n      return\n    }\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Request constructor' })\n\n    input = webidl.converters.RequestInfo(input)\n    init = webidl.converters.RequestInit(init)\n\n    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n    this[kRealm] = {\n      settingsObject: {\n        baseUrl: getGlobalOrigin(),\n        get origin () {\n          return this.baseUrl?.origin\n        },\n        policyContainer: makePolicyContainer()\n      }\n    }\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be thiss relevant settings objects API base URL.\n    const baseUrl = this[kRealm].settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        throw new TypeError('Failed to parse URL from ' + input, { cause: err })\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request)\n\n      // 8. Set request to inputs request.\n      request = input[kState]\n\n      // 9. Set signal to inputs signal.\n      signal = input[kSignal]\n    }\n\n    // 7. Let origin be thiss relevant settings objects origin.\n    const origin = this[kRealm].settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If requests window is an environment settings object and its origin\n    // is same origin with origin, then set window to requests window.\n    if (\n      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if (init.window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL requests URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method requests method.\n      method: request.method,\n      // header list A copy of requests header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client Thiss relevant settings object.\n      client: this[kRealm].settingsObject,\n      // window window.\n      window,\n      // priority requests priority.\n      priority: request.priority,\n      // origin requests origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer requests referrer.\n      referrer: request.referrer,\n      // referrer policy requests referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode requests mode.\n      mode: request.mode,\n      // credentials mode requests credentials mode.\n      credentials: request.credentials,\n      // cache mode requests cache mode.\n      cache: request.cache,\n      // redirect mode requests redirect mode.\n      redirect: request.redirect,\n      // integrity metadata requests integrity metadata.\n      integrity: request.integrity,\n      // keepalive requests keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag requests reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag requests history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of requests URL list.\n      urlList: [...request.urlList]\n    })\n\n    // 13. If init is not empty, then:\n    if (Object.keys(init).length > 0) {\n      // 1. If requests mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset requests reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset requests history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set requests origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set requests referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set requests referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set requests URL to requests current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set requests URL list to  requests URL .\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if (init.referrer !== undefined) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set requests referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, { cause: err })\n        }\n\n        // 3. If one of the following is true\n        // - parsedReferrers scheme is \"about\" and path is the string \"client\"\n        // - parsedReferrers origin is not same origin with origin\n        // then set requests referrer to \"client\".\n        if (\n          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||\n          (origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl))\n        ) {\n          request.referrer = 'client'\n        } else {\n          // 4. Otherwise, set requests referrer to parsedReferrer.\n          request.referrer = parsedReferrer\n        }\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set requests referrer policy\n    // to it.\n    if (init.referrerPolicy !== undefined) {\n      request.referrerPolicy = init.referrerPolicy\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if (init.mode !== undefined) {\n      mode = init.mode\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw webidl.errors.exception({\n        header: 'Request constructor',\n        message: 'invalid request mode navigate.'\n      })\n    }\n\n    // 18. If mode is non-null, set requests mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set requests credentials mode\n    // to it.\n    if (init.credentials !== undefined) {\n      request.credentials = init.credentials\n    }\n\n    // 18. If init[\"cache\"] exists, then set requests cache mode to it.\n    if (init.cache !== undefined) {\n      request.cache = init.cache\n    }\n\n    // 21. If requests cache mode is \"only-if-cached\" and requests mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set requests redirect mode to it.\n    if (init.redirect !== undefined) {\n      request.redirect = init.redirect\n    }\n\n    // 23. If init[\"integrity\"] exists, then set requests integrity metadata to it.\n    if (init.integrity !== undefined && init.integrity != null) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set requests keepalive to it.\n    if (init.keepalive !== undefined) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if (init.method !== undefined) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      // 2. If method is not a method or method is a forbidden method, then\n      // throw a TypeError.\n      if (!isValidHTTPToken(init.method)) {\n        throw TypeError(`'${init.method}' is not a valid HTTP method.`)\n      }\n\n      if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n        throw TypeError(`'${init.method}' HTTP method is unsupported.`)\n      }\n\n      // 3. Normalize method.\n      method = normalizeMethod(init.method)\n\n      // 4. Set requests method to method.\n      request.method = method\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if (init.signal !== undefined) {\n      signal = init.signal\n    }\n\n    // 27. Set thiss request to request.\n    this[kState] = request\n\n    // 28. Set thiss signal to a new AbortSignal object with thiss relevant\n    // Realm.\n    // TODO: could this be simplified with AbortSignal.any\n    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n    const ac = new AbortController()\n    this[kSignal] = ac.signal\n    this[kSignal][kRealm] = this[kRealm]\n\n    // 29. If signal is not null, then make thiss signal follow signal.\n    if (signal != null) {\n      if (\n        !signal ||\n        typeof signal.aborted !== 'boolean' ||\n        typeof signal.addEventListener !== 'function'\n      ) {\n        throw new TypeError(\n          \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n        )\n      }\n\n      if (signal.aborted) {\n        ac.abort(signal.reason)\n      } else {\n        // Keep a strong ref to ac while request object\n        // is alive. This is needed to prevent AbortController\n        // from being prematurely garbage collected.\n        // See, https://github.com/nodejs/undici/issues/1926.\n        this[kAbortController] = ac\n\n        const acRef = new WeakRef(ac)\n        const abort = function () {\n          const ac = acRef.deref()\n          if (ac !== undefined) {\n            ac.abort(this.reason)\n          }\n        }\n\n        // Third-party AbortControllers may not work with these.\n        // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.\n        try {\n          // If the max amount of listeners is equal to the default, increase it\n          // This is only available in node >= v19.9.0\n          if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {\n            setMaxListeners(100, signal)\n          } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {\n            setMaxListeners(100, signal)\n          }\n        } catch {}\n\n        util.addAbortListener(signal, abort)\n        requestFinalizer.register(ac, { signal, abort })\n      }\n    }\n\n    // 30. Set thiss headers to a new Headers object with thiss relevant\n    // Realm, whose header list is requests header list and guard is\n    // \"request\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kHeadersList] = request.headersList\n    this[kHeaders][kGuard] = 'request'\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 31. If thiss requests mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If thiss requests method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethods.includes(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set thiss headerss guard to \"request-no-cors\".\n      this[kHeaders][kGuard] = 'request-no-cors'\n    }\n\n    // 32. If init is not empty, then:\n    if (Object.keys(init).length !== 0) {\n      // 1. Let headers be a copy of thiss headers and its associated header\n      // list.\n      let headers = new Headers(this[kHeaders])\n\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      if (init.headers !== undefined) {\n        headers = init.headers\n      }\n\n      // 3. Empty thiss headerss header list.\n      this[kHeaders][kHeadersList].clear()\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append headers name/headers value to thiss headers.\n      if (headers.constructor.name === 'Headers') {\n        for (const [key, val] of headers) {\n          this[kHeaders].append(key, val)\n        }\n      } else {\n        // 5. Otherwise, fill thiss headers with headers.\n        fillHeaders(this[kHeaders], headers)\n      }\n    }\n\n    // 33. Let inputBody be inputs requests body if input is a Request\n    // object; otherwise null.\n    const inputBody = input instanceof Request ? input[kState].body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and requests method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (init.body != null || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if (init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to requests keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and thiss headerss header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // thiss headers.\n      if (contentType && !this[kHeaders][kHeadersList].contains('content-type')) {\n        this[kHeaders].append('content-type', contentType)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBodys source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n      //    then throw a TypeError.\n      if (initBody != null && init.duplex == null) {\n        throw new TypeError('RequestInit: duplex option is required when sending a body.')\n      }\n\n      // 2. If thiss requests mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 3. Set thiss requests use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      if (!TransformStream) {\n        TransformStream = (__webpack_require__(/*! stream/web */ \"stream/web\").TransformStream)\n      }\n\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set thiss requests body to finalBody.\n    this[kState].body = finalBody\n  }\n\n  // Returns requests HTTP method, which is \"GET\" by default.\n  get method () {\n    webidl.brandCheck(this, Request)\n\n    // The method getter steps are to return thiss requests method.\n    return this[kState].method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    webidl.brandCheck(this, Request)\n\n    // The url getter steps are to return thiss requests URL, serialized.\n    return URLSerializer(this[kState].url)\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    webidl.brandCheck(this, Request)\n\n    // The headers getter steps are to return thiss headers.\n    return this[kHeaders]\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    webidl.brandCheck(this, Request)\n\n    // The destination getter are to return thiss requests destination.\n    return this[kState].destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the globals default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If thiss requests referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this[kState].referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If thiss requests referrer is \"client\", then return\n    // \"about:client\".\n    if (this[kState].referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return thiss requests referrer, serialized.\n    return this[kState].referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the requests\n  // referrer.\n  get referrerPolicy () {\n    webidl.brandCheck(this, Request)\n\n    // The referrerPolicy getter steps are to return thiss requests referrer policy.\n    return this[kState].referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    webidl.brandCheck(this, Request)\n\n    // The mode getter steps are to return thiss requests mode.\n    return this[kState].mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    // The credentials getter steps are to return thiss requests credentials mode.\n    return this[kState].credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browsers cache when fetching.\n  get cache () {\n    webidl.brandCheck(this, Request)\n\n    // The cache getter steps are to return thiss requests cache mode.\n    return this[kState].cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    webidl.brandCheck(this, Request)\n\n    // The redirect getter steps are to return thiss requests redirect mode.\n    return this[kState].redirect\n  }\n\n  // Returns requests subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    webidl.brandCheck(this, Request)\n\n    // The integrity getter steps are to return thiss requests integrity\n    // metadata.\n    return this[kState].integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    webidl.brandCheck(this, Request)\n\n    // The keepalive getter steps are to return thiss requests keepalive.\n    return this[kState].keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isReloadNavigation getter steps are to return true if thiss\n    // requests reload-navigation flag is set; otherwise false.\n    return this[kState].reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-foward navigation).\n  get isHistoryNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isHistoryNavigation getter steps are to return true if thiss requests\n    // history-navigation flag is set; otherwise false.\n    return this[kState].historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    webidl.brandCheck(this, Request)\n\n    // The signal getter steps are to return thiss signal.\n    return this[kSignal]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Request)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Request)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  get duplex () {\n    webidl.brandCheck(this, Request)\n\n    return 'half'\n  }\n\n  // Returns a clone of request.\n  clone () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || this.body?.locked) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning thiss request.\n    const clonedRequest = cloneRequest(this[kState])\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, thiss headerss guard, and thiss relevant Realm.\n    const clonedRequestObject = new Request(kInit)\n    clonedRequestObject[kState] = clonedRequest\n    clonedRequestObject[kRealm] = this[kRealm]\n    clonedRequestObject[kHeaders] = new Headers()\n    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList\n    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    // 4. Make clonedRequestObjects signal follow thiss signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort(this.signal.reason)\n    } else {\n      util.addAbortListener(\n        this.signal,\n        () => {\n          ac.abort(this.signal.reason)\n        }\n      )\n    }\n    clonedRequestObject[kSignal] = ac.signal\n\n    // 4. Return clonedRequestObject.\n    return clonedRequestObject\n  }\n}\n\nmixinBody(Request)\n\nfunction makeRequest (init) {\n  // https://fetch.spec.whatwg.org/#requests\n  const request = {\n    method: 'GET',\n    localURLsOnly: false,\n    unsafeRequest: false,\n    body: null,\n    client: null,\n    reservedClient: null,\n    replacesClientId: '',\n    window: 'client',\n    keepalive: false,\n    serviceWorkers: 'all',\n    initiator: '',\n    destination: '',\n    priority: null,\n    origin: 'client',\n    policyContainer: 'client',\n    referrer: 'client',\n    referrerPolicy: '',\n    mode: 'no-cors',\n    useCORSPreflightFlag: false,\n    credentials: 'same-origin',\n    useCredentials: false,\n    cache: 'default',\n    redirect: 'follow',\n    integrity: '',\n    cryptoGraphicsNonceMetadata: '',\n    parserMetadata: '',\n    reloadNavigation: false,\n    historyNavigation: false,\n    userActivation: false,\n    taintedOrigin: false,\n    redirectCount: 0,\n    responseTainting: 'basic',\n    preventNoCacheCacheControlHeaderModification: false,\n    done: false,\n    timingAllowFailed: false,\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList()\n  }\n  request.url = request.urlList[0]\n  return request\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If requests body is non-null, set newRequests body to the\n  // result of cloning requests body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty,\n  duplex: kEnumerableProperty,\n  destination: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  isHistoryNavigation: kEnumerableProperty,\n  isReloadNavigation: kEnumerableProperty,\n  keepalive: kEnumerableProperty,\n  integrity: kEnumerableProperty,\n  cache: kEnumerableProperty,\n  credentials: kEnumerableProperty,\n  attribute: kEnumerableProperty,\n  referrerPolicy: kEnumerableProperty,\n  referrer: kEnumerableProperty,\n  mode: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Request',\n    configurable: true\n  }\n})\n\nwebidl.converters.Request = webidl.interfaceConverter(\n  Request\n)\n\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  if (V instanceof Request) {\n    return webidl.converters.Request(V)\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nwebidl.converters.AbortSignal = webidl.interfaceConverter(\n  AbortSignal\n)\n\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n  {\n    key: 'method',\n    converter: webidl.converters.ByteString\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  },\n  {\n    key: 'body',\n    converter: webidl.nullableConverter(\n      webidl.converters.BodyInit\n    )\n  },\n  {\n    key: 'referrer',\n    converter: webidl.converters.USVString\n  },\n  {\n    key: 'referrerPolicy',\n    converter: webidl.converters.DOMString,\n    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n    allowedValues: referrerPolicy\n  },\n  {\n    key: 'mode',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#concept-request-mode\n    allowedValues: requestMode\n  },\n  {\n    key: 'credentials',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcredentials\n    allowedValues: requestCredentials\n  },\n  {\n    key: 'cache',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcache\n    allowedValues: requestCache\n  },\n  {\n    key: 'redirect',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestredirect\n    allowedValues: requestRedirect\n  },\n  {\n    key: 'integrity',\n    converter: webidl.converters.DOMString\n  },\n  {\n    key: 'keepalive',\n    converter: webidl.converters.boolean\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(\n      (signal) => webidl.converters.AbortSignal(\n        signal,\n        { strict: false }\n      )\n    )\n  },\n  {\n    key: 'window',\n    converter: webidl.converters.any\n  },\n  {\n    key: 'duplex',\n    converter: webidl.converters.DOMString,\n    allowedValues: requestDuplex\n  }\n])\n\nmodule.exports = { Request, makeRequest }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVZOztBQUVaLFFBQVEsb0NBQW9DLEVBQUUsbUJBQU8sQ0FBQyw2REFBUTtBQUM5RCxRQUFRLDBDQUEwQyxFQUFFLG1CQUFPLENBQUMsbUVBQVc7QUFDdkUsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLGtHQUE4QjtBQUN2RSxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDZEQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHVFQUFhO0FBQ3pCLFFBQVEsc0JBQXNCO0FBQzlCLFFBQVEsNENBQTRDLEVBQUUsbUJBQU8sQ0FBQyxtRUFBVztBQUN6RSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLGlFQUFVO0FBQ3JDLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyxpRUFBVTtBQUM5QyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsbUVBQVc7QUFDN0MsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDbEQsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsMkVBQTJFLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFckc7O0FBRUE7QUFDQTs7QUFFQSxxREFBcUQsZUFBZTtBQUNwRTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsK0JBQStCOztBQUU5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixtRUFBbUUsWUFBWTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixzQkFBc0I7O0FBRXBEO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQ0FBMkMsU0FBUywwQkFBMEIsWUFBWTtBQUMxRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDOztBQUVBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixxRUFBcUM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLHdCQUF3Qjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9yZXF1ZXN0LmpzPzBlOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBBYm9ydENvbnRyb2xsZXIgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZXh0cmFjdEJvZHksIG1peGluQm9keSwgY2xvbmVCb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3QgeyBIZWFkZXJzLCBmaWxsOiBmaWxsSGVhZGVycywgSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IEZpbmFsaXphdGlvblJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuLi9jb21wYXQvZGlzcGF0Y2hlci13ZWFrcmVmJykoKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7XG4gIGlzVmFsaWRIVFRQVG9rZW4sXG4gIHNhbWVPcmlnaW4sXG4gIG5vcm1hbGl6ZU1ldGhvZCxcbiAgbWFrZVBvbGljeUNvbnRhaW5lclxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIGZvcmJpZGRlbk1ldGhvZHMsXG4gIGNvcnNTYWZlTGlzdGVkTWV0aG9kcyxcbiAgcmVmZXJyZXJQb2xpY3ksXG4gIHJlcXVlc3RSZWRpcmVjdCxcbiAgcmVxdWVzdE1vZGUsXG4gIHJlcXVlc3RDcmVkZW50aWFscyxcbiAgcmVxdWVzdENhY2hlLFxuICByZXF1ZXN0RHVwbGV4XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSB1dGlsXG5jb25zdCB7IGtIZWFkZXJzLCBrU2lnbmFsLCBrU3RhdGUsIGtHdWFyZCwga1JlYWxtIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgZ2V0R2xvYmFsT3JpZ2luIH0gPSByZXF1aXJlKCcuL2dsb2JhbCcpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4vZGF0YVVSTCcpXG5jb25zdCB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGdldE1heExpc3RlbmVycywgc2V0TWF4TGlzdGVuZXJzLCBnZXRFdmVudExpc3RlbmVycywgZGVmYXVsdE1heExpc3RlbmVycyB9ID0gcmVxdWlyZSgnZXZlbnRzJylcblxubGV0IFRyYW5zZm9ybVN0cmVhbSA9IGdsb2JhbFRoaXMuVHJhbnNmb3JtU3RyZWFtXG5cbmNvbnN0IGtJbml0ID0gU3ltYm9sKCdpbml0JylcbmNvbnN0IGtBYm9ydENvbnRyb2xsZXIgPSBTeW1ib2woJ2Fib3J0Q29udHJvbGxlcicpXG5cbmNvbnN0IHJlcXVlc3RGaW5hbGl6ZXIgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHsgc2lnbmFsLCBhYm9ydCB9KSA9PiB7XG4gIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KVxufSlcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtY2xhc3NcbmNsYXNzIFJlcXVlc3Qge1xuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3RcbiAgY29uc3RydWN0b3IgKGlucHV0LCBpbml0ID0ge30pIHtcbiAgICBpZiAoaW5wdXQgPT09IGtJbml0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnUmVxdWVzdCBjb25zdHJ1Y3RvcicgfSlcblxuICAgIGlucHV0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8oaW5wdXQpXG4gICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbml0KGluaXQpXG5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjZW52aXJvbm1lbnQtc2V0dGluZ3Mtb2JqZWN0XG4gICAgdGhpc1trUmVhbG1dID0ge1xuICAgICAgc2V0dGluZ3NPYmplY3Q6IHtcbiAgICAgICAgYmFzZVVybDogZ2V0R2xvYmFsT3JpZ2luKCksXG4gICAgICAgIGdldCBvcmlnaW4gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VVcmw/Lm9yaWdpblxuICAgICAgICB9LFxuICAgICAgICBwb2xpY3lDb250YWluZXI6IG1ha2VQb2xpY3lDb250YWluZXIoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEuIExldCByZXF1ZXN0IGJlIG51bGwuXG4gICAgbGV0IHJlcXVlc3QgPSBudWxsXG5cbiAgICAvLyAyLiBMZXQgZmFsbGJhY2tNb2RlIGJlIG51bGwuXG4gICAgbGV0IGZhbGxiYWNrTW9kZSA9IG51bGxcblxuICAgIC8vIDMuIExldCBiYXNlVVJMIGJlIHRoaXPigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgQVBJIGJhc2UgVVJMLlxuICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzW2tSZWFsbV0uc2V0dGluZ3NPYmplY3QuYmFzZVVybFxuXG4gICAgLy8gNC4gTGV0IHNpZ25hbCBiZSBudWxsLlxuICAgIGxldCBzaWduYWwgPSBudWxsXG5cbiAgICAvLyA1LiBJZiBpbnB1dCBpcyBhIHN0cmluZywgdGhlbjpcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gMS4gTGV0IHBhcnNlZFVSTCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgaW5wdXQgd2l0aCBiYXNlVVJMLlxuICAgICAgLy8gMi4gSWYgcGFyc2VkVVJMIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBsZXQgcGFyc2VkVVJMXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRVUkwgPSBuZXcgVVJMKGlucHV0LCBiYXNlVXJsKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBVUkwgZnJvbSAnICsgaW5wdXQsIHsgY2F1c2U6IGVyciB9KVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiBwYXJzZWRVUkwgaW5jbHVkZXMgY3JlZGVudGlhbHMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAocGFyc2VkVVJMLnVzZXJuYW1lIHx8IHBhcnNlZFVSTC5wYXNzd29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdSZXF1ZXN0IGNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBmcm9tIGEgVVJMIHRoYXQgaW5jbHVkZXMgY3JlZGVudGlhbHM6ICcgK1xuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdCB0byBhIG5ldyByZXF1ZXN0IHdob3NlIFVSTCBpcyBwYXJzZWRVUkwuXG4gICAgICByZXF1ZXN0ID0gbWFrZVJlcXVlc3QoeyB1cmxMaXN0OiBbcGFyc2VkVVJMXSB9KVxuXG4gICAgICAvLyA1LiBTZXQgZmFsbGJhY2tNb2RlIHRvIFwiY29yc1wiLlxuICAgICAgZmFsbGJhY2tNb2RlID0gJ2NvcnMnXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDYuIE90aGVyd2lzZTpcblxuICAgICAgLy8gNy4gQXNzZXJ0OiBpbnB1dCBpcyBhIFJlcXVlc3Qgb2JqZWN0LlxuICAgICAgYXNzZXJ0KGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdClcblxuICAgICAgLy8gOC4gU2V0IHJlcXVlc3QgdG8gaW5wdXTigJlzIHJlcXVlc3QuXG4gICAgICByZXF1ZXN0ID0gaW5wdXRba1N0YXRlXVxuXG4gICAgICAvLyA5LiBTZXQgc2lnbmFsIHRvIGlucHV04oCZcyBzaWduYWwuXG4gICAgICBzaWduYWwgPSBpbnB1dFtrU2lnbmFsXVxuICAgIH1cblxuICAgIC8vIDcuIExldCBvcmlnaW4gYmUgdGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBvcmlnaW4uXG4gICAgY29uc3Qgb3JpZ2luID0gdGhpc1trUmVhbG1dLnNldHRpbmdzT2JqZWN0Lm9yaWdpblxuXG4gICAgLy8gOC4gTGV0IHdpbmRvdyBiZSBcImNsaWVudFwiLlxuICAgIGxldCB3aW5kb3cgPSAnY2xpZW50J1xuXG4gICAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCBhbmQgaXRzIG9yaWdpblxuICAgIC8vIGlzIHNhbWUgb3JpZ2luIHdpdGggb3JpZ2luLCB0aGVuIHNldCB3aW5kb3cgdG8gcmVxdWVzdOKAmXMgd2luZG93LlxuICAgIGlmIChcbiAgICAgIHJlcXVlc3Qud2luZG93Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vudmlyb25tZW50U2V0dGluZ3NPYmplY3QnICYmXG4gICAgICBzYW1lT3JpZ2luKHJlcXVlc3Qud2luZG93LCBvcmlnaW4pXG4gICAgKSB7XG4gICAgICB3aW5kb3cgPSByZXF1ZXN0LndpbmRvd1xuICAgIH1cblxuICAgIC8vIDEwLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKGluaXQud2luZG93ICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCd3aW5kb3cnIG9wdGlvbiAnJHt3aW5kb3d9JyBtdXN0IGJlIG51bGxgKVxuICAgIH1cblxuICAgIC8vIDExLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cywgdGhlbiBzZXQgd2luZG93IHRvIFwibm8td2luZG93XCIuXG4gICAgaWYgKCd3aW5kb3cnIGluIGluaXQpIHtcbiAgICAgIHdpbmRvdyA9ICduby13aW5kb3cnXG4gICAgfVxuXG4gICAgLy8gMTIuIFNldCByZXF1ZXN0IHRvIGEgbmV3IHJlcXVlc3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICAgIC8vIFVSTCByZXF1ZXN04oCZcyBVUkwuXG4gICAgICAvLyB1bmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogdGhpcyBpcyBzZXQgYXMgdGhlIGZpcnN0IGl0ZW0gaW4gcmVxdWVzdCdzIHVybExpc3QgaW4gbWFrZVJlcXVlc3RcbiAgICAgIC8vIG1ldGhvZCByZXF1ZXN04oCZcyBtZXRob2QuXG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgLy8gaGVhZGVyIGxpc3QgQSBjb3B5IG9mIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gdW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IGhlYWRlcnNMaXN0IGlzIGNsb25lZCBpbiBtYWtlUmVxdWVzdFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlcXVlc3QuaGVhZGVyc0xpc3QsXG4gICAgICAvLyB1bnNhZmUtcmVxdWVzdCBmbGFnIFNldC5cbiAgICAgIHVuc2FmZVJlcXVlc3Q6IHJlcXVlc3QudW5zYWZlUmVxdWVzdCxcbiAgICAgIC8vIGNsaWVudCBUaGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgICBjbGllbnQ6IHRoaXNba1JlYWxtXS5zZXR0aW5nc09iamVjdCxcbiAgICAgIC8vIHdpbmRvdyB3aW5kb3cuXG4gICAgICB3aW5kb3csXG4gICAgICAvLyBwcmlvcml0eSByZXF1ZXN04oCZcyBwcmlvcml0eS5cbiAgICAgIHByaW9yaXR5OiByZXF1ZXN0LnByaW9yaXR5LFxuICAgICAgLy8gb3JpZ2luIHJlcXVlc3TigJlzIG9yaWdpbi4gVGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBvcmlnaW4gaXMgb25seSBzaWduaWZpY2FudCBmb3IgbmF2aWdhdGlvbiByZXF1ZXN0c1xuICAgICAgLy8gYmVpbmcgaGFuZGxlZCBieSBhIHNlcnZpY2Ugd29ya2VyLiBJbiB0aGlzIHNjZW5hcmlvIGEgcmVxdWVzdCBjYW4gaGF2ZSBhbiBvcmlnaW4gdGhhdCBpcyBkaWZmZXJlbnRcbiAgICAgIC8vIGZyb20gdGhlIGN1cnJlbnQgY2xpZW50LlxuICAgICAgb3JpZ2luOiByZXF1ZXN0Lm9yaWdpbixcbiAgICAgIC8vIHJlZmVycmVyIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICAgICAgcmVmZXJyZXI6IHJlcXVlc3QucmVmZXJyZXIsXG4gICAgICAvLyByZWZlcnJlciBwb2xpY3kgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICAgICAgcmVmZXJyZXJQb2xpY3k6IHJlcXVlc3QucmVmZXJyZXJQb2xpY3ksXG4gICAgICAvLyBtb2RlIHJlcXVlc3TigJlzIG1vZGUuXG4gICAgICBtb2RlOiByZXF1ZXN0Lm1vZGUsXG4gICAgICAvLyBjcmVkZW50aWFscyBtb2RlIHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGUuXG4gICAgICBjcmVkZW50aWFsczogcmVxdWVzdC5jcmVkZW50aWFscyxcbiAgICAgIC8vIGNhY2hlIG1vZGUgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZS5cbiAgICAgIGNhY2hlOiByZXF1ZXN0LmNhY2hlLFxuICAgICAgLy8gcmVkaXJlY3QgbW9kZSByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlLlxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICAvLyBpbnRlZ3JpdHkgbWV0YWRhdGEgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhLlxuICAgICAgaW50ZWdyaXR5OiByZXF1ZXN0LmludGVncml0eSxcbiAgICAgIC8vIGtlZXBhbGl2ZSByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgICBrZWVwYWxpdmU6IHJlcXVlc3Qua2VlcGFsaXZlLFxuICAgICAgLy8gcmVsb2FkLW5hdmlnYXRpb24gZmxhZyByZXF1ZXN04oCZcyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgcmVsb2FkTmF2aWdhdGlvbjogcmVxdWVzdC5yZWxvYWROYXZpZ2F0aW9uLFxuICAgICAgLy8gaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcgcmVxdWVzdOKAmXMgaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICBoaXN0b3J5TmF2aWdhdGlvbjogcmVxdWVzdC5oaXN0b3J5TmF2aWdhdGlvbixcbiAgICAgIC8vIFVSTCBsaXN0IEEgY2xvbmUgb2YgcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gICAgICB1cmxMaXN0OiBbLi4ucmVxdWVzdC51cmxMaXN0XVxuICAgIH0pXG5cbiAgICAvLyAxMy4gSWYgaW5pdCBpcyBub3QgZW1wdHksIHRoZW46XG4gICAgaWYgKE9iamVjdC5rZXlzKGluaXQpLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiLCB0aGVuIHNldCBpdCB0byBcInNhbWUtb3JpZ2luXCIuXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnKSB7XG4gICAgICAgIHJlcXVlc3QubW9kZSA9ICdzYW1lLW9yaWdpbidcbiAgICAgIH1cblxuICAgICAgLy8gMi4gVW5zZXQgcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlcXVlc3QucmVsb2FkTmF2aWdhdGlvbiA9IGZhbHNlXG5cbiAgICAgIC8vIDMuIFVuc2V0IHJlcXVlc3TigJlzIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgcmVxdWVzdC5oaXN0b3J5TmF2aWdhdGlvbiA9IGZhbHNlXG5cbiAgICAgIC8vIDQuIFNldCByZXF1ZXN04oCZcyBvcmlnaW4gdG8gXCJjbGllbnRcIi5cbiAgICAgIHJlcXVlc3Qub3JpZ2luID0gJ2NsaWVudCdcblxuICAgICAgLy8gNS4gU2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwiY2xpZW50XCJcbiAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSAnY2xpZW50J1xuXG4gICAgICAvLyA2LiBTZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gJydcblxuICAgICAgLy8gNy4gU2V0IHJlcXVlc3TigJlzIFVSTCB0byByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgICAgIHJlcXVlc3QudXJsID0gcmVxdWVzdC51cmxMaXN0W3JlcXVlc3QudXJsTGlzdC5sZW5ndGggLSAxXVxuXG4gICAgICAvLyA4LiBTZXQgcmVxdWVzdOKAmXMgVVJMIGxpc3QgdG8gwqsgcmVxdWVzdOKAmXMgVVJMIMK7LlxuICAgICAgcmVxdWVzdC51cmxMaXN0ID0gW3JlcXVlc3QudXJsXVxuICAgIH1cblxuICAgIC8vIDE0LiBJZiBpbml0W1wicmVmZXJyZXJcIl0gZXhpc3RzLCB0aGVuOlxuICAgIGlmIChpbml0LnJlZmVycmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCByZWZlcnJlciBiZSBpbml0W1wicmVmZXJyZXJcIl0uXG4gICAgICBjb25zdCByZWZlcnJlciA9IGluaXQucmVmZXJyZXJcblxuICAgICAgLy8gMi4gSWYgcmVmZXJyZXIgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJuby1yZWZlcnJlclwiLlxuICAgICAgaWYgKHJlZmVycmVyID09PSAnJykge1xuICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ25vLXJlZmVycmVyJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMS4gTGV0IHBhcnNlZFJlZmVycmVyIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyByZWZlcnJlciB3aXRoXG4gICAgICAgIC8vIGJhc2VVUkwuXG4gICAgICAgIC8vIDIuIElmIHBhcnNlZFJlZmVycmVyIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIGxldCBwYXJzZWRSZWZlcnJlclxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZFJlZmVycmVyID0gbmV3IFVSTChyZWZlcnJlciwgYmFzZVVybClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVmZXJyZXIgXCIke3JlZmVycmVyfVwiIGlzIG5vdCBhIHZhbGlkIFVSTC5gLCB7IGNhdXNlOiBlcnIgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIElmIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWVcbiAgICAgICAgLy8gLSBwYXJzZWRSZWZlcnJlcuKAmXMgc2NoZW1lIGlzIFwiYWJvdXRcIiBhbmQgcGF0aCBpcyB0aGUgc3RyaW5nIFwiY2xpZW50XCJcbiAgICAgICAgLy8gLSBwYXJzZWRSZWZlcnJlcuKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIG9yaWdpblxuICAgICAgICAvLyB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcImNsaWVudFwiLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgKHBhcnNlZFJlZmVycmVyLnByb3RvY29sID09PSAnYWJvdXQ6JyAmJiBwYXJzZWRSZWZlcnJlci5ob3N0bmFtZSA9PT0gJ2NsaWVudCcpIHx8XG4gICAgICAgICAgKG9yaWdpbiAmJiAhc2FtZU9yaWdpbihwYXJzZWRSZWZlcnJlciwgdGhpc1trUmVhbG1dLnNldHRpbmdzT2JqZWN0LmJhc2VVcmwpKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ2NsaWVudCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyA0LiBPdGhlcndpc2UsIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBwYXJzZWRSZWZlcnJlci5cbiAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gcGFyc2VkUmVmZXJyZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDE1LiBJZiBpbml0W1wicmVmZXJyZXJQb2xpY3lcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3lcbiAgICAvLyB0byBpdC5cbiAgICBpZiAoaW5pdC5yZWZlcnJlclBvbGljeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gaW5pdC5yZWZlcnJlclBvbGljeVxuICAgIH1cblxuICAgIC8vIDE2LiBMZXQgbW9kZSBiZSBpbml0W1wibW9kZVwiXSBpZiBpdCBleGlzdHMsIGFuZCBmYWxsYmFja01vZGUgb3RoZXJ3aXNlLlxuICAgIGxldCBtb2RlXG4gICAgaWYgKGluaXQubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtb2RlID0gaW5pdC5tb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGUgPSBmYWxsYmFja01vZGVcbiAgICB9XG5cbiAgICAvLyAxNy4gSWYgbW9kZSBpcyBcIm5hdmlnYXRlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKG1vZGUgPT09ICduYXZpZ2F0ZScpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVxdWVzdCBjb25zdHJ1Y3RvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIHJlcXVlc3QgbW9kZSBuYXZpZ2F0ZS4nXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDE4LiBJZiBtb2RlIGlzIG5vbi1udWxsLCBzZXQgcmVxdWVzdOKAmXMgbW9kZSB0byBtb2RlLlxuICAgIGlmIChtb2RlICE9IG51bGwpIHtcbiAgICAgIHJlcXVlc3QubW9kZSA9IG1vZGVcbiAgICB9XG5cbiAgICAvLyAxOS4gSWYgaW5pdFtcImNyZWRlbnRpYWxzXCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZVxuICAgIC8vIHRvIGl0LlxuICAgIGlmIChpbml0LmNyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPSBpbml0LmNyZWRlbnRpYWxzXG4gICAgfVxuXG4gICAgLy8gMTguIElmIGluaXRbXCJjYWNoZVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gaXQuXG4gICAgaWYgKGluaXQuY2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5jYWNoZSA9IGluaXQuY2FjaGVcbiAgICB9XG5cbiAgICAvLyAyMS4gSWYgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm9ubHktaWYtY2FjaGVkXCIgYW5kIHJlcXVlc3TigJlzIG1vZGUgaXNcbiAgICAvLyBub3QgXCJzYW1lLW9yaWdpblwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChyZXF1ZXN0LmNhY2hlID09PSAnb25seS1pZi1jYWNoZWQnICYmIHJlcXVlc3QubW9kZSAhPT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCInb25seS1pZi1jYWNoZWQnIGNhbiBiZSBzZXQgb25seSB3aXRoICdzYW1lLW9yaWdpbicgbW9kZVwiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gMjIuIElmIGluaXRbXCJyZWRpcmVjdFwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgdG8gaXQuXG4gICAgaWYgKGluaXQucmVkaXJlY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5yZWRpcmVjdCA9IGluaXQucmVkaXJlY3RcbiAgICB9XG5cbiAgICAvLyAyMy4gSWYgaW5pdFtcImludGVncml0eVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YSB0byBpdC5cbiAgICBpZiAoaW5pdC5pbnRlZ3JpdHkgIT09IHVuZGVmaW5lZCAmJiBpbml0LmludGVncml0eSAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LmludGVncml0eSA9IFN0cmluZyhpbml0LmludGVncml0eSlcbiAgICB9XG5cbiAgICAvLyAyNC4gSWYgaW5pdFtcImtlZXBhbGl2ZVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGtlZXBhbGl2ZSB0byBpdC5cbiAgICBpZiAoaW5pdC5rZWVwYWxpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5rZWVwYWxpdmUgPSBCb29sZWFuKGluaXQua2VlcGFsaXZlKVxuICAgIH1cblxuICAgIC8vIDI1LiBJZiBpbml0W1wibWV0aG9kXCJdIGV4aXN0cywgdGhlbjpcbiAgICBpZiAoaW5pdC5tZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMS4gTGV0IG1ldGhvZCBiZSBpbml0W1wibWV0aG9kXCJdLlxuICAgICAgbGV0IG1ldGhvZCA9IGluaXQubWV0aG9kXG5cbiAgICAgIC8vIDIuIElmIG1ldGhvZCBpcyBub3QgYSBtZXRob2Qgb3IgbWV0aG9kIGlzIGEgZm9yYmlkZGVuIG1ldGhvZCwgdGhlblxuICAgICAgLy8gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoIWlzVmFsaWRIVFRQVG9rZW4oaW5pdC5tZXRob2QpKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgJyR7aW5pdC5tZXRob2R9JyBpcyBub3QgYSB2YWxpZCBIVFRQIG1ldGhvZC5gKVxuICAgICAgfVxuXG4gICAgICBpZiAoZm9yYmlkZGVuTWV0aG9kcy5pbmRleE9mKG1ldGhvZC50b1VwcGVyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKGAnJHtpbml0Lm1ldGhvZH0nIEhUVFAgbWV0aG9kIGlzIHVuc3VwcG9ydGVkLmApXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIE5vcm1hbGl6ZSBtZXRob2QuXG4gICAgICBtZXRob2QgPSBub3JtYWxpemVNZXRob2QoaW5pdC5tZXRob2QpXG5cbiAgICAgIC8vIDQuIFNldCByZXF1ZXN04oCZcyBtZXRob2QgdG8gbWV0aG9kLlxuICAgICAgcmVxdWVzdC5tZXRob2QgPSBtZXRob2RcbiAgICB9XG5cbiAgICAvLyAyNi4gSWYgaW5pdFtcInNpZ25hbFwiXSBleGlzdHMsIHRoZW4gc2V0IHNpZ25hbCB0byBpdC5cbiAgICBpZiAoaW5pdC5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2lnbmFsID0gaW5pdC5zaWduYWxcbiAgICB9XG5cbiAgICAvLyAyNy4gU2V0IHRoaXPigJlzIHJlcXVlc3QgdG8gcmVxdWVzdC5cbiAgICB0aGlzW2tTdGF0ZV0gPSByZXF1ZXN0XG5cbiAgICAvLyAyOC4gU2V0IHRoaXPigJlzIHNpZ25hbCB0byBhIG5ldyBBYm9ydFNpZ25hbCBvYmplY3Qgd2l0aCB0aGlz4oCZcyByZWxldmFudFxuICAgIC8vIFJlYWxtLlxuICAgIC8vIFRPRE86IGNvdWxkIHRoaXMgYmUgc2ltcGxpZmllZCB3aXRoIEFib3J0U2lnbmFsLmFueVxuICAgIC8vIChodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1hYm9ydHNpZ25hbC1hbnkpXG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICB0aGlzW2tTaWduYWxdID0gYWMuc2lnbmFsXG4gICAgdGhpc1trU2lnbmFsXVtrUmVhbG1dID0gdGhpc1trUmVhbG1dXG5cbiAgICAvLyAyOS4gSWYgc2lnbmFsIGlzIG5vdCBudWxsLCB0aGVuIG1ha2UgdGhpc+KAmXMgc2lnbmFsIGZvbGxvdyBzaWduYWwuXG4gICAgaWYgKHNpZ25hbCAhPSBudWxsKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFzaWduYWwgfHxcbiAgICAgICAgdHlwZW9mIHNpZ25hbC5hYm9ydGVkICE9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1JlcXVlc3QnOiBtZW1iZXIgc2lnbmFsIGlzIG5vdCBvZiB0eXBlIEFib3J0U2lnbmFsLlwiXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFjLmFib3J0KHNpZ25hbC5yZWFzb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBLZWVwIGEgc3Ryb25nIHJlZiB0byBhYyB3aGlsZSByZXF1ZXN0IG9iamVjdFxuICAgICAgICAvLyBpcyBhbGl2ZS4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudCBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgLy8gZnJvbSBiZWluZyBwcmVtYXR1cmVseSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTkyNi5cbiAgICAgICAgdGhpc1trQWJvcnRDb250cm9sbGVyXSA9IGFjXG5cbiAgICAgICAgY29uc3QgYWNSZWYgPSBuZXcgV2Vha1JlZihhYylcbiAgICAgICAgY29uc3QgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgYWMgPSBhY1JlZi5kZXJlZigpXG4gICAgICAgICAgaWYgKGFjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFjLmFib3J0KHRoaXMucmVhc29uKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXJkLXBhcnR5IEFib3J0Q29udHJvbGxlcnMgbWF5IG5vdCB3b3JrIHdpdGggdGhlc2UuXG4gICAgICAgIC8vIFNlZSwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvcHVsbC8xOTEwI2lzc3VlY29tbWVudC0xNDY0NDk1NjE5LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIElmIHRoZSBtYXggYW1vdW50IG9mIGxpc3RlbmVycyBpcyBlcXVhbCB0byB0aGUgZGVmYXVsdCwgaW5jcmVhc2UgaXRcbiAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGluIG5vZGUgPj0gdjE5LjkuMFxuICAgICAgICAgIGlmICh0eXBlb2YgZ2V0TWF4TGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmIGdldE1heExpc3RlbmVycyhzaWduYWwpID09PSBkZWZhdWx0TWF4TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBzZXRNYXhMaXN0ZW5lcnMoMTAwLCBzaWduYWwpXG4gICAgICAgICAgfSBlbHNlIGlmIChnZXRFdmVudExpc3RlbmVycyhzaWduYWwsICdhYm9ydCcpLmxlbmd0aCA+PSBkZWZhdWx0TWF4TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBzZXRNYXhMaXN0ZW5lcnMoMTAwLCBzaWduYWwpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHt9XG5cbiAgICAgICAgdXRpbC5hZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgYWJvcnQpXG4gICAgICAgIHJlcXVlc3RGaW5hbGl6ZXIucmVnaXN0ZXIoYWMsIHsgc2lnbmFsLCBhYm9ydCB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMwLiBTZXQgdGhpc+KAmXMgaGVhZGVycyB0byBhIG5ldyBIZWFkZXJzIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0sIHdob3NlIGhlYWRlciBsaXN0IGlzIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGFuZCBndWFyZCBpc1xuICAgIC8vIFwicmVxdWVzdFwiLlxuICAgIHRoaXNba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoKVxuICAgIHRoaXNba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSByZXF1ZXN0LmhlYWRlcnNMaXN0XG4gICAgdGhpc1trSGVhZGVyc11ba0d1YXJkXSA9ICdyZXF1ZXN0J1xuICAgIHRoaXNba0hlYWRlcnNdW2tSZWFsbV0gPSB0aGlzW2tSZWFsbV1cblxuICAgIC8vIDMxLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIFwibm8tY29yc1wiLCB0aGVuOlxuICAgIGlmIChtb2RlID09PSAnbm8tY29ycycpIHtcbiAgICAgIC8vIDEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgbWV0aG9kLFxuICAgICAgLy8gdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmICghY29yc1NhZmVMaXN0ZWRNZXRob2RzLmluY2x1ZGVzKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnJHtyZXF1ZXN0Lm1ldGhvZH0gaXMgdW5zdXBwb3J0ZWQgaW4gbm8tY29ycyBtb2RlLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQgdG8gXCJyZXF1ZXN0LW5vLWNvcnNcIi5cbiAgICAgIHRoaXNba0hlYWRlcnNdW2tHdWFyZF0gPSAncmVxdWVzdC1uby1jb3JzJ1xuICAgIH1cblxuICAgIC8vIDMyLiBJZiBpbml0IGlzIG5vdCBlbXB0eSwgdGhlbjpcbiAgICBpZiAoT2JqZWN0LmtleXMoaW5pdCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAvLyAxLiBMZXQgaGVhZGVycyBiZSBhIGNvcHkgb2YgdGhpc+KAmXMgaGVhZGVycyBhbmQgaXRzIGFzc29jaWF0ZWQgaGVhZGVyXG4gICAgICAvLyBsaXN0LlxuICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzW2tIZWFkZXJzXSlcblxuICAgICAgLy8gMi4gSWYgaW5pdFtcImhlYWRlcnNcIl0gZXhpc3RzLCB0aGVuIHNldCBoZWFkZXJzIHRvIGluaXRbXCJoZWFkZXJzXCJdLlxuICAgICAgaWYgKGluaXQuaGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlYWRlcnMgPSBpbml0LmhlYWRlcnNcbiAgICAgIH1cblxuICAgICAgLy8gMy4gRW1wdHkgdGhpc+KAmXMgaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QuXG4gICAgICB0aGlzW2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdLmNsZWFyKClcblxuICAgICAgLy8gNC4gSWYgaGVhZGVycyBpcyBhIEhlYWRlcnMgb2JqZWN0LCB0aGVuIGZvciBlYWNoIGhlYWRlciBpbiBpdHMgaGVhZGVyXG4gICAgICAvLyBsaXN0LCBhcHBlbmQgaGVhZGVy4oCZcyBuYW1lL2hlYWRlcuKAmXMgdmFsdWUgdG8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChoZWFkZXJzLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdIZWFkZXJzJykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgaGVhZGVycykge1xuICAgICAgICAgIHRoaXNba0hlYWRlcnNdLmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBmaWxsIHRoaXPigJlzIGhlYWRlcnMgd2l0aCBoZWFkZXJzLlxuICAgICAgICBmaWxsSGVhZGVycyh0aGlzW2tIZWFkZXJzXSwgaGVhZGVycylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzMy4gTGV0IGlucHV0Qm9keSBiZSBpbnB1dOKAmXMgcmVxdWVzdOKAmXMgYm9keSBpZiBpbnB1dCBpcyBhIFJlcXVlc3RcbiAgICAvLyBvYmplY3Q7IG90aGVyd2lzZSBudWxsLlxuICAgIGNvbnN0IGlucHV0Qm9keSA9IGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGlucHV0W2tTdGF0ZV0uYm9keSA6IG51bGxcblxuICAgIC8vIDM0LiBJZiBlaXRoZXIgaW5pdFtcImJvZHlcIl0gZXhpc3RzIGFuZCBpcyBub24tbnVsbCBvciBpbnB1dEJvZHkgaXNcbiAgICAvLyBub24tbnVsbCwgYW5kIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBgR0VUYCBvciBgSEVBRGAsIHRoZW4gdGhyb3cgYVxuICAgIC8vIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICAoaW5pdC5ib2R5ICE9IG51bGwgfHwgaW5wdXRCb2R5ICE9IG51bGwpICYmXG4gICAgICAocmVxdWVzdC5tZXRob2QgPT09ICdHRVQnIHx8IHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0IHdpdGggR0VUL0hFQUQgbWV0aG9kIGNhbm5vdCBoYXZlIGJvZHkuJylcbiAgICB9XG5cbiAgICAvLyAzNS4gTGV0IGluaXRCb2R5IGJlIG51bGwuXG4gICAgbGV0IGluaXRCb2R5ID0gbnVsbFxuXG4gICAgLy8gMzYuIElmIGluaXRbXCJib2R5XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwsIHRoZW46XG4gICAgaWYgKGluaXQuYm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxLiBMZXQgQ29udGVudC1UeXBlIGJlIG51bGwuXG4gICAgICAvLyAyLiBTZXQgaW5pdEJvZHkgYW5kIENvbnRlbnQtVHlwZSB0byB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmdcbiAgICAgIC8vIGluaXRbXCJib2R5XCJdLCB3aXRoIGtlZXBhbGl2ZSBzZXQgdG8gcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgICAgY29uc3QgW2V4dHJhY3RlZEJvZHksIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KFxuICAgICAgICBpbml0LmJvZHksXG4gICAgICAgIHJlcXVlc3Qua2VlcGFsaXZlXG4gICAgICApXG4gICAgICBpbml0Qm9keSA9IGV4dHJhY3RlZEJvZHlcblxuICAgICAgLy8gMywgSWYgQ29udGVudC1UeXBlIGlzIG5vbi1udWxsIGFuZCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdCBkb2VzXG4gICAgICAvLyBub3QgY29udGFpbiBgQ29udGVudC1UeXBlYCwgdGhlbiBhcHBlbmQgYENvbnRlbnQtVHlwZWAvQ29udGVudC1UeXBlIHRvXG4gICAgICAvLyB0aGlz4oCZcyBoZWFkZXJzLlxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmICF0aGlzW2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdLmNvbnRhaW5zKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICB0aGlzW2tIZWFkZXJzXS5hcHBlbmQoJ2NvbnRlbnQtdHlwZScsIGNvbnRlbnRUeXBlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDM3LiBMZXQgaW5wdXRPckluaXRCb2R5IGJlIGluaXRCb2R5IGlmIGl0IGlzIG5vbi1udWxsOyBvdGhlcndpc2VcbiAgICAvLyBpbnB1dEJvZHkuXG4gICAgY29uc3QgaW5wdXRPckluaXRCb2R5ID0gaW5pdEJvZHkgPz8gaW5wdXRCb2R5XG5cbiAgICAvLyAzOC4gSWYgaW5wdXRPckluaXRCb2R5IGlzIG5vbi1udWxsIGFuZCBpbnB1dE9ySW5pdEJvZHnigJlzIHNvdXJjZSBpc1xuICAgIC8vIG51bGwsIHRoZW46XG4gICAgaWYgKGlucHV0T3JJbml0Qm9keSAhPSBudWxsICYmIGlucHV0T3JJbml0Qm9keS5zb3VyY2UgPT0gbnVsbCkge1xuICAgICAgLy8gMS4gSWYgaW5pdEJvZHkgaXMgbm9uLW51bGwgYW5kIGluaXRbXCJkdXBsZXhcIl0gZG9lcyBub3QgZXhpc3QsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKGluaXRCb2R5ICE9IG51bGwgJiYgaW5pdC5kdXBsZXggPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0SW5pdDogZHVwbGV4IG9wdGlvbiBpcyByZXF1aXJlZCB3aGVuIHNlbmRpbmcgYSBib2R5LicpXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1vZGUgaXMgbmVpdGhlciBcInNhbWUtb3JpZ2luXCIgbm9yIFwiY29yc1wiLFxuICAgICAgLy8gdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChyZXF1ZXN0Lm1vZGUgIT09ICdzYW1lLW9yaWdpbicgJiYgcmVxdWVzdC5tb2RlICE9PSAnY29ycycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnSWYgcmVxdWVzdCBpcyBtYWRlIGZyb20gUmVhZGFibGVTdHJlYW0sIG1vZGUgc2hvdWxkIGJlIFwic2FtZS1vcmlnaW5cIiBvciBcImNvcnNcIidcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBTZXQgdGhpc+KAmXMgcmVxdWVzdOKAmXMgdXNlLUNPUlMtcHJlZmxpZ2h0IGZsYWcuXG4gICAgICByZXF1ZXN0LnVzZUNPUlNQcmVmbGlnaHRGbGFnID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIDM5LiBMZXQgZmluYWxCb2R5IGJlIGlucHV0T3JJbml0Qm9keS5cbiAgICBsZXQgZmluYWxCb2R5ID0gaW5wdXRPckluaXRCb2R5XG5cbiAgICAvLyA0MC4gSWYgaW5pdEJvZHkgaXMgbnVsbCBhbmQgaW5wdXRCb2R5IGlzIG5vbi1udWxsLCB0aGVuOlxuICAgIGlmIChpbml0Qm9keSA9PSBudWxsICYmIGlucHV0Qm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxLiBJZiBpbnB1dCBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmICh1dGlsLmlzRGlzdHVyYmVkKGlucHV0Qm9keS5zdHJlYW0pIHx8IGlucHV0Qm9keS5zdHJlYW0ubG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb25zdHJ1Y3QgYSBSZXF1ZXN0IHdpdGggYSBSZXF1ZXN0IG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdXNlZC4nXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IGZpbmFsQm9keSB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgcHJveHkgZm9yIGlucHV0Qm9keS5cbiAgICAgIGlmICghVHJhbnNmb3JtU3RyZWFtKSB7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5UcmFuc2Zvcm1TdHJlYW1cbiAgICAgIH1cblxuICAgICAgLy8gaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW0tY3JlYXRlLWEtcHJveHlcbiAgICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpXG4gICAgICBpbnB1dEJvZHkuc3RyZWFtLnBpcGVUaHJvdWdoKGlkZW50aXR5VHJhbnNmb3JtKVxuICAgICAgZmluYWxCb2R5ID0ge1xuICAgICAgICBzb3VyY2U6IGlucHV0Qm9keS5zb3VyY2UsXG4gICAgICAgIGxlbmd0aDogaW5wdXRCb2R5Lmxlbmd0aCxcbiAgICAgICAgc3RyZWFtOiBpZGVudGl0eVRyYW5zZm9ybS5yZWFkYWJsZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQxLiBTZXQgdGhpc+KAmXMgcmVxdWVzdOKAmXMgYm9keSB0byBmaW5hbEJvZHkuXG4gICAgdGhpc1trU3RhdGVdLmJvZHkgPSBmaW5hbEJvZHlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgSFRUUCBtZXRob2QsIHdoaWNoIGlzIFwiR0VUXCIgYnkgZGVmYXVsdC5cbiAgZ2V0IG1ldGhvZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBtZXRob2QgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgbWV0aG9kLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubWV0aG9kXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBVUkwgb2YgcmVxdWVzdCBhcyBhIHN0cmluZy5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgVVJMLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHRoaXNba1N0YXRlXS51cmwpXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgSGVhZGVycyBvYmplY3QgY29uc2lzdGluZyBvZiB0aGUgaGVhZGVycyBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdC5cbiAgLy8gTm90ZSB0aGF0IGhlYWRlcnMgYWRkZWQgaW4gdGhlIG5ldHdvcmsgbGF5ZXIgYnkgdGhlIHVzZXIgYWdlbnQgd2lsbCBub3RcbiAgLy8gYmUgYWNjb3VudGVkIGZvciBpbiB0aGlzIG9iamVjdCwgZS5nLiwgdGhlIFwiSG9zdFwiIGhlYWRlci5cbiAgZ2V0IGhlYWRlcnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzXVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUga2luZCBvZiByZXNvdXJjZSByZXF1ZXN0ZWQgYnkgcmVxdWVzdCwgZS5nLiwgXCJkb2N1bWVudFwiXG4gIC8vIG9yIFwic2NyaXB0XCIuXG4gIGdldCBkZXN0aW5hdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBnZXR0ZXIgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbi5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmRlc3RpbmF0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWZlcnJlciBvZiByZXF1ZXN0LiBJdHMgdmFsdWUgY2FuIGJlIGEgc2FtZS1vcmlnaW4gVVJMIGlmXG4gIC8vIGV4cGxpY2l0bHkgc2V0IGluIGluaXQsIHRoZSBlbXB0eSBzdHJpbmcgdG8gaW5kaWNhdGUgbm8gcmVmZXJyZXIsIGFuZFxuICAvLyBcImFib3V0OmNsaWVudFwiIHdoZW4gZGVmYXVsdGluZyB0byB0aGUgZ2xvYmFs4oCZcyBkZWZhdWx0LiBUaGlzIGlzIHVzZWRcbiAgLy8gZHVyaW5nIGZldGNoaW5nIHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgdGhlIGBSZWZlcmVyYCBoZWFkZXIgb2YgdGhlXG4gIC8vIHJlcXVlc3QgYmVpbmcgbWFkZS5cbiAgZ2V0IHJlZmVycmVyICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJuby1yZWZlcnJlclwiLCB0aGVuIHJldHVybiB0aGVcbiAgICAvLyBlbXB0eSBzdHJpbmcuXG4gICAgaWYgKHRoaXNba1N0YXRlXS5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJykge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJjbGllbnRcIiwgdGhlbiByZXR1cm5cbiAgICAvLyBcImFib3V0OmNsaWVudFwiLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0ucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG4gICAgICByZXR1cm4gJ2Fib3V0OmNsaWVudCdcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIsIHNlcmlhbGl6ZWQuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWZlcnJlci50b1N0cmluZygpXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWZlcnJlciBwb2xpY3kgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdXNlZCBkdXJpbmcgZmV0Y2hpbmcgdG8gY29tcHV0ZSB0aGUgdmFsdWUgb2YgdGhlIHJlcXVlc3TigJlzXG4gIC8vIHJlZmVycmVyLlxuICBnZXQgcmVmZXJyZXJQb2xpY3kgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgcmVmZXJyZXJQb2xpY3kgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVmZXJyZXJQb2xpY3lcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmdcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCB3aWxsIHVzZSBDT1JTLCBvciB3aWxsIGJlIHJlc3RyaWN0ZWQgdG8gc2FtZS1vcmlnaW5cbiAgLy8gVVJMcy5cbiAgZ2V0IG1vZGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgbW9kZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubW9kZVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgY3JlZGVudGlhbHMgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyB3aGV0aGVyIGNyZWRlbnRpYWxzIHdpbGwgYmUgc2VudCB3aXRoIHRoZVxuICAvLyByZXF1ZXN0IGFsd2F5cywgbmV2ZXIsIG9yIG9ubHkgd2hlbiBzZW50IHRvIGEgc2FtZS1vcmlnaW4gVVJMLlxuICBnZXQgY3JlZGVudGlhbHMgKCkge1xuICAgIC8vIFRoZSBjcmVkZW50aWFscyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uY3JlZGVudGlhbHNcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGNhY2hlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgaG93IHRoZSByZXF1ZXN0IHdpbGxcbiAgLy8gaW50ZXJhY3Qgd2l0aCB0aGUgYnJvd3NlcuKAmXMgY2FjaGUgd2hlbiBmZXRjaGluZy5cbiAgZ2V0IGNhY2hlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGNhY2hlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5jYWNoZVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVkaXJlY3QgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyBob3cgcmVkaXJlY3RzIGZvciB0aGVcbiAgLy8gcmVxdWVzdCB3aWxsIGJlIGhhbmRsZWQgZHVyaW5nIGZldGNoaW5nLiBBIHJlcXVlc3RcbiAgLy8gd2lsbCBmb2xsb3cgcmVkaXJlY3RzIGJ5IGRlZmF1bHQuXG4gIGdldCByZWRpcmVjdCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSByZWRpcmVjdCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVkaXJlY3RcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgc3VicmVzb3VyY2UgaW50ZWdyaXR5IG1ldGFkYXRhLCB3aGljaCBpcyBhXG4gIC8vIGNyeXB0b2dyYXBoaWMgaGFzaCBvZiB0aGUgcmVzb3VyY2UgYmVpbmcgZmV0Y2hlZC4gSXRzIHZhbHVlXG4gIC8vIGNvbnNpc3RzIG9mIG11bHRpcGxlIGhhc2hlcyBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZS4gW1NSSV1cbiAgZ2V0IGludGVncml0eSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpbnRlZ3JpdHkgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgaW50ZWdyaXR5XG4gICAgLy8gbWV0YWRhdGEuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5pbnRlZ3JpdHlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBjYW4gb3V0bGl2ZSB0aGVcbiAgLy8gZ2xvYmFsIGluIHdoaWNoIGl0IHdhcyBjcmVhdGVkLlxuICBnZXQga2VlcGFsaXZlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGtlZXBhbGl2ZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5rZWVwYWxpdmVcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBpcyBmb3IgYSByZWxvYWRcbiAgLy8gbmF2aWdhdGlvbi5cbiAgZ2V0IGlzUmVsb2FkTmF2aWdhdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpc1JlbG9hZE5hdmlnYXRpb24gZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZc1xuICAgIC8vIHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcgaXMgc2V0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWxvYWROYXZpZ2F0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgaGlzdG9yeVxuICAvLyBuYXZpZ2F0aW9uIChhLmsuYS4gYmFjay1mb3dhcmQgbmF2aWdhdGlvbikuXG4gIGdldCBpc0hpc3RvcnlOYXZpZ2F0aW9uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGlzSGlzdG9yeU5hdmlnYXRpb24gZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyByZXF1ZXN04oCZc1xuICAgIC8vIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnIGlzIHNldDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uaGlzdG9yeU5hdmlnYXRpb25cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHNpZ25hbCBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCwgd2hpY2ggaXMgYW4gQWJvcnRTaWduYWxcbiAgLy8gb2JqZWN0IGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBhbmQgaXRzXG4gIC8vIGFib3J0IGV2ZW50IGhhbmRsZXIuXG4gIGdldCBzaWduYWwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgc2lnbmFsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHNpZ25hbC5cbiAgICByZXR1cm4gdGhpc1trU2lnbmFsXVxuICB9XG5cbiAgZ2V0IGJvZHkgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJvZHkgPyB0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0gOiBudWxsXG4gIH1cblxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gISF0aGlzW2tTdGF0ZV0uYm9keSAmJiB1dGlsLmlzRGlzdHVyYmVkKHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSlcbiAgfVxuXG4gIGdldCBkdXBsZXggKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gJ2hhbGYnXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgY2xvbmUgb2YgcmVxdWVzdC5cbiAgY2xvbmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyAxLiBJZiB0aGlzIGlzIHVudXNhYmxlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh0aGlzLmJvZHlVc2VkIHx8IHRoaXMuYm9keT8ubG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnVzYWJsZScpXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGNsb25lZFJlcXVlc3QgYmUgdGhlIHJlc3VsdCBvZiBjbG9uaW5nIHRoaXPigJlzIHJlcXVlc3QuXG4gICAgY29uc3QgY2xvbmVkUmVxdWVzdCA9IGNsb25lUmVxdWVzdCh0aGlzW2tTdGF0ZV0pXG5cbiAgICAvLyAzLiBMZXQgY2xvbmVkUmVxdWVzdE9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVxdWVzdCBvYmplY3QsXG4gICAgLy8gZ2l2ZW4gY2xvbmVkUmVxdWVzdCwgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCBjbG9uZWRSZXF1ZXN0T2JqZWN0ID0gbmV3IFJlcXVlc3Qoa0luaXQpXG4gICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrU3RhdGVdID0gY2xvbmVkUmVxdWVzdFxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba1JlYWxtXSA9IHRoaXNba1JlYWxtXVxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoKVxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSBjbG9uZWRSZXF1ZXN0LmhlYWRlcnNMaXN0XG4gICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9IHRoaXNba0hlYWRlcnNdW2tHdWFyZF1cbiAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trSGVhZGVyc11ba1JlYWxtXVxuXG4gICAgLy8gNC4gTWFrZSBjbG9uZWRSZXF1ZXN0T2JqZWN04oCZcyBzaWduYWwgZm9sbG93IHRoaXPigJlzIHNpZ25hbC5cbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBhYy5hYm9ydCh0aGlzLnNpZ25hbC5yZWFzb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuYWRkQWJvcnRMaXN0ZW5lcihcbiAgICAgICAgdGhpcy5zaWduYWwsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBhYy5hYm9ydCh0aGlzLnNpZ25hbC5yZWFzb24pXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrU2lnbmFsXSA9IGFjLnNpZ25hbFxuXG4gICAgLy8gNC4gUmV0dXJuIGNsb25lZFJlcXVlc3RPYmplY3QuXG4gICAgcmV0dXJuIGNsb25lZFJlcXVlc3RPYmplY3RcbiAgfVxufVxuXG5taXhpbkJvZHkoUmVxdWVzdClcblxuZnVuY3Rpb24gbWFrZVJlcXVlc3QgKGluaXQpIHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RzXG4gIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBsb2NhbFVSTHNPbmx5OiBmYWxzZSxcbiAgICB1bnNhZmVSZXF1ZXN0OiBmYWxzZSxcbiAgICBib2R5OiBudWxsLFxuICAgIGNsaWVudDogbnVsbCxcbiAgICByZXNlcnZlZENsaWVudDogbnVsbCxcbiAgICByZXBsYWNlc0NsaWVudElkOiAnJyxcbiAgICB3aW5kb3c6ICdjbGllbnQnLFxuICAgIGtlZXBhbGl2ZTogZmFsc2UsXG4gICAgc2VydmljZVdvcmtlcnM6ICdhbGwnLFxuICAgIGluaXRpYXRvcjogJycsXG4gICAgZGVzdGluYXRpb246ICcnLFxuICAgIHByaW9yaXR5OiBudWxsLFxuICAgIG9yaWdpbjogJ2NsaWVudCcsXG4gICAgcG9saWN5Q29udGFpbmVyOiAnY2xpZW50JyxcbiAgICByZWZlcnJlcjogJ2NsaWVudCcsXG4gICAgcmVmZXJyZXJQb2xpY3k6ICcnLFxuICAgIG1vZGU6ICduby1jb3JzJyxcbiAgICB1c2VDT1JTUHJlZmxpZ2h0RmxhZzogZmFsc2UsXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgdXNlQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIGNhY2hlOiAnZGVmYXVsdCcsXG4gICAgcmVkaXJlY3Q6ICdmb2xsb3cnLFxuICAgIGludGVncml0eTogJycsXG4gICAgY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhOiAnJyxcbiAgICBwYXJzZXJNZXRhZGF0YTogJycsXG4gICAgcmVsb2FkTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgaGlzdG9yeU5hdmlnYXRpb246IGZhbHNlLFxuICAgIHVzZXJBY3RpdmF0aW9uOiBmYWxzZSxcbiAgICB0YWludGVkT3JpZ2luOiBmYWxzZSxcbiAgICByZWRpcmVjdENvdW50OiAwLFxuICAgIHJlc3BvbnNlVGFpbnRpbmc6ICdiYXNpYycsXG4gICAgcHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb246IGZhbHNlLFxuICAgIGRvbmU6IGZhbHNlLFxuICAgIHRpbWluZ0FsbG93RmFpbGVkOiBmYWxzZSxcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNMaXN0OiBpbml0LmhlYWRlcnNMaXN0XG4gICAgICA/IG5ldyBIZWFkZXJzTGlzdChpbml0LmhlYWRlcnNMaXN0KVxuICAgICAgOiBuZXcgSGVhZGVyc0xpc3QoKVxuICB9XG4gIHJlcXVlc3QudXJsID0gcmVxdWVzdC51cmxMaXN0WzBdXG4gIHJldHVybiByZXF1ZXN0XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlcXVlc3QtY2xvbmVcbmZ1bmN0aW9uIGNsb25lUmVxdWVzdCAocmVxdWVzdCkge1xuICAvLyBUbyBjbG9uZSBhIHJlcXVlc3QgcmVxdWVzdCwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIDEuIExldCBuZXdSZXF1ZXN0IGJlIGEgY29weSBvZiByZXF1ZXN0LCBleGNlcHQgZm9yIGl0cyBib2R5LlxuICBjb25zdCBuZXdSZXF1ZXN0ID0gbWFrZVJlcXVlc3QoeyAuLi5yZXF1ZXN0LCBib2R5OiBudWxsIH0pXG5cbiAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgc2V0IG5ld1JlcXVlc3TigJlzIGJvZHkgdG8gdGhlXG4gIC8vIHJlc3VsdCBvZiBjbG9uaW5nIHJlcXVlc3TigJlzIGJvZHkuXG4gIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIG5ld1JlcXVlc3QuYm9keSA9IGNsb25lQm9keShyZXF1ZXN0LmJvZHkpXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gbmV3UmVxdWVzdC5cbiAgcmV0dXJuIG5ld1JlcXVlc3Rcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdC5wcm90b3R5cGUsIHtcbiAgbWV0aG9kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhlYWRlcnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2lnbmFsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkdXBsZXg6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlc3RpbmF0aW9uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5VXNlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaXNIaXN0b3J5TmF2aWdhdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaXNSZWxvYWROYXZpZ2F0aW9uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZWVwYWxpdmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGludGVncml0eToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2FjaGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNyZWRlbnRpYWxzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhdHRyaWJ1dGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZmVycmVyUG9saWN5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWZlcnJlcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbW9kZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ1JlcXVlc3QnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0ID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgUmVxdWVzdFxuKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGluZm9cbndlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbiAgfVxuXG4gIGlmIChWIGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0KFYpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgQWJvcnRTaWduYWxcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3Rpbml0XG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ21ldGhvZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdib2R5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcihcbiAgICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0XG4gICAgKVxuICB9LFxuICB7XG4gICAga2V5OiAncmVmZXJyZXInLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWZlcnJlclBvbGljeScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3JlZmVycmVyLXBvbGljeVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlZmVycmVyUG9saWN5XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdtb2RlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXF1ZXN0LW1vZGVcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0TW9kZVxuICB9LFxuICB7XG4gICAga2V5OiAnY3JlZGVudGlhbHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0Y3JlZGVudGlhbHNcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSxcbiAge1xuICAgIGtleTogJ2NhY2hlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGNhY2hlXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdENhY2hlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWRpcmVjdCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RyZWRpcmVjdFxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RSZWRpcmVjdFxuICB9LFxuICB7XG4gICAga2V5OiAnaW50ZWdyaXR5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAna2VlcGFsaXZlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW5cbiAgfSxcbiAge1xuICAgIGtleTogJ3NpZ25hbCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICAoc2lnbmFsKSA9PiB3ZWJpZGwuY29udmVydGVycy5BYm9ydFNpZ25hbChcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICB7IHN0cmljdDogZmFsc2UgfVxuICAgICAgKVxuICAgIClcbiAgfSxcbiAge1xuICAgIGtleTogJ3dpbmRvdycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgfSxcbiAge1xuICAgIGtleTogJ2R1cGxleCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdER1cGxleFxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgUmVxdWVzdCwgbWFrZVJlcXVlc3QgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/response.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/fetch/response.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Headers, HeadersList, fill } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/fetch/headers.js\")\nconst { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/fetch/body.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { kEnumerableProperty } = util\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  DOMException\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/fetch/constants.js\")\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/fetch/formdata.js\")\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(ssr)/./node_modules/undici/lib/fetch/global.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { types } = __webpack_require__(/*! util */ \"util\")\n\nconst ReadableStream = globalThis.ReadableStream || (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // TODO\n    const relevantRealm = { settingsObject: {} }\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and thiss\n    // relevant Realm.\n    const responseObject = new Response()\n    responseObject[kState] = makeNetworkError()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.json' })\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = new TextEncoder('utf-8').encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and thiss relevant Realm.\n    const relevantRealm = { settingsObject: {} }\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'response'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    const relevantRealm = { settingsObject: {} }\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.redirect' })\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // objects API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, getGlobalOrigin())\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code ' + status)\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and thiss relevant Realm.\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Set responseObjects responses status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL))\n\n    // 7. Append `Location`/value to responseObjects responses header list.\n    responseObject[kState].headersList.append('location', value)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = {}) {\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body)\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. Set thiss response to a new response.\n    this[kState] = makeResponse({})\n\n    // 2. Set thiss headers to a new Headers object with thiss relevant\n    // Realm, whose header list is thiss responses header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'response'\n    this[kHeaders][kHeadersList] = this[kState].headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  // Returns responses type, e.g., \"cors\".\n  get type () {\n    webidl.brandCheck(this, Response)\n\n    // The type getter steps are to return thiss responses type.\n    return this[kState].type\n  }\n\n  // Returns responses URL, if it has one; otherwise the empty string.\n  get url () {\n    webidl.brandCheck(this, Response)\n\n    const urlList = this[kState].urlList\n\n    // The url getter steps are to return the empty string if thiss\n    // responses URL is null; otherwise thiss responses URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null\n\n    if (url === null) {\n      return ''\n    }\n\n    return URLSerializer(url, true)\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    webidl.brandCheck(this, Response)\n\n    // The redirected getter steps are to return true if thiss responses URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns responses status.\n  get status () {\n    webidl.brandCheck(this, Response)\n\n    // The status getter steps are to return thiss responses status.\n    return this[kState].status\n  }\n\n  // Returns whether responses status is an ok status.\n  get ok () {\n    webidl.brandCheck(this, Response)\n\n    // The ok getter steps are to return true if thiss responses status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns responses status message.\n  get statusText () {\n    webidl.brandCheck(this, Response)\n\n    // The statusText getter steps are to return thiss responses status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns responses headers as Headers.\n  get headers () {\n    webidl.brandCheck(this, Response)\n\n    // The headers getter steps are to return thiss headers.\n    return this[kHeaders]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Response)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Response)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  // Returns a clone of response.\n  clone () {\n    webidl.brandCheck(this, Response)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning thiss response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, thiss headerss guard, and thiss relevant Realm.\n    const clonedResponseObject = new Response()\n    clonedResponseObject[kState] = clonedResponse\n    clonedResponseObject[kRealm] = this[kRealm]\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    return clonedResponseObject\n  }\n}\n\nmixinBody(Response)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n})\n\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of responses\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If responses body is non-null, then set newResponses body to the\n  // result of cloning responses body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on requests response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal responses header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal responses header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal responses CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams, err = null) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))\n    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set responses responses status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status\n  }\n\n  // 4. Set responses responses status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill responses headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kHeaders], init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: 'Invalid response status code ' + response.status\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.contains('Content-Type')) {\n      response[kState].headersList.append('content-type', body.type)\n    }\n  }\n}\n\nwebidl.converters.ReadableStream = webidl.interfaceConverter(\n  ReadableStream\n)\n\nwebidl.converters.FormData = webidl.interfaceConverter(\n  FormData\n)\n\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(\n  URLSearchParams\n)\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, { strict: false })\n  }\n\n  if (\n    types.isAnyArrayBuffer(V) ||\n    types.isTypedArray(V) ||\n    types.isDataView(V)\n  ) {\n    return webidl.converters.BufferSource(V)\n  }\n\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, { strict: false })\n  }\n\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V)\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLDZCQUE2QixFQUFFLG1CQUFPLENBQUMsbUVBQVc7QUFDMUQsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLDZEQUFRO0FBQzlELGFBQWEsbUJBQU8sQ0FBQyxrRUFBYztBQUNuQyxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNkRBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx1RUFBYTtBQUN6QixRQUFRLG1DQUFtQyxFQUFFLG1CQUFPLENBQUMsbUVBQVc7QUFDaEUsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxpRUFBVTtBQUNyQyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHFFQUFZO0FBQ3pDLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyxpRUFBVTtBQUM5QyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsbUVBQVc7QUFDN0MsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDbEQsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsUUFBUSxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRWhDLG9EQUFvRCxvRUFBb0M7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsK0NBQStDLHlCQUF5Qjs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3Jlc3BvbnNlLmpzPzBmODkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSGVhZGVycywgSGVhZGVyc0xpc3QsIGZpbGwgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBjbG9uZUJvZHksIG1peGluQm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSB1dGlsXG5jb25zdCB7XG4gIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gIGlzQ2FuY2VsbGVkLFxuICBpc0Fib3J0ZWQsXG4gIGlzQmxvYkxpa2UsXG4gIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyxcbiAgaXNFcnJvckxpa2UsXG4gIGlzb21vcnBoaWNFbmNvZGVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICByZWRpcmVjdFN0YXR1cyxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIERPTUV4Y2VwdGlvblxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga1N0YXRlLCBrSGVhZGVycywga0d1YXJkLCBrUmVhbG0gfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBGb3JtRGF0YSB9ID0gcmVxdWlyZSgnLi9mb3JtZGF0YScpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGFVUkwnKVxuY29uc3QgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgndXRpbCcpXG5cbmNvbnN0IFJlYWRhYmxlU3RyZWFtID0gZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSB8fCByZXF1aXJlKCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Jlc3BvbnNlLWNsYXNzXG5jbGFzcyBSZXNwb25zZSB7XG4gIC8vIENyZWF0ZXMgbmV0d29yayBlcnJvciBSZXNwb25zZS5cbiAgc3RhdGljIGVycm9yICgpIHtcbiAgICAvLyBUT0RPXG4gICAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH1cblxuICAgIC8vIFRoZSBzdGF0aWMgZXJyb3IoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFcbiAgICAvLyBSZXNwb25zZSBvYmplY3QsIGdpdmVuIGEgbmV3IG5ldHdvcmsgZXJyb3IsIFwiaW1tdXRhYmxlXCIsIGFuZCB0aGlz4oCZc1xuICAgIC8vIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKClcbiAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdID0gbWFrZU5ldHdvcmtFcnJvcigpXG4gICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uaGVhZGVyc0xpc3RcbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9ICdpbW11dGFibGUnXG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tSZWFsbV0gPSByZWxldmFudFJlYWxtXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlc3BvbnNlLWpzb25cbiAgc3RhdGljIGpzb24gKGRhdGEsIGluaXQgPSB7fSkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdSZXNwb25zZS5qc29uJyB9KVxuXG4gICAgaWYgKGluaXQgIT09IG51bGwpIHtcbiAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgYnl0ZXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNlcmlhbGl6ZSBhIEphdmFTY3JpcHQgdmFsdWUgdG8gSlNPTiBieXRlcyBvbiBkYXRhLlxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpLmVuY29kZShcbiAgICAgIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyhkYXRhKVxuICAgIClcblxuICAgIC8vIDIuIExldCBib2R5IGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBieXRlcy5cbiAgICBjb25zdCBib2R5ID0gZXh0cmFjdEJvZHkoYnl0ZXMpXG5cbiAgICAvLyAzLiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW4gYSBuZXcgcmVzcG9uc2UsXG4gICAgLy8gICAgXCJyZXNwb25zZVwiLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH1cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpXG4gICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9ICdyZXNwb25zZSdcbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cblxuICAgIC8vIDQuIFBlcmZvcm0gaW5pdGlhbGl6ZSBhIHJlc3BvbnNlIGdpdmVuIHJlc3BvbnNlT2JqZWN0LCBpbml0LCBhbmQgKGJvZHksIFwiYXBwbGljYXRpb24vanNvblwiKS5cbiAgICBpbml0aWFsaXplUmVzcG9uc2UocmVzcG9uc2VPYmplY3QsIGluaXQsIHsgYm9keTogYm9keVswXSwgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pXG5cbiAgICAvLyA1LiBSZXR1cm4gcmVzcG9uc2VPYmplY3QuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgcmVkaXJlY3QgUmVzcG9uc2UgdGhhdCByZWRpcmVjdHMgdG8gdXJsIHdpdGggc3RhdHVzIHN0YXR1cy5cbiAgc3RhdGljIHJlZGlyZWN0ICh1cmwsIHN0YXR1cyA9IDMwMikge1xuICAgIGNvbnN0IHJlbGV2YW50UmVhbG0gPSB7IHNldHRpbmdzT2JqZWN0OiB7fSB9XG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnUmVzcG9uc2UucmVkaXJlY3QnIH0pXG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsKVxuICAgIHN0YXR1cyA9IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddKHN0YXR1cylcblxuICAgIC8vIDEuIExldCBwYXJzZWRVUkwgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHVybCB3aXRoIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAvLyBvYmplY3TigJlzIEFQSSBiYXNlIFVSTC5cbiAgICAvLyAyLiBJZiBwYXJzZWRVUkwgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyBUT0RPOiBiYXNlLVVSTD9cbiAgICBsZXQgcGFyc2VkVVJMXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwodXJsLCBnZXRHbG9iYWxPcmlnaW4oKSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIHBhcnNlIFVSTCBmcm9tICcgKyB1cmwpLCB7XG4gICAgICAgIGNhdXNlOiBlcnJcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgc3RhdHVzIGlzIG5vdCBhIHJlZGlyZWN0IHN0YXR1cywgdGhlbiB0aHJvdyBhIFJhbmdlRXJyb3IuXG4gICAgaWYgKCFyZWRpcmVjdFN0YXR1cy5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZSAnICsgc3RhdHVzKVxuICAgIH1cblxuICAgIC8vIDQuIExldCByZXNwb25zZU9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LFxuICAgIC8vIGdpdmVuIGEgbmV3IHJlc3BvbnNlLCBcImltbXV0YWJsZVwiLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UoKVxuICAgIHJlc3BvbnNlT2JqZWN0W2tSZWFsbV0gPSByZWxldmFudFJlYWxtXG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSAnaW1tdXRhYmxlJ1xuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuXG4gICAgLy8gNS4gU2V0IHJlc3BvbnNlT2JqZWN04oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIHRvIHN0YXR1cy5cbiAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdLnN0YXR1cyA9IHN0YXR1c1xuXG4gICAgLy8gNi4gTGV0IHZhbHVlIGJlIHBhcnNlZFVSTCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICAgIGNvbnN0IHZhbHVlID0gaXNvbW9ycGhpY0VuY29kZShVUkxTZXJpYWxpemVyKHBhcnNlZFVSTCkpXG5cbiAgICAvLyA3LiBBcHBlbmQgYExvY2F0aW9uYC92YWx1ZSB0byByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uaGVhZGVyc0xpc3QuYXBwZW5kKCdsb2NhdGlvbicsIHZhbHVlKVxuXG4gICAgLy8gOC4gUmV0dXJuIHJlc3BvbnNlT2JqZWN0LlxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXNwb25zZVxuICBjb25zdHJ1Y3RvciAoYm9keSA9IG51bGwsIGluaXQgPSB7fSkge1xuICAgIGlmIChib2R5ICE9PSBudWxsKSB7XG4gICAgICBib2R5ID0gd2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQoYm9keSlcbiAgICB9XG5cbiAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0KGluaXQpXG5cbiAgICAvLyBUT0RPXG4gICAgdGhpc1trUmVhbG1dID0geyBzZXR0aW5nc09iamVjdDoge30gfVxuXG4gICAgLy8gMS4gU2V0IHRoaXPigJlzIHJlc3BvbnNlIHRvIGEgbmV3IHJlc3BvbnNlLlxuICAgIHRoaXNba1N0YXRlXSA9IG1ha2VSZXNwb25zZSh7fSlcblxuICAgIC8vIDIuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgdGhpc+KAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IGFuZCBndWFyZFxuICAgIC8vIGlzIFwicmVzcG9uc2VcIi5cbiAgICB0aGlzW2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKClcbiAgICB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdID0gJ3Jlc3BvbnNlJ1xuICAgIHRoaXNba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSB0aGlzW2tTdGF0ZV0uaGVhZGVyc0xpc3RcbiAgICB0aGlzW2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trUmVhbG1dXG5cbiAgICAvLyAzLiBMZXQgYm9keVdpdGhUeXBlIGJlIG51bGwuXG4gICAgbGV0IGJvZHlXaXRoVHlwZSA9IG51bGxcblxuICAgIC8vIDQuIElmIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IGJvZHlXaXRoVHlwZSB0byB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYm9keS5cbiAgICBpZiAoYm9keSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBbZXh0cmFjdGVkQm9keSwgdHlwZV0gPSBleHRyYWN0Qm9keShib2R5KVxuICAgICAgYm9keVdpdGhUeXBlID0geyBib2R5OiBleHRyYWN0ZWRCb2R5LCB0eXBlIH1cbiAgICB9XG5cbiAgICAvLyA1LiBQZXJmb3JtIGluaXRpYWxpemUgYSByZXNwb25zZSBnaXZlbiB0aGlzLCBpbml0LCBhbmQgYm9keVdpdGhUeXBlLlxuICAgIGluaXRpYWxpemVSZXNwb25zZSh0aGlzLCBpbml0LCBib2R5V2l0aFR5cGUpXG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyB0eXBlLCBlLmcuLCBcImNvcnNcIi5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHR5cGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVzcG9uc2XigJlzIHR5cGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS50eXBlXG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBVUkwsIGlmIGl0IGhhcyBvbmU7IG90aGVyd2lzZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBnZXQgdXJsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIGNvbnN0IHVybExpc3QgPSB0aGlzW2tTdGF0ZV0udXJsTGlzdFxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nIGlmIHRoaXPigJlzXG4gICAgLy8gcmVzcG9uc2XigJlzIFVSTCBpcyBudWxsOyBvdGhlcndpc2UgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTCxcbiAgICAvLyBzZXJpYWxpemVkIHdpdGggZXhjbHVkZSBmcmFnbWVudCBzZXQgdG8gdHJ1ZS5cbiAgICBjb25zdCB1cmwgPSB1cmxMaXN0W3VybExpc3QubGVuZ3RoIC0gMV0gPz8gbnVsbFxuXG4gICAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIFVSTFNlcmlhbGl6ZXIodXJsLCB0cnVlKVxuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIHJlc3BvbnNlIHdhcyBvYnRhaW5lZCB0aHJvdWdoIGEgcmVkaXJlY3QuXG4gIGdldCByZWRpcmVjdGVkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSByZWRpcmVjdGVkIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTFxuICAgIC8vIGxpc3QgaGFzIG1vcmUgdGhhbiBvbmUgaXRlbTsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udXJsTGlzdC5sZW5ndGggPiAxXG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBzdGF0dXMuXG4gIGdldCBzdGF0dXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHN0YXR1cyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uc3RhdHVzXG4gIH1cblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhbiBvayBzdGF0dXMuXG4gIGdldCBvayAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgb2sgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIGlzIGFuXG4gICAgLy8gb2sgc3RhdHVzOyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXMgPj0gMjAwICYmIHRoaXNba1N0YXRlXS5zdGF0dXMgPD0gMjk5XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZS5cbiAgZ2V0IHN0YXR1c1RleHQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHN0YXR1c1RleHQgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVzcG9uc2XigJlzIHN0YXR1c1xuICAgIC8vIG1lc3NhZ2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXNUZXh0XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBoZWFkZXJzIGFzIEhlYWRlcnMuXG4gIGdldCBoZWFkZXJzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBoZWFkZXJzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIGhlYWRlcnMuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNdXG4gIH1cblxuICBnZXQgYm9keSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJvZHkgPyB0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0gOiBudWxsXG4gIH1cblxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgcmV0dXJuICEhdGhpc1trU3RhdGVdLmJvZHkgJiYgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0pXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgY2xvbmUgb2YgcmVzcG9uc2UuXG4gIGNsb25lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIDEuIElmIHRoaXMgaXMgdW51c2FibGUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHRoaXMuYm9keVVzZWQgfHwgKHRoaXMuYm9keSAmJiB0aGlzLmJvZHkubG9ja2VkKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdSZXNwb25zZS5jbG9uZScsXG4gICAgICAgIG1lc3NhZ2U6ICdCb2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgY2xvbmVkUmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBjbG9uaW5nIHRoaXPigJlzIHJlc3BvbnNlLlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZSh0aGlzW2tTdGF0ZV0pXG5cbiAgICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW5cbiAgICAvLyBjbG9uZWRSZXNwb25zZSwgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpXG4gICAgY2xvbmVkUmVzcG9uc2VPYmplY3Rba1N0YXRlXSA9IGNsb25lZFJlc3BvbnNlXG4gICAgY2xvbmVkUmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHRoaXNba1JlYWxtXVxuICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gY2xvbmVkUmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9IHRoaXNba0hlYWRlcnNdW2tHdWFyZF1cbiAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHRoaXNba0hlYWRlcnNdW2tSZWFsbV1cblxuICAgIHJldHVybiBjbG9uZWRSZXNwb25zZU9iamVjdFxuICB9XG59XG5cbm1peGluQm9keShSZXNwb25zZSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG4gIHR5cGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc3RhdHVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvazoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVkaXJlY3RlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc3RhdHVzVGV4dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGVhZGVyczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvbmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHlVc2VkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnUmVzcG9uc2UnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZSwge1xuICBqc29uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlc3BvbnNlLWNsb25lXG5mdW5jdGlvbiBjbG9uZVJlc3BvbnNlIChyZXNwb25zZSkge1xuICAvLyBUbyBjbG9uZSBhIHJlc3BvbnNlIHJlc3BvbnNlLCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSwgdGhlbiByZXR1cm4gYSBuZXcgaWRlbnRpY2FsXG4gIC8vIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIGludGVybmFsIHJlc3BvbnNlIGlzIGEgY2xvbmUgb2YgcmVzcG9uc2XigJlzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLlxuICBpZiAocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSkge1xuICAgIHJldHVybiBmaWx0ZXJSZXNwb25zZShcbiAgICAgIGNsb25lUmVzcG9uc2UocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSksXG4gICAgICByZXNwb25zZS50eXBlXG4gICAgKVxuICB9XG5cbiAgLy8gMi4gTGV0IG5ld1Jlc3BvbnNlIGJlIGEgY29weSBvZiByZXNwb25zZSwgZXhjZXB0IGZvciBpdHMgYm9keS5cbiAgY29uc3QgbmV3UmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyAuLi5yZXNwb25zZSwgYm9keTogbnVsbCB9KVxuXG4gIC8vIDMuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHNldCBuZXdSZXNwb25zZeKAmXMgYm9keSB0byB0aGVcbiAgLy8gcmVzdWx0IG9mIGNsb25pbmcgcmVzcG9uc2XigJlzIGJvZHkuXG4gIGlmIChyZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICBuZXdSZXNwb25zZS5ib2R5ID0gY2xvbmVCb2R5KHJlc3BvbnNlLmJvZHkpXG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbmV3UmVzcG9uc2UuXG4gIHJldHVybiBuZXdSZXNwb25zZVxufVxuXG5mdW5jdGlvbiBtYWtlUmVzcG9uc2UgKGluaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICByYW5nZVJlcXVlc3RlZDogZmFsc2UsXG4gICAgdGltaW5nQWxsb3dQYXNzZWQ6IGZhbHNlLFxuICAgIHJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgc3RhdHVzOiAyMDAsXG4gICAgdGltaW5nSW5mbzogbnVsbCxcbiAgICBjYWNoZVN0YXRlOiAnJyxcbiAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNMaXN0OiBpbml0LmhlYWRlcnNMaXN0XG4gICAgICA/IG5ldyBIZWFkZXJzTGlzdChpbml0LmhlYWRlcnNMaXN0KVxuICAgICAgOiBuZXcgSGVhZGVyc0xpc3QoKSxcbiAgICB1cmxMaXN0OiBpbml0LnVybExpc3QgPyBbLi4uaW5pdC51cmxMaXN0XSA6IFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZU5ldHdvcmtFcnJvciAocmVhc29uKSB7XG4gIGNvbnN0IGlzRXJyb3IgPSBpc0Vycm9yTGlrZShyZWFzb24pXG4gIHJldHVybiBtYWtlUmVzcG9uc2Uoe1xuICAgIHR5cGU6ICdlcnJvcicsXG4gICAgc3RhdHVzOiAwLFxuICAgIGVycm9yOiBpc0Vycm9yXG4gICAgICA/IHJlYXNvblxuICAgICAgOiBuZXcgRXJyb3IocmVhc29uID8gU3RyaW5nKHJlYXNvbikgOiByZWFzb24pLFxuICAgIGFib3J0ZWQ6IHJlYXNvbiAmJiByZWFzb24ubmFtZSA9PT0gJ0Fib3J0RXJyb3InXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1ha2VGaWx0ZXJlZFJlc3BvbnNlIChyZXNwb25zZSwgc3RhdGUpIHtcbiAgc3RhdGUgPSB7XG4gICAgaW50ZXJuYWxSZXNwb25zZTogcmVzcG9uc2UsXG4gICAgLi4uc3RhdGVcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJveHkocmVzcG9uc2UsIHtcbiAgICBnZXQgKHRhcmdldCwgcCkge1xuICAgICAgcmV0dXJuIHAgaW4gc3RhdGUgPyBzdGF0ZVtwXSA6IHRhcmdldFtwXVxuICAgIH0sXG4gICAgc2V0ICh0YXJnZXQsIHAsIHZhbHVlKSB7XG4gICAgICBhc3NlcnQoIShwIGluIHN0YXRlKSlcbiAgICAgIHRhcmdldFtwXSA9IHZhbHVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZmlsdGVyZWQtcmVzcG9uc2VcbmZ1bmN0aW9uIGZpbHRlclJlc3BvbnNlIChyZXNwb25zZSwgdHlwZSkge1xuICAvLyBTZXQgcmVzcG9uc2UgdG8gdGhlIGZvbGxvd2luZyBmaWx0ZXJlZCByZXNwb25zZSB3aXRoIHJlc3BvbnNlIGFzIGl0c1xuICAvLyBpbnRlcm5hbCByZXNwb25zZSwgZGVwZW5kaW5nIG9uIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nOlxuICBpZiAodHlwZSA9PT0gJ2Jhc2ljJykge1xuICAgIC8vIEEgYmFzaWMgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlIGlzIFwiYmFzaWNcIlxuICAgIC8vIGFuZCBoZWFkZXIgbGlzdCBleGNsdWRlcyBhbnkgaGVhZGVycyBpbiBpbnRlcm5hbCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3RcbiAgICAvLyB3aG9zZSBuYW1lIGlzIGEgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLlxuXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWVzXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnYmFzaWMnLFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnY29ycycpIHtcbiAgICAvLyBBIENPUlMgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlIGlzIFwiY29yc1wiXG4gICAgLy8gYW5kIGhlYWRlciBsaXN0IGV4Y2x1ZGVzIGFueSBoZWFkZXJzIGluIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXJcbiAgICAvLyBsaXN0IHdob3NlIG5hbWUgaXMgbm90IGEgQ09SUy1zYWZlbGlzdGVkIHJlc3BvbnNlLWhlYWRlciBuYW1lLCBnaXZlblxuICAgIC8vIGludGVybmFsIHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdC5cblxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgQ09SUy1zYWZlbGlzdGVkIHJlc3BvbnNlLWhlYWRlciBuYW1lc1xuICAgIHJldHVybiBtYWtlRmlsdGVyZWRSZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgdHlwZTogJ2NvcnMnLFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BhcXVlJykge1xuICAgIC8vIEFuIG9wYXF1ZSBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXNcbiAgICAvLyBcIm9wYXF1ZVwiLCBVUkwgbGlzdCBpcyB0aGUgZW1wdHkgbGlzdCwgc3RhdHVzIGlzIDAsIHN0YXR1cyBtZXNzYWdlXG4gICAgLy8gaXMgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UsIGhlYWRlciBsaXN0IGlzIGVtcHR5LCBhbmQgYm9keSBpcyBudWxsLlxuXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnb3BhcXVlJyxcbiAgICAgIHVybExpc3Q6IE9iamVjdC5mcmVlemUoW10pLFxuICAgICAgc3RhdHVzOiAwLFxuICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICBib2R5OiBudWxsXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BhcXVlcmVkaXJlY3QnKSB7XG4gICAgLy8gQW4gb3BhcXVlLXJlZGlyZWN0IGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZVxuICAgIC8vIGlzIFwib3BhcXVlcmVkaXJlY3RcIiwgc3RhdHVzIGlzIDAsIHN0YXR1cyBtZXNzYWdlIGlzIHRoZSBlbXB0eSBieXRlXG4gICAgLy8gc2VxdWVuY2UsIGhlYWRlciBsaXN0IGlzIGVtcHR5LCBhbmQgYm9keSBpcyBudWxsLlxuXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnb3BhcXVlcmVkaXJlY3QnLFxuICAgICAgc3RhdHVzOiAwLFxuICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICBoZWFkZXJzTGlzdDogW10sXG4gICAgICBib2R5OiBudWxsXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2FwcHJvcHJpYXRlLW5ldHdvcmstZXJyb3JcbmZ1bmN0aW9uIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvciAoZmV0Y2hQYXJhbXMsIGVyciA9IG51bGwpIHtcbiAgLy8gMS4gQXNzZXJ0OiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZC5cbiAgYXNzZXJ0KGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSlcblxuICAvLyAyLiBSZXR1cm4gYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yIGlmIGZldGNoUGFyYW1zIGlzIGFib3J0ZWQ7XG4gIC8vIG90aGVyd2lzZSByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICByZXR1cm4gaXNBYm9ydGVkKGZldGNoUGFyYW1zKVxuICAgID8gbWFrZU5ldHdvcmtFcnJvcihPYmplY3QuYXNzaWduKG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSwgeyBjYXVzZTogZXJyIH0pKVxuICAgIDogbWFrZU5ldHdvcmtFcnJvcihPYmplY3QuYXNzaWduKG5ldyBET01FeGNlcHRpb24oJ1JlcXVlc3Qgd2FzIGNhbmNlbGxlZC4nKSwgeyBjYXVzZTogZXJyIH0pKVxufVxuXG4vLyBodHRwczovL3doYXRwci5vcmcvZmV0Y2gvMTM5Mi5odG1sI2luaXRpYWxpemUtYS1yZXNwb25zZVxuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlc3BvbnNlIChyZXNwb25zZSwgaW5pdCwgYm9keSkge1xuICAvLyAxLiBJZiBpbml0W1wic3RhdHVzXCJdIGlzIG5vdCBpbiB0aGUgcmFuZ2UgMjAwIHRvIDU5OSwgaW5jbHVzaXZlLCB0aGVuXG4gIC8vICAgIHRocm93IGEgUmFuZ2VFcnJvci5cbiAgaWYgKGluaXQuc3RhdHVzICE9PSBudWxsICYmIChpbml0LnN0YXR1cyA8IDIwMCB8fCBpbml0LnN0YXR1cyA+IDU5OSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5pdFtcInN0YXR1c1wiXSBtdXN0IGJlIGluIHRoZSByYW5nZSBvZiAyMDAgdG8gNTk5LCBpbmNsdXNpdmUuJylcbiAgfVxuXG4gIC8vIDIuIElmIGluaXRbXCJzdGF0dXNUZXh0XCJdIGRvZXMgbm90IG1hdGNoIHRoZSByZWFzb24tcGhyYXNlIHRva2VuIHByb2R1Y3Rpb24sXG4gIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmICgnc3RhdHVzVGV4dCcgaW4gaW5pdCAmJiBpbml0LnN0YXR1c1RleHQgIT0gbnVsbCkge1xuICAgIC8vIFNlZSwgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4xLjI6XG4gICAgLy8gICByZWFzb24tcGhyYXNlICA9ICooIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVxuICAgIGlmICghaXNWYWxpZFJlYXNvblBocmFzZShTdHJpbmcoaW5pdC5zdGF0dXNUZXh0KSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzVGV4dCcpXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gU2V0IHJlc3BvbnNl4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIHRvIGluaXRbXCJzdGF0dXNcIl0uXG4gIGlmICgnc3RhdHVzJyBpbiBpbml0ICYmIGluaXQuc3RhdHVzICE9IG51bGwpIHtcbiAgICByZXNwb25zZVtrU3RhdGVdLnN0YXR1cyA9IGluaXQuc3RhdHVzXG4gIH1cblxuICAvLyA0LiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZSB0byBpbml0W1wic3RhdHVzVGV4dFwiXS5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgcmVzcG9uc2Vba1N0YXRlXS5zdGF0dXNUZXh0ID0gaW5pdC5zdGF0dXNUZXh0XG4gIH1cblxuICAvLyA1LiBJZiBpbml0W1wiaGVhZGVyc1wiXSBleGlzdHMsIHRoZW4gZmlsbCByZXNwb25zZeKAmXMgaGVhZGVycyB3aXRoIGluaXRbXCJoZWFkZXJzXCJdLlxuICBpZiAoJ2hlYWRlcnMnIGluIGluaXQgJiYgaW5pdC5oZWFkZXJzICE9IG51bGwpIHtcbiAgICBmaWxsKHJlc3BvbnNlW2tIZWFkZXJzXSwgaW5pdC5oZWFkZXJzKVxuICB9XG5cbiAgLy8gNi4gSWYgYm9keSB3YXMgZ2l2ZW4sIHRoZW46XG4gIGlmIChib2R5KSB7XG4gICAgLy8gMS4gSWYgcmVzcG9uc2UncyBzdGF0dXMgaXMgYSBudWxsIGJvZHkgc3RhdHVzLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1Jlc3BvbnNlIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1c1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBTZXQgcmVzcG9uc2UncyBib2R5IHRvIGJvZHkncyBib2R5LlxuICAgIHJlc3BvbnNlW2tTdGF0ZV0uYm9keSA9IGJvZHkuYm9keVxuXG4gICAgLy8gMy4gSWYgYm9keSdzIHR5cGUgaXMgbm9uLW51bGwgYW5kIHJlc3BvbnNlJ3MgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpblxuICAgIC8vICAgIGBDb250ZW50LVR5cGVgLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtVHlwZWAsIGJvZHkncyB0eXBlKSB0byByZXNwb25zZSdzIGhlYWRlciBsaXN0LlxuICAgIGlmIChib2R5LnR5cGUgIT0gbnVsbCAmJiAhcmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdC5jb250YWlucygnQ29udGVudC1UeXBlJykpIHtcbiAgICAgIHJlc3BvbnNlW2tTdGF0ZV0uaGVhZGVyc0xpc3QuYXBwZW5kKCdjb250ZW50LXR5cGUnLCBib2R5LnR5cGUpXG4gICAgfVxuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgUmVhZGFibGVTdHJlYW1cbilcblxud2ViaWRsLmNvbnZlcnRlcnMuRm9ybURhdGEgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBGb3JtRGF0YVxuKVxuXG53ZWJpZGwuY29udmVydGVycy5VUkxTZWFyY2hQYXJhbXMgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBVUkxTZWFyY2hQYXJhbXNcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3R5cGVkZWZkZWYteG1saHR0cHJlcXVlc3Rib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdCA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh0eXBlb2YgViA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG4gIH1cblxuICBpZiAoaXNCbG9iTGlrZShWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKFxuICAgIHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVikgfHxcbiAgICB0eXBlcy5pc1R5cGVkQXJyYXkoVikgfHxcbiAgICB0eXBlcy5pc0RhdGFWaWV3KFYpXG4gICkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UoVilcbiAgfVxuXG4gIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkZvcm1EYXRhKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKFYgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVJMU2VhcmNoUGFyYW1zKFYpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQgPSBmdW5jdGlvbiAoVikge1xuICBpZiAoViBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtKFYpXG4gIH1cblxuICAvLyBOb3RlOiB0aGUgc3BlYyBkb2Vzbid0IGluY2x1ZGUgYXN5bmMgaXRlcmFibGVzLFxuICAvLyB0aGlzIGlzIGFuIHVuZGljaSBleHRlbnNpb24uXG4gIGlmIChWPy5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5YTUxIdHRwUmVxdWVzdEJvZHlJbml0KFYpXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3N0YXR1cycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDIwMFxuICB9LFxuICB7XG4gICAga2V5OiAnc3RhdHVzVGV4dCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2hlYWRlcnMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXRcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1ha2VOZXR3b3JrRXJyb3IsXG4gIG1ha2VSZXNwb25zZSxcbiAgbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yLFxuICBmaWx0ZXJSZXNwb25zZSxcbiAgUmVzcG9uc2UsXG4gIGNsb25lUmVzcG9uc2Vcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/response.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/symbols.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/fetch/symbols.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kUrl: Symbol('url'),\n  kHeaders: Symbol('headers'),\n  kSignal: Symbol('signal'),\n  kState: Symbol('state'),\n  kGuard: Symbol('guard'),\n  kRealm: Symbol('realm')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9zeW1ib2xzLmpzPzhkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrVXJsOiBTeW1ib2woJ3VybCcpLFxuICBrSGVhZGVyczogU3ltYm9sKCdoZWFkZXJzJyksXG4gIGtTaWduYWw6IFN5bWJvbCgnc2lnbmFsJyksXG4gIGtTdGF0ZTogU3ltYm9sKCdzdGF0ZScpLFxuICBrR3VhcmQ6IFN5bWJvbCgnZ3VhcmQnKSxcbiAga1JlYWxtOiBTeW1ib2woJ3JlYWxtJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/util.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/fetch/util.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { redirectStatus, badPorts, referrerPolicy: referrerPolicyTokens } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/fetch/constants.js\")\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(ssr)/./node_modules/undici/lib/fetch/global.js\")\nconst { performance } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\")\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { isUint8Array } = __webpack_require__(/*! util/types */ \"util/types\")\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto\n\ntry {\n  crypto = __webpack_require__(/*! crypto */ \"crypto\")\n} catch {\n\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in responses URL list and null if responses URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If responses status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and responses header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with responses URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set locations\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be requests current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPorts.includes(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isTokenChar (c) {\n  return !(\n    c >= 0x7f ||\n    c <= 0x20 ||\n    c === '(' ||\n    c === ')' ||\n    c === '<' ||\n    c === '>' ||\n    c === '@' ||\n    c === ',' ||\n    c === ';' ||\n    c === ':' ||\n    c === '\\\\' ||\n    c === '\"' ||\n    c === '/' ||\n    c === '[' ||\n    c === ']' ||\n    c === '?' ||\n    c === '=' ||\n    c === '{' ||\n    c === '}'\n  )\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken (characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i)\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false\n    }\n  }\n  return true\n}\n\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName (potentialValue) {\n  if (potentialValue.length === 0) {\n    return false\n  }\n\n  return isValidHTTPToken(potentialValue)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (\n    potentialValue.startsWith('\\t') ||\n    potentialValue.startsWith(' ') ||\n    potentialValue.endsWith('\\t') ||\n    potentialValue.endsWith(' ')\n  ) {\n    return false\n  }\n\n  if (\n    potentialValue.includes('\\0') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\n')\n  ) {\n    return false\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates requests referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing  8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.\n  const { headersList } = actualResponse\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',')\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = ''\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.includes(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set requests referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: rs url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set headers value to rs mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.\n  httpRequest.headersList.set('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If requests response tainting is \"cors\" or requests mode is \"websocket\", then append (`Origin`, serializedOrigin) to requests header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('origin', serializedOrigin)\n    }\n\n  // 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on requests referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If requests origin is a tuple origin, its scheme is \"https\", and requests current URLs scheme is not \"https\", then set serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If requests origin is not same origin with requests current URLs origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to requests header list.\n      request.headersList.append('origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be requests client.\n\n  let referrerSource = null\n\n  // 3. Switch on requests referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be requests referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let requests referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  const areSameOrigin = sameOrigin(request, referrerURL)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerURL\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of requests current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and requests\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * requests current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * requests current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer (url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL)\n\n  // 2. If urls scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer'\n  }\n\n  // 3. Set urls username to the empty string.\n  url.username = ''\n\n  // 4. Set urls password to the empty string.\n  url.password = ''\n\n  // 5. Set urls fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set urls path to  the empty string .\n    url.pathname = ''\n\n    // 2. Set urls query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo))\n  // get the strongest algorithm\n  const strongest = list[0].algo\n  // get all entries that use the strongest algorithm; ignore weaker\n  const metadata = list.filter((item) => item.algo === strongest)\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    let expectedValue = item.hash\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    if (expectedValue.endsWith('==')) {\n      expectedValue = expectedValue.slice(0, -2)\n    }\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    if (actualValue.endsWith('==')) {\n      actualValue = actualValue.slice(0, -2)\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true\n    }\n\n    let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest('base64url')\n\n    if (actualBase64URL.endsWith('==')) {\n      actualBase64URL = actualBase64URL.slice(0, -2)\n    }\n\n    if (actualBase64URL === expectedValue) {\n      return true\n    }\n  }\n\n  // 6. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  const supportedHashes = crypto.getHashes()\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod (method) {\n  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method)\n    ? method.toUpperCase()\n    : method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */\nfunction makeIterator (iterator, name, kind) {\n  const object = {\n    index: 0,\n    kind,\n    target: iterator\n  }\n\n  const i = {\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n\n      // 2. Let thisValue be the this value.\n\n      // 3. Let object be ? ToObject(thisValue).\n\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be objects index.\n      // 7. Let kind be objects kind.\n      // 8. Let values be objects target's value pairs to iterate over.\n      const { index, kind, target } = object\n      const values = target()\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return { value: undefined, done: true }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const pair = values[index]\n\n      // 12. Set objects index to index + 1.\n      object.index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n      return iteratorResult(pair, kind)\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  }\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype)\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i)\n}\n\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult (pair, kind) {\n  let result\n\n  // 1. Let result be a value determined by the value of kind:\n  switch (kind) {\n    case 'key': {\n      // 1. Let idlKey be pairs key.\n      // 2. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 3. result is key.\n      result = pair[0]\n      break\n    }\n    case 'value': {\n      // 1. Let idlValue be pairs value.\n      // 2. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 3. result is value.\n      result = pair[1]\n      break\n    }\n    case 'key+value': {\n      // 1. Let idlKey be pairs key.\n      // 2. Let idlValue be pairs value.\n      // 3. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 4. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 5. Let array be ! ArrayCreate(2).\n      // 6. Call ! CreateDataProperty(array, \"0\", key).\n      // 7. Call ! CreateDataProperty(array, \"1\", value).\n      // 8. result is array.\n      result = pair\n      break\n    }\n  }\n\n  // 2. Return CreateIterResultObject(result, false).\n  return { value: result, done: false }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  // 4. Let reader be the result of getting a reader for bodys stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  try {\n    const result = await readAllBytes(reader)\n    successSteps(result)\n  } catch (e) {\n    errorSteps(e)\n  }\n}\n\n/** @type {ReadableStream} */\nlet ReadableStream = globalThis.ReadableStream\n\nfunction isReadableStreamLike (stream) {\n  if (!ReadableStream) {\n    ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream)\n  }\n\n  return stream instanceof ReadableStream || (\n    stream[Symbol.toStringTag] === 'ReadableStream' &&\n    typeof stream.tee === 'function'\n  )\n}\n\nconst MAXIMUM_ARGUMENT_LENGTH = 65535\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to inputs length and whose code points have the same values\n  //    as the values of inputs bytes, in the same order.\n\n  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n    return String.fromCharCode(...input)\n  }\n\n  return input.reduce((previous, current) => previous + String.fromCharCode(current), '')\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed')) {\n      throw err\n    }\n  }\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  for (let i = 0; i < input.length; i++) {\n    assert(input.charCodeAt(i) <= 0xFF)\n  }\n\n  // 2. Return a byte sequence whose length is equal to inputs code\n  //    point length and whose bytes have the same values as the\n  //    values of inputs code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */\nasync function readAllBytes (reader) {\n  const bytes = []\n  let byteLength = 0\n\n  while (true) {\n    const { done, value: chunk } = await reader.read()\n\n    if (done) {\n      // 1. Call successSteps with bytes.\n      return Buffer.concat(bytes, byteLength)\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      throw new TypeError('Received non-Uint8Array chunk')\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk)\n    byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n */\nfunction urlHasHttpsScheme (url) {\n  if (typeof url === 'string') {\n    return url.startsWith('https:')\n  }\n\n  return url.protocol === 'https:'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key))\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  isomorphicDecode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsaUVBQWlFLEVBQUUsbUJBQU8sQ0FBQyx1RUFBYTtBQUNoRyxRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsaUVBQVU7QUFDOUMsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyw4QkFBWTtBQUM1QyxRQUFRLDhDQUE4QyxFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDOUUsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsOEJBQVk7O0FBRTdDO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7O0FBRUE7QUFDQSxXQUFXLG1CQUFPLENBQUMsc0JBQVE7QUFDM0IsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvdXRpbC5qcz8wYmY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHJlZGlyZWN0U3RhdHVzLCBiYWRQb3J0cywgcmVmZXJyZXJQb2xpY3k6IHJlZmVycmVyUG9saWN5VG9rZW5zIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gcmVxdWlyZSgncGVyZl9ob29rcycpXG5jb25zdCB7IGlzQmxvYkxpa2UsIHRvVVNWU3RyaW5nLCBSZWFkYWJsZVN0cmVhbUZyb20gfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBpc1VpbnQ4QXJyYXkgfSA9IHJlcXVpcmUoJ3V0aWwvdHlwZXMnKVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2RldGVybWluaW5nLWlmLWNyeXB0by1zdXBwb3J0LWlzLXVuYXZhaWxhYmxlXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl8dW5kZWZpbmVkfSAqL1xubGV0IGNyeXB0b1xuXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxufSBjYXRjaCB7XG5cbn1cblxuZnVuY3Rpb24gcmVzcG9uc2VVUkwgKHJlc3BvbnNlKSB7XG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZXNcbiAgLy8gQSByZXNwb25zZSBoYXMgYW4gYXNzb2NpYXRlZCBVUkwuIEl0IGlzIGEgcG9pbnRlciB0byB0aGUgbGFzdCBVUkxcbiAgLy8gaW4gcmVzcG9uc2XigJlzIFVSTCBsaXN0IGFuZCBudWxsIGlmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBlbXB0eS5cbiAgY29uc3QgdXJsTGlzdCA9IHJlc3BvbnNlLnVybExpc3RcbiAgY29uc3QgbGVuZ3RoID0gdXJsTGlzdC5sZW5ndGhcbiAgcmV0dXJuIGxlbmd0aCA9PT0gMCA/IG51bGwgOiB1cmxMaXN0W2xlbmd0aCAtIDFdLnRvU3RyaW5nKClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtbG9jYXRpb24tdXJsXG5mdW5jdGlvbiByZXNwb25zZUxvY2F0aW9uVVJMIChyZXNwb25zZSwgcmVxdWVzdEZyYWdtZW50KSB7XG4gIC8vIDEuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHJldHVybiBudWxsLlxuICBpZiAoIXJlZGlyZWN0U3RhdHVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gMi4gTGV0IGxvY2F0aW9uIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW5cbiAgLy8gYExvY2F0aW9uYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBsZXQgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ2xvY2F0aW9uJylcblxuICAvLyAzLiBJZiBsb2NhdGlvbiBpcyBhIGhlYWRlciB2YWx1ZSwgdGhlbiBzZXQgbG9jYXRpb24gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyAgICBwYXJzaW5nIGxvY2F0aW9uIHdpdGggcmVzcG9uc2XigJlzIFVSTC5cbiAgaWYgKGxvY2F0aW9uICE9PSBudWxsICYmIGlzVmFsaWRIZWFkZXJWYWx1ZShsb2NhdGlvbikpIHtcbiAgICBsb2NhdGlvbiA9IG5ldyBVUkwobG9jYXRpb24sIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8vIDQuIElmIGxvY2F0aW9uIGlzIGEgVVJMIHdob3NlIGZyYWdtZW50IGlzIG51bGwsIHRoZW4gc2V0IGxvY2F0aW9u4oCZc1xuICAvLyBmcmFnbWVudCB0byByZXF1ZXN0RnJhZ21lbnQuXG4gIGlmIChsb2NhdGlvbiAmJiAhbG9jYXRpb24uaGFzaCkge1xuICAgIGxvY2F0aW9uLmhhc2ggPSByZXF1ZXN0RnJhZ21lbnRcbiAgfVxuXG4gIC8vIDUuIFJldHVybiBsb2NhdGlvbi5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKiBAcmV0dXJucyB7VVJMfSAqL1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRVUkwgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEJhZFBvcnQgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHVybCBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhbiBIVFRQKFMpIHNjaGVtZSBhbmQgdXJs4oCZcyBwb3J0IGlzIGEgYmFkIHBvcnQsXG4gIC8vIHRoZW4gcmV0dXJuIGJsb2NrZWQuXG4gIGlmICh1cmxJc0h0dHBIdHRwc1NjaGVtZSh1cmwpICYmIGJhZFBvcnRzLmluY2x1ZGVzKHVybC5wb3J0KSkge1xuICAgIHJldHVybiAnYmxvY2tlZCdcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBhbGxvd2VkLlxuICByZXR1cm4gJ2FsbG93ZWQnXG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JMaWtlIChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEVycm9yIHx8IChcbiAgICBvYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnRXJyb3InIHx8XG4gICAgb2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0RPTUV4Y2VwdGlvbidcbiAgKVxufVxuXG4vLyBDaGVjayB3aGV0aGVyIHxzdGF0dXNUZXh0fCBpcyBhIEJ5dGVTdHJpbmcgYW5kXG4vLyBtYXRjaGVzIHRoZSBSZWFzb24tUGhyYXNlIHRva2VuIHByb2R1Y3Rpb24uXG4vLyBSRkMgMjYxNjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTZcbi8vIFJGQyA3MjMwOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMFxuLy8gXCJyZWFzb24tcGhyYXNlID0gKiggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXCJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJvbWl1bS9jaHJvbWl1bS9ibG9iLzk0LjAuNDYwNC4xL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvZmV0Y2gvcmVzcG9uc2UuY2MjTDExNlxuZnVuY3Rpb24gaXNWYWxpZFJlYXNvblBocmFzZSAoc3RhdHVzVGV4dCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXR1c1RleHQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjID0gc3RhdHVzVGV4dC5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgKFxuICAgICAgICAgIGMgPT09IDB4MDkgfHwgLy8gSFRBQlxuICAgICAgICAgIChjID49IDB4MjAgJiYgYyA8PSAweDdlKSB8fCAvLyBTUCAvIFZDSEFSXG4gICAgICAgICAgKGMgPj0gMHg4MCAmJiBjIDw9IDB4ZmYpXG4gICAgICAgICkgLy8gb2JzLXRleHRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc1Rva2VuQ2hhciAoYykge1xuICByZXR1cm4gIShcbiAgICBjID49IDB4N2YgfHxcbiAgICBjIDw9IDB4MjAgfHxcbiAgICBjID09PSAnKCcgfHxcbiAgICBjID09PSAnKScgfHxcbiAgICBjID09PSAnPCcgfHxcbiAgICBjID09PSAnPicgfHxcbiAgICBjID09PSAnQCcgfHxcbiAgICBjID09PSAnLCcgfHxcbiAgICBjID09PSAnOycgfHxcbiAgICBjID09PSAnOicgfHxcbiAgICBjID09PSAnXFxcXCcgfHxcbiAgICBjID09PSAnXCInIHx8XG4gICAgYyA9PT0gJy8nIHx8XG4gICAgYyA9PT0gJ1snIHx8XG4gICAgYyA9PT0gJ10nIHx8XG4gICAgYyA9PT0gJz8nIHx8XG4gICAgYyA9PT0gJz0nIHx8XG4gICAgYyA9PT0gJ3snIHx8XG4gICAgYyA9PT0gJ30nXG4gIClcbn1cblxuLy8gU2VlIFJGQyA3MjMwLCBTZWN0aW9uIDMuMi42LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvZDdkYTAyNDBjYWU3NzgyNGQxZWRhMjU3NDVjNDAyMjc1NzQ5OTEzMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9wbGF0Zm9ybS9uZXR3b3JrL2h0dHBfcGFyc2Vycy5jYyNMMzIxXG5mdW5jdGlvbiBpc1ZhbGlkSFRUUFRva2VuIChjaGFyYWN0ZXJzKSB7XG4gIGlmICghY2hhcmFjdGVycyB8fCB0eXBlb2YgY2hhcmFjdGVycyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJhY3RlcnMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjID0gY2hhcmFjdGVycy5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGMgPiAweDdmIHx8ICFpc1Rva2VuQ2hhcihjKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbmFtZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvYjNkMzdlNmY5NGY4N2Q1OWU0NDY2MmQ2MDc4ZjZhMTJkZTg0NWQxNy9uZXQvaHR0cC9odHRwX3V0aWwuY2MjTDM0MlxuZnVuY3Rpb24gaXNWYWxpZEhlYWRlck5hbWUgKHBvdGVudGlhbFZhbHVlKSB7XG4gIGlmIChwb3RlbnRpYWxWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBpc1ZhbGlkSFRUUFRva2VuKHBvdGVudGlhbFZhbHVlKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci12YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSAocG90ZW50aWFsVmFsdWUpIHtcbiAgLy8gLSBIYXMgbm8gbGVhZGluZyBvciB0cmFpbGluZyBIVFRQIHRhYiBvciBzcGFjZSBieXRlcy5cbiAgLy8gLSBDb250YWlucyBubyAweDAwIChOVUwpIG9yIEhUVFAgbmV3bGluZSBieXRlcy5cbiAgaWYgKFxuICAgIHBvdGVudGlhbFZhbHVlLnN0YXJ0c1dpdGgoJ1xcdCcpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuc3RhcnRzV2l0aCgnICcpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuZW5kc1dpdGgoJ1xcdCcpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuZW5kc1dpdGgoJyAnKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChcbiAgICBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcygnXFwwJykgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcygnXFxyJykgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcygnXFxuJylcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc2V0LXJlcXVlc3RzLXJlZmVycmVyLXBvbGljeS1vbi1yZWRpcmVjdFxuZnVuY3Rpb24gc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCAocmVxdWVzdCwgYWN0dWFsUmVzcG9uc2UpIHtcbiAgLy8gIEdpdmVuIGEgcmVxdWVzdCByZXF1ZXN0IGFuZCBhIHJlc3BvbnNlIGFjdHVhbFJlc3BvbnNlLCB0aGlzIGFsZ29yaXRobVxuICAvLyAgdXBkYXRlcyByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgYWNjb3JkaW5nIHRvIHRoZSBSZWZlcnJlci1Qb2xpY3lcbiAgLy8gIGhlYWRlciAoaWYgYW55KSBpbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyAxLiBMZXQgcG9saWN5IGJlIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIMKnIDguMSBQYXJzZSBhIHJlZmVycmVyIHBvbGljeVxuICAvLyBmcm9tIGEgUmVmZXJyZXItUG9saWN5IGhlYWRlciBvbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyA4LjEgUGFyc2UgYSByZWZlcnJlciBwb2xpY3kgZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXJcbiAgLy8gMS4gTGV0IHBvbGljeS10b2tlbnMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlcyBnaXZlbiBgUmVmZXJyZXItUG9saWN5YCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBjb25zdCB7IGhlYWRlcnNMaXN0IH0gPSBhY3R1YWxSZXNwb25zZVxuICAvLyAyLiBMZXQgcG9saWN5IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIC8vIDMuIEZvciBlYWNoIHRva2VuIGluIHBvbGljeS10b2tlbnMsIGlmIHRva2VuIGlzIGEgcmVmZXJyZXIgcG9saWN5IGFuZCB0b2tlbiBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcG9saWN5IHRvIHRva2VuLlxuICAvLyA0LiBSZXR1cm4gcG9saWN5LlxuICBjb25zdCBwb2xpY3lIZWFkZXIgPSAoaGVhZGVyc0xpc3QuZ2V0KCdyZWZlcnJlci1wb2xpY3knKSA/PyAnJykuc3BsaXQoJywnKVxuXG4gIC8vIE5vdGU6IEFzIHRoZSByZWZlcnJlci1wb2xpY3kgY2FuIGNvbnRhaW4gbXVsdGlwbGUgcG9saWNpZXNcbiAgLy8gc2VwYXJhdGVkIGJ5IGNvbW1hLCB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBhbGwgb2YgdGhlbVxuICAvLyBhbmQgcGljayB0aGUgZmlyc3QgdmFsaWQgb25lLlxuICAvLyBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZWZlcnJlci1Qb2xpY3kjc3BlY2lmeV9hX2ZhbGxiYWNrX3BvbGljeVxuICBsZXQgcG9saWN5ID0gJydcbiAgaWYgKHBvbGljeUhlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgLy8gVGhlIHJpZ2h0LW1vc3QgcG9saWN5IHRha2VzIHByZWNlZGVuY2UuXG4gICAgLy8gVGhlIGxlZnQtbW9zdCBwb2xpY3kgaXMgdGhlIGZhbGxiYWNrLlxuICAgIGZvciAobGV0IGkgPSBwb2xpY3lIZWFkZXIubGVuZ3RoOyBpICE9PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gcG9saWN5SGVhZGVyW2kgLSAxXS50cmltKClcbiAgICAgIGlmIChyZWZlcnJlclBvbGljeVRva2Vucy5pbmNsdWRlcyh0b2tlbikpIHtcbiAgICAgICAgcG9saWN5ID0gdG9rZW5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAyLiBJZiBwb2xpY3kgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSB0byBwb2xpY3kuXG4gIGlmIChwb2xpY3kgIT09ICcnKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IHBvbGljeVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjcm9zcy1vcmlnaW4tcmVzb3VyY2UtcG9saWN5LWNoZWNrXG5mdW5jdGlvbiBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnYWxsb3dlZCdcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtY29ycy1jaGVja1xuZnVuY3Rpb24gY29yc0NoZWNrICgpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gJ3N1Y2Nlc3MnXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXRhby1jaGVja1xuZnVuY3Rpb24gVEFPQ2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnc3VjY2Vzcydcbn1cblxuZnVuY3Rpb24gYXBwZW5kRmV0Y2hNZXRhZGF0YSAoaHR0cFJlcXVlc3QpIHtcbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1kZXN0LWhlYWRlclxuICAvLyAgVE9ET1xuXG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtbW9kZS1oZWFkZXJcblxuICAvLyAgMS4gQXNzZXJ0OiBy4oCZcyB1cmwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwuXG4gIC8vICBUT0RPXG5cbiAgLy8gIDIuIExldCBoZWFkZXIgYmUgYSBTdHJ1Y3R1cmVkIEhlYWRlciB3aG9zZSB2YWx1ZSBpcyBhIHRva2VuLlxuICBsZXQgaGVhZGVyID0gbnVsbFxuXG4gIC8vICAzLiBTZXQgaGVhZGVy4oCZcyB2YWx1ZSB0byBy4oCZcyBtb2RlLlxuICBoZWFkZXIgPSBodHRwUmVxdWVzdC5tb2RlXG5cbiAgLy8gIDQuIFNldCBhIHN0cnVjdHVyZWQgZmllbGQgdmFsdWUgYFNlYy1GZXRjaC1Nb2RlYC9oZWFkZXIgaW4gcuKAmXMgaGVhZGVyIGxpc3QuXG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LnNldCgnc2VjLWZldGNoLW1vZGUnLCBoZWFkZXIpXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1zaXRlLWhlYWRlclxuICAvLyAgVE9ET1xuXG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtdXNlci1oZWFkZXJcbiAgLy8gIFRPRE9cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2FwcGVuZC1hLXJlcXVlc3Qtb3JpZ2luLWhlYWRlclxuZnVuY3Rpb24gYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlciAocmVxdWVzdCkge1xuICAvLyAxLiBMZXQgc2VyaWFsaXplZE9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIGJ5dGUtc2VyaWFsaXppbmcgYSByZXF1ZXN0IG9yaWdpbiB3aXRoIHJlcXVlc3QuXG4gIGxldCBzZXJpYWxpemVkT3JpZ2luID0gcmVxdWVzdC5vcmlnaW5cblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiBvciByZXF1ZXN04oCZcyBtb2RlIGlzIFwid2Vic29ja2V0XCIsIHRoZW4gYXBwZW5kIChgT3JpZ2luYCwgc2VyaWFsaXplZE9yaWdpbikgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyB8fCByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgaWYgKHNlcmlhbGl6ZWRPcmlnaW4pIHtcbiAgICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdvcmlnaW4nLCBzZXJpYWxpemVkT3JpZ2luKVxuICAgIH1cblxuICAvLyAzLiBPdGhlcndpc2UsIGlmIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBuZWl0aGVyIGBHRVRgIG5vciBgSEVBRGAsIHRoZW46XG4gIH0gZWxzZSBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAvLyAxLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5OlxuICAgIHN3aXRjaCAocmVxdWVzdC5yZWZlcnJlclBvbGljeSkge1xuICAgICAgY2FzZSAnbm8tcmVmZXJyZXInOlxuICAgICAgICAvLyBTZXQgc2VyaWFsaXplZE9yaWdpbiB0byBgbnVsbGAuXG4gICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZSc6XG4gICAgICBjYXNlICdzdHJpY3Qtb3JpZ2luJzpcbiAgICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuICAgICAgICAvLyBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgYSB0dXBsZSBvcmlnaW4sIGl0cyBzY2hlbWUgaXMgXCJodHRwc1wiLCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBub3QgXCJodHRwc1wiLCB0aGVuIHNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgaWYgKHJlcXVlc3Qub3JpZ2luICYmIHVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3Qub3JpZ2luKSAmJiAhdXJsSGFzSHR0cHNTY2hlbWUocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc2FtZS1vcmlnaW4nOlxuICAgICAgICAvLyBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbiwgdGhlbiBzZXQgc2VyaWFsaXplZE9yaWdpbiB0byBgbnVsbGAuXG4gICAgICAgIGlmICghc2FtZU9yaWdpbihyZXF1ZXN0LCByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH1cblxuICAgIGlmIChzZXJpYWxpemVkT3JpZ2luKSB7XG4gICAgICAvLyAyLiBBcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdvcmlnaW4nLCBzZXJpYWxpemVkT3JpZ2luKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSAoY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NyZWF0ZS1hbi1vcGFxdWUtdGltaW5nLWluZm9cbmZ1bmN0aW9uIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8gKHRpbWluZ0luZm8pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lID8/IDAsXG4gICAgcmVkaXJlY3RTdGFydFRpbWU6IDAsXG4gICAgcmVkaXJlY3RFbmRUaW1lOiAwLFxuICAgIHBvc3RSZWRpcmVjdFN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWUgPz8gMCxcbiAgICBmaW5hbFNlcnZpY2VXb3JrZXJTdGFydFRpbWU6IDAsXG4gICAgZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWU6IDAsXG4gICAgZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZTogMCxcbiAgICBlbmRUaW1lOiAwLFxuICAgIGVuY29kZWRCb2R5U2l6ZTogMCxcbiAgICBkZWNvZGVkQm9keVNpemU6IDAsXG4gICAgZmluYWxDb25uZWN0aW9uVGltaW5nSW5mbzogbnVsbFxuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3BvbGljeS1jb250YWluZXJcbmZ1bmN0aW9uIG1ha2VQb2xpY3lDb250YWluZXIgKCkge1xuICAvLyBOb3RlOiB0aGUgZmV0Y2ggc3BlYyBkb2Vzbid0IG1ha2UgdXNlIG9mIGVtYmVkZGVyIHBvbGljeSBvciBDU1AgbGlzdFxuICByZXR1cm4ge1xuICAgIHJlZmVycmVyUG9saWN5OiAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbidcbiAgfVxufVxuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNjbG9uZS1hLXBvbGljeS1jb250YWluZXJcbmZ1bmN0aW9uIGNsb25lUG9saWN5Q29udGFpbmVyIChwb2xpY3lDb250YWluZXIpIHtcbiAgcmV0dXJuIHtcbiAgICByZWZlcnJlclBvbGljeTogcG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI2RldGVybWluZS1yZXF1ZXN0cy1yZWZlcnJlclxuZnVuY3Rpb24gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlciAocmVxdWVzdCkge1xuICAvLyAxLiBMZXQgcG9saWN5IGJlIHJlcXVlc3QncyByZWZlcnJlciBwb2xpY3kuXG4gIGNvbnN0IHBvbGljeSA9IHJlcXVlc3QucmVmZXJyZXJQb2xpY3lcblxuICAvLyBOb3RlOiBwb2xpY3kgY2Fubm90IChzaG91bGRuJ3QpIGJlIG51bGwgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICBhc3NlcnQocG9saWN5KVxuXG4gIC8vIDIuIExldCBlbnZpcm9ubWVudCBiZSByZXF1ZXN04oCZcyBjbGllbnQuXG5cbiAgbGV0IHJlZmVycmVyU291cmNlID0gbnVsbFxuXG4gIC8vIDMuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyByZWZlcnJlcjpcbiAgaWYgKHJlcXVlc3QucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gTm90ZTogbm9kZSBpc24ndCBhIGJyb3dzZXIgYW5kIGRvZXNuJ3QgaW1wbGVtZW50IGRvY3VtZW50L2lmcmFtZXMsXG4gICAgLy8gc28gd2UgYnlwYXNzIHRoaXMgc3RlcCBhbmQgcmVwbGFjZSBpdCB3aXRoIG91ciBvd24uXG5cbiAgICBjb25zdCBnbG9iYWxPcmlnaW4gPSBnZXRHbG9iYWxPcmlnaW4oKVxuXG4gICAgaWYgKCFnbG9iYWxPcmlnaW4gfHwgZ2xvYmFsT3JpZ2luLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgIH1cblxuICAgIC8vIG5vdGU6IHdlIG5lZWQgdG8gY2xvbmUgaXQgYXMgaXQncyBtdXRhdGVkXG4gICAgcmVmZXJyZXJTb3VyY2UgPSBuZXcgVVJMKGdsb2JhbE9yaWdpbilcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZmVycmVyIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgLy8gTGV0IHJlZmVycmVyU291cmNlIGJlIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICAgIHJlZmVycmVyU291cmNlID0gcmVxdWVzdC5yZWZlcnJlclxuICB9XG5cbiAgLy8gNC4gTGV0IHJlcXVlc3TigJlzIHJlZmVycmVyVVJMIGJlIHRoZSByZXN1bHQgb2Ygc3RyaXBwaW5nIHJlZmVycmVyU291cmNlIGZvclxuICAvLyAgICB1c2UgYXMgYSByZWZlcnJlci5cbiAgbGV0IHJlZmVycmVyVVJMID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSlcblxuICAvLyA1LiBMZXQgcmVmZXJyZXJPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhc1xuICAvLyAgICBhIHJlZmVycmVyLCB3aXRoIHRoZSBvcmlnaW4tb25seSBmbGFnIHNldCB0byB0cnVlLlxuICBjb25zdCByZWZlcnJlck9yaWdpbiA9IHN0cmlwVVJMRm9yUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UsIHRydWUpXG5cbiAgLy8gNi4gSWYgdGhlIHJlc3VsdCBvZiBzZXJpYWxpemluZyByZWZlcnJlclVSTCBpcyBhIHN0cmluZyB3aG9zZSBsZW5ndGggaXNcbiAgLy8gICAgZ3JlYXRlciB0aGFuIDQwOTYsIHNldCByZWZlcnJlclVSTCB0byByZWZlcnJlck9yaWdpbi5cbiAgaWYgKHJlZmVycmVyVVJMLnRvU3RyaW5nKCkubGVuZ3RoID4gNDA5Nikge1xuICAgIHJlZmVycmVyVVJMID0gcmVmZXJyZXJPcmlnaW5cbiAgfVxuXG4gIGNvbnN0IGFyZVNhbWVPcmlnaW4gPSBzYW1lT3JpZ2luKHJlcXVlc3QsIHJlZmVycmVyVVJMKVxuICBjb25zdCBpc05vblBvdGVudGlhbGx5VHJ1c3RXb3J0aHkgPSBpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmXG4gICAgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZXF1ZXN0LnVybClcblxuICAvLyA4LiBFeGVjdXRlIHRoZSBzd2l0Y2ggc3RhdGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSB2YWx1ZSBvZiBwb2xpY3k6XG4gIHN3aXRjaCAocG9saWN5KSB7XG4gICAgY2FzZSAnb3JpZ2luJzogcmV0dXJuIHJlZmVycmVyT3JpZ2luICE9IG51bGwgPyByZWZlcnJlck9yaWdpbiA6IHN0cmlwVVJMRm9yUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UsIHRydWUpXG4gICAgY2FzZSAndW5zYWZlLXVybCc6IHJldHVybiByZWZlcnJlclVSTFxuICAgIGNhc2UgJ3NhbWUtb3JpZ2luJzpcbiAgICAgIHJldHVybiBhcmVTYW1lT3JpZ2luID8gcmVmZXJyZXJPcmlnaW4gOiAnbm8tcmVmZXJyZXInXG4gICAgY2FzZSAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcbiAgICAgIHJldHVybiBhcmVTYW1lT3JpZ2luID8gcmVmZXJyZXJVUkwgOiByZWZlcnJlck9yaWdpblxuICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOiB7XG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAgICAgLy8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN04oCZcyBjdXJyZW50XG4gICAgICAvLyAgICBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuIHJldHVybiByZWZlcnJlclVSTC5cbiAgICAgIGlmIChzYW1lT3JpZ2luKHJlZmVycmVyVVJMLCBjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gcmVmZXJyZXJVUkxcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kIHJlcXVlc3TigJlzXG4gICAgICAvLyAgICBjdXJyZW50IFVSTCBpcyBub3QgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vXG4gICAgICAvLyAgICByZWZlcnJlci5cbiAgICAgIGlmIChpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmICFpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoY3VycmVudFVSTCkpIHtcbiAgICAgICAgcmV0dXJuICduby1yZWZlcnJlcidcbiAgICAgIH1cblxuICAgICAgLy8gMy4gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuICAgICAgcmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgfVxuICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4nOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvKipcbiAgICAgICAgICogMS4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kXG4gICAgICAgICAqIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCxcbiAgICAgICAgICogdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gICAgICAgICAqIDIuIFJldHVybiByZWZlcnJlck9yaWdpblxuICAgICAgICAqL1xuICAgIGNhc2UgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJzogLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLyoqXG4gICAgICAgKiAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmRcbiAgICAgICAqIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCxcbiAgICAgICAqIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuICAgICAgICogMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICAqL1xuXG4gICAgZGVmYXVsdDogLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIGlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSA/ICduby1yZWZlcnJlcicgOiByZWZlcnJlck9yaWdpblxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc3RyaXAtdXJsXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBvcmlnaW5Pbmx5XG4gKi9cbmZ1bmN0aW9uIHN0cmlwVVJMRm9yUmVmZXJyZXIgKHVybCwgb3JpZ2luT25seSkge1xuICAvLyAxLiBBc3NlcnQ6IHVybCBpcyBhIFVSTC5cbiAgYXNzZXJ0KHVybCBpbnN0YW5jZW9mIFVSTClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhIGxvY2FsIHNjaGVtZSwgdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdmaWxlOicgfHwgdXJsLnByb3RvY29sID09PSAnYWJvdXQ6JyB8fCB1cmwucHJvdG9jb2wgPT09ICdibGFuazonKSB7XG4gICAgcmV0dXJuICduby1yZWZlcnJlcidcbiAgfVxuXG4gIC8vIDMuIFNldCB1cmzigJlzIHVzZXJuYW1lIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gIHVybC51c2VybmFtZSA9ICcnXG5cbiAgLy8gNC4gU2V0IHVybOKAmXMgcGFzc3dvcmQgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgdXJsLnBhc3N3b3JkID0gJydcblxuICAvLyA1LiBTZXQgdXJs4oCZcyBmcmFnbWVudCB0byBudWxsLlxuICB1cmwuaGFzaCA9ICcnXG5cbiAgLy8gNi4gSWYgdGhlIG9yaWdpbi1vbmx5IGZsYWcgaXMgdHJ1ZSwgdGhlbjpcbiAgaWYgKG9yaWdpbk9ubHkpIHtcbiAgICAvLyAxLiBTZXQgdXJs4oCZcyBwYXRoIHRvIMKrIHRoZSBlbXB0eSBzdHJpbmcgwrsuXG4gICAgdXJsLnBhdGhuYW1lID0gJydcblxuICAgIC8vIDIuIFNldCB1cmzigJlzIHF1ZXJ5IHRvIG51bGwuXG4gICAgdXJsLnNlYXJjaCA9ICcnXG4gIH1cblxuICAvLyA3LiBSZXR1cm4gdXJsLlxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSAodXJsKSB7XG4gIGlmICghKHVybCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIElmIGNoaWxkIG9mIGFib3V0LCByZXR1cm4gdHJ1ZVxuICBpZiAodXJsLmhyZWYgPT09ICdhYm91dDpibGFuaycgfHwgdXJsLmhyZWYgPT09ICdhYm91dDpzcmNkb2MnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIElmIHNjaGVtZSBpcyBkYXRhLCByZXR1cm4gdHJ1ZVxuICBpZiAodXJsLnByb3RvY29sID09PSAnZGF0YTonKSByZXR1cm4gdHJ1ZVxuXG4gIC8vIElmIGZpbGUsIHJldHVybiB0cnVlXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdmaWxlOicpIHJldHVybiB0cnVlXG5cbiAgcmV0dXJuIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwub3JpZ2luKVxuXG4gIGZ1bmN0aW9uIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSAob3JpZ2luKSB7XG4gICAgLy8gSWYgb3JpZ2luIGlzIGV4cGxpY2l0bHkgbnVsbCwgcmV0dXJuIGZhbHNlXG4gICAgaWYgKG9yaWdpbiA9PSBudWxsIHx8IG9yaWdpbiA9PT0gJ251bGwnKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IG9yaWdpbkFzVVJMID0gbmV3IFVSTChvcmlnaW4pXG5cbiAgICAvLyBJZiBzZWN1cmUsIHJldHVybiB0cnVlXG4gICAgaWYgKG9yaWdpbkFzVVJMLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCBvcmlnaW5Bc1VSTC5wcm90b2NvbCA9PT0gJ3dzczonKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIGxvY2FsaG9zdCBvciB2YXJpYW50cywgcmV0dXJuIHRydWVcbiAgICBpZiAoL14xMjcoPzpcXC5bMC05XSspezAsMn1cXC5bMC05XSskfF5cXFsoPzowKjopKj86PzAqMVxcXSQvLnRlc3Qob3JpZ2luQXNVUkwuaG9zdG5hbWUpIHx8XG4gICAgIChvcmlnaW5Bc1VSTC5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgfHwgb3JpZ2luQXNVUkwuaG9zdG5hbWUuaW5jbHVkZXMoJ2xvY2FsaG9zdC4nKSkgfHxcbiAgICAgKG9yaWdpbkFzVVJMLmhvc3RuYW1lLmVuZHNXaXRoKCcubG9jYWxob3N0JykpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIGFueSBvdGhlciwgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNkb2VzLXJlc3BvbnNlLW1hdGNoLW1ldGFkYXRhbGlzdFxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IG1ldGFkYXRhTGlzdFxuICovXG5mdW5jdGlvbiBieXRlc01hdGNoIChieXRlcywgbWV0YWRhdGFMaXN0KSB7XG4gIC8vIElmIG5vZGUgaXMgbm90IGJ1aWx0IHdpdGggT3BlblNTTCBzdXBwb3J0LCB3ZSBjYW5ub3QgY2hlY2tcbiAgLy8gYSByZXF1ZXN0J3MgaW50ZWdyaXR5LCBzbyBhbGxvdyBpdCBieSBkZWZhdWx0ICh0aGUgc3BlYyB3aWxsXG4gIC8vIGFsbG93IHJlcXVlc3RzIGlmIGFuIGludmFsaWQgaGFzaCBpcyBnaXZlbiwgYXMgcHJlY2VkZW5jZSkuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogb25seSBpZiBub2RlIGlzIGJ1aWx0IHdpdGggLS13aXRob3V0LXNzbCAqL1xuICBpZiAoY3J5cHRvID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMS4gTGV0IHBhcnNlZE1ldGFkYXRhIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBtZXRhZGF0YUxpc3QuXG4gIGNvbnN0IHBhcnNlZE1ldGFkYXRhID0gcGFyc2VNZXRhZGF0YShtZXRhZGF0YUxpc3QpXG5cbiAgLy8gMi4gSWYgcGFyc2VkTWV0YWRhdGEgaXMgbm8gbWV0YWRhdGEsIHJldHVybiB0cnVlLlxuICBpZiAocGFyc2VkTWV0YWRhdGEgPT09ICdubyBtZXRhZGF0YScpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gSWYgcGFyc2VkTWV0YWRhdGEgaXMgdGhlIGVtcHR5IHNldCwgcmV0dXJuIHRydWUuXG4gIGlmIChwYXJzZWRNZXRhZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNC4gTGV0IG1ldGFkYXRhIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyB0aGUgc3Ryb25nZXN0XG4gIC8vICAgIG1ldGFkYXRhIGZyb20gcGFyc2VkTWV0YWRhdGEuXG4gIGNvbnN0IGxpc3QgPSBwYXJzZWRNZXRhZGF0YS5zb3J0KChjLCBkKSA9PiBkLmFsZ28ubG9jYWxlQ29tcGFyZShjLmFsZ28pKVxuICAvLyBnZXQgdGhlIHN0cm9uZ2VzdCBhbGdvcml0aG1cbiAgY29uc3Qgc3Ryb25nZXN0ID0gbGlzdFswXS5hbGdvXG4gIC8vIGdldCBhbGwgZW50cmllcyB0aGF0IHVzZSB0aGUgc3Ryb25nZXN0IGFsZ29yaXRobTsgaWdub3JlIHdlYWtlclxuICBjb25zdCBtZXRhZGF0YSA9IGxpc3QuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmFsZ28gPT09IHN0cm9uZ2VzdClcblxuICAvLyA1LiBGb3IgZWFjaCBpdGVtIGluIG1ldGFkYXRhOlxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbWV0YWRhdGEpIHtcbiAgICAvLyAxLiBMZXQgYWxnb3JpdGhtIGJlIHRoZSBhbGcgY29tcG9uZW50IG9mIGl0ZW0uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gaXRlbS5hbGdvXG5cbiAgICAvLyAyLiBMZXQgZXhwZWN0ZWRWYWx1ZSBiZSB0aGUgdmFsIGNvbXBvbmVudCBvZiBpdGVtLlxuICAgIGxldCBleHBlY3RlZFZhbHVlID0gaXRlbS5oYXNoXG5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYi1wbGF0Zm9ybS10ZXN0cy93cHQvY29tbWl0L2U0YzVjYzdhNWU0ODA5MzIyMDUyOGRmZGQxYzQwMTJkYzM4MzdhMGVcbiAgICAvLyBcImJlIGxpYmVyYWwgd2l0aCBwYWRkaW5nXCIuIFRoaXMgaXMgYW5ub3lpbmcsIGFuZCBpdCdzIG5vdCBldmVuIGluIHRoZSBzcGVjLlxuXG4gICAgaWYgKGV4cGVjdGVkVmFsdWUuZW5kc1dpdGgoJz09JykpIHtcbiAgICAgIGV4cGVjdGVkVmFsdWUgPSBleHBlY3RlZFZhbHVlLnNsaWNlKDAsIC0yKVxuICAgIH1cblxuICAgIC8vIDMuIExldCBhY3R1YWxWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGFsZ29yaXRobSB0byBieXRlcy5cbiAgICBsZXQgYWN0dWFsVmFsdWUgPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShieXRlcykuZGlnZXN0KCdiYXNlNjQnKVxuXG4gICAgaWYgKGFjdHVhbFZhbHVlLmVuZHNXaXRoKCc9PScpKSB7XG4gICAgICBhY3R1YWxWYWx1ZSA9IGFjdHVhbFZhbHVlLnNsaWNlKDAsIC0yKVxuICAgIH1cblxuICAgIC8vIDQuIElmIGFjdHVhbFZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmUgbWF0Y2ggZm9yIGV4cGVjdGVkVmFsdWUsXG4gICAgLy8gICAgcmV0dXJuIHRydWUuXG4gICAgaWYgKGFjdHVhbFZhbHVlID09PSBleHBlY3RlZFZhbHVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBhY3R1YWxCYXNlNjRVUkwgPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShieXRlcykuZGlnZXN0KCdiYXNlNjR1cmwnKVxuXG4gICAgaWYgKGFjdHVhbEJhc2U2NFVSTC5lbmRzV2l0aCgnPT0nKSkge1xuICAgICAgYWN0dWFsQmFzZTY0VVJMID0gYWN0dWFsQmFzZTY0VVJMLnNsaWNlKDAsIC0yKVxuICAgIH1cblxuICAgIGlmIChhY3R1YWxCYXNlNjRVUkwgPT09IGV4cGVjdGVkVmFsdWUpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gNi4gUmV0dXJuIGZhbHNlLlxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI2dyYW1tYXJkZWYtaGFzaC13aXRoLW9wdGlvbnNcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9DU1AyLyNzb3VyY2UtbGlzdC1zeW50YXhcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM1MjM0I2FwcGVuZGl4LUIuMVxuY29uc3QgcGFyc2VIYXNoV2l0aE9wdGlvbnMgPSAvKCg/PGFsZ28+c2hhMjU2fHNoYTM4NHxzaGE1MTIpLSg/PGhhc2g+W0EtejAtOSsvXXsxfS4qPXswLDJ9KSkoICtbXFx4MjEtXFx4N2VdPyk/L2lcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNwYXJzZS1tZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWV0YWRhdGEgKG1ldGFkYXRhKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgdGhlIGVtcHR5IHNldC5cbiAgLyoqIEB0eXBlIHt7IGFsZ286IHN0cmluZywgaGFzaDogc3RyaW5nIH1bXX0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICAvLyAyLiBMZXQgZW1wdHkgYmUgZXF1YWwgdG8gdHJ1ZS5cbiAgbGV0IGVtcHR5ID0gdHJ1ZVxuXG4gIGNvbnN0IHN1cHBvcnRlZEhhc2hlcyA9IGNyeXB0by5nZXRIYXNoZXMoKVxuXG4gIC8vIDMuIEZvciBlYWNoIHRva2VuIHJldHVybmVkIGJ5IHNwbGl0dGluZyBtZXRhZGF0YSBvbiBzcGFjZXM6XG4gIGZvciAoY29uc3QgdG9rZW4gb2YgbWV0YWRhdGEuc3BsaXQoJyAnKSkge1xuICAgIC8vIDEuIFNldCBlbXB0eSB0byBmYWxzZS5cbiAgICBlbXB0eSA9IGZhbHNlXG5cbiAgICAvLyAyLiBQYXJzZSB0b2tlbiBhcyBhIGhhc2gtd2l0aC1vcHRpb25zLlxuICAgIGNvbnN0IHBhcnNlZFRva2VuID0gcGFyc2VIYXNoV2l0aE9wdGlvbnMuZXhlYyh0b2tlbilcblxuICAgIC8vIDMuIElmIHRva2VuIGRvZXMgbm90IHBhcnNlLCBjb250aW51ZSB0byB0aGUgbmV4dCB0b2tlbi5cbiAgICBpZiAocGFyc2VkVG9rZW4gPT09IG51bGwgfHwgcGFyc2VkVG9rZW4uZ3JvdXBzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE5vdGU6IENocm9taXVtIGJsb2NrcyB0aGUgcmVxdWVzdCBhdCB0aGlzIHBvaW50LCBidXQgRmlyZWZveFxuICAgICAgLy8gZ2l2ZXMgYSB3YXJuaW5nIHRoYXQgYW4gaW52YWxpZCBpbnRlZ3JpdHkgd2FzIGdpdmVuLiBUaGVcbiAgICAgIC8vIGNvcnJlY3QgYmVoYXZpb3IgaXMgdG8gaWdub3JlIHRoZXNlLCBhbmQgc3Vic2VxdWVudGx5IG5vdFxuICAgICAgLy8gY2hlY2sgdGhlIGludGVncml0eSBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIDQuIExldCBhbGdvcml0aG0gYmUgdGhlIGhhc2gtYWxnbyBjb21wb25lbnQgb2YgdG9rZW4uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gcGFyc2VkVG9rZW4uZ3JvdXBzLmFsZ29cblxuICAgIC8vIDUuIElmIGFsZ29yaXRobSBpcyBhIGhhc2ggZnVuY3Rpb24gcmVjb2duaXplZCBieSB0aGUgdXNlclxuICAgIC8vICAgIGFnZW50LCBhZGQgdGhlIHBhcnNlZCB0b2tlbiB0byByZXN1bHQuXG4gICAgaWYgKHN1cHBvcnRlZEhhc2hlcy5pbmNsdWRlcyhhbGdvcml0aG0udG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlZFRva2VuLmdyb3VwcylcbiAgICB9XG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbm8gbWV0YWRhdGEgaWYgZW1wdHkgaXMgdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiByZXN1bHQuXG4gIGlmIChlbXB0eSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnbm8gbWV0YWRhdGEnXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtdXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cy8jdXBncmFkZS1yZXF1ZXN0XG5mdW5jdGlvbiB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwgKHJlcXVlc3QpIHtcbiAgLy8gVE9ET1xufVxuXG4vKipcbiAqIEBsaW5rIHtodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNzYW1lLW9yaWdpbn1cbiAqIEBwYXJhbSB7VVJMfSBBXG4gKiBAcGFyYW0ge1VSTH0gQlxuICovXG5mdW5jdGlvbiBzYW1lT3JpZ2luIChBLCBCKSB7XG4gIC8vIDEuIElmIEEgYW5kIEIgYXJlIHRoZSBzYW1lIG9wYXF1ZSBvcmlnaW4sIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLm9yaWdpbiA9PT0gQi5vcmlnaW4gJiYgQS5vcmlnaW4gPT09ICdudWxsJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAyLiBJZiBBIGFuZCBCIGFyZSBib3RoIHR1cGxlIG9yaWdpbnMgYW5kIHRoZWlyIHNjaGVtZXMsXG4gIC8vICAgIGhvc3RzLCBhbmQgcG9ydCBhcmUgaWRlbnRpY2FsLCB0aGVuIHJldHVybiB0cnVlLlxuICBpZiAoQS5wcm90b2NvbCA9PT0gQi5wcm90b2NvbCAmJiBBLmhvc3RuYW1lID09PSBCLmhvc3RuYW1lICYmIEEucG9ydCA9PT0gQi5wb3J0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBmYWxzZS5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZSAoKSB7XG4gIGxldCByZXNcbiAgbGV0IHJlalxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcyA9IHJlc29sdmVcbiAgICByZWogPSByZWplY3RcbiAgfSlcblxuICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlOiByZXMsIHJlamVjdDogcmVqIH1cbn1cblxuZnVuY3Rpb24gaXNBYm9ydGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnXG59XG5cbmZ1bmN0aW9uIGlzQ2FuY2VsbGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnIHx8XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZC1ub3JtYWxpemVcbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZCAobWV0aG9kKSB7XG4gIHJldHVybiAvXihERUxFVEV8R0VUfEhFQUR8T1BUSU9OU3xQT1NUfFBVVCkkL2kudGVzdChtZXRob2QpXG4gICAgPyBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIDogbWV0aG9kXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzZXJpYWxpemUtYS1qYXZhc2NyaXB0LXZhbHVlLXRvLWEtanNvbi1zdHJpbmdcbmZ1bmN0aW9uIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyAodmFsdWUpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSA/IENhbGwoJUpTT04uc3RyaW5naWZ5JSwgdW5kZWZpbmVkLCDCqyB2YWx1ZSDCuykuXG4gIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuXG4gIC8vIDIuIElmIHJlc3VsdCBpcyB1bmRlZmluZWQsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZScpXG4gIH1cblxuICAvLyAzLiBBc3NlcnQ6IHJlc3VsdCBpcyBhIHN0cmluZy5cbiAgYXNzZXJ0KHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKVxuXG4gIC8vIDQuIFJldHVybiByZXN1bHQuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lMjVpdGVyYXRvcnByb3RvdHlwZSUyNS1vYmplY3RcbmNvbnN0IGVzSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0geygpID0+IHVua25vd25bXX0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0geydrZXknfCd2YWx1ZSd8J2tleSt2YWx1ZSd9IGtpbmRcbiAqL1xuZnVuY3Rpb24gbWFrZUl0ZXJhdG9yIChpdGVyYXRvciwgbmFtZSwga2luZCkge1xuICBjb25zdCBvYmplY3QgPSB7XG4gICAgaW5kZXg6IDAsXG4gICAga2luZCxcbiAgICB0YXJnZXQ6IGl0ZXJhdG9yXG4gIH1cblxuICBjb25zdCBpID0ge1xuICAgIG5leHQgKCkge1xuICAgICAgLy8gMS4gTGV0IGludGVyZmFjZSBiZSB0aGUgaW50ZXJmYWNlIGZvciB3aGljaCB0aGUgaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBleGlzdHMuXG5cbiAgICAgIC8vIDIuIExldCB0aGlzVmFsdWUgYmUgdGhlIHRoaXMgdmFsdWUuXG5cbiAgICAgIC8vIDMuIExldCBvYmplY3QgYmUgPyBUb09iamVjdCh0aGlzVmFsdWUpLlxuXG4gICAgICAvLyA0LiBJZiBvYmplY3QgaXMgYSBwbGF0Zm9ybSBvYmplY3QsIHRoZW4gcGVyZm9ybSBhIHNlY3VyaXR5XG4gICAgICAvLyAgICBjaGVjaywgcGFzc2luZzpcblxuICAgICAgLy8gNS4gSWYgb2JqZWN0IGlzIG5vdCBhIGRlZmF1bHQgaXRlcmF0b3Igb2JqZWN0IGZvciBpbnRlcmZhY2UsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gaSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnbmV4dCcgY2FsbGVkIG9uIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgJHtuYW1lfSBJdGVyYXRvci5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IGluZGV4IGJlIG9iamVjdOKAmXMgaW5kZXguXG4gICAgICAvLyA3LiBMZXQga2luZCBiZSBvYmplY3TigJlzIGtpbmQuXG4gICAgICAvLyA4LiBMZXQgdmFsdWVzIGJlIG9iamVjdOKAmXMgdGFyZ2V0J3MgdmFsdWUgcGFpcnMgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAgY29uc3QgeyBpbmRleCwga2luZCwgdGFyZ2V0IH0gPSBvYmplY3RcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRhcmdldCgpXG5cbiAgICAgIC8vIDkuIExldCBsZW4gYmUgdGhlIGxlbmd0aCBvZiB2YWx1ZXMuXG4gICAgICBjb25zdCBsZW4gPSB2YWx1ZXMubGVuZ3RoXG5cbiAgICAgIC8vIDEwLiBJZiBpbmRleCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbGVuLCB0aGVuIHJldHVyblxuICAgICAgLy8gICAgIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKS5cbiAgICAgIGlmIChpbmRleCA+PSBsZW4pIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gICAgICB9XG5cbiAgICAgIC8vIDExLiBMZXQgcGFpciBiZSB0aGUgZW50cnkgaW4gdmFsdWVzIGF0IGluZGV4IGluZGV4LlxuICAgICAgY29uc3QgcGFpciA9IHZhbHVlc1tpbmRleF1cblxuICAgICAgLy8gMTIuIFNldCBvYmplY3TigJlzIGluZGV4IHRvIGluZGV4ICsgMS5cbiAgICAgIG9iamVjdC5pbmRleCA9IGluZGV4ICsgMVxuXG4gICAgICAvLyAxMy4gUmV0dXJuIHRoZSBpdGVyYXRvciByZXN1bHQgZm9yIHBhaXIgYW5kIGtpbmQuXG4gICAgICByZXR1cm4gaXRlcmF0b3JSZXN1bHQocGFpciwga2luZClcbiAgICB9LFxuICAgIC8vIFRoZSBjbGFzcyBzdHJpbmcgb2YgYW4gaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBmb3IgYSBnaXZlbiBpbnRlcmZhY2UgaXMgdGhlXG4gICAgLy8gcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGludGVyZmFjZSBhbmQgdGhlIHN0cmluZyBcIiBJdGVyYXRvclwiLlxuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiBgJHtuYW1lfSBJdGVyYXRvcmBcbiAgfVxuXG4gIC8vIFRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHNsb3Qgb2YgYW4gaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBtdXN0IGJlICVJdGVyYXRvclByb3RvdHlwZSUuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihpLCBlc0l0ZXJhdG9yUHJvdG90eXBlKVxuICAvLyBlc0l0ZXJhdG9yUHJvdG90eXBlIG5lZWRzIHRvIGJlIHRoZSBwcm90b3R5cGUgb2YgaVxuICAvLyB3aGljaCBpcyB0aGUgcHJvdG90eXBlIG9mIGFuIGVtcHR5IG9iamVjdC4gWWVzLCBpdCdzIGNvbmZ1c2luZy5cbiAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZih7fSwgaSlcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpdGVyYXRvci1yZXN1bHRcbmZ1bmN0aW9uIGl0ZXJhdG9yUmVzdWx0IChwYWlyLCBraW5kKSB7XG4gIGxldCByZXN1bHRcblxuICAvLyAxLiBMZXQgcmVzdWx0IGJlIGEgdmFsdWUgZGV0ZXJtaW5lZCBieSB0aGUgdmFsdWUgb2Yga2luZDpcbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSAna2V5Jzoge1xuICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAvLyAyLiBMZXQga2V5IGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxLZXkgdG8gYW5cbiAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAvLyAzLiByZXN1bHQgaXMga2V5LlxuICAgICAgcmVzdWx0ID0gcGFpclswXVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAndmFsdWUnOiB7XG4gICAgICAvLyAxLiBMZXQgaWRsVmFsdWUgYmUgcGFpcuKAmXMgdmFsdWUuXG4gICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbFZhbHVlIHRvXG4gICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgLy8gMy4gcmVzdWx0IGlzIHZhbHVlLlxuICAgICAgcmVzdWx0ID0gcGFpclsxXVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAna2V5K3ZhbHVlJzoge1xuICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAvLyAyLiBMZXQgaWRsVmFsdWUgYmUgcGFpcuKAmXMgdmFsdWUuXG4gICAgICAvLyAzLiBMZXQga2V5IGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxLZXkgdG8gYW5cbiAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAvLyA0LiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbFZhbHVlIHRvXG4gICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgLy8gNS4gTGV0IGFycmF5IGJlICEgQXJyYXlDcmVhdGUoMikuXG4gICAgICAvLyA2LiBDYWxsICEgQ3JlYXRlRGF0YVByb3BlcnR5KGFycmF5LCBcIjBcIiwga2V5KS5cbiAgICAgIC8vIDcuIENhbGwgISBDcmVhdGVEYXRhUHJvcGVydHkoYXJyYXksIFwiMVwiLCB2YWx1ZSkuXG4gICAgICAvLyA4LiByZXN1bHQgaXMgYXJyYXkuXG4gICAgICByZXN1bHQgPSBwYWlyXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuIFJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHJlc3VsdCwgZmFsc2UpLlxuICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LCBkb25lOiBmYWxzZSB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS1mdWxseS1yZWFkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZ1bGx5UmVhZEJvZHkgKGJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKSB7XG4gIC8vIDEuIElmIHRhc2tEZXN0aW5hdGlvbiBpcyBudWxsLCB0aGVuIHNldCB0YXNrRGVzdGluYXRpb24gdG9cbiAgLy8gICAgdGhlIHJlc3VsdCBvZiBzdGFydGluZyBhIG5ldyBwYXJhbGxlbCBxdWV1ZS5cblxuICAvLyAyLiBMZXQgc3VjY2Vzc1N0ZXBzIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlcyBiZSB0byBxdWV1ZSBhXG4gIC8vICAgIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5IGdpdmVuIGJ5dGVzLCB3aXRoIHRhc2tEZXN0aW5hdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gcHJvY2Vzc0JvZHlcblxuICAvLyAzLiBMZXQgZXJyb3JTdGVwcyBiZSB0byBxdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5RXJyb3IsXG4gIC8vICAgIHdpdGggdGFza0Rlc3RpbmF0aW9uLlxuICBjb25zdCBlcnJvclN0ZXBzID0gcHJvY2Vzc0JvZHlFcnJvclxuXG4gIC8vIDQuIExldCByZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgcmVhZGVyIGZvciBib2R54oCZcyBzdHJlYW0uXG4gIC8vICAgIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzIHdpdGggdGhhdFxuICAvLyAgICBleGNlcHRpb24gYW5kIHJldHVybi5cbiAgbGV0IHJlYWRlclxuXG4gIHRyeSB7XG4gICAgcmVhZGVyID0gYm9keS5zdHJlYW0uZ2V0UmVhZGVyKClcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yU3RlcHMoZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDUuIFJlYWQgYWxsIGJ5dGVzIGZyb20gcmVhZGVyLCBnaXZlbiBzdWNjZXNzU3RlcHMgYW5kIGVycm9yU3RlcHMuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZEFsbEJ5dGVzKHJlYWRlcilcbiAgICBzdWNjZXNzU3RlcHMocmVzdWx0KVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JTdGVwcyhlKVxuICB9XG59XG5cbi8qKiBAdHlwZSB7UmVhZGFibGVTdHJlYW19ICovXG5sZXQgUmVhZGFibGVTdHJlYW0gPSBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtXG5cbmZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW1MaWtlIChzdHJlYW0pIHtcbiAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtL3dlYicpLlJlYWRhYmxlU3RyZWFtXG4gIH1cblxuICByZXR1cm4gc3RyZWFtIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgKFxuICAgIHN0cmVhbVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnUmVhZGFibGVTdHJlYW0nICYmXG4gICAgdHlwZW9mIHN0cmVhbS50ZWUgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG5jb25zdCBNQVhJTVVNX0FSR1VNRU5UX0xFTkdUSCA9IDY1NTM1XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jaXNvbW9ycGhpYy1kZWNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyW118VWludDhBcnJheX0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpY0RlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gVG8gaXNvbW9ycGhpYyBkZWNvZGUgYSBieXRlIHNlcXVlbmNlIGlucHV0LCByZXR1cm4gYSBzdHJpbmcgd2hvc2UgY29kZSBwb2ludFxuICAvLyAgICBsZW5ndGggaXMgZXF1YWwgdG8gaW5wdXTigJlzIGxlbmd0aCBhbmQgd2hvc2UgY29kZSBwb2ludHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXNcbiAgLy8gICAgYXMgdGhlIHZhbHVlcyBvZiBpbnB1dOKAmXMgYnl0ZXMsIGluIHRoZSBzYW1lIG9yZGVyLlxuXG4gIGlmIChpbnB1dC5sZW5ndGggPCBNQVhJTVVNX0FSR1VNRU5UX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmlucHV0KVxuICB9XG5cbiAgcmV0dXJuIGlucHV0LnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzICsgU3RyaW5nLmZyb21DaGFyQ29kZShjdXJyZW50KSwgJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI8VWludDhBcnJheT59IGNvbnRyb2xsZXJcbiAqL1xuZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1DbG9zZSAoY29udHJvbGxlcikge1xuICB0cnkge1xuICAgIGNvbnRyb2xsZXIuY2xvc2UoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBUT0RPOiBhZGQgY29tbWVudCBleHBsYWluaW5nIHdoeSB0aGlzIGVycm9yIG9jY3Vycy5cbiAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdDb250cm9sbGVyIGlzIGFscmVhZHkgY2xvc2VkJykpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2lzb21vcnBoaWMtZW5jb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpY0VuY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gQXNzZXJ0OiBpbnB1dCBjb250YWlucyBubyBjb2RlIHBvaW50cyBncmVhdGVyIHRoYW4gVSswMEZGLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXNzZXJ0KGlucHV0LmNoYXJDb2RlQXQoaSkgPD0gMHhGRilcbiAgfVxuXG4gIC8vIDIuIFJldHVybiBhIGJ5dGUgc2VxdWVuY2Ugd2hvc2UgbGVuZ3RoIGlzIGVxdWFsIHRvIGlucHV04oCZcyBjb2RlXG4gIC8vICAgIHBvaW50IGxlbmd0aCBhbmQgd2hvc2UgYnl0ZXMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gIC8vICAgIHZhbHVlcyBvZiBpbnB1dOKAmXMgY29kZSBwb2ludHMsIGluIHRoZSBzYW1lIG9yZGVyXG4gIHJldHVybiBpbnB1dFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW1kZWZhdWx0cmVhZGVyLXJlYWQtYWxsLWJ5dGVzXG4gKiBAc2VlIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWQtbG9vcFxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJ9IHJlYWRlclxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkQWxsQnl0ZXMgKHJlYWRlcikge1xuICBjb25zdCBieXRlcyA9IFtdXG4gIGxldCBieXRlTGVuZ3RoID0gMFxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZTogY2h1bmsgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcblxuICAgIGlmIChkb25lKSB7XG4gICAgICAvLyAxLiBDYWxsIHN1Y2Nlc3NTdGVwcyB3aXRoIGJ5dGVzLlxuICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnl0ZXMsIGJ5dGVMZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgY2h1bmsgaXMgbm90IGEgVWludDhBcnJheSBvYmplY3QsIGNhbGwgZmFpbHVyZVN0ZXBzXG4gICAgLy8gICAgd2l0aCBhIFR5cGVFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWNlaXZlZCBub24tVWludDhBcnJheSBjaHVuaycpXG4gICAgfVxuXG4gICAgLy8gMi4gQXBwZW5kIHRoZSBieXRlcyByZXByZXNlbnRlZCBieSBjaHVuayB0byBieXRlcy5cbiAgICBieXRlcy5wdXNoKGNodW5rKVxuICAgIGJ5dGVMZW5ndGggKz0gY2h1bmsubGVuZ3RoXG5cbiAgICAvLyAzLiBSZWFkLWxvb3AgZ2l2ZW4gcmVhZGVyLCBieXRlcywgc3VjY2Vzc1N0ZXBzLCBhbmQgZmFpbHVyZVN0ZXBzLlxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaXMtbG9jYWxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSXNMb2NhbCAodXJsKSB7XG4gIGFzc2VydCgncHJvdG9jb2wnIGluIHVybCkgLy8gZW5zdXJlIGl0J3MgYSB1cmwgb2JqZWN0XG5cbiAgY29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2xcblxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHByb3RvY29sID09PSAnYmxvYjonIHx8IHByb3RvY29sID09PSAnZGF0YTonXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSGFzSHR0cHNTY2hlbWUgKHVybCkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpXG4gIH1cblxuICByZXR1cm4gdXJsLnByb3RvY29sID09PSAnaHR0cHM6J1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtc2NoZW1lXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKi9cbmZ1bmN0aW9uIHVybElzSHR0cEh0dHBzU2NoZW1lICh1cmwpIHtcbiAgYXNzZXJ0KCdwcm90b2NvbCcgaW4gdXJsKSAvLyBlbnN1cmUgaXQncyBhIHVybCBvYmplY3RcblxuICBjb25zdCBwcm90b2NvbCA9IHVybC5wcm90b2NvbFxuXG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHA6JyB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzOidcbn1cblxuLyoqXG4gKiBGZXRjaCBzdXBwb3J0cyBub2RlID49IDE2LjguMCwgYnV0IE9iamVjdC5oYXNPd24gd2FzIGFkZGVkIGluIHYxNi45LjAuXG4gKi9cbmNvbnN0IGhhc093biA9IE9iamVjdC5oYXNPd24gfHwgKChkaWN0LCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkaWN0LCBrZXkpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBYm9ydGVkLFxuICBpc0NhbmNlbGxlZCxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIHRvVVNWU3RyaW5nLFxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lLFxuICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICBjbG9uZVBvbGljeUNvbnRhaW5lcixcbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgVEFPQ2hlY2ssXG4gIGNvcnNDaGVjayxcbiAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrLFxuICBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLFxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICBpc1ZhbGlkSFRUUFRva2VuLFxuICByZXF1ZXN0QmFkUG9ydCxcbiAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gIHJlc3BvbnNlVVJMLFxuICByZXNwb25zZUxvY2F0aW9uVVJMLFxuICBpc0Jsb2JMaWtlLFxuICBpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHksXG4gIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gIHNhbWVPcmlnaW4sXG4gIG5vcm1hbGl6ZU1ldGhvZCxcbiAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nLFxuICBtYWtlSXRlcmF0b3IsXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gIGhhc093bixcbiAgaXNFcnJvckxpa2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIGJ5dGVzTWF0Y2gsXG4gIGlzUmVhZGFibGVTdHJlYW1MaWtlLFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBpc29tb3JwaGljRW5jb2RlLFxuICBpc29tb3JwaGljRGVjb2RlLFxuICB1cmxJc0xvY2FsLFxuICB1cmxIYXNIdHRwc1NjaGVtZSxcbiAgdXJsSXNIdHRwSHR0cHNTY2hlbWUsXG4gIHJlYWRBbGxCeXRlc1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fetch/webidl.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/fetch/webidl.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { types } = __webpack_require__(/*! util */ \"util\")\nconst { hasOwn, toUSVString } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fetch/util.js\")\n\n/** @type {import('../../types/webidl').Webidl} */\nconst webidl = {}\nwebidl.converters = {}\nwebidl.util = {}\nwebidl.errors = {}\n\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of'\n  const message =\n    `${context.argument} could not be converted to` +\n    `${plural}: ${context.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  })\n}\n\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I, opts = undefined) {\n  if (opts?.strict !== false && !(V instanceof I)) {\n    throw new TypeError('Illegal invocation')\n  } else {\n    return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag]\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      ...ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return 'Undefined'\n    case 'boolean': return 'Boolean'\n    case 'string': return 'String'\n    case 'symbol': return 'Symbol'\n    case 'number': return 'Number'\n    case 'bigint': return 'BigInt'\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return 'Null'\n      }\n\n      return 'Object'\n    }\n  }\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53  1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be 2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength  1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength  1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength  1  1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is 0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts.enforceRange === true) {\n    // 1. If x is NaN, +, or , then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${V} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than 0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +, or , then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x  2^bitLength  1,\n  //    then return x  2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1  r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Sequence',\n        message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = V?.[Symbol.iterator]?.()\n    const seq = []\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: 'Sequence',\n        message: 'Object is not an iterator.'\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Record',\n        message: `Value of type ${webidl.util.Type(O)} is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // Object.keys only returns enumerable properties\n      const keys = Object.keys(O)\n\n      for (const key of keys) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key])\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key])\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (i) {\n  return (V, opts = {}) => {\n    if (opts.strict !== false && !(V instanceof i)) {\n      throw webidl.errors.exception({\n        header: i.name,\n        message: `Expected ${V} to be an instance of ${i.name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary) => {\n    const type = webidl.util.Type(dictionary)\n    const dict = {}\n\n    if (type === 'Null' || type === 'Undefined') {\n      return dict\n    } else if (type !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Dictionary',\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (!hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: 'Dictionary',\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary[key]\n      const hasDefault = hasOwn(options, 'defaultValue')\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value = value ?? defaultValue\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: 'Dictionary',\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V)\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, opts = {}) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw new TypeError('Could not convert argument of type symbol to string.')\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    const charCode = x.charCodeAt(index)\n\n    if (charCode > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${charCode} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-USVString\nwebidl.converters.USVString = toUSVString\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed')\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned')\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned')\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix: `${V}`,\n      argument: `${V}`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal.\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, opts = {}) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to Ts name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix: `${T.name}`,\n      argument: `${V}`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable array buffers are currently a proposal\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: 'DataView',\n      message: 'Object is not a DataView.'\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, opts = {}) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, opts)\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor)\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, opts)\n  }\n\n  throw new TypeError(`Could not convert ${V} to a BufferSource.`)\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nmodule.exports = {\n  webidl\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC93ZWJpZGwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxRQUFRLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNoQyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsNkRBQVE7O0FBRWhELFdBQVcscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGVBQWUsSUFBSSxnQkFBZ0I7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrQkFBa0I7QUFDekIsT0FBTyxPQUFPLElBQUkseUJBQXlCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWMsa0JBQWtCLGFBQWE7QUFDOUQsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssVUFBVSxzQkFBc0I7QUFDdkQscUJBQXFCLHVCQUF1QixFQUFFLFFBQVE7QUFDdEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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IjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC93ZWJpZGwuanM/MzQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCB7IGhhc093biwgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi90eXBlcy93ZWJpZGwnKS5XZWJpZGx9ICovXG5jb25zdCB3ZWJpZGwgPSB7fVxud2ViaWRsLmNvbnZlcnRlcnMgPSB7fVxud2ViaWRsLnV0aWwgPSB7fVxud2ViaWRsLmVycm9ycyA9IHt9XG5cbndlYmlkbC5lcnJvcnMuZXhjZXB0aW9uID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYCR7bWVzc2FnZS5oZWFkZXJ9OiAke21lc3NhZ2UubWVzc2FnZX1gKVxufVxuXG53ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBwbHVyYWwgPSBjb250ZXh0LnR5cGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJyBvbmUgb2YnXG4gIGNvbnN0IG1lc3NhZ2UgPVxuICAgIGAke2NvbnRleHQuYXJndW1lbnR9IGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG9gICtcbiAgICBgJHtwbHVyYWx9OiAke2NvbnRleHQudHlwZXMuam9pbignLCAnKX0uYFxuXG4gIHJldHVybiB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiBjb250ZXh0LnByZWZpeCxcbiAgICBtZXNzYWdlXG4gIH0pXG59XG5cbndlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgcmV0dXJuIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6IGNvbnRleHQucHJlZml4LFxuICAgIG1lc3NhZ2U6IGBcIiR7Y29udGV4dC52YWx1ZX1cIiBpcyBhbiBpbnZhbGlkICR7Y29udGV4dC50eXBlfS5gXG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jaW1wbGVtZW50c1xud2ViaWRsLmJyYW5kQ2hlY2sgPSBmdW5jdGlvbiAoViwgSSwgb3B0cyA9IHVuZGVmaW5lZCkge1xuICBpZiAob3B0cz8uc3RyaWN0ICE9PSBmYWxzZSAmJiAhKFYgaW5zdGFuY2VvZiBJKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgaW52b2NhdGlvbicpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFY/LltTeW1ib2wudG9TdHJpbmdUYWddID09PSBJLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddXG4gIH1cbn1cblxud2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2sgPSBmdW5jdGlvbiAoeyBsZW5ndGggfSwgbWluLCBjdHgpIHtcbiAgaWYgKGxlbmd0aCA8IG1pbikge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIG1lc3NhZ2U6IGAke21pbn0gYXJndW1lbnQke21pbiAhPT0gMSA/ICdzJyA6ICcnfSByZXF1aXJlZCwgYCArXG4gICAgICAgICAgICAgICBgYnV0JHtsZW5ndGggPyAnIG9ubHknIDogJyd9ICR7bGVuZ3RofSBmb3VuZC5gLFxuICAgICAgLi4uY3R4XG4gICAgfSlcbiAgfVxufVxuXG53ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiAnVHlwZUVycm9yJyxcbiAgICBtZXNzYWdlOiAnSWxsZWdhbCBjb25zdHJ1Y3RvcidcbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xud2ViaWRsLnV0aWwuVHlwZSA9IGZ1bmN0aW9uIChWKSB7XG4gIHN3aXRjaCAodHlwZW9mIFYpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOiByZXR1cm4gJ1VuZGVmaW5lZCdcbiAgICBjYXNlICdib29sZWFuJzogcmV0dXJuICdCb29sZWFuJ1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiAnU3RyaW5nJ1xuICAgIGNhc2UgJ3N5bWJvbCc6IHJldHVybiAnU3ltYm9sJ1xuICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnTnVtYmVyJ1xuICAgIGNhc2UgJ2JpZ2ludCc6IHJldHVybiAnQmlnSW50J1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICBpZiAoViA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ051bGwnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnT2JqZWN0J1xuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWNvbnZlcnR0b2ludFxud2ViaWRsLnV0aWwuQ29udmVydFRvSW50ID0gZnVuY3Rpb24gKFYsIGJpdExlbmd0aCwgc2lnbmVkbmVzcywgb3B0cyA9IHt9KSB7XG4gIGxldCB1cHBlckJvdW5kXG4gIGxldCBsb3dlckJvdW5kXG5cbiAgLy8gMS4gSWYgYml0TGVuZ3RoIGlzIDY0LCB0aGVuOlxuICBpZiAoYml0TGVuZ3RoID09PSA2NCkge1xuICAgIC8vIDEuIExldCB1cHBlckJvdW5kIGJlIDJeNTMg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIDUzKSAtIDFcblxuICAgIC8vIDIuIElmIHNpZ25lZG5lc3MgaXMgXCJ1bnNpZ25lZFwiLCB0aGVuIGxldCBsb3dlckJvdW5kIGJlIDAuXG4gICAgaWYgKHNpZ25lZG5lc3MgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgIGxvd2VyQm91bmQgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDMuIE90aGVyd2lzZSBsZXQgbG93ZXJCb3VuZCBiZSDiiJIyXjUzICsgMS5cbiAgICAgIGxvd2VyQm91bmQgPSBNYXRoLnBvdygtMiwgNTMpICsgMVxuICAgIH1cbiAgfSBlbHNlIGlmIChzaWduZWRuZXNzID09PSAndW5zaWduZWQnKSB7XG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiBzaWduZWRuZXNzIGlzIFwidW5zaWduZWRcIiwgdGhlbjpcblxuICAgIC8vIDEuIExldCBsb3dlckJvdW5kIGJlIDAuXG4gICAgbG93ZXJCb3VuZCA9IDBcblxuICAgIC8vIDIuIExldCB1cHBlckJvdW5kIGJlIDJeYml0TGVuZ3RoIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpIC0gMVxuICB9IGVsc2Uge1xuICAgIC8vIDMuIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIExldCBsb3dlckJvdW5kIGJlIC0yXmJpdExlbmd0aCDiiJIgMS5cbiAgICBsb3dlckJvdW5kID0gTWF0aC5wb3coLTIsIGJpdExlbmd0aCkgLSAxXG5cbiAgICAvLyAyLiBMZXQgdXBwZXJCb3VuZCBiZSAyXmJpdExlbmd0aCDiiJIgMSDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSkgLSAxXG4gIH1cblxuICAvLyA0LiBMZXQgeCBiZSA/IFRvTnVtYmVyKFYpLlxuICBsZXQgeCA9IE51bWJlcihWKVxuXG4gIC8vIDUuIElmIHggaXMg4oiSMCwgdGhlbiBzZXQgeCB0byArMC5cbiAgaWYgKHggPT09IDApIHtcbiAgICB4ID0gMFxuICB9XG5cbiAgLy8gNi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbRW5mb3JjZVJhbmdlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIHRoZW46XG4gIGlmIChvcHRzLmVuZm9yY2VSYW5nZSA9PT0gdHJ1ZSkge1xuICAgIC8vIDEuIElmIHggaXMgTmFOLCAr4oieLCBvciDiiJLiiJ4sIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgTnVtYmVyLmlzTmFOKHgpIHx8XG4gICAgICB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICAgIHggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdJbnRlZ2VyIGNvbnZlcnNpb24nLFxuICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IGNvbnZlcnQgJHtWfSB0byBhbiBpbnRlZ2VyLmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gU2V0IHggdG8gSW50ZWdlclBhcnQoeCkuXG4gICAgeCA9IHdlYmlkbC51dGlsLkludGVnZXJQYXJ0KHgpXG5cbiAgICAvLyAzLiBJZiB4IDwgbG93ZXJCb3VuZCBvciB4ID4gdXBwZXJCb3VuZCwgdGhlblxuICAgIC8vICAgIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdJbnRlZ2VyIGNvbnZlcnNpb24nLFxuICAgICAgICBtZXNzYWdlOiBgVmFsdWUgbXVzdCBiZSBiZXR3ZWVuICR7bG93ZXJCb3VuZH0tJHt1cHBlckJvdW5kfSwgZ290ICR7eH0uYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4geC5cbiAgICByZXR1cm4geFxuICB9XG5cbiAgLy8gNy4gSWYgeCBpcyBub3QgTmFOIGFuZCB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJRExcbiAgLy8gICAgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIFtDbGFtcF0gZXh0ZW5kZWRcbiAgLy8gICAgYXR0cmlidXRlLCB0aGVuOlxuICBpZiAoIU51bWJlci5pc05hTih4KSAmJiBvcHRzLmNsYW1wID09PSB0cnVlKSB7XG4gICAgLy8gMS4gU2V0IHggdG8gbWluKG1heCh4LCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCkuXG4gICAgeCA9IE1hdGgubWluKE1hdGgubWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKVxuXG4gICAgLy8gMi4gUm91bmQgeCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLCBjaG9vc2luZyB0aGVcbiAgICAvLyAgICBldmVuIGludGVnZXIgaWYgaXQgbGllcyBoYWxmd2F5IGJldHdlZW4gdHdvLFxuICAgIC8vICAgIGFuZCBjaG9vc2luZyArMCByYXRoZXIgdGhhbiDiiJIwLlxuICAgIGlmIChNYXRoLmZsb29yKHgpICUgMiA9PT0gMCkge1xuICAgICAgeCA9IE1hdGguZmxvb3IoeClcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IE1hdGguY2VpbCh4KVxuICAgIH1cblxuICAgIC8vIDMuIFJldHVybiB4LlxuICAgIHJldHVybiB4XG4gIH1cblxuICAvLyA4LiBJZiB4IGlzIE5hTiwgKzAsICviiJ4sIG9yIOKIkuKIniwgdGhlbiByZXR1cm4gKzAuXG4gIGlmIChcbiAgICBOdW1iZXIuaXNOYU4oeCkgfHxcbiAgICAoeCA9PT0gMCAmJiBPYmplY3QuaXMoMCwgeCkpIHx8XG4gICAgeCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8XG4gICAgeCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICkge1xuICAgIHJldHVybiAwXG4gIH1cblxuICAvLyA5LiBTZXQgeCB0byBJbnRlZ2VyUGFydCh4KS5cbiAgeCA9IHdlYmlkbC51dGlsLkludGVnZXJQYXJ0KHgpXG5cbiAgLy8gMTAuIFNldCB4IHRvIHggbW9kdWxvIDJeYml0TGVuZ3RoLlxuICB4ID0geCAlIE1hdGgucG93KDIsIGJpdExlbmd0aClcblxuICAvLyAxMS4gSWYgc2lnbmVkbmVzcyBpcyBcInNpZ25lZFwiIGFuZCB4IOKJpSAyXmJpdExlbmd0aCDiiJIgMSxcbiAgLy8gICAgdGhlbiByZXR1cm4geCDiiJIgMl5iaXRMZW5ndGguXG4gIGlmIChzaWduZWRuZXNzID09PSAnc2lnbmVkJyAmJiB4ID49IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxKSB7XG4gICAgcmV0dXJuIHggLSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpXG4gIH1cblxuICAvLyAxMi4gT3RoZXJ3aXNlLCByZXR1cm4geC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNhYnN0cmFjdC1vcGRlZi1pbnRlZ2VycGFydFxud2ViaWRsLnV0aWwuSW50ZWdlclBhcnQgPSBmdW5jdGlvbiAobikge1xuICAvLyAxLiBMZXQgciBiZSBmbG9vcihhYnMobikpLlxuICBjb25zdCByID0gTWF0aC5mbG9vcihNYXRoLmFicyhuKSlcblxuICAvLyAyLiBJZiBuIDwgMCwgdGhlbiByZXR1cm4gLTEgw5cgci5cbiAgaWYgKG4gPCAwKSB7XG4gICAgcmV0dXJuIC0xICogclxuICB9XG5cbiAgLy8gMy4gT3RoZXJ3aXNlLCByZXR1cm4gci5cbiAgcmV0dXJuIHJcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1zZXF1ZW5jZVxud2ViaWRsLnNlcXVlbmNlQ29udmVydGVyID0gZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuICByZXR1cm4gKFYpID0+IHtcbiAgICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0Jykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdTZXF1ZW5jZScsXG4gICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBvZiB0eXBlICR7d2ViaWRsLnV0aWwuVHlwZShWKX0gaXMgbm90IGFuIE9iamVjdC5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCBtZXRob2QgYmUgPyBHZXRNZXRob2QoViwgQEBpdGVyYXRvcikuXG4gICAgLyoqIEB0eXBlIHtHZW5lcmF0b3J9ICovXG4gICAgY29uc3QgbWV0aG9kID0gVj8uW1N5bWJvbC5pdGVyYXRvcl0/LigpXG4gICAgY29uc3Qgc2VxID0gW11cblxuICAgIC8vIDMuIElmIG1ldGhvZCBpcyB1bmRlZmluZWQsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChcbiAgICAgIG1ldGhvZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0eXBlb2YgbWV0aG9kLm5leHQgIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnU2VxdWVuY2UnLFxuICAgICAgICBtZXNzYWdlOiAnT2JqZWN0IGlzIG5vdCBhbiBpdGVyYXRvci4nXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jY3JlYXRlLXNlcXVlbmNlLWZyb20taXRlcmFibGVcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gbWV0aG9kLm5leHQoKVxuXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBzZXEucHVzaChjb252ZXJ0ZXIodmFsdWUpKVxuICAgIH1cblxuICAgIHJldHVybiBzZXFcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXRvLXJlY29yZFxud2ViaWRsLnJlY29yZENvbnZlcnRlciA9IGZ1bmN0aW9uIChrZXlDb252ZXJ0ZXIsIHZhbHVlQ29udmVydGVyKSB7XG4gIHJldHVybiAoTykgPT4ge1xuICAgIC8vIDEuIElmIFR5cGUoTykgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoTykgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1JlY29yZCcsXG4gICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBvZiB0eXBlICR7d2ViaWRsLnV0aWwuVHlwZShPKX0gaXMgbm90IGFuIE9iamVjdC5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCByZXN1bHQgYmUgYSBuZXcgZW1wdHkgaW5zdGFuY2Ugb2YgcmVjb3JkPEssIFY+LlxuICAgIGNvbnN0IHJlc3VsdCA9IHt9XG5cbiAgICBpZiAoIXR5cGVzLmlzUHJveHkoTykpIHtcbiAgICAgIC8vIE9iamVjdC5rZXlzIG9ubHkgcmV0dXJucyBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhPKVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIC8vIDEuIExldCB0eXBlZEtleSBiZSBrZXkgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIEsuXG4gICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5Q29udmVydGVyKGtleSlcblxuICAgICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgPyBHZXQoTywga2V5KS5cbiAgICAgICAgLy8gMy4gTGV0IHR5cGVkVmFsdWUgYmUgdmFsdWUgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIFYuXG4gICAgICAgIGNvbnN0IHR5cGVkVmFsdWUgPSB2YWx1ZUNvbnZlcnRlcihPW2tleV0pXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlc3VsdFt0eXBlZEtleV0gdG8gdHlwZWRWYWx1ZS5cbiAgICAgICAgcmVzdWx0W3R5cGVkS2V5XSA9IHR5cGVkVmFsdWVcbiAgICAgIH1cblxuICAgICAgLy8gNS4gUmV0dXJuIHJlc3VsdC5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQga2V5cyBiZSA/IE8uW1tPd25Qcm9wZXJ0eUtleXNdXSgpLlxuICAgIGNvbnN0IGtleXMgPSBSZWZsZWN0Lm93bktleXMoTylcblxuICAgIC8vIDQuIEZvciBlYWNoIGtleSBvZiBrZXlzLlxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIC8vIDEuIExldCBkZXNjIGJlID8gTy5bW0dldE93blByb3BlcnR5XV0oa2V5KS5cbiAgICAgIGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkpXG5cbiAgICAgIC8vIDIuIElmIGRlc2MgaXMgbm90IHVuZGVmaW5lZCBhbmQgZGVzYy5bW0VudW1lcmFibGVdXSBpcyB0cnVlOlxuICAgICAgaWYgKGRlc2M/LmVudW1lcmFibGUpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGVkS2V5IGJlIGtleSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgSy5cbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXlDb252ZXJ0ZXIoa2V5KVxuXG4gICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSA/IEdldChPLCBrZXkpLlxuICAgICAgICAvLyAzLiBMZXQgdHlwZWRWYWx1ZSBiZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgVi5cbiAgICAgICAgY29uc3QgdHlwZWRWYWx1ZSA9IHZhbHVlQ29udmVydGVyKE9ba2V5XSlcblxuICAgICAgICAvLyA0LiBTZXQgcmVzdWx0W3R5cGVkS2V5XSB0byB0eXBlZFZhbHVlLlxuICAgICAgICByZXN1bHRbdHlwZWRLZXldID0gdHlwZWRWYWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuIFJldHVybiByZXN1bHQuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbndlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gKFYsIG9wdHMgPSB7fSkgPT4ge1xuICAgIGlmIChvcHRzLnN0cmljdCAhPT0gZmFsc2UgJiYgIShWIGluc3RhbmNlb2YgaSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBpLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAke1Z9IHRvIGJlIGFuIGluc3RhbmNlIG9mICR7aS5uYW1lfS5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBWXG4gIH1cbn1cblxud2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVycykge1xuICByZXR1cm4gKGRpY3Rpb25hcnkpID0+IHtcbiAgICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShkaWN0aW9uYXJ5KVxuICAgIGNvbnN0IGRpY3QgPSB7fVxuXG4gICAgaWYgKHR5cGUgPT09ICdOdWxsJyB8fCB0eXBlID09PSAnVW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRpY3RcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0RpY3Rpb25hcnknLFxuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJHtkaWN0aW9uYXJ5fSB0byBiZSBvbmUgb2Y6IE51bGwsIFVuZGVmaW5lZCwgT2JqZWN0LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBvcHRpb25zIG9mIGNvbnZlcnRlcnMpIHtcbiAgICAgIGNvbnN0IHsga2V5LCBkZWZhdWx0VmFsdWUsIHJlcXVpcmVkLCBjb252ZXJ0ZXIgfSA9IG9wdGlvbnNcblxuICAgICAgaWYgKHJlcXVpcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICghaGFzT3duKGRpY3Rpb25hcnksIGtleSkpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdEaWN0aW9uYXJ5JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBNaXNzaW5nIHJlcXVpcmVkIGtleSBcIiR7a2V5fVwiLmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCB2YWx1ZSA9IGRpY3Rpb25hcnlba2V5XVxuICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHRpb25zLCAnZGVmYXVsdFZhbHVlJylcblxuICAgICAgLy8gT25seSB1c2UgZGVmYXVsdFZhbHVlIGlmIHZhbHVlIGlzIHVuZGVmaW5lZCBhbmRcbiAgICAgIC8vIGEgZGVmYXVsdFZhbHVlIG9wdGlvbnMgd2FzIHByb3ZpZGVkLlxuICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA/PyBkZWZhdWx0VmFsdWVcbiAgICAgIH1cblxuICAgICAgLy8gQSBrZXkgY2FuIGJlIG9wdGlvbmFsIGFuZCBoYXZlIG5vIGRlZmF1bHQgdmFsdWUuXG4gICAgICAvLyBXaGVuIHRoaXMgaGFwcGVucywgZG8gbm90IHBlcmZvcm0gYSBjb252ZXJzaW9uLFxuICAgICAgLy8gYW5kIGRvIG5vdCBhc3NpZ24gdGhlIGtleSBhIHZhbHVlLlxuICAgICAgaWYgKHJlcXVpcmVkIHx8IGhhc0RlZmF1bHQgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IGNvbnZlcnRlcih2YWx1ZSlcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgb3B0aW9ucy5hbGxvd2VkVmFsdWVzICYmXG4gICAgICAgICAgIW9wdGlvbnMuYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiAnRGljdGlvbmFyeScsXG4gICAgICAgICAgICBtZXNzYWdlOiBgJHt2YWx1ZX0gaXMgbm90IGFuIGFjY2VwdGVkIHR5cGUuIEV4cGVjdGVkIG9uZSBvZiAke29wdGlvbnMuYWxsb3dlZFZhbHVlcy5qb2luKCcsICcpfS5gXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGRpY3Rba2V5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpY3RcbiAgfVxufVxuXG53ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XG4gIHJldHVybiAoVikgPT4ge1xuICAgIGlmIChWID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gVlxuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0ZXIoVilcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLURPTVN0cmluZ1xud2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nID0gZnVuY3Rpb24gKFYsIG9wdHMgPSB7fSkge1xuICAvLyAxLiBJZiBWIGlzIG51bGwgYW5kIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETCB0eXBlXG4gIC8vICAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgW0xlZ2FjeU51bGxUb0VtcHR5U3RyaW5nXVxuICAvLyAgICBleHRlbmRlZCBhdHRyaWJ1dGUsIHRoZW4gcmV0dXJuIHRoZSBET01TdHJpbmcgdmFsdWVcbiAgLy8gICAgdGhhdCByZXByZXNlbnRzIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGlmIChWID09PSBudWxsICYmIG9wdHMubGVnYWN5TnVsbFRvRW1wdHlTdHJpbmcpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIDIuIExldCB4IGJlID8gVG9TdHJpbmcoVikuXG4gIGlmICh0eXBlb2YgViA9PT0gJ3N5bWJvbCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlIHN5bWJvbCB0byBzdHJpbmcuJylcbiAgfVxuXG4gIC8vIDMuIFJldHVybiB0aGUgSURMIERPTVN0cmluZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlXG4gIC8vICAgIHNhbWUgc2VxdWVuY2Ugb2YgY29kZSB1bml0cyBhcyB0aGUgb25lIHRoZVxuICAvLyAgICBFQ01BU2NyaXB0IFN0cmluZyB2YWx1ZSB4IHJlcHJlc2VudHMuXG4gIHJldHVybiBTdHJpbmcoVilcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1CeXRlU3RyaW5nXG53ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBUb1N0cmluZyhWKS5cbiAgLy8gTm90ZTogRE9NU3RyaW5nIGNvbnZlcnRlciBwZXJmb3JtID8gVG9TdHJpbmcoVilcbiAgY29uc3QgeCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWKVxuXG4gIC8vIDIuIElmIHRoZSB2YWx1ZSBvZiBhbnkgZWxlbWVudCBvZiB4IGlzIGdyZWF0ZXIgdGhhblxuICAvLyAgICAyNTUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGNoYXJDb2RlID0geC5jaGFyQ29kZUF0KGluZGV4KVxuXG4gICAgaWYgKGNoYXJDb2RlID4gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgdG8gYSBCeXRlU3RyaW5nIGJlY2F1c2UgdGhlIGNoYXJhY3RlciBhdCAnICtcbiAgICAgICAgYGluZGV4ICR7aW5kZXh9IGhhcyBhIHZhbHVlIG9mICR7Y2hhckNvZGV9IHdoaWNoIGlzIGdyZWF0ZXIgdGhhbiAyNTUuYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFJldHVybiBhbiBJREwgQnl0ZVN0cmluZyB2YWx1ZSB3aG9zZSBsZW5ndGggaXMgdGhlXG4gIC8vICAgIGxlbmd0aCBvZiB4LCBhbmQgd2hlcmUgdGhlIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBpc1xuICAvLyAgICB0aGUgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBvZiB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLVVTVlN0cmluZ1xud2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nID0gdG9VU1ZTdHJpbmdcblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1ib29sZWFuXG53ZWJpZGwuY29udmVydGVycy5ib29sZWFuID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgdGhlIHJlc3VsdCBvZiBjb21wdXRpbmcgVG9Cb29sZWFuKFYpLlxuICBjb25zdCB4ID0gQm9vbGVhbihWKVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIGJvb2xlYW4gdmFsdWUgdGhhdCBpcyB0aGUgb25lIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSB0cnV0aCB2YWx1ZSBhcyB0aGUgRUNNQVNjcmlwdCBCb29sZWFuIHZhbHVlIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtYW55XG53ZWJpZGwuY29udmVydGVycy5hbnkgPSBmdW5jdGlvbiAoVikge1xuICByZXR1cm4gVlxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWxvbmctbG9uZ1xud2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgNjQsIFwic2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDY0LCAnc2lnbmVkJylcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCBsb25nIGxvbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1sb25nLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSA9IGZ1bmN0aW9uIChWKSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDY0LCBcInVuc2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDY0LCAndW5zaWduZWQnKVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIHVuc2lnbmVkIGxvbmcgbG9uZyB2YWx1ZSB0aGF0XG4gIC8vICAgIHJlcHJlc2VudHMgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10gPSBmdW5jdGlvbiAoVikge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCAzMiwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCAzMiwgJ3Vuc2lnbmVkJylcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBsb25nIHZhbHVlIHRoYXRcbiAgLy8gICAgcmVwcmVzZW50cyB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtc2hvcnRcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgMTYsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgMTYsICd1bnNpZ25lZCcsIG9wdHMpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgc2hvcnQgdmFsdWUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpZGwtQXJyYXlCdWZmZXJcbndlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyID0gZnVuY3Rpb24gKFYsIG9wdHMgPSB7fSkge1xuICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhblxuICAvLyAgICBbW0FycmF5QnVmZmVyRGF0YV1dIGludGVybmFsIHNsb3QsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIC8vIHNlZTogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1hcnJheWJ1ZmZlci1pbnN0YW5jZXNcbiAgLy8gc2VlOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLXNoYXJlZGFycmF5YnVmZmVyLWluc3RhbmNlc1xuICBpZiAoXG4gICAgd2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gJ09iamVjdCcgfHxcbiAgICAhdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKVxuICApIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4OiBgJHtWfWAsXG4gICAgICBhcmd1bWVudDogYCR7Vn1gLFxuICAgICAgdHlwZXM6IFsnQXJyYXlCdWZmZXInXVxuICAgIH0pXG4gIH1cblxuICAvLyAyLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dTaGFyZWRdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzU2hhcmVkQXJyYXlCdWZmZXIoVikgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgaWYgKG9wdHMuYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuJ1xuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVikgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgLy8gTm90ZTogcmVzaXphYmxlIEFycmF5QnVmZmVycyBhcmUgY3VycmVudGx5IGEgcHJvcG9zYWwuXG5cbiAgLy8gNC4gUmV0dXJuIHRoZSBJREwgQXJyYXlCdWZmZXIgdmFsdWUgdGhhdCBpcyBhXG4gIC8vICAgIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChWLCBULCBvcHRzID0ge30pIHtcbiAgLy8gMS4gTGV0IFQgYmUgdGhlIElETCB0eXBlIFYgaXMgYmVpbmcgY29udmVydGVkIHRvLlxuXG4gIC8vIDIuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgb3IgViBkb2VzIG5vdCBoYXZlIGFcbiAgLy8gICAgW1tUeXBlZEFycmF5TmFtZV1dIGludGVybmFsIHNsb3Qgd2l0aCBhIHZhbHVlXG4gIC8vICAgIGVxdWFsIHRvIFTigJlzIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChcbiAgICB3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0JyB8fFxuICAgICF0eXBlcy5pc1R5cGVkQXJyYXkoVikgfHxcbiAgICBWLmNvbnN0cnVjdG9yLm5hbWUgIT09IFQubmFtZVxuICApIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4OiBgJHtULm5hbWV9YCxcbiAgICAgIGFyZ3VtZW50OiBgJHtWfWAsXG4gICAgICB0eXBlczogW1QubmFtZV1cbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpc1xuICAvLyAgICB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAob3B0cy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuJ1xuICAgIH0pXG4gIH1cblxuICAvLyA0LiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzXG4gIC8vICAgIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIC8vIE5vdGU6IHJlc2l6YWJsZSBhcnJheSBidWZmZXJzIGFyZSBjdXJyZW50bHkgYSBwcm9wb3NhbFxuXG4gIC8vIDUuIFJldHVybiB0aGUgSURMIHZhbHVlIG9mIHR5cGUgVCB0aGF0IGlzIGEgcmVmZXJlbmNlXG4gIC8vICAgIHRvIHRoZSBzYW1lIG9iamVjdCBhcyBWLlxuICByZXR1cm4gVlxufVxuXG53ZWJpZGwuY29udmVydGVycy5EYXRhVmlldyA9IGZ1bmN0aW9uIChWLCBvcHRzID0ge30pIHtcbiAgLy8gMS4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYVxuICAvLyAgICBbW0RhdGFWaWV3XV0gaW50ZXJuYWwgc2xvdCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnIHx8ICF0eXBlcy5pc0RhdGFWaWV3KFYpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnRGF0YVZpZXcnLFxuICAgICAgbWVzc2FnZTogJ09iamVjdCBpcyBub3QgYSBEYXRhVmlldy4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDIuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKG9wdHMuYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVi5idWZmZXIpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1NoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLidcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93UmVzaXphYmxlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1Jlc2l6YWJsZUFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpc1xuICAvLyAgICB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAvLyBOb3RlOiByZXNpemFibGUgQXJyYXlCdWZmZXJzIGFyZSBjdXJyZW50bHkgYSBwcm9wb3NhbFxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIERhdGFWaWV3IHZhbHVlIHRoYXQgaXMgYSByZWZlcmVuY2VcbiAgLy8gICAgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jQnVmZmVyU291cmNlXG53ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoViwgb3B0cyA9IHt9KSB7XG4gIGlmICh0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyKFYsIG9wdHMpXG4gIH1cblxuICBpZiAodHlwZXMuaXNUeXBlZEFycmF5KFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlR5cGVkQXJyYXkoViwgVi5jb25zdHJ1Y3RvcilcbiAgfVxuXG4gIGlmICh0eXBlcy5pc0RhdGFWaWV3KFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkRhdGFWaWV3KFYsIG9wdHMpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDb3VsZCBub3QgY29udmVydCAke1Z9IHRvIGEgQnVmZmVyU291cmNlLmApXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCeXRlU3RyaW5nPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPEJ5dGVTdHJpbmc+J11cbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3JlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiddID0gd2ViaWRsLnJlY29yZENvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyxcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd2ViaWRsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fetch/webidl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fileapi/encoding.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/encoding.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * @see https://encoding.spec.whatwg.org/#concept-encoding-get\n * @param {string|undefined} label\n */\nfunction getEncoding (label) {\n  if (!label) {\n    return 'failure'\n  }\n\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  // 2. If label is an ASCII case-insensitive match for any of the\n  //    labels listed in the table below, then return the\n  //    corresponding encoding; otherwise return failure.\n  switch (label.trim().toLowerCase()) {\n    case 'unicode-1-1-utf-8':\n    case 'unicode11utf8':\n    case 'unicode20utf8':\n    case 'utf-8':\n    case 'utf8':\n    case 'x-unicode20utf8':\n      return 'UTF-8'\n    case '866':\n    case 'cp866':\n    case 'csibm866':\n    case 'ibm866':\n      return 'IBM866'\n    case 'csisolatin2':\n    case 'iso-8859-2':\n    case 'iso-ir-101':\n    case 'iso8859-2':\n    case 'iso88592':\n    case 'iso_8859-2':\n    case 'iso_8859-2:1987':\n    case 'l2':\n    case 'latin2':\n      return 'ISO-8859-2'\n    case 'csisolatin3':\n    case 'iso-8859-3':\n    case 'iso-ir-109':\n    case 'iso8859-3':\n    case 'iso88593':\n    case 'iso_8859-3':\n    case 'iso_8859-3:1988':\n    case 'l3':\n    case 'latin3':\n      return 'ISO-8859-3'\n    case 'csisolatin4':\n    case 'iso-8859-4':\n    case 'iso-ir-110':\n    case 'iso8859-4':\n    case 'iso88594':\n    case 'iso_8859-4':\n    case 'iso_8859-4:1988':\n    case 'l4':\n    case 'latin4':\n      return 'ISO-8859-4'\n    case 'csisolatincyrillic':\n    case 'cyrillic':\n    case 'iso-8859-5':\n    case 'iso-ir-144':\n    case 'iso8859-5':\n    case 'iso88595':\n    case 'iso_8859-5':\n    case 'iso_8859-5:1988':\n      return 'ISO-8859-5'\n    case 'arabic':\n    case 'asmo-708':\n    case 'csiso88596e':\n    case 'csiso88596i':\n    case 'csisolatinarabic':\n    case 'ecma-114':\n    case 'iso-8859-6':\n    case 'iso-8859-6-e':\n    case 'iso-8859-6-i':\n    case 'iso-ir-127':\n    case 'iso8859-6':\n    case 'iso88596':\n    case 'iso_8859-6':\n    case 'iso_8859-6:1987':\n      return 'ISO-8859-6'\n    case 'csisolatingreek':\n    case 'ecma-118':\n    case 'elot_928':\n    case 'greek':\n    case 'greek8':\n    case 'iso-8859-7':\n    case 'iso-ir-126':\n    case 'iso8859-7':\n    case 'iso88597':\n    case 'iso_8859-7':\n    case 'iso_8859-7:1987':\n    case 'sun_eu_greek':\n      return 'ISO-8859-7'\n    case 'csiso88598e':\n    case 'csisolatinhebrew':\n    case 'hebrew':\n    case 'iso-8859-8':\n    case 'iso-8859-8-e':\n    case 'iso-ir-138':\n    case 'iso8859-8':\n    case 'iso88598':\n    case 'iso_8859-8':\n    case 'iso_8859-8:1988':\n    case 'visual':\n      return 'ISO-8859-8'\n    case 'csiso88598i':\n    case 'iso-8859-8-i':\n    case 'logical':\n      return 'ISO-8859-8-I'\n    case 'csisolatin6':\n    case 'iso-8859-10':\n    case 'iso-ir-157':\n    case 'iso8859-10':\n    case 'iso885910':\n    case 'l6':\n    case 'latin6':\n      return 'ISO-8859-10'\n    case 'iso-8859-13':\n    case 'iso8859-13':\n    case 'iso885913':\n      return 'ISO-8859-13'\n    case 'iso-8859-14':\n    case 'iso8859-14':\n    case 'iso885914':\n      return 'ISO-8859-14'\n    case 'csisolatin9':\n    case 'iso-8859-15':\n    case 'iso8859-15':\n    case 'iso885915':\n    case 'iso_8859-15':\n    case 'l9':\n      return 'ISO-8859-15'\n    case 'iso-8859-16':\n      return 'ISO-8859-16'\n    case 'cskoi8r':\n    case 'koi':\n    case 'koi8':\n    case 'koi8-r':\n    case 'koi8_r':\n      return 'KOI8-R'\n    case 'koi8-ru':\n    case 'koi8-u':\n      return 'KOI8-U'\n    case 'csmacintosh':\n    case 'mac':\n    case 'macintosh':\n    case 'x-mac-roman':\n      return 'macintosh'\n    case 'iso-8859-11':\n    case 'iso8859-11':\n    case 'iso885911':\n    case 'tis-620':\n    case 'windows-874':\n      return 'windows-874'\n    case 'cp1250':\n    case 'windows-1250':\n    case 'x-cp1250':\n      return 'windows-1250'\n    case 'cp1251':\n    case 'windows-1251':\n    case 'x-cp1251':\n      return 'windows-1251'\n    case 'ansi_x3.4-1968':\n    case 'ascii':\n    case 'cp1252':\n    case 'cp819':\n    case 'csisolatin1':\n    case 'ibm819':\n    case 'iso-8859-1':\n    case 'iso-ir-100':\n    case 'iso8859-1':\n    case 'iso88591':\n    case 'iso_8859-1':\n    case 'iso_8859-1:1987':\n    case 'l1':\n    case 'latin1':\n    case 'us-ascii':\n    case 'windows-1252':\n    case 'x-cp1252':\n      return 'windows-1252'\n    case 'cp1253':\n    case 'windows-1253':\n    case 'x-cp1253':\n      return 'windows-1253'\n    case 'cp1254':\n    case 'csisolatin5':\n    case 'iso-8859-9':\n    case 'iso-ir-148':\n    case 'iso8859-9':\n    case 'iso88599':\n    case 'iso_8859-9':\n    case 'iso_8859-9:1989':\n    case 'l5':\n    case 'latin5':\n    case 'windows-1254':\n    case 'x-cp1254':\n      return 'windows-1254'\n    case 'cp1255':\n    case 'windows-1255':\n    case 'x-cp1255':\n      return 'windows-1255'\n    case 'cp1256':\n    case 'windows-1256':\n    case 'x-cp1256':\n      return 'windows-1256'\n    case 'cp1257':\n    case 'windows-1257':\n    case 'x-cp1257':\n      return 'windows-1257'\n    case 'cp1258':\n    case 'windows-1258':\n    case 'x-cp1258':\n      return 'windows-1258'\n    case 'x-mac-cyrillic':\n    case 'x-mac-ukrainian':\n      return 'x-mac-cyrillic'\n    case 'chinese':\n    case 'csgb2312':\n    case 'csiso58gb231280':\n    case 'gb2312':\n    case 'gb_2312':\n    case 'gb_2312-80':\n    case 'gbk':\n    case 'iso-ir-58':\n    case 'x-gbk':\n      return 'GBK'\n    case 'gb18030':\n      return 'gb18030'\n    case 'big5':\n    case 'big5-hkscs':\n    case 'cn-big5':\n    case 'csbig5':\n    case 'x-x-big5':\n      return 'Big5'\n    case 'cseucpkdfmtjapanese':\n    case 'euc-jp':\n    case 'x-euc-jp':\n      return 'EUC-JP'\n    case 'csiso2022jp':\n    case 'iso-2022-jp':\n      return 'ISO-2022-JP'\n    case 'csshiftjis':\n    case 'ms932':\n    case 'ms_kanji':\n    case 'shift-jis':\n    case 'shift_jis':\n    case 'sjis':\n    case 'windows-31j':\n    case 'x-sjis':\n      return 'Shift_JIS'\n    case 'cseuckr':\n    case 'csksc56011987':\n    case 'euc-kr':\n    case 'iso-ir-149':\n    case 'korean':\n    case 'ks_c_5601-1987':\n    case 'ks_c_5601-1989':\n    case 'ksc5601':\n    case 'ksc_5601':\n    case 'windows-949':\n      return 'EUC-KR'\n    case 'csiso2022kr':\n    case 'hz-gb-2312':\n    case 'iso-2022-cn':\n    case 'iso-2022-cn-ext':\n    case 'iso-2022-kr':\n    case 'replacement':\n      return 'replacement'\n    case 'unicodefffe':\n    case 'utf-16be':\n      return 'UTF-16BE'\n    case 'csunicode':\n    case 'iso-10646-ucs-2':\n    case 'ucs-2':\n    case 'unicode':\n    case 'unicodefeff':\n    case 'utf-16':\n    case 'utf-16le':\n      return 'UTF-16LE'\n    case 'x-user-defined':\n      return 'x-user-defined'\n    default: return 'failure'\n  }\n}\n\nmodule.exports = {\n  getEncoding\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL2VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL2VuY29kaW5nLmpzP2I1ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1lbmNvZGluZy1nZXRcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gbGFiZWxcbiAqL1xuZnVuY3Rpb24gZ2V0RW5jb2RpbmcgKGxhYmVsKSB7XG4gIGlmICghbGFiZWwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxLiBSZW1vdmUgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEFTQ0lJIHdoaXRlc3BhY2UgZnJvbSBsYWJlbC5cbiAgLy8gMi4gSWYgbGFiZWwgaXMgYW4gQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYW55IG9mIHRoZVxuICAvLyAgICBsYWJlbHMgbGlzdGVkIGluIHRoZSB0YWJsZSBiZWxvdywgdGhlbiByZXR1cm4gdGhlXG4gIC8vICAgIGNvcnJlc3BvbmRpbmcgZW5jb2Rpbmc7IG90aGVyd2lzZSByZXR1cm4gZmFpbHVyZS5cbiAgc3dpdGNoIChsYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3VuaWNvZGUtMS0xLXV0Zi04JzpcbiAgICBjYXNlICd1bmljb2RlMTF1dGY4JzpcbiAgICBjYXNlICd1bmljb2RlMjB1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAneC11bmljb2RlMjB1dGY4JzpcbiAgICAgIHJldHVybiAnVVRGLTgnXG4gICAgY2FzZSAnODY2JzpcbiAgICBjYXNlICdjcDg2Nic6XG4gICAgY2FzZSAnY3NpYm04NjYnOlxuICAgIGNhc2UgJ2libTg2Nic6XG4gICAgICByZXR1cm4gJ0lCTTg2NidcbiAgICBjYXNlICdjc2lzb2xhdGluMic6XG4gICAgY2FzZSAnaXNvLTg4NTktMic6XG4gICAgY2FzZSAnaXNvLWlyLTEwMSc6XG4gICAgY2FzZSAnaXNvODg1OS0yJzpcbiAgICBjYXNlICdpc284ODU5Mic6XG4gICAgY2FzZSAnaXNvXzg4NTktMic6XG4gICAgY2FzZSAnaXNvXzg4NTktMjoxOTg3JzpcbiAgICBjYXNlICdsMic6XG4gICAgY2FzZSAnbGF0aW4yJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMidcbiAgICBjYXNlICdjc2lzb2xhdGluMyc6XG4gICAgY2FzZSAnaXNvLTg4NTktMyc6XG4gICAgY2FzZSAnaXNvLWlyLTEwOSc6XG4gICAgY2FzZSAnaXNvODg1OS0zJzpcbiAgICBjYXNlICdpc284ODU5Myc6XG4gICAgY2FzZSAnaXNvXzg4NTktMyc6XG4gICAgY2FzZSAnaXNvXzg4NTktMzoxOTg4JzpcbiAgICBjYXNlICdsMyc6XG4gICAgY2FzZSAnbGF0aW4zJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMydcbiAgICBjYXNlICdjc2lzb2xhdGluNCc6XG4gICAgY2FzZSAnaXNvLTg4NTktNCc6XG4gICAgY2FzZSAnaXNvLWlyLTExMCc6XG4gICAgY2FzZSAnaXNvODg1OS00JzpcbiAgICBjYXNlICdpc284ODU5NCc6XG4gICAgY2FzZSAnaXNvXzg4NTktNCc6XG4gICAgY2FzZSAnaXNvXzg4NTktNDoxOTg4JzpcbiAgICBjYXNlICdsNCc6XG4gICAgY2FzZSAnbGF0aW40JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNCdcbiAgICBjYXNlICdjc2lzb2xhdGluY3lyaWxsaWMnOlxuICAgIGNhc2UgJ2N5cmlsbGljJzpcbiAgICBjYXNlICdpc28tODg1OS01JzpcbiAgICBjYXNlICdpc28taXItMTQ0JzpcbiAgICBjYXNlICdpc284ODU5LTUnOlxuICAgIGNhc2UgJ2lzbzg4NTk1JzpcbiAgICBjYXNlICdpc29fODg1OS01JzpcbiAgICBjYXNlICdpc29fODg1OS01OjE5ODgnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS01J1xuICAgIGNhc2UgJ2FyYWJpYyc6XG4gICAgY2FzZSAnYXNtby03MDgnOlxuICAgIGNhc2UgJ2NzaXNvODg1OTZlJzpcbiAgICBjYXNlICdjc2lzbzg4NTk2aSc6XG4gICAgY2FzZSAnY3Npc29sYXRpbmFyYWJpYyc6XG4gICAgY2FzZSAnZWNtYS0xMTQnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYtZSc6XG4gICAgY2FzZSAnaXNvLTg4NTktNi1pJzpcbiAgICBjYXNlICdpc28taXItMTI3JzpcbiAgICBjYXNlICdpc284ODU5LTYnOlxuICAgIGNhc2UgJ2lzbzg4NTk2JzpcbiAgICBjYXNlICdpc29fODg1OS02JzpcbiAgICBjYXNlICdpc29fODg1OS02OjE5ODcnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS02J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW5ncmVlayc6XG4gICAgY2FzZSAnZWNtYS0xMTgnOlxuICAgIGNhc2UgJ2Vsb3RfOTI4JzpcbiAgICBjYXNlICdncmVlayc6XG4gICAgY2FzZSAnZ3JlZWs4JzpcbiAgICBjYXNlICdpc28tODg1OS03JzpcbiAgICBjYXNlICdpc28taXItMTI2JzpcbiAgICBjYXNlICdpc284ODU5LTcnOlxuICAgIGNhc2UgJ2lzbzg4NTk3JzpcbiAgICBjYXNlICdpc29fODg1OS03JzpcbiAgICBjYXNlICdpc29fODg1OS03OjE5ODcnOlxuICAgIGNhc2UgJ3N1bl9ldV9ncmVlayc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTcnXG4gICAgY2FzZSAnY3Npc284ODU5OGUnOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW5oZWJyZXcnOlxuICAgIGNhc2UgJ2hlYnJldyc6XG4gICAgY2FzZSAnaXNvLTg4NTktOCc6XG4gICAgY2FzZSAnaXNvLTg4NTktOC1lJzpcbiAgICBjYXNlICdpc28taXItMTM4JzpcbiAgICBjYXNlICdpc284ODU5LTgnOlxuICAgIGNhc2UgJ2lzbzg4NTk4JzpcbiAgICBjYXNlICdpc29fODg1OS04JzpcbiAgICBjYXNlICdpc29fODg1OS04OjE5ODgnOlxuICAgIGNhc2UgJ3Zpc3VhbCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTgnXG4gICAgY2FzZSAnY3Npc284ODU5OGknOlxuICAgIGNhc2UgJ2lzby04ODU5LTgtaSc6XG4gICAgY2FzZSAnbG9naWNhbCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTgtSSdcbiAgICBjYXNlICdjc2lzb2xhdGluNic6XG4gICAgY2FzZSAnaXNvLTg4NTktMTAnOlxuICAgIGNhc2UgJ2lzby1pci0xNTcnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTAnOlxuICAgIGNhc2UgJ2lzbzg4NTkxMCc6XG4gICAgY2FzZSAnbDYnOlxuICAgIGNhc2UgJ2xhdGluNic6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTEwJ1xuICAgIGNhc2UgJ2lzby04ODU5LTEzJzpcbiAgICBjYXNlICdpc284ODU5LTEzJzpcbiAgICBjYXNlICdpc284ODU5MTMnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xMydcbiAgICBjYXNlICdpc28tODg1OS0xNCc6XG4gICAgY2FzZSAnaXNvODg1OS0xNCc6XG4gICAgY2FzZSAnaXNvODg1OTE0JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTQnXG4gICAgY2FzZSAnY3Npc29sYXRpbjknOlxuICAgIGNhc2UgJ2lzby04ODU5LTE1JzpcbiAgICBjYXNlICdpc284ODU5LTE1JzpcbiAgICBjYXNlICdpc284ODU5MTUnOlxuICAgIGNhc2UgJ2lzb184ODU5LTE1JzpcbiAgICBjYXNlICdsOSc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTE1J1xuICAgIGNhc2UgJ2lzby04ODU5LTE2JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTYnXG4gICAgY2FzZSAnY3Nrb2k4cic6XG4gICAgY2FzZSAna29pJzpcbiAgICBjYXNlICdrb2k4JzpcbiAgICBjYXNlICdrb2k4LXInOlxuICAgIGNhc2UgJ2tvaThfcic6XG4gICAgICByZXR1cm4gJ0tPSTgtUidcbiAgICBjYXNlICdrb2k4LXJ1JzpcbiAgICBjYXNlICdrb2k4LXUnOlxuICAgICAgcmV0dXJuICdLT0k4LVUnXG4gICAgY2FzZSAnY3NtYWNpbnRvc2gnOlxuICAgIGNhc2UgJ21hYyc6XG4gICAgY2FzZSAnbWFjaW50b3NoJzpcbiAgICBjYXNlICd4LW1hYy1yb21hbic6XG4gICAgICByZXR1cm4gJ21hY2ludG9zaCdcbiAgICBjYXNlICdpc28tODg1OS0xMSc6XG4gICAgY2FzZSAnaXNvODg1OS0xMSc6XG4gICAgY2FzZSAnaXNvODg1OTExJzpcbiAgICBjYXNlICd0aXMtNjIwJzpcbiAgICBjYXNlICd3aW5kb3dzLTg3NCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtODc0J1xuICAgIGNhc2UgJ2NwMTI1MCc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUwJzpcbiAgICBjYXNlICd4LWNwMTI1MCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MCdcbiAgICBjYXNlICdjcDEyNTEnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1MSc6XG4gICAgY2FzZSAneC1jcDEyNTEnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTEnXG4gICAgY2FzZSAnYW5zaV94My40LTE5NjgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdjcDEyNTInOlxuICAgIGNhc2UgJ2NwODE5JzpcbiAgICBjYXNlICdjc2lzb2xhdGluMSc6XG4gICAgY2FzZSAnaWJtODE5JzpcbiAgICBjYXNlICdpc28tODg1OS0xJzpcbiAgICBjYXNlICdpc28taXItMTAwJzpcbiAgICBjYXNlICdpc284ODU5LTEnOlxuICAgIGNhc2UgJ2lzbzg4NTkxJzpcbiAgICBjYXNlICdpc29fODg1OS0xJzpcbiAgICBjYXNlICdpc29fODg1OS0xOjE5ODcnOlxuICAgIGNhc2UgJ2wxJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ3VzLWFzY2lpJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTInOlxuICAgIGNhc2UgJ3gtY3AxMjUyJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUyJ1xuICAgIGNhc2UgJ2NwMTI1Myc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUzJzpcbiAgICBjYXNlICd4LWNwMTI1Myc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MydcbiAgICBjYXNlICdjcDEyNTQnOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW41JzpcbiAgICBjYXNlICdpc28tODg1OS05JzpcbiAgICBjYXNlICdpc28taXItMTQ4JzpcbiAgICBjYXNlICdpc284ODU5LTknOlxuICAgIGNhc2UgJ2lzbzg4NTk5JzpcbiAgICBjYXNlICdpc29fODg1OS05JzpcbiAgICBjYXNlICdpc29fODg1OS05OjE5ODknOlxuICAgIGNhc2UgJ2w1JzpcbiAgICBjYXNlICdsYXRpbjUnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1NCc6XG4gICAgY2FzZSAneC1jcDEyNTQnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTQnXG4gICAgY2FzZSAnY3AxMjU1JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTUnOlxuICAgIGNhc2UgJ3gtY3AxMjU1JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU1J1xuICAgIGNhc2UgJ2NwMTI1Nic6XG4gICAgY2FzZSAnd2luZG93cy0xMjU2JzpcbiAgICBjYXNlICd4LWNwMTI1Nic6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NidcbiAgICBjYXNlICdjcDEyNTcnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Nyc6XG4gICAgY2FzZSAneC1jcDEyNTcnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTcnXG4gICAgY2FzZSAnY3AxMjU4JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTgnOlxuICAgIGNhc2UgJ3gtY3AxMjU4JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU4J1xuICAgIGNhc2UgJ3gtbWFjLWN5cmlsbGljJzpcbiAgICBjYXNlICd4LW1hYy11a3JhaW5pYW4nOlxuICAgICAgcmV0dXJuICd4LW1hYy1jeXJpbGxpYydcbiAgICBjYXNlICdjaGluZXNlJzpcbiAgICBjYXNlICdjc2diMjMxMic6XG4gICAgY2FzZSAnY3Npc281OGdiMjMxMjgwJzpcbiAgICBjYXNlICdnYjIzMTInOlxuICAgIGNhc2UgJ2diXzIzMTInOlxuICAgIGNhc2UgJ2diXzIzMTItODAnOlxuICAgIGNhc2UgJ2diayc6XG4gICAgY2FzZSAnaXNvLWlyLTU4JzpcbiAgICBjYXNlICd4LWdiayc6XG4gICAgICByZXR1cm4gJ0dCSydcbiAgICBjYXNlICdnYjE4MDMwJzpcbiAgICAgIHJldHVybiAnZ2IxODAzMCdcbiAgICBjYXNlICdiaWc1JzpcbiAgICBjYXNlICdiaWc1LWhrc2NzJzpcbiAgICBjYXNlICdjbi1iaWc1JzpcbiAgICBjYXNlICdjc2JpZzUnOlxuICAgIGNhc2UgJ3gteC1iaWc1JzpcbiAgICAgIHJldHVybiAnQmlnNSdcbiAgICBjYXNlICdjc2V1Y3BrZGZtdGphcGFuZXNlJzpcbiAgICBjYXNlICdldWMtanAnOlxuICAgIGNhc2UgJ3gtZXVjLWpwJzpcbiAgICAgIHJldHVybiAnRVVDLUpQJ1xuICAgIGNhc2UgJ2NzaXNvMjAyMmpwJzpcbiAgICBjYXNlICdpc28tMjAyMi1qcCc6XG4gICAgICByZXR1cm4gJ0lTTy0yMDIyLUpQJ1xuICAgIGNhc2UgJ2Nzc2hpZnRqaXMnOlxuICAgIGNhc2UgJ21zOTMyJzpcbiAgICBjYXNlICdtc19rYW5qaSc6XG4gICAgY2FzZSAnc2hpZnQtamlzJzpcbiAgICBjYXNlICdzaGlmdF9qaXMnOlxuICAgIGNhc2UgJ3NqaXMnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMzFqJzpcbiAgICBjYXNlICd4LXNqaXMnOlxuICAgICAgcmV0dXJuICdTaGlmdF9KSVMnXG4gICAgY2FzZSAnY3NldWNrcic6XG4gICAgY2FzZSAnY3Nrc2M1NjAxMTk4Nyc6XG4gICAgY2FzZSAnZXVjLWtyJzpcbiAgICBjYXNlICdpc28taXItMTQ5JzpcbiAgICBjYXNlICdrb3JlYW4nOlxuICAgIGNhc2UgJ2tzX2NfNTYwMS0xOTg3JzpcbiAgICBjYXNlICdrc19jXzU2MDEtMTk4OSc6XG4gICAgY2FzZSAna3NjNTYwMSc6XG4gICAgY2FzZSAna3NjXzU2MDEnOlxuICAgIGNhc2UgJ3dpbmRvd3MtOTQ5JzpcbiAgICAgIHJldHVybiAnRVVDLUtSJ1xuICAgIGNhc2UgJ2NzaXNvMjAyMmtyJzpcbiAgICBjYXNlICdoei1nYi0yMzEyJzpcbiAgICBjYXNlICdpc28tMjAyMi1jbic6XG4gICAgY2FzZSAnaXNvLTIwMjItY24tZXh0JzpcbiAgICBjYXNlICdpc28tMjAyMi1rcic6XG4gICAgY2FzZSAncmVwbGFjZW1lbnQnOlxuICAgICAgcmV0dXJuICdyZXBsYWNlbWVudCdcbiAgICBjYXNlICd1bmljb2RlZmZmZSc6XG4gICAgY2FzZSAndXRmLTE2YmUnOlxuICAgICAgcmV0dXJuICdVVEYtMTZCRSdcbiAgICBjYXNlICdjc3VuaWNvZGUnOlxuICAgIGNhc2UgJ2lzby0xMDY0Ni11Y3MtMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3VuaWNvZGUnOlxuICAgIGNhc2UgJ3VuaWNvZGVmZWZmJzpcbiAgICBjYXNlICd1dGYtMTYnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiAnVVRGLTE2TEUnXG4gICAgY2FzZSAneC11c2VyLWRlZmluZWQnOlxuICAgICAgcmV0dXJuICd4LXVzZXItZGVmaW5lZCdcbiAgICBkZWZhdWx0OiByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEVuY29kaW5nXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fileapi/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fileapi/filereader.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/filereader.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/fileapi/util.js\")\nconst {\n  kState,\n  kError,\n  kResult,\n  kEvents,\n  kAborted\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/fileapi/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\nclass FileReader extends EventTarget {\n  constructor () {\n    super()\n\n    this[kState] = 'empty'\n    this[kResult] = null\n    this[kError] = null\n    this[kEvents] = {\n      loadend: null,\n      error: null,\n      abort: null,\n      load: null,\n      progress: null,\n      loadstart: null\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer\n   * @param {import('buffer').Blob} blob\n   */\n  readAsArrayBuffer (blob) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsArrayBuffer' })\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    // The readAsArrayBuffer(blob) method, when invoked,\n    // must initiate a read operation for blob with ArrayBuffer.\n    readOperation(this, blob, 'ArrayBuffer')\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#readAsBinaryString\n   * @param {import('buffer').Blob} blob\n   */\n  readAsBinaryString (blob) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsBinaryString' })\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    // The readAsBinaryString(blob) method, when invoked,\n    // must initiate a read operation for blob with BinaryString.\n    readOperation(this, blob, 'BinaryString')\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#readAsDataText\n   * @param {import('buffer').Blob} blob\n   * @param {string?} encoding\n   */\n  readAsText (blob, encoding = undefined) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsText' })\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    if (encoding !== undefined) {\n      encoding = webidl.converters.DOMString(encoding)\n    }\n\n    // The readAsText(blob, encoding) method, when invoked,\n    // must initiate a read operation for blob with Text and encoding.\n    readOperation(this, blob, 'Text', encoding)\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL\n   * @param {import('buffer').Blob} blob\n   */\n  readAsDataURL (blob) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsDataURL' })\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    // The readAsDataURL(blob) method, when invoked, must\n    // initiate a read operation for blob with DataURL.\n    readOperation(this, blob, 'DataURL')\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dfn-abort\n   */\n  abort () {\n    // 1. If this's state is \"empty\" or if this's state is\n    //    \"done\" set this's result to null and terminate\n    //    this algorithm.\n    if (this[kState] === 'empty' || this[kState] === 'done') {\n      this[kResult] = null\n      return\n    }\n\n    // 2. If this's state is \"loading\" set this's state to\n    //    \"done\" and set this's result to null.\n    if (this[kState] === 'loading') {\n      this[kState] = 'done'\n      this[kResult] = null\n    }\n\n    // 3. If there are any tasks from this on the file reading\n    //    task source in an affiliated task queue, then remove\n    //    those tasks from that task queue.\n    this[kAborted] = true\n\n    // 4. Terminate the algorithm for the read method being processed.\n    // TODO\n\n    // 5. Fire a progress event called abort at this.\n    fireAProgressEvent('abort', this)\n\n    // 6. If this's state is not \"loading\", fire a progress\n    //    event called loadend at this.\n    if (this[kState] !== 'loading') {\n      fireAProgressEvent('loadend', this)\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate\n   */\n  get readyState () {\n    webidl.brandCheck(this, FileReader)\n\n    switch (this[kState]) {\n      case 'empty': return this.EMPTY\n      case 'loading': return this.LOADING\n      case 'done': return this.DONE\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-result\n   */\n  get result () {\n    webidl.brandCheck(this, FileReader)\n\n    // The result attributes getter, when invoked, must return\n    // this's result.\n    return this[kResult]\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-error\n   */\n  get error () {\n    webidl.brandCheck(this, FileReader)\n\n    // The error attributes getter, when invoked, must return\n    // this's error.\n    return this[kError]\n  }\n\n  get onloadend () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].loadend\n  }\n\n  set onloadend (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].loadend) {\n      this.removeEventListener('loadend', this[kEvents].loadend)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].loadend = fn\n      this.addEventListener('loadend', fn)\n    } else {\n      this[kEvents].loadend = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].error) {\n      this.removeEventListener('error', this[kEvents].error)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this[kEvents].error = null\n    }\n  }\n\n  get onloadstart () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].loadstart\n  }\n\n  set onloadstart (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].loadstart) {\n      this.removeEventListener('loadstart', this[kEvents].loadstart)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].loadstart = fn\n      this.addEventListener('loadstart', fn)\n    } else {\n      this[kEvents].loadstart = null\n    }\n  }\n\n  get onprogress () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].progress\n  }\n\n  set onprogress (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].progress) {\n      this.removeEventListener('progress', this[kEvents].progress)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].progress = fn\n      this.addEventListener('progress', fn)\n    } else {\n      this[kEvents].progress = null\n    }\n  }\n\n  get onload () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].load\n  }\n\n  set onload (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].load) {\n      this.removeEventListener('load', this[kEvents].load)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].load = fn\n      this.addEventListener('load', fn)\n    } else {\n      this[kEvents].load = null\n    }\n  }\n\n  get onabort () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].abort\n  }\n\n  set onabort (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].abort) {\n      this.removeEventListener('abort', this[kEvents].abort)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].abort = fn\n      this.addEventListener('abort', fn)\n    } else {\n      this[kEvents].abort = null\n    }\n  }\n}\n\n// https://w3c.github.io/FileAPI/#dom-filereader-empty\nFileReader.EMPTY = FileReader.prototype.EMPTY = 0\n// https://w3c.github.io/FileAPI/#dom-filereader-loading\nFileReader.LOADING = FileReader.prototype.LOADING = 1\n// https://w3c.github.io/FileAPI/#dom-filereader-done\nFileReader.DONE = FileReader.prototype.DONE = 2\n\nObject.defineProperties(FileReader.prototype, {\n  EMPTY: staticPropertyDescriptors,\n  LOADING: staticPropertyDescriptors,\n  DONE: staticPropertyDescriptors,\n  readAsArrayBuffer: kEnumerableProperty,\n  readAsBinaryString: kEnumerableProperty,\n  readAsText: kEnumerableProperty,\n  readAsDataURL: kEnumerableProperty,\n  abort: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  result: kEnumerableProperty,\n  error: kEnumerableProperty,\n  onloadstart: kEnumerableProperty,\n  onprogress: kEnumerableProperty,\n  onload: kEnumerableProperty,\n  onabort: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onloadend: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'FileReader',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(FileReader, {\n  EMPTY: staticPropertyDescriptors,\n  LOADING: staticPropertyDescriptors,\n  DONE: staticPropertyDescriptors\n})\n\nmodule.exports = {\n  FileReader\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL2ZpbGVyZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywrREFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVztBQUN2QixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUM1QyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsa0VBQWM7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0Msd0NBQXdDOztBQUV2RiwwQ0FBMEMsZUFBZTs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MseUNBQXlDOztBQUV4RiwwQ0FBMEMsZUFBZTs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGlDQUFpQzs7QUFFaEYsMENBQTBDLGVBQWU7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxvQ0FBb0M7O0FBRW5GLDBDQUEwQyxlQUFlOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL2ZpbGVyZWFkZXIuanM/Yjg1MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICByZWFkT3BlcmF0aW9uLFxuICBmaXJlQVByb2dyZXNzRXZlbnRcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICBrU3RhdGUsXG4gIGtFcnJvcixcbiAga1Jlc3VsdCxcbiAga0V2ZW50cyxcbiAga0Fib3J0ZWRcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmNsYXNzIEZpbGVSZWFkZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tTdGF0ZV0gPSAnZW1wdHknXG4gICAgdGhpc1trUmVzdWx0XSA9IG51bGxcbiAgICB0aGlzW2tFcnJvcl0gPSBudWxsXG4gICAgdGhpc1trRXZlbnRzXSA9IHtcbiAgICAgIGxvYWRlbmQ6IG51bGwsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIGFib3J0OiBudWxsLFxuICAgICAgbG9hZDogbnVsbCxcbiAgICAgIHByb2dyZXNzOiBudWxsLFxuICAgICAgbG9hZHN0YXJ0OiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Rmbi1yZWFkQXNBcnJheUJ1ZmZlclxuICAgKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICAgKi9cbiAgcmVhZEFzQXJyYXlCdWZmZXIgKGJsb2IpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0ZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXInIH0pXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNBcnJheUJ1ZmZlcihibG9iKSBtZXRob2QsIHdoZW4gaW52b2tlZCxcbiAgICAvLyBtdXN0IGluaXRpYXRlIGEgcmVhZCBvcGVyYXRpb24gZm9yIGJsb2Igd2l0aCBBcnJheUJ1ZmZlci5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdBcnJheUJ1ZmZlcicpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jcmVhZEFzQmluYXJ5U3RyaW5nXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNCaW5hcnlTdHJpbmcgKGJsb2IpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0ZpbGVSZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nJyB9KVxuXG4gICAgYmxvYiA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoYmxvYiwgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgICAvLyBUaGUgcmVhZEFzQmluYXJ5U3RyaW5nKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIG11c3QgaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIEJpbmFyeVN0cmluZy5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdCaW5hcnlTdHJpbmcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI3JlYWRBc0RhdGFUZXh0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqIEBwYXJhbSB7c3RyaW5nP30gZW5jb2RpbmdcbiAgICovXG4gIHJlYWRBc1RleHQgKGJsb2IsIGVuY29kaW5nID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGaWxlUmVhZGVyLnJlYWRBc1RleHQnIH0pXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmNvZGluZyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhlbmNvZGluZylcbiAgICB9XG5cbiAgICAvLyBUaGUgcmVhZEFzVGV4dChibG9iLCBlbmNvZGluZykgbWV0aG9kLCB3aGVuIGludm9rZWQsXG4gICAgLy8gbXVzdCBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggVGV4dCBhbmQgZW5jb2RpbmcuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnVGV4dCcsIGVuY29kaW5nKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Rmbi1yZWFkQXNEYXRhVVJMXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNEYXRhVVJMIChibG9iKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwnIH0pXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNEYXRhVVJMKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLCBtdXN0XG4gICAgLy8gaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIERhdGFVUkwuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnRGF0YVVSTCcpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZGZuLWFib3J0XG4gICAqL1xuICBhYm9ydCAoKSB7XG4gICAgLy8gMS4gSWYgdGhpcydzIHN0YXRlIGlzIFwiZW1wdHlcIiBvciBpZiB0aGlzJ3Mgc3RhdGUgaXNcbiAgICAvLyAgICBcImRvbmVcIiBzZXQgdGhpcydzIHJlc3VsdCB0byBudWxsIGFuZCB0ZXJtaW5hdGVcbiAgICAvLyAgICB0aGlzIGFsZ29yaXRobS5cbiAgICBpZiAodGhpc1trU3RhdGVdID09PSAnZW1wdHknIHx8IHRoaXNba1N0YXRlXSA9PT0gJ2RvbmUnKSB7XG4gICAgICB0aGlzW2tSZXN1bHRdID0gbnVsbFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpcydzIHN0YXRlIGlzIFwibG9hZGluZ1wiIHNldCB0aGlzJ3Mgc3RhdGUgdG9cbiAgICAvLyAgICBcImRvbmVcIiBhbmQgc2V0IHRoaXMncyByZXN1bHQgdG8gbnVsbC5cbiAgICBpZiAodGhpc1trU3RhdGVdID09PSAnbG9hZGluZycpIHtcbiAgICAgIHRoaXNba1N0YXRlXSA9ICdkb25lJ1xuICAgICAgdGhpc1trUmVzdWx0XSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyAzLiBJZiB0aGVyZSBhcmUgYW55IHRhc2tzIGZyb20gdGhpcyBvbiB0aGUgZmlsZSByZWFkaW5nXG4gICAgLy8gICAgdGFzayBzb3VyY2UgaW4gYW4gYWZmaWxpYXRlZCB0YXNrIHF1ZXVlLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHRob3NlIHRhc2tzIGZyb20gdGhhdCB0YXNrIHF1ZXVlLlxuICAgIHRoaXNba0Fib3J0ZWRdID0gdHJ1ZVxuXG4gICAgLy8gNC4gVGVybWluYXRlIHRoZSBhbGdvcml0aG0gZm9yIHRoZSByZWFkIG1ldGhvZCBiZWluZyBwcm9jZXNzZWQuXG4gICAgLy8gVE9ET1xuXG4gICAgLy8gNS4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBhYm9ydCBhdCB0aGlzLlxuICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnYWJvcnQnLCB0aGlzKVxuXG4gICAgLy8gNi4gSWYgdGhpcydzIHN0YXRlIGlzIG5vdCBcImxvYWRpbmdcIiwgZmlyZSBhIHByb2dyZXNzXG4gICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgdGhpcy5cbiAgICBpZiAodGhpc1trU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZGVuZCcsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLXJlYWR5c3RhdGVcbiAgICovXG4gIGdldCByZWFkeVN0YXRlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgc3dpdGNoICh0aGlzW2tTdGF0ZV0pIHtcbiAgICAgIGNhc2UgJ2VtcHR5JzogcmV0dXJuIHRoaXMuRU1QVFlcbiAgICAgIGNhc2UgJ2xvYWRpbmcnOiByZXR1cm4gdGhpcy5MT0FESU5HXG4gICAgICBjYXNlICdkb25lJzogcmV0dXJuIHRoaXMuRE9ORVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1yZXN1bHRcbiAgICovXG4gIGdldCByZXN1bHQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICAvLyBUaGUgcmVzdWx0IGF0dHJpYnV0ZeKAmXMgZ2V0dGVyLCB3aGVuIGludm9rZWQsIG11c3QgcmV0dXJuXG4gICAgLy8gdGhpcydzIHJlc3VsdC5cbiAgICByZXR1cm4gdGhpc1trUmVzdWx0XVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWVycm9yXG4gICAqL1xuICBnZXQgZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICAvLyBUaGUgZXJyb3IgYXR0cmlidXRl4oCZcyBnZXR0ZXIsIHdoZW4gaW52b2tlZCwgbXVzdCByZXR1cm5cbiAgICAvLyB0aGlzJ3MgZXJyb3IuXG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXVxuICB9XG5cbiAgZ2V0IG9ubG9hZGVuZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRlbmRcbiAgfVxuXG4gIHNldCBvbmxvYWRlbmQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmxvYWRlbmQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIHRoaXNba0V2ZW50c10ubG9hZGVuZClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRlbmQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZGVuZCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10uZXJyb3IpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzW2tFdmVudHNdLmVycm9yKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10uZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmxvYWRzdGFydCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRzdGFydFxuICB9XG5cbiAgc2V0IG9ubG9hZHN0YXJ0IChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ucHJvZ3Jlc3MgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5wcm9ncmVzc1xuICB9XG5cbiAgc2V0IG9ucHJvZ3Jlc3MgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLnByb2dyZXNzKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpc1trRXZlbnRzXS5wcm9ncmVzcylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLnByb2dyZXNzID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5wcm9ncmVzcyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25sb2FkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ubG9hZFxuICB9XG5cbiAgc2V0IG9ubG9hZCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ubG9hZCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpc1trRXZlbnRzXS5sb2FkKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmFib3J0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10uYWJvcnRcbiAgfVxuXG4gIHNldCBvbmFib3J0IChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5hYm9ydCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRoaXNba0V2ZW50c10uYWJvcnQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5hYm9ydCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10uYWJvcnQgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1lbXB0eVxuRmlsZVJlYWRlci5FTVBUWSA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkVNUFRZID0gMFxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWxvYWRpbmdcbkZpbGVSZWFkZXIuTE9BRElORyA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkxPQURJTkcgPSAxXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItZG9uZVxuRmlsZVJlYWRlci5ET05FID0gRmlsZVJlYWRlci5wcm90b3R5cGUuRE9ORSA9IDJcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmlsZVJlYWRlci5wcm90b3R5cGUsIHtcbiAgRU1QVFk6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIExPQURJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIERPTkU6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRBc0FycmF5QnVmZmVyOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkQXNCaW5hcnlTdHJpbmc6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc1RleHQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc0RhdGFVUkw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFib3J0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZXN1bHQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWRzdGFydDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25wcm9ncmVzczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25sb2FkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmFib3J0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWRlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdGaWxlUmVhZGVyJyxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZpbGVSZWFkZXIsIHtcbiAgRU1QVFk6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIExPQURJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIERPTkU6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnNcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGaWxlUmVhZGVyXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fileapi/filereader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fileapi/progressevent.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/progressevent.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\n\nconst kState = Symbol('ProgressEvent state')\n\n/**\n * @see https://xhr.spec.whatwg.org/#progressevent\n */\nclass ProgressEvent extends Event {\n  constructor (type, eventInitDict = {}) {\n    type = webidl.converters.DOMString(type)\n    eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {})\n\n    super(type, eventInitDict)\n\n    this[kState] = {\n      lengthComputable: eventInitDict.lengthComputable,\n      loaded: eventInitDict.loaded,\n      total: eventInitDict.total\n    }\n  }\n\n  get lengthComputable () {\n    webidl.brandCheck(this, ProgressEvent)\n\n    return this[kState].lengthComputable\n  }\n\n  get loaded () {\n    webidl.brandCheck(this, ProgressEvent)\n\n    return this[kState].loaded\n  }\n\n  get total () {\n    webidl.brandCheck(this, ProgressEvent)\n\n    return this[kState].total\n  }\n}\n\nwebidl.converters.ProgressEventInit = webidl.dictionaryConverter([\n  {\n    key: 'lengthComputable',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'loaded',\n    converter: webidl.converters['unsigned long long'],\n    defaultValue: 0\n  },\n  {\n    key: 'total',\n    converter: webidl.converters['unsigned long long'],\n    defaultValue: 0\n  },\n  {\n    key: 'bubbles',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'cancelable',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'composed',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  }\n])\n\nmodule.exports = {\n  ProgressEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3Byb2dyZXNzZXZlbnQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsMkVBQTJFOztBQUUzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3Byb2dyZXNzZXZlbnQuanM/N2NhZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5cbmNvbnN0IGtTdGF0ZSA9IFN5bWJvbCgnUHJvZ3Jlc3NFdmVudCBzdGF0ZScpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI3Byb2dyZXNzZXZlbnRcbiAqL1xuY2xhc3MgUHJvZ3Jlc3NFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSlcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUHJvZ3Jlc3NFdmVudEluaXQoZXZlbnRJbml0RGljdCA/PyB7fSlcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzW2tTdGF0ZV0gPSB7XG4gICAgICBsZW5ndGhDb21wdXRhYmxlOiBldmVudEluaXREaWN0Lmxlbmd0aENvbXB1dGFibGUsXG4gICAgICBsb2FkZWQ6IGV2ZW50SW5pdERpY3QubG9hZGVkLFxuICAgICAgdG90YWw6IGV2ZW50SW5pdERpY3QudG90YWxcbiAgICB9XG4gIH1cblxuICBnZXQgbGVuZ3RoQ29tcHV0YWJsZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUHJvZ3Jlc3NFdmVudClcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubGVuZ3RoQ29tcHV0YWJsZVxuICB9XG5cbiAgZ2V0IGxvYWRlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUHJvZ3Jlc3NFdmVudClcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubG9hZGVkXG4gIH1cblxuICBnZXQgdG90YWwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnRvdGFsXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuUHJvZ3Jlc3NFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdsZW5ndGhDb21wdXRhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnbG9hZGVkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ3RvdGFsJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2J1YmJsZXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYW5jZWxhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29tcG9zZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQcm9ncmVzc0V2ZW50XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fileapi/progressevent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fileapi/symbols.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/symbols.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kState: Symbol('FileReader state'),\n  kResult: Symbol('FileReader result'),\n  kError: Symbol('FileReader error'),\n  kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),\n  kEvents: Symbol('FileReader events'),\n  kAborted: Symbol('FileReader aborted')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZpbGVhcGkvc3ltYm9scy5qcz9mY2E3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga1N0YXRlOiBTeW1ib2woJ0ZpbGVSZWFkZXIgc3RhdGUnKSxcbiAga1Jlc3VsdDogU3ltYm9sKCdGaWxlUmVhZGVyIHJlc3VsdCcpLFxuICBrRXJyb3I6IFN5bWJvbCgnRmlsZVJlYWRlciBlcnJvcicpLFxuICBrTGFzdFByb2dyZXNzRXZlbnRGaXJlZDogU3ltYm9sKCdGaWxlUmVhZGVyIGxhc3QgcHJvZ3Jlc3MgZXZlbnQgZmlyZWQgdGltZXN0YW1wJyksXG4gIGtFdmVudHM6IFN5bWJvbCgnRmlsZVJlYWRlciBldmVudHMnKSxcbiAga0Fib3J0ZWQ6IFN5bWJvbCgnRmlsZVJlYWRlciBhYm9ydGVkJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fileapi/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/fileapi/util.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/util.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  kState,\n  kError,\n  kResult,\n  kAborted,\n  kLastProgressEventFired\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/fileapi/symbols.js\")\nconst { ProgressEvent } = __webpack_require__(/*! ./progressevent */ \"(ssr)/./node_modules/undici/lib/fileapi/progressevent.js\")\nconst { getEncoding } = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/undici/lib/fileapi/encoding.js\")\nconst { DOMException } = __webpack_require__(/*! ../fetch/constants */ \"(ssr)/./node_modules/undici/lib/fetch/constants.js\")\nconst { serializeAMimeType, parseMIMEType } = __webpack_require__(/*! ../fetch/dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\nconst { types } = __webpack_require__(/*! util */ \"util\")\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\")\nconst { btoa } = __webpack_require__(/*! buffer */ \"buffer\")\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */\nfunction readOperation (fr, blob, type, encodingName) {\n  // 1. If frs state is \"loading\", throw an InvalidStateError\n  //    DOMException.\n  if (fr[kState] === 'loading') {\n    throw new DOMException('Invalid state', 'InvalidStateError')\n  }\n\n  // 2. Set frs state to \"loading\".\n  fr[kState] = 'loading'\n\n  // 3. Set frs result to null.\n  fr[kResult] = null\n\n  // 4. Set frs error to null.\n  fr[kError] = null\n\n  // 5. Let stream be the result of calling get stream on blob.\n  /** @type {import('stream/web').ReadableStream} */\n  const stream = blob.stream()\n\n  // 6. Let reader be the result of getting a reader from stream.\n  const reader = stream.getReader()\n\n  // 7. Let bytes be an empty byte sequence.\n  /** @type {Uint8Array[]} */\n  const bytes = []\n\n  // 8. Let chunkPromise be the result of reading a chunk from\n  //    stream with reader.\n  let chunkPromise = reader.read()\n\n  // 9. Let isFirstChunk be true.\n  let isFirstChunk = true\n\n  // 10. In parallel, while true:\n  // Note: \"In parallel\" just means non-blocking\n  // Note 2: readOperation itself cannot be async as double\n  // reading the body would then reject the promise, instead\n  // of throwing an error.\n  ;(async () => {\n    while (!fr[kAborted]) {\n      // 1. Wait for chunkPromise to be fulfilled or rejected.\n      try {\n        const { done, value } = await chunkPromise\n\n        // 2. If chunkPromise is fulfilled, and isFirstChunk is\n        //    true, queue a task to fire a progress event called\n        //    loadstart at fr.\n        if (isFirstChunk && !fr[kAborted]) {\n          queueMicrotask(() => {\n            fireAProgressEvent('loadstart', fr)\n          })\n        }\n\n        // 3. Set isFirstChunk to false.\n        isFirstChunk = false\n\n        // 4. If chunkPromise is fulfilled with an object whose\n        //    done property is false and whose value property is\n        //    a Uint8Array object, run these steps:\n        if (!done && types.isUint8Array(value)) {\n          // 1. Let bs be the byte sequence represented by the\n          //    Uint8Array object.\n\n          // 2. Append bs to bytes.\n          bytes.push(value)\n\n          // 3. If roughly 50ms have passed since these steps\n          //    were last invoked, queue a task to fire a\n          //    progress event called progress at fr.\n          if (\n            (\n              fr[kLastProgressEventFired] === undefined ||\n              Date.now() - fr[kLastProgressEventFired] >= 50\n            ) &&\n            !fr[kAborted]\n          ) {\n            fr[kLastProgressEventFired] = Date.now()\n            queueMicrotask(() => {\n              fireAProgressEvent('progress', fr)\n            })\n          }\n\n          // 4. Set chunkPromise to the result of reading a\n          //    chunk from stream with reader.\n          chunkPromise = reader.read()\n        } else if (done) {\n          // 5. Otherwise, if chunkPromise is fulfilled with an\n          //    object whose done property is true, queue a task\n          //    to run the following steps and abort this algorithm:\n          queueMicrotask(() => {\n            // 1. Set frs state to \"done\".\n            fr[kState] = 'done'\n\n            // 2. Let result be the result of package data given\n            //    bytes, type, blobs type, and encodingName.\n            try {\n              const result = packageData(bytes, type, blob.type, encodingName)\n\n              // 4. Else:\n\n              if (fr[kAborted]) {\n                return\n              }\n\n              // 1. Set frs result to result.\n              fr[kResult] = result\n\n              // 2. Fire a progress event called load at the fr.\n              fireAProgressEvent('load', fr)\n            } catch (error) {\n              // 3. If package data threw an exception error:\n\n              // 1. Set frs error to error.\n              fr[kError] = error\n\n              // 2. Fire a progress event called error at fr.\n              fireAProgressEvent('error', fr)\n            }\n\n            // 5. If frs state is not \"loading\", fire a progress\n            //    event called loadend at the fr.\n            if (fr[kState] !== 'loading') {\n              fireAProgressEvent('loadend', fr)\n            }\n          })\n\n          break\n        }\n      } catch (error) {\n        if (fr[kAborted]) {\n          return\n        }\n\n        // 6. Otherwise, if chunkPromise is rejected with an\n        //    error error, queue a task to run the following\n        //    steps and abort this algorithm:\n        queueMicrotask(() => {\n          // 1. Set frs state to \"done\".\n          fr[kState] = 'done'\n\n          // 2. Set frs error to error.\n          fr[kError] = error\n\n          // 3. Fire a progress event called error at fr.\n          fireAProgressEvent('error', fr)\n\n          // 4. If frs state is not \"loading\", fire a progress\n          //    event called loadend at fr.\n          if (fr[kState] !== 'loading') {\n            fireAProgressEvent('loadend', fr)\n          }\n        })\n\n        break\n      }\n    }\n  })()\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */\nfunction fireAProgressEvent (e, reader) {\n  // The progress event e does not bubble. e.bubbles must be false\n  // The progress event e is NOT cancelable. e.cancelable must be false\n  const event = new ProgressEvent(e, {\n    bubbles: false,\n    cancelable: false\n  })\n\n  reader.dispatchEvent(event)\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */\nfunction packageData (bytes, type, mimeType, encodingName) {\n  // 1. A Blob has an associated package data algorithm, given\n  //    bytes, a type, a optional mimeType, and a optional\n  //    encodingName, which switches on type and runs the\n  //    associated steps:\n\n  switch (type) {\n    case 'DataURL': {\n      // 1. Return bytes as a DataURL [RFC2397] subject to\n      //    the considerations below:\n      //  * Use mimeType as part of the Data URL if it is\n      //    available in keeping with the Data URL\n      //    specification [RFC2397].\n      //  * If mimeType is not available return a Data URL\n      //    without a media-type. [RFC2397].\n\n      // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n      // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n      // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n      // data       := *urlchar\n      // parameter  := attribute \"=\" value\n      let dataURL = 'data:'\n\n      const parsed = parseMIMEType(mimeType || 'application/octet-stream')\n\n      if (parsed !== 'failure') {\n        dataURL += serializeAMimeType(parsed)\n      }\n\n      dataURL += ';base64,'\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        dataURL += btoa(decoder.write(chunk))\n      }\n\n      dataURL += btoa(decoder.end())\n\n      return dataURL\n    }\n    case 'Text': {\n      // 1. Let encoding be failure\n      let encoding = 'failure'\n\n      // 2. If the encodingName is present, set encoding to the\n      //    result of getting an encoding from encodingName.\n      if (encodingName) {\n        encoding = getEncoding(encodingName)\n      }\n\n      // 3. If encoding is failure, and mimeType is present:\n      if (encoding === 'failure' && mimeType) {\n        // 1. Let type be the result of parse a MIME type\n        //    given mimeType.\n        const type = parseMIMEType(mimeType)\n\n        // 2. If type is not failure, set encoding to the result\n        //    of getting an encoding from types parameters[\"charset\"].\n        if (type !== 'failure') {\n          encoding = getEncoding(type.parameters.get('charset'))\n        }\n      }\n\n      // 4. If encoding is failure, then set encoding to UTF-8.\n      if (encoding === 'failure') {\n        encoding = 'UTF-8'\n      }\n\n      // 5. Decode bytes using fallback encoding encoding, and\n      //    return the result.\n      return decode(bytes, encoding)\n    }\n    case 'ArrayBuffer': {\n      // Return a new ArrayBuffer whose contents are bytes.\n      const sequence = combineByteSequences(bytes)\n\n      return sequence.buffer\n    }\n    case 'BinaryString': {\n      // Return bytes as a binary string, in which every byte\n      //  is represented by a code unit of equal value [0..255].\n      let binaryString = ''\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        binaryString += decoder.write(chunk)\n      }\n\n      binaryString += decoder.end()\n\n      return binaryString\n    }\n  }\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */\nfunction decode (ioQueue, encoding) {\n  const bytes = combineByteSequences(ioQueue)\n\n  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n  const BOMEncoding = BOMSniffing(bytes)\n\n  let slice = 0\n\n  // 2. If BOMEncoding is non-null:\n  if (BOMEncoding !== null) {\n    // 1. Set encoding to BOMEncoding.\n    encoding = BOMEncoding\n\n    // 2. Read three bytes from ioQueue, if BOMEncoding is\n    //    UTF-8; otherwise read two bytes.\n    //    (Do nothing with those bytes.)\n    slice = BOMEncoding === 'UTF-8' ? 3 : 2\n  }\n\n  // 3. Process a queue with an instance of encodings\n  //    decoder, ioQueue, output, and \"replacement\".\n\n  // 4. Return output.\n\n  const sliced = bytes.slice(slice)\n  return new TextDecoder(encoding).decode(sliced)\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */\nfunction BOMSniffing (ioQueue) {\n  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n  //    converted to a byte sequence.\n  const [a, b, c] = ioQueue\n\n  // 2. For each of the rows in the table below, starting with\n  //    the first one and going down, if BOM starts with the\n  //    bytes given in the first column, then return the\n  //    encoding given in the cell in the second column of that\n  //    row. Otherwise, return null.\n  if (a === 0xEF && b === 0xBB && c === 0xBF) {\n    return 'UTF-8'\n  } else if (a === 0xFE && b === 0xFF) {\n    return 'UTF-16BE'\n  } else if (a === 0xFF && b === 0xFE) {\n    return 'UTF-16LE'\n  }\n\n  return null\n}\n\n/**\n * @param {Uint8Array[]} sequences\n */\nfunction combineByteSequences (sequences) {\n  const size = sequences.reduce((a, b) => {\n    return a + b.byteLength\n  }, 0)\n\n  let offset = 0\n\n  return sequences.reduce((a, b) => {\n    a.set(b, offset)\n    offset += b.byteLength\n    return a\n  }, new Uint8Array(size))\n}\n\nmodule.exports = {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscUVBQVc7QUFDdkIsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGlGQUFpQjtBQUNuRCxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHVFQUFZO0FBQzVDLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQ3JELFFBQVEsb0NBQW9DLEVBQUUsbUJBQU8sQ0FBQywwRUFBa0I7QUFDeEUsUUFBUSxRQUFRLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNoQyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsc0NBQWdCO0FBQ2xELFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRWpDLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFDQUFxQztBQUNsRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS91dGlsLmpzP2FkNjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAga1N0YXRlLFxuICBrRXJyb3IsXG4gIGtSZXN1bHQsXG4gIGtBYm9ydGVkLFxuICBrTGFzdFByb2dyZXNzRXZlbnRGaXJlZFxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IFByb2dyZXNzRXZlbnQgfSA9IHJlcXVpcmUoJy4vcHJvZ3Jlc3NldmVudCcpXG5jb25zdCB7IGdldEVuY29kaW5nIH0gPSByZXF1aXJlKCcuL2VuY29kaW5nJylcbmNvbnN0IHsgRE9NRXhjZXB0aW9uIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9jb25zdGFudHMnKVxuY29uc3QgeyBzZXJpYWxpemVBTWltZVR5cGUsIHBhcnNlTUlNRVR5cGUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGFVUkwnKVxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCB7IFN0cmluZ0RlY29kZXIgfSA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJylcbmNvbnN0IHsgYnRvYSB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuLyoqIEB0eXBlIHtQcm9wZXJ0eURlc2NyaXB0b3J9ICovXG5jb25zdCBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNyZWFkT3BlcmF0aW9uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9maWxlcmVhZGVyJykuRmlsZVJlYWRlcn0gZnJcbiAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmc/fSBlbmNvZGluZ05hbWVcbiAqL1xuZnVuY3Rpb24gcmVhZE9wZXJhdGlvbiAoZnIsIGJsb2IsIHR5cGUsIGVuY29kaW5nTmFtZSkge1xuICAvLyAxLiBJZiBmcuKAmXMgc3RhdGUgaXMgXCJsb2FkaW5nXCIsIHRocm93IGFuIEludmFsaWRTdGF0ZUVycm9yXG4gIC8vICAgIERPTUV4Y2VwdGlvbi5cbiAgaWYgKGZyW2tTdGF0ZV0gPT09ICdsb2FkaW5nJykge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgc3RhdGUnLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICB9XG5cbiAgLy8gMi4gU2V0IGZy4oCZcyBzdGF0ZSB0byBcImxvYWRpbmdcIi5cbiAgZnJba1N0YXRlXSA9ICdsb2FkaW5nJ1xuXG4gIC8vIDMuIFNldCBmcuKAmXMgcmVzdWx0IHRvIG51bGwuXG4gIGZyW2tSZXN1bHRdID0gbnVsbFxuXG4gIC8vIDQuIFNldCBmcuKAmXMgZXJyb3IgdG8gbnVsbC5cbiAgZnJba0Vycm9yXSA9IG51bGxcblxuICAvLyA1LiBMZXQgc3RyZWFtIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBnZXQgc3RyZWFtIG9uIGJsb2IuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW19ICovXG4gIGNvbnN0IHN0cmVhbSA9IGJsb2Iuc3RyZWFtKClcblxuICAvLyA2LiBMZXQgcmVhZGVyIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBhIHJlYWRlciBmcm9tIHN0cmVhbS5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG5cbiAgLy8gNy4gTGV0IGJ5dGVzIGJlIGFuIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIC8qKiBAdHlwZSB7VWludDhBcnJheVtdfSAqL1xuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgLy8gOC4gTGV0IGNodW5rUHJvbWlzZSBiZSB0aGUgcmVzdWx0IG9mIHJlYWRpbmcgYSBjaHVuayBmcm9tXG4gIC8vICAgIHN0cmVhbSB3aXRoIHJlYWRlci5cbiAgbGV0IGNodW5rUHJvbWlzZSA9IHJlYWRlci5yZWFkKClcblxuICAvLyA5LiBMZXQgaXNGaXJzdENodW5rIGJlIHRydWUuXG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlXG5cbiAgLy8gMTAuIEluIHBhcmFsbGVsLCB3aGlsZSB0cnVlOlxuICAvLyBOb3RlOiBcIkluIHBhcmFsbGVsXCIganVzdCBtZWFucyBub24tYmxvY2tpbmdcbiAgLy8gTm90ZSAyOiByZWFkT3BlcmF0aW9uIGl0c2VsZiBjYW5ub3QgYmUgYXN5bmMgYXMgZG91YmxlXG4gIC8vIHJlYWRpbmcgdGhlIGJvZHkgd291bGQgdGhlbiByZWplY3QgdGhlIHByb21pc2UsIGluc3RlYWRcbiAgLy8gb2YgdGhyb3dpbmcgYW4gZXJyb3IuXG4gIDsoYXN5bmMgKCkgPT4ge1xuICAgIHdoaWxlICghZnJba0Fib3J0ZWRdKSB7XG4gICAgICAvLyAxLiBXYWl0IGZvciBjaHVua1Byb21pc2UgdG8gYmUgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgY2h1bmtQcm9taXNlXG5cbiAgICAgICAgLy8gMi4gSWYgY2h1bmtQcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIGlzRmlyc3RDaHVuayBpc1xuICAgICAgICAvLyAgICB0cnVlLCBxdWV1ZSBhIHRhc2sgdG8gZmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZFxuICAgICAgICAvLyAgICBsb2Fkc3RhcnQgYXQgZnIuXG4gICAgICAgIGlmIChpc0ZpcnN0Q2h1bmsgJiYgIWZyW2tBYm9ydGVkXSkge1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZHN0YXJ0JywgZnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIFNldCBpc0ZpcnN0Q2h1bmsgdG8gZmFsc2UuXG4gICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlXG5cbiAgICAgICAgLy8gNC4gSWYgY2h1bmtQcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIG9iamVjdCB3aG9zZVxuICAgICAgICAvLyAgICBkb25lIHByb3BlcnR5IGlzIGZhbHNlIGFuZCB3aG9zZSB2YWx1ZSBwcm9wZXJ0eSBpc1xuICAgICAgICAvLyAgICBhIFVpbnQ4QXJyYXkgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG4gICAgICAgIGlmICghZG9uZSAmJiB0eXBlcy5pc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgLy8gMS4gTGV0IGJzIGJlIHRoZSBieXRlIHNlcXVlbmNlIHJlcHJlc2VudGVkIGJ5IHRoZVxuICAgICAgICAgIC8vICAgIFVpbnQ4QXJyYXkgb2JqZWN0LlxuXG4gICAgICAgICAgLy8gMi4gQXBwZW5kIGJzIHRvIGJ5dGVzLlxuICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUpXG5cbiAgICAgICAgICAvLyAzLiBJZiByb3VnaGx5IDUwbXMgaGF2ZSBwYXNzZWQgc2luY2UgdGhlc2Ugc3RlcHNcbiAgICAgICAgICAvLyAgICB3ZXJlIGxhc3QgaW52b2tlZCwgcXVldWUgYSB0YXNrIHRvIGZpcmUgYVxuICAgICAgICAgIC8vICAgIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBwcm9ncmVzcyBhdCBmci5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIGZyW2tMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIERhdGUubm93KCkgLSBmcltrTGFzdFByb2dyZXNzRXZlbnRGaXJlZF0gPj0gNTBcbiAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgICFmcltrQWJvcnRlZF1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZyW2tMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXSA9IERhdGUubm93KClcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdwcm9ncmVzcycsIGZyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LiBTZXQgY2h1bmtQcm9taXNlIHRvIHRoZSByZXN1bHQgb2YgcmVhZGluZyBhXG4gICAgICAgICAgLy8gICAgY2h1bmsgZnJvbSBzdHJlYW0gd2l0aCByZWFkZXIuXG4gICAgICAgICAgY2h1bmtQcm9taXNlID0gcmVhZGVyLnJlYWQoKVxuICAgICAgICB9IGVsc2UgaWYgKGRvbmUpIHtcbiAgICAgICAgICAvLyA1LiBPdGhlcndpc2UsIGlmIGNodW5rUHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhblxuICAgICAgICAgIC8vICAgIG9iamVjdCB3aG9zZSBkb25lIHByb3BlcnR5IGlzIHRydWUsIHF1ZXVlIGEgdGFza1xuICAgICAgICAgIC8vICAgIHRvIHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzIGFuZCBhYm9ydCB0aGlzIGFsZ29yaXRobTpcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIHN0YXRlIHRvIFwiZG9uZVwiLlxuICAgICAgICAgICAgZnJba1N0YXRlXSA9ICdkb25lJ1xuXG4gICAgICAgICAgICAvLyAyLiBMZXQgcmVzdWx0IGJlIHRoZSByZXN1bHQgb2YgcGFja2FnZSBkYXRhIGdpdmVuXG4gICAgICAgICAgICAvLyAgICBieXRlcywgdHlwZSwgYmxvYuKAmXMgdHlwZSwgYW5kIGVuY29kaW5nTmFtZS5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhY2thZ2VEYXRhKGJ5dGVzLCB0eXBlLCBibG9iLnR5cGUsIGVuY29kaW5nTmFtZSlcblxuICAgICAgICAgICAgICAvLyA0LiBFbHNlOlxuXG4gICAgICAgICAgICAgIGlmIChmcltrQWJvcnRlZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgcmVzdWx0IHRvIHJlc3VsdC5cbiAgICAgICAgICAgICAgZnJba1Jlc3VsdF0gPSByZXN1bHRcblxuICAgICAgICAgICAgICAvLyAyLiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGxvYWQgYXQgdGhlIGZyLlxuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWQnLCBmcilcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIDMuIElmIHBhY2thZ2UgZGF0YSB0aHJldyBhbiBleGNlcHRpb24gZXJyb3I6XG5cbiAgICAgICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyBlcnJvciB0byBlcnJvci5cbiAgICAgICAgICAgICAgZnJba0Vycm9yXSA9IGVycm9yXG5cbiAgICAgICAgICAgICAgLy8gMi4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBlcnJvciBhdCBmci5cbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdlcnJvcicsIGZyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyA1LiBJZiBmcuKAmXMgc3RhdGUgaXMgbm90IFwibG9hZGluZ1wiLCBmaXJlIGEgcHJvZ3Jlc3NcbiAgICAgICAgICAgIC8vICAgIGV2ZW50IGNhbGxlZCBsb2FkZW5kIGF0IHRoZSBmci5cbiAgICAgICAgICAgIGlmIChmcltrU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkZW5kJywgZnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChmcltrQWJvcnRlZF0pIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuIE90aGVyd2lzZSwgaWYgY2h1bmtQcm9taXNlIGlzIHJlamVjdGVkIHdpdGggYW5cbiAgICAgICAgLy8gICAgZXJyb3IgZXJyb3IsIHF1ZXVlIGEgdGFzayB0byBydW4gdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyAgICBzdGVwcyBhbmQgYWJvcnQgdGhpcyBhbGdvcml0aG06XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIHN0YXRlIHRvIFwiZG9uZVwiLlxuICAgICAgICAgIGZyW2tTdGF0ZV0gPSAnZG9uZSdcblxuICAgICAgICAgIC8vIDIuIFNldCBmcuKAmXMgZXJyb3IgdG8gZXJyb3IuXG4gICAgICAgICAgZnJba0Vycm9yXSA9IGVycm9yXG5cbiAgICAgICAgICAvLyAzLiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGVycm9yIGF0IGZyLlxuICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnZXJyb3InLCBmcilcblxuICAgICAgICAgIC8vIDQuIElmIGZy4oCZcyBzdGF0ZSBpcyBub3QgXCJsb2FkaW5nXCIsIGZpcmUgYSBwcm9ncmVzc1xuICAgICAgICAgIC8vICAgIGV2ZW50IGNhbGxlZCBsb2FkZW5kIGF0IGZyLlxuICAgICAgICAgIGlmIChmcltrU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZGVuZCcsIGZyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfSkoKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2ZpcmUtYS1wcm9ncmVzcy1ldmVudFxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZXZlbnQtZmlyZVxuICogQHBhcmFtIHtzdHJpbmd9IGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9maWxlcmVhZGVyJykuRmlsZVJlYWRlcn0gcmVhZGVyXG4gKi9cbmZ1bmN0aW9uIGZpcmVBUHJvZ3Jlc3NFdmVudCAoZSwgcmVhZGVyKSB7XG4gIC8vIFRoZSBwcm9ncmVzcyBldmVudCBlIGRvZXMgbm90IGJ1YmJsZS4gZS5idWJibGVzIG11c3QgYmUgZmFsc2VcbiAgLy8gVGhlIHByb2dyZXNzIGV2ZW50IGUgaXMgTk9UIGNhbmNlbGFibGUuIGUuY2FuY2VsYWJsZSBtdXN0IGJlIGZhbHNlXG4gIGNvbnN0IGV2ZW50ID0gbmV3IFByb2dyZXNzRXZlbnQoZSwge1xuICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gIH0pXG5cbiAgcmVhZGVyLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jYmxvYi1wYWNrYWdlLWRhdGFcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBieXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gbWltZVR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gZW5jb2RpbmdOYW1lXG4gKi9cbmZ1bmN0aW9uIHBhY2thZ2VEYXRhIChieXRlcywgdHlwZSwgbWltZVR5cGUsIGVuY29kaW5nTmFtZSkge1xuICAvLyAxLiBBIEJsb2IgaGFzIGFuIGFzc29jaWF0ZWQgcGFja2FnZSBkYXRhIGFsZ29yaXRobSwgZ2l2ZW5cbiAgLy8gICAgYnl0ZXMsIGEgdHlwZSwgYSBvcHRpb25hbCBtaW1lVHlwZSwgYW5kIGEgb3B0aW9uYWxcbiAgLy8gICAgZW5jb2RpbmdOYW1lLCB3aGljaCBzd2l0Y2hlcyBvbiB0eXBlIGFuZCBydW5zIHRoZVxuICAvLyAgICBhc3NvY2lhdGVkIHN0ZXBzOlxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0RhdGFVUkwnOiB7XG4gICAgICAvLyAxLiBSZXR1cm4gYnl0ZXMgYXMgYSBEYXRhVVJMIFtSRkMyMzk3XSBzdWJqZWN0IHRvXG4gICAgICAvLyAgICB0aGUgY29uc2lkZXJhdGlvbnMgYmVsb3c6XG4gICAgICAvLyAgKiBVc2UgbWltZVR5cGUgYXMgcGFydCBvZiB0aGUgRGF0YSBVUkwgaWYgaXQgaXNcbiAgICAgIC8vICAgIGF2YWlsYWJsZSBpbiBrZWVwaW5nIHdpdGggdGhlIERhdGEgVVJMXG4gICAgICAvLyAgICBzcGVjaWZpY2F0aW9uIFtSRkMyMzk3XS5cbiAgICAgIC8vICAqIElmIG1pbWVUeXBlIGlzIG5vdCBhdmFpbGFibGUgcmV0dXJuIGEgRGF0YSBVUkxcbiAgICAgIC8vICAgIHdpdGhvdXQgYSBtZWRpYS10eXBlLiBbUkZDMjM5N10uXG5cbiAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMjM5NyNzZWN0aW9uLTNcbiAgICAgIC8vIGRhdGF1cmwgICAgOj0gXCJkYXRhOlwiIFsgbWVkaWF0eXBlIF0gWyBcIjtiYXNlNjRcIiBdIFwiLFwiIGRhdGFcbiAgICAgIC8vIG1lZGlhdHlwZSAgOj0gWyB0eXBlIFwiL1wiIHN1YnR5cGUgXSAqKCBcIjtcIiBwYXJhbWV0ZXIgKVxuICAgICAgLy8gZGF0YSAgICAgICA6PSAqdXJsY2hhclxuICAgICAgLy8gcGFyYW1ldGVyICA6PSBhdHRyaWJ1dGUgXCI9XCIgdmFsdWVcbiAgICAgIGxldCBkYXRhVVJMID0gJ2RhdGE6J1xuXG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKVxuXG4gICAgICBpZiAocGFyc2VkICE9PSAnZmFpbHVyZScpIHtcbiAgICAgICAgZGF0YVVSTCArPSBzZXJpYWxpemVBTWltZVR5cGUocGFyc2VkKVxuICAgICAgfVxuXG4gICAgICBkYXRhVVJMICs9ICc7YmFzZTY0LCdcblxuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCdsYXRpbjEnKVxuXG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGJ5dGVzKSB7XG4gICAgICAgIGRhdGFVUkwgKz0gYnRvYShkZWNvZGVyLndyaXRlKGNodW5rKSlcbiAgICAgIH1cblxuICAgICAgZGF0YVVSTCArPSBidG9hKGRlY29kZXIuZW5kKCkpXG5cbiAgICAgIHJldHVybiBkYXRhVVJMXG4gICAgfVxuICAgIGNhc2UgJ1RleHQnOiB7XG4gICAgICAvLyAxLiBMZXQgZW5jb2RpbmcgYmUgZmFpbHVyZVxuICAgICAgbGV0IGVuY29kaW5nID0gJ2ZhaWx1cmUnXG5cbiAgICAgIC8vIDIuIElmIHRoZSBlbmNvZGluZ05hbWUgaXMgcHJlc2VudCwgc2V0IGVuY29kaW5nIHRvIHRoZVxuICAgICAgLy8gICAgcmVzdWx0IG9mIGdldHRpbmcgYW4gZW5jb2RpbmcgZnJvbSBlbmNvZGluZ05hbWUuXG4gICAgICBpZiAoZW5jb2RpbmdOYW1lKSB7XG4gICAgICAgIGVuY29kaW5nID0gZ2V0RW5jb2RpbmcoZW5jb2RpbmdOYW1lKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiBlbmNvZGluZyBpcyBmYWlsdXJlLCBhbmQgbWltZVR5cGUgaXMgcHJlc2VudDpcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2ZhaWx1cmUnICYmIG1pbWVUeXBlKSB7XG4gICAgICAgIC8vIDEuIExldCB0eXBlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2UgYSBNSU1FIHR5cGVcbiAgICAgICAgLy8gICAgZ2l2ZW4gbWltZVR5cGUuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlKVxuXG4gICAgICAgIC8vIDIuIElmIHR5cGUgaXMgbm90IGZhaWx1cmUsIHNldCBlbmNvZGluZyB0byB0aGUgcmVzdWx0XG4gICAgICAgIC8vICAgIG9mIGdldHRpbmcgYW4gZW5jb2RpbmcgZnJvbSB0eXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXS5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIGVuY29kaW5nID0gZ2V0RW5jb2RpbmcodHlwZS5wYXJhbWV0ZXJzLmdldCgnY2hhcnNldCcpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDQuIElmIGVuY29kaW5nIGlzIGZhaWx1cmUsIHRoZW4gc2V0IGVuY29kaW5nIHRvIFVURi04LlxuICAgICAgaWYgKGVuY29kaW5nID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgZW5jb2RpbmcgPSAnVVRGLTgnXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIERlY29kZSBieXRlcyB1c2luZyBmYWxsYmFjayBlbmNvZGluZyBlbmNvZGluZywgYW5kXG4gICAgICAvLyAgICByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgIHJldHVybiBkZWNvZGUoYnl0ZXMsIGVuY29kaW5nKVxuICAgIH1cbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6IHtcbiAgICAgIC8vIFJldHVybiBhIG5ldyBBcnJheUJ1ZmZlciB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMuXG4gICAgICBjb25zdCBzZXF1ZW5jZSA9IGNvbWJpbmVCeXRlU2VxdWVuY2VzKGJ5dGVzKVxuXG4gICAgICByZXR1cm4gc2VxdWVuY2UuYnVmZmVyXG4gICAgfVxuICAgIGNhc2UgJ0JpbmFyeVN0cmluZyc6IHtcbiAgICAgIC8vIFJldHVybiBieXRlcyBhcyBhIGJpbmFyeSBzdHJpbmcsIGluIHdoaWNoIGV2ZXJ5IGJ5dGVcbiAgICAgIC8vICBpcyByZXByZXNlbnRlZCBieSBhIGNvZGUgdW5pdCBvZiBlcXVhbCB2YWx1ZSBbMC4uMjU1XS5cbiAgICAgIGxldCBiaW5hcnlTdHJpbmcgPSAnJ1xuXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoJ2xhdGluMScpXG5cbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgYnl0ZXMpIHtcbiAgICAgICAgYmluYXJ5U3RyaW5nICs9IGRlY29kZXIud3JpdGUoY2h1bmspXG4gICAgICB9XG5cbiAgICAgIGJpbmFyeVN0cmluZyArPSBkZWNvZGVyLmVuZCgpXG5cbiAgICAgIHJldHVybiBiaW5hcnlTdHJpbmdcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNkZWNvZGVcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBpb1F1ZXVlXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChpb1F1ZXVlLCBlbmNvZGluZykge1xuICBjb25zdCBieXRlcyA9IGNvbWJpbmVCeXRlU2VxdWVuY2VzKGlvUXVldWUpXG5cbiAgLy8gMS4gTGV0IEJPTUVuY29kaW5nIGJlIHRoZSByZXN1bHQgb2YgQk9NIHNuaWZmaW5nIGlvUXVldWUuXG4gIGNvbnN0IEJPTUVuY29kaW5nID0gQk9NU25pZmZpbmcoYnl0ZXMpXG5cbiAgbGV0IHNsaWNlID0gMFxuXG4gIC8vIDIuIElmIEJPTUVuY29kaW5nIGlzIG5vbi1udWxsOlxuICBpZiAoQk9NRW5jb2RpbmcgIT09IG51bGwpIHtcbiAgICAvLyAxLiBTZXQgZW5jb2RpbmcgdG8gQk9NRW5jb2RpbmcuXG4gICAgZW5jb2RpbmcgPSBCT01FbmNvZGluZ1xuXG4gICAgLy8gMi4gUmVhZCB0aHJlZSBieXRlcyBmcm9tIGlvUXVldWUsIGlmIEJPTUVuY29kaW5nIGlzXG4gICAgLy8gICAgVVRGLTg7IG90aGVyd2lzZSByZWFkIHR3byBieXRlcy5cbiAgICAvLyAgICAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgICBzbGljZSA9IEJPTUVuY29kaW5nID09PSAnVVRGLTgnID8gMyA6IDJcbiAgfVxuXG4gIC8vIDMuIFByb2Nlc3MgYSBxdWV1ZSB3aXRoIGFuIGluc3RhbmNlIG9mIGVuY29kaW5n4oCZc1xuICAvLyAgICBkZWNvZGVyLCBpb1F1ZXVlLCBvdXRwdXQsIGFuZCBcInJlcGxhY2VtZW50XCIuXG5cbiAgLy8gNC4gUmV0dXJuIG91dHB1dC5cblxuICBjb25zdCBzbGljZWQgPSBieXRlcy5zbGljZShzbGljZSlcbiAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZykuZGVjb2RlKHNsaWNlZClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNib20tc25pZmZcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaW9RdWV1ZVxuICovXG5mdW5jdGlvbiBCT01TbmlmZmluZyAoaW9RdWV1ZSkge1xuICAvLyAxLiBMZXQgQk9NIGJlIHRoZSByZXN1bHQgb2YgcGVla2luZyAzIGJ5dGVzIGZyb20gaW9RdWV1ZSxcbiAgLy8gICAgY29udmVydGVkIHRvIGEgYnl0ZSBzZXF1ZW5jZS5cbiAgY29uc3QgW2EsIGIsIGNdID0gaW9RdWV1ZVxuXG4gIC8vIDIuIEZvciBlYWNoIG9mIHRoZSByb3dzIGluIHRoZSB0YWJsZSBiZWxvdywgc3RhcnRpbmcgd2l0aFxuICAvLyAgICB0aGUgZmlyc3Qgb25lIGFuZCBnb2luZyBkb3duLCBpZiBCT00gc3RhcnRzIHdpdGggdGhlXG4gIC8vICAgIGJ5dGVzIGdpdmVuIGluIHRoZSBmaXJzdCBjb2x1bW4sIHRoZW4gcmV0dXJuIHRoZVxuICAvLyAgICBlbmNvZGluZyBnaXZlbiBpbiB0aGUgY2VsbCBpbiB0aGUgc2Vjb25kIGNvbHVtbiBvZiB0aGF0XG4gIC8vICAgIHJvdy4gT3RoZXJ3aXNlLCByZXR1cm4gbnVsbC5cbiAgaWYgKGEgPT09IDB4RUYgJiYgYiA9PT0gMHhCQiAmJiBjID09PSAweEJGKSB7XG4gICAgcmV0dXJuICdVVEYtOCdcbiAgfSBlbHNlIGlmIChhID09PSAweEZFICYmIGIgPT09IDB4RkYpIHtcbiAgICByZXR1cm4gJ1VURi0xNkJFJ1xuICB9IGVsc2UgaWYgKGEgPT09IDB4RkYgJiYgYiA9PT0gMHhGRSkge1xuICAgIHJldHVybiAnVVRGLTE2TEUnXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBzZXF1ZW5jZXNcbiAqL1xuZnVuY3Rpb24gY29tYmluZUJ5dGVTZXF1ZW5jZXMgKHNlcXVlbmNlcykge1xuICBjb25zdCBzaXplID0gc2VxdWVuY2VzLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIHJldHVybiBhICsgYi5ieXRlTGVuZ3RoXG4gIH0sIDApXG5cbiAgbGV0IG9mZnNldCA9IDBcblxuICByZXR1cm4gc2VxdWVuY2VzLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIGEuc2V0KGIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYi5ieXRlTGVuZ3RoXG4gICAgcmV0dXJuIGFcbiAgfSwgbmV3IFVpbnQ4QXJyYXkoc2l6ZSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICByZWFkT3BlcmF0aW9uLFxuICBmaXJlQVByb2dyZXNzRXZlbnRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/fileapi/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/global.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for('undici.globalDispatcher.1')\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/undici/lib/agent.js\")\n\nif (getGlobalDispatcher() === undefined) {\n  setGlobalDispatcher(new Agent())\n}\n\nfunction setGlobalDispatcher (agent) {\n  if (!agent || typeof agent.dispatch !== 'function') {\n    throw new InvalidArgumentError('Argument agent must implement Agent')\n  }\n  Object.defineProperty(globalThis, globalDispatcher, {\n    value: agent,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nfunction getGlobalDispatcher () {\n  return globalThis[globalDispatcher]\n}\n\nmodule.exports = {\n  setGlobalDispatcher,\n  getGlobalDispatcher\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHFFQUFlO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyx5REFBUzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanM/NzE1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gV2UgaW5jbHVkZSBhIHZlcnNpb24gbnVtYmVyIGZvciB0aGUgRGlzcGF0Y2hlciBBUEkuIEluIGNhc2Ugb2YgYnJlYWtpbmcgY2hhbmdlcyxcbi8vIHRoaXMgdmVyc2lvbiBudW1iZXIgbXVzdCBiZSBpbmNyZWFzZWQgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsRGlzcGF0Y2hlciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5nbG9iYWxEaXNwYXRjaGVyLjEnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQnKVxuXG5pZiAoZ2V0R2xvYmFsRGlzcGF0Y2hlcigpID09PSB1bmRlZmluZWQpIHtcbiAgc2V0R2xvYmFsRGlzcGF0Y2hlcihuZXcgQWdlbnQoKSlcbn1cblxuZnVuY3Rpb24gc2V0R2xvYmFsRGlzcGF0Y2hlciAoYWdlbnQpIHtcbiAgaWYgKCFhZ2VudCB8fCB0eXBlb2YgYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IGFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsRGlzcGF0Y2hlciwge1xuICAgIHZhbHVlOiBhZ2VudCxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldEdsb2JhbERpc3BhdGNoZXIgKCkge1xuICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxEaXNwYXRjaGVyXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0R2xvYmFsRGlzcGF0Y2hlcixcbiAgZ2V0R2xvYmFsRGlzcGF0Y2hlclxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/DecoratorHandler.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/handler/DecoratorHandler.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = class DecoratorHandler {\n  constructor (handler) {\n    this.handler = handler\n  }\n\n  onConnect (...args) {\n    return this.handler.onConnect(...args)\n  }\n\n  onError (...args) {\n    return this.handler.onError(...args)\n  }\n\n  onUpgrade (...args) {\n    return this.handler.onUpgrade(...args)\n  }\n\n  onHeaders (...args) {\n    return this.handler.onHeaders(...args)\n  }\n\n  onData (...args) {\n    return this.handler.onData(...args)\n  }\n\n  onComplete (...args) {\n    return this.handler.onComplete(...args)\n  }\n\n  onBodySent (...args) {\n    return this.handler.onBodySent(...args)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL0RlY29yYXRvckhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL0RlY29yYXRvckhhbmRsZXIuanM/MGRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEZWNvcmF0b3JIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhhbmRsZXIpIHtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gIH1cblxuICBvbkNvbm5lY3QgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uQ29ubmVjdCguLi5hcmdzKVxuICB9XG5cbiAgb25FcnJvciAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25FcnJvciguLi5hcmdzKVxuICB9XG5cbiAgb25VcGdyYWRlICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vblVwZ3JhZGUoLi4uYXJncylcbiAgfVxuXG4gIG9uSGVhZGVycyAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25IZWFkZXJzKC4uLmFyZ3MpXG4gIH1cblxuICBvbkRhdGEgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRGF0YSguLi5hcmdzKVxuICB9XG5cbiAgb25Db21wbGV0ZSAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25Db21wbGV0ZSguLi5hcmdzKVxuICB9XG5cbiAgb25Cb2R5U2VudCAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25Cb2R5U2VudCguLi5hcmdzKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/DecoratorHandler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/RedirectHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/handler/RedirectHandler.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst EE = __webpack_require__(/*! events */ \"events\")\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308]\n\nconst kBody = Symbol('body')\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nclass RedirectHandler {\n  constructor (dispatch, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    util.validateHandler(handler, opts.method, opts.upgrade)\n\n    this.dispatch = dispatch\n    this.location = null\n    this.abort = null\n    this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy\n    this.maxRedirections = maxRedirections\n    this.handler = handler\n    this.history = []\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body\n          .on('data', function () {\n            assert(false)\n          })\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true\n        })\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    } else if (\n      this.opts.body &&\n      typeof this.opts.body !== 'string' &&\n      !ArrayBuffer.isView(this.opts.body) &&\n      util.isIterable(this.opts.body)\n    ) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    }\n  }\n\n  onConnect (abort) {\n    this.abort = abort\n    this.handler.onConnect(abort, { history: this.history })\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    this.handler.onUpgrade(statusCode, headers, socket)\n  }\n\n  onError (error) {\n    this.handler.onError(error)\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)\n      ? null\n      : parseLocation(statusCode, headers)\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin))\n    }\n\n    if (!this.location) {\n      return this.handler.onHeaders(statusCode, headers, resume, statusText)\n    }\n\n    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)))\n    const path = search ? `${pathname}${search}` : pathname\n\n    // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)\n    this.opts.path = path\n    this.opts.origin = origin\n    this.opts.maxRedirections = 0\n    this.opts.query = null\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET'\n      this.opts.body = null\n    }\n  }\n\n  onData (chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitily chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      return this.handler.onData(chunk)\n    }\n  }\n\n  onComplete (trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed informations.\n      */\n\n      this.location = null\n      this.abort = null\n\n      this.dispatch(this.opts, this)\n    } else {\n      this.handler.onComplete(trailers)\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) {\n      this.handler.onBodySent(chunk)\n    }\n  }\n}\n\nfunction parseLocation (statusCode, headers) {\n  if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n    return null\n  }\n\n  for (let i = 0; i < headers.length; i += 2) {\n    if (headers[i].toString().toLowerCase() === 'location') {\n      return headers[i + 1]\n    }\n  }\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader (header, removeContent, unknownOrigin) {\n  return (\n    (header.length === 4 && header.toString().toLowerCase() === 'host') ||\n    (removeContent && header.toString().toLowerCase().indexOf('content-') === 0) ||\n    (unknownOrigin && header.length === 13 && header.toString().toLowerCase() === 'authorization') ||\n    (unknownOrigin && header.length === 6 && header.toString().toLowerCase() === 'cookie')\n  )\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders (headers, removeContent, unknownOrigin) {\n  const ret = []\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1])\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    for (const key of Object.keys(headers)) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, headers[key])\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array')\n  }\n  return ret\n}\n\nmodule.exports = RedirectHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL1JlZGlyZWN0SGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDekQsV0FBVyxtQkFBTyxDQUFDLHNCQUFROztBQUUzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksMkJBQTJCO0FBQ3ZDLDZCQUE2QixTQUFTLEVBQUUsT0FBTzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL1JlZGlyZWN0SGFuZGxlci5qcz80ZTIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsga0JvZHlVc2VkIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcblxuY29uc3QgcmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMgPSBbMzAwLCAzMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuY29uc3Qga0JvZHkgPSBTeW1ib2woJ2JvZHknKVxuXG5jbGFzcyBCb2R5QXN5bmNJdGVyYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChib2R5KSB7XG4gICAgdGhpc1trQm9keV0gPSBib2R5XG4gICAgdGhpc1trQm9keVVzZWRdID0gZmFsc2VcbiAgfVxuXG4gIGFzeW5jICogW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgYXNzZXJ0KCF0aGlzW2tCb2R5VXNlZF0sICdkaXN0dXJiZWQnKVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICB5aWVsZCAqIHRoaXNba0JvZHldXG4gIH1cbn1cblxuY2xhc3MgUmVkaXJlY3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGRpc3BhdGNoLCBtYXhSZWRpcmVjdGlvbnMsIG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIHV0aWwudmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIsIG9wdHMubWV0aG9kLCBvcHRzLnVwZ3JhZGUpXG5cbiAgICB0aGlzLmRpc3BhdGNoID0gZGlzcGF0Y2hcbiAgICB0aGlzLmxvY2F0aW9uID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBtYXhSZWRpcmVjdGlvbnM6IDAgfSAvLyBvcHRzIG11c3QgYmUgYSBjb3B5XG4gICAgdGhpcy5tYXhSZWRpcmVjdGlvbnMgPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gICAgdGhpcy5oaXN0b3J5ID0gW11cblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgLy8gVE9ETyAoZml4KTogUHJvdmlkZSBzb21lIHdheSBmb3IgdGhlIHVzZXIgdG8gY2FjaGUgdGhlIGZpbGUgdG8gZS5nLiAvdG1wXG4gICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGFnYWluP1xuICAgICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCAxMDAtZXhwZWN0IHN1cHBvcnQgdG8gcHJvdmlkZSBhIHdheSB0byBkbyB0aGlzIHByb3Blcmx5P1xuICAgICAgaWYgKHV0aWwuYm9keUxlbmd0aCh0aGlzLm9wdHMuYm9keSkgPT09IDApIHtcbiAgICAgICAgdGhpcy5vcHRzLmJvZHlcbiAgICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UpXG4gICAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMuYm9keS5yZWFkYWJsZURpZFJlYWQgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLm9wdHMuYm9keVtrQm9keVVzZWRdID0gZmFsc2VcbiAgICAgICAgRUUucHJvdG90eXBlLm9uLmNhbGwodGhpcy5vcHRzLmJvZHksICdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5ib2R5ICYmIHR5cGVvZiB0aGlzLm9wdHMuYm9keS5waXBlVG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRPRE8gKGZpeCk6IFdlIGNhbid0IGFjY2VzcyBSZWFkYWJsZVN0cmVhbSBpbnRlcm5hbCBzdGF0ZVxuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBiZWVuIGRpc3R1cmJlZC4gVGhpcyBpcyBqdXN0XG4gICAgICAvLyBhIHdvcmthcm91bmQuXG4gICAgICB0aGlzLm9wdHMuYm9keSA9IG5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5vcHRzLmJvZHkgJiZcbiAgICAgIHR5cGVvZiB0aGlzLm9wdHMuYm9keSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5vcHRzLmJvZHkpICYmXG4gICAgICB1dGlsLmlzSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpXG4gICAgKSB7XG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgYWxsb3cgcmUtdXNpbmcgaXRlcmFibGUgaWYgIXRoaXMub3B0cy5pZGVtcG90ZW50XG4gICAgICAvLyBvciB0aHJvdWdoIHNvbWUgb3RoZXIgZmxhZz9cbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmhhbmRsZXIub25Db25uZWN0KGFib3J0LCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSB9KVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICB0aGlzLmhhbmRsZXIub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyb3IpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmhpc3RvcnkubGVuZ3RoID49IHRoaXMubWF4UmVkaXJlY3Rpb25zIHx8IHV0aWwuaXNEaXN0dXJiZWQodGhpcy5vcHRzLmJvZHkpXG4gICAgICA/IG51bGxcbiAgICAgIDogcGFyc2VMb2NhdGlvbihzdGF0dXNDb2RlLCBoZWFkZXJzKVxuXG4gICAgaWYgKHRoaXMub3B0cy5vcmlnaW4pIHtcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKG5ldyBVUkwodGhpcy5vcHRzLnBhdGgsIHRoaXMub3B0cy5vcmlnaW4pKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICAgIH1cblxuICAgIGNvbnN0IHsgb3JpZ2luLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1dGlsLnBhcnNlVVJMKG5ldyBVUkwodGhpcy5sb2NhdGlvbiwgdGhpcy5vcHRzLm9yaWdpbiAmJiBuZXcgVVJMKHRoaXMub3B0cy5wYXRoLCB0aGlzLm9wdHMub3JpZ2luKSkpXG4gICAgY29uc3QgcGF0aCA9IHNlYXJjaCA/IGAke3BhdGhuYW1lfSR7c2VhcmNofWAgOiBwYXRobmFtZVxuXG4gICAgLy8gUmVtb3ZlIGhlYWRlcnMgcmVmZXJyaW5nIHRvIHRoZSBvcmlnaW5hbCBVUkwuXG4gICAgLy8gQnkgZGVmYXVsdCBpdCBpcyBIb3N0IG9ubHksIHVubGVzcyBpdCdzIGEgMzAzIChzZWUgYmVsb3cpLCB3aGljaCByZW1vdmVzIGFsc28gYWxsIENvbnRlbnQtKiBoZWFkZXJzLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG4gICAgdGhpcy5vcHRzLmhlYWRlcnMgPSBjbGVhblJlcXVlc3RIZWFkZXJzKHRoaXMub3B0cy5oZWFkZXJzLCBzdGF0dXNDb2RlID09PSAzMDMsIHRoaXMub3B0cy5vcmlnaW4gIT09IG9yaWdpbilcbiAgICB0aGlzLm9wdHMucGF0aCA9IHBhdGhcbiAgICB0aGlzLm9wdHMub3JpZ2luID0gb3JpZ2luXG4gICAgdGhpcy5vcHRzLm1heFJlZGlyZWN0aW9ucyA9IDBcbiAgICB0aGlzLm9wdHMucXVlcnkgPSBudWxsXG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNC40XG4gICAgLy8gSW4gY2FzZSBvZiBIVFRQIDMwMywgYWx3YXlzIHJlcGxhY2UgbWV0aG9kIHRvIGJlIGVpdGhlciBIRUFEIG9yIEdFVFxuICAgIGlmIChzdGF0dXNDb2RlID09PSAzMDMgJiYgdGhpcy5vcHRzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLm9wdHMubWV0aG9kID0gJ0dFVCdcbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgLypcbiAgICAgICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcblxuICAgICAgICBUTERSOiB1bmRpY2kgYWx3YXlzIGlnbm9yZXMgM3h4IHJlc3BvbnNlIGJvZGllcy5cblxuICAgICAgICBSZWRpcmVjdGlvbiBpcyB1c2VkIHRvIHNlcnZlIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgZnJvbSBhbm90aGVyIFVSTCwgc28gaXQgaXMgYXNzdW1lcyB0aGF0XG4gICAgICAgIG5vIGJvZHkgaXMgZ2VuZXJhdGVkIChhbmQgdGh1cyBjYW4gYmUgaWdub3JlZCkuIEV2ZW4gdGhvdWdoIGdlbmVyYXRpbmcgYSBib2R5IGlzIG5vdCBwcm9oaWJpdGVkLlxuXG4gICAgICAgIEZvciBzdGF0dXMgMzAxLCAzMDIsIDMwMywgMzA3IGFuZCAzMDggKHRoZSBsYXR0ZXIgZnJvbSBSRkMgNzIzOCksIHRoZSBzcGVjcyBtZW50aW9uIHRoYXQgdGhlIGJvZHkgdXN1YWxseVxuICAgICAgICAod2hpY2ggbWVhbnMgaXQncyBvcHRpb25hbCBhbmQgbm90IG1hbmRhdGVkKSBjb250YWluIGp1c3QgYW4gaHlwZXJsaW5rIHRvIHRoZSB2YWx1ZSBvZlxuICAgICAgICB0aGUgTG9jYXRpb24gcmVzcG9uc2UgaGVhZGVyLCBzbyB0aGUgYm9keSBjYW4gYmUgaWdub3JlZCBzYWZlbHkuXG5cbiAgICAgICAgRm9yIHN0YXR1cyAzMDAsIHdoaWNoIGlzIFwiTXVsdGlwbGUgQ2hvaWNlc1wiLCB0aGUgc3BlYyBtZW50aW9ucyBib3RoIGdlbmVyYXRpbmcgYSBMb2NhdGlvblxuICAgICAgICByZXNwb25zZSBoZWFkZXIgQU5EIGEgcmVzcG9uc2UgYm9keSB3aXRoIHRoZSBvdGhlciBwb3NzaWJsZSBsb2NhdGlvbiB0byBmb2xsb3cuXG4gICAgICAgIFNpbmNlIHRoZSBzcGVjIGV4cGxpY2l0aWx5IGNob29zZXMgbm90IHRvIHNwZWNpZnkgYSBmb3JtYXQgZm9yIHN1Y2ggYm9keSBhbmQgbGVhdmUgaXQgdG9cbiAgICAgICAgc2VydmVycyBhbmQgYnJvd3NlcnMgaW1wbGVtZW50b3JzLCB3ZSBpZ25vcmUgdGhlIGJvZHkgYXMgdGhlcmUgaXMgbm8gc3BlY2lmaWVkIHdheSB0byBldmVudHVhbGx5IHBhcnNlIGl0LlxuICAgICAgKi9cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkRhdGEoY2h1bmspXG4gICAgfVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgLypcbiAgICAgICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcblxuICAgICAgICBUTERSOiB1bmRpY2kgYWx3YXlzIGlnbm9yZXMgM3h4IHJlc3BvbnNlIHRyYWlsZXJzIGFzIHRoZXkgYXJlIG5vdCBleHBlY3RlZCBpbiBjYXNlIG9mIHJlZGlyZWN0aW9uc1xuICAgICAgICBhbmQgbmVpdGhlciBhcmUgdXNlZnVsIGlmIHByZXNlbnQuXG5cbiAgICAgICAgU2VlIGNvbW1lbnQgb24gb25EYXRhIG1ldGhvZCBhYm92ZSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbnMuXG4gICAgICAqL1xuXG4gICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbFxuICAgICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLm9wdHMsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vbkNvbXBsZXRlKHRyYWlsZXJzKVxuICAgIH1cbiAgfVxuXG4gIG9uQm9keVNlbnQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25Cb2R5U2VudChjaHVuaylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhdGlvbiAoc3RhdHVzQ29kZSwgaGVhZGVycykge1xuICBpZiAocmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMuaW5kZXhPZihzdGF0dXNDb2RlKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKGhlYWRlcnNbaV0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnbG9jYXRpb24nKSB7XG4gICAgICByZXR1cm4gaGVhZGVyc1tpICsgMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuNFxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlSGVhZGVyIChoZWFkZXIsIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pIHtcbiAgcmV0dXJuIChcbiAgICAoaGVhZGVyLmxlbmd0aCA9PT0gNCAmJiBoZWFkZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnaG9zdCcpIHx8XG4gICAgKHJlbW92ZUNvbnRlbnQgJiYgaGVhZGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjb250ZW50LScpID09PSAwKSB8fFxuICAgICh1bmtub3duT3JpZ2luICYmIGhlYWRlci5sZW5ndGggPT09IDEzICYmIGhlYWRlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICdhdXRob3JpemF0aW9uJykgfHxcbiAgICAodW5rbm93bk9yaWdpbiAmJiBoZWFkZXIubGVuZ3RoID09PSA2ICYmIGhlYWRlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICdjb29raWUnKVxuICApXG59XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG5mdW5jdGlvbiBjbGVhblJlcXVlc3RIZWFkZXJzIChoZWFkZXJzLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gIGNvbnN0IHJldCA9IFtdXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoIXNob3VsZFJlbW92ZUhlYWRlcihoZWFkZXJzW2ldLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICByZXQucHVzaChoZWFkZXJzW2ldLCBoZWFkZXJzW2kgKyAxXSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoa2V5LCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICByZXQucHVzaChrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGhlYWRlcnMgPT0gbnVsbCwgJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWRpcmVjdEhhbmRsZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/RedirectHandler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/redirectInterceptor.js":
/*!********************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirectInterceptor.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst RedirectHandler = __webpack_require__(/*! ../handler/RedirectHandler */ \"(ssr)/./node_modules/undici/lib/handler/RedirectHandler.js\")\n\nfunction createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections }) {\n  return (dispatch) => {\n    return function Intercept (opts, handler) {\n      const { maxRedirections = defaultMaxRedirections } = opts\n\n      if (!maxRedirections) {\n        return dispatch(opts, handler)\n      }\n\n      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler)\n      opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.\n      return dispatch(opts, redirectHandler)\n    }\n  }\n}\n\nmodule.exports = createRedirectInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdEludGVyY2VwdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHdCQUF3QixtQkFBTyxDQUFDLDhGQUE0Qjs7QUFFNUQsc0NBQXNDLHlDQUF5QztBQUMvRTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3RJbnRlcmNlcHRvci5qcz83ZDRjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSZWRpcmVjdEhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL1JlZGlyZWN0SGFuZGxlcicpXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgKHsgbWF4UmVkaXJlY3Rpb25zOiBkZWZhdWx0TWF4UmVkaXJlY3Rpb25zIH0pIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBJbnRlcmNlcHQgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgbWF4UmVkaXJlY3Rpb25zID0gZGVmYXVsdE1heFJlZGlyZWN0aW9ucyB9ID0gb3B0c1xuXG4gICAgICBpZiAoIW1heFJlZGlyZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVkaXJlY3RIYW5kbGVyID0gbmV3IFJlZGlyZWN0SGFuZGxlcihkaXNwYXRjaCwgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgb3B0cyA9IHsgLi4ub3B0cywgbWF4UmVkaXJlY3Rpb25zOiAwIH0gLy8gU3RvcCBzdWIgZGlzcGF0Y2hlciBmcm9tIGFsc28gcmVkaXJlY3RpbmcuXG4gICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgcmVkaXJlY3RIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3JcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/redirectInterceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/undici/lib/llhttp/utils.js\");\n// C headers\nvar ERROR;\n(function (ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function (TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function (FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function (LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function (METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */\n    METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */\n    METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */\n    METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */\n    METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */\n    METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */\n    METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */\n    METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */\n    METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */\n    METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */\n    METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */\n    METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS['M-SEARCH'],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE,\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE,\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST,\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key) => {\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function (FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n};\nexports.HEX_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,\n    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,\n};\nexports.NUM = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = ['-', '_', '.', '!', '~', '*', '\\'', '(', ')'];\nexports.USERINFO_CHARS = exports.ALPHANUM\n    .concat(exports.MARK)\n    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    '!', '\"', '$', '%', '&', '\\'',\n    '(', ')', '*', '+', ',', '-', '.', '/',\n    ':', ';', '<', '=', '>',\n    '@', '[', '\\\\', ']', '^', '_',\n    '`',\n    '{', '|', '}', '~',\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR\n    .concat(['\\t', '\\f']);\n// All characters with 0x80 bit set to 1\nfor (let i = 0x80; i <= 0xff; i++) {\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */\nexports.STRICT_TOKEN = [\n    '!', '#', '$', '%', '&', '\\'',\n    '*', '+', '-', '.',\n    '^', '_', '`',\n    '|', '~',\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([' ']);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */\nexports.HEADER_CHARS = ['\\t'];\nfor (let i = 32; i <= 255; i++) {\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function (HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    'connection': HEADER_STATE.CONNECTION,\n    'content-length': HEADER_STATE.CONTENT_LENGTH,\n    'proxy-connection': HEADER_STATE.CONNECTION,\n    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,\n    'upgrade': HEADER_STATE.UPGRADE,\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcsb0JBQW9CLEdBQUcsYUFBYSxHQUFHLG9CQUFvQixHQUFHLFdBQVcsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxhQUFhO0FBQy9qQixnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLGFBQWEsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsWUFBWSxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLGFBQWEsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEMscUJBQXFCLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDLGVBQWUsS0FBSztBQUNyRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCLGNBQWMsS0FBSztBQUNsRCxhQUFhO0FBQ2IsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNLFVBQVU7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDLG9CQUFvQixLQUFLO0FBQ3BFLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9jb25zdGFudHMuanM/YjQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0gZXhwb3J0cy5IRUFERVJfU1RBVEUgPSBleHBvcnRzLk1JTk9SID0gZXhwb3J0cy5NQUpPUiA9IGV4cG9ydHMuQ09OTkVDVElPTl9UT0tFTl9DSEFSUyA9IGV4cG9ydHMuSEVBREVSX0NIQVJTID0gZXhwb3J0cy5UT0tFTiA9IGV4cG9ydHMuU1RSSUNUX1RPS0VOID0gZXhwb3J0cy5IRVggPSBleHBvcnRzLlVSTF9DSEFSID0gZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVIgPSBleHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5NQVJLID0gZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuTlVNID0gZXhwb3J0cy5IRVhfTUFQID0gZXhwb3J0cy5OVU1fTUFQID0gZXhwb3J0cy5BTFBIQSA9IGV4cG9ydHMuRklOSVNIID0gZXhwb3J0cy5IX01FVEhPRF9NQVAgPSBleHBvcnRzLk1FVEhPRF9NQVAgPSBleHBvcnRzLk1FVEhPRFNfUlRTUCA9IGV4cG9ydHMuTUVUSE9EU19JQ0UgPSBleHBvcnRzLk1FVEhPRFNfSFRUUCA9IGV4cG9ydHMuTUVUSE9EUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuRkxBR1MgPSBleHBvcnRzLlRZUEUgPSBleHBvcnRzLkVSUk9SID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLy8gQyBoZWFkZXJzXG52YXIgRVJST1I7XG4oZnVuY3Rpb24gKEVSUk9SKSB7XG4gICAgRVJST1JbRVJST1JbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5URVJOQUxcIl0gPSAxXSA9IFwiSU5URVJOQUxcIjtcbiAgICBFUlJPUltFUlJPUltcIlNUUklDVFwiXSA9IDJdID0gXCJTVFJJQ1RcIjtcbiAgICBFUlJPUltFUlJPUltcIkxGX0VYUEVDVEVEXCJdID0gM10gPSBcIkxGX0VYUEVDVEVEXCI7XG4gICAgRVJST1JbRVJST1JbXCJVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIXCJdID0gNF0gPSBcIlVORVhQRUNURURfQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBFUlJPUltFUlJPUltcIkNMT1NFRF9DT05ORUNUSU9OXCJdID0gNV0gPSBcIkNMT1NFRF9DT05ORUNUSU9OXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX01FVEhPRFwiXSA9IDZdID0gXCJJTlZBTElEX01FVEhPRFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9VUkxcIl0gPSA3XSA9IFwiSU5WQUxJRF9VUkxcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ09OU1RBTlRcIl0gPSA4XSA9IFwiSU5WQUxJRF9DT05TVEFOVFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9WRVJTSU9OXCJdID0gOV0gPSBcIklOVkFMSURfVkVSU0lPTlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9IRUFERVJfVE9LRU5cIl0gPSAxMF0gPSBcIklOVkFMSURfSEVBREVSX1RPS0VOXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0NPTlRFTlRfTEVOR1RIXCJdID0gMTFdID0gXCJJTlZBTElEX0NPTlRFTlRfTEVOR1RIXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0NIVU5LX1NJWkVcIl0gPSAxMl0gPSBcIklOVkFMSURfQ0hVTktfU0laRVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9TVEFUVVNcIl0gPSAxM10gPSBcIklOVkFMSURfU1RBVFVTXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0VPRl9TVEFURVwiXSA9IDE0XSA9IFwiSU5WQUxJRF9FT0ZfU1RBVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIl0gPSAxNV0gPSBcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX01FU1NBR0VfQkVHSU5cIl0gPSAxNl0gPSBcIkNCX01FU1NBR0VfQkVHSU5cIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0hFQURFUlNfQ09NUExFVEVcIl0gPSAxN10gPSBcIkNCX0hFQURFUlNfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX01FU1NBR0VfQ09NUExFVEVcIl0gPSAxOF0gPSBcIkNCX01FU1NBR0VfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0NIVU5LX0hFQURFUlwiXSA9IDE5XSA9IFwiQ0JfQ0hVTktfSEVBREVSXCI7XG4gICAgRVJST1JbRVJST1JbXCJDQl9DSFVOS19DT01QTEVURVwiXSA9IDIwXSA9IFwiQ0JfQ0hVTktfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRFwiXSA9IDIxXSA9IFwiUEFVU0VEXCI7XG4gICAgRVJST1JbRVJST1JbXCJQQVVTRURfVVBHUkFERVwiXSA9IDIyXSA9IFwiUEFVU0VEX1VQR1JBREVcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRF9IMl9VUEdSQURFXCJdID0gMjNdID0gXCJQQVVTRURfSDJfVVBHUkFERVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiVVNFUlwiXSA9IDI0XSA9IFwiVVNFUlwiO1xufSkoRVJST1IgPSBleHBvcnRzLkVSUk9SIHx8IChleHBvcnRzLkVSUk9SID0ge30pKTtcbnZhciBUWVBFO1xuKGZ1bmN0aW9uIChUWVBFKSB7XG4gICAgVFlQRVtUWVBFW1wiQk9USFwiXSA9IDBdID0gXCJCT1RIXCI7XG4gICAgVFlQRVtUWVBFW1wiUkVRVUVTVFwiXSA9IDFdID0gXCJSRVFVRVNUXCI7XG4gICAgVFlQRVtUWVBFW1wiUkVTUE9OU0VcIl0gPSAyXSA9IFwiUkVTUE9OU0VcIjtcbn0pKFRZUEUgPSBleHBvcnRzLlRZUEUgfHwgKGV4cG9ydHMuVFlQRSA9IHt9KSk7XG52YXIgRkxBR1M7XG4oZnVuY3Rpb24gKEZMQUdTKSB7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIl0gPSAxXSA9IFwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05ORUNUSU9OX0NMT1NFXCJdID0gMl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fVVBHUkFERVwiXSA9IDRdID0gXCJDT05ORUNUSU9OX1VQR1JBREVcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNIVU5LRURcIl0gPSA4XSA9IFwiQ0hVTktFRFwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiVVBHUkFERVwiXSA9IDE2XSA9IFwiVVBHUkFERVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ09OVEVOVF9MRU5HVEhcIl0gPSAzMl0gPSBcIkNPTlRFTlRfTEVOR1RIXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJTS0lQQk9EWVwiXSA9IDY0XSA9IFwiU0tJUEJPRFlcIjtcbiAgICBGTEFHU1tGTEFHU1tcIlRSQUlMSU5HXCJdID0gMTI4XSA9IFwiVFJBSUxJTkdcIjtcbiAgICAvLyAxIDw8IDggaXMgdW51c2VkXG4gICAgRkxBR1NbRkxBR1NbXCJUUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDUxMl0gPSBcIlRSQU5TRkVSX0VOQ09ESU5HXCI7XG59KShGTEFHUyA9IGV4cG9ydHMuRkxBR1MgfHwgKGV4cG9ydHMuRkxBR1MgPSB7fSkpO1xudmFyIExFTklFTlRfRkxBR1M7XG4oZnVuY3Rpb24gKExFTklFTlRfRkxBR1MpIHtcbiAgICBMRU5JRU5UX0ZMQUdTW0xFTklFTlRfRkxBR1NbXCJIRUFERVJTXCJdID0gMV0gPSBcIkhFQURFUlNcIjtcbiAgICBMRU5JRU5UX0ZMQUdTW0xFTklFTlRfRkxBR1NbXCJDSFVOS0VEX0xFTkdUSFwiXSA9IDJdID0gXCJDSFVOS0VEX0xFTkdUSFwiO1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIktFRVBfQUxJVkVcIl0gPSA0XSA9IFwiS0VFUF9BTElWRVwiO1xufSkoTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyB8fCAoZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0ge30pKTtcbnZhciBNRVRIT0RTO1xuKGZ1bmN0aW9uIChNRVRIT0RTKSB7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiREVMRVRFXCJdID0gMF0gPSBcIkRFTEVURVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkdFVFwiXSA9IDFdID0gXCJHRVRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJIRUFEXCJdID0gMl0gPSBcIkhFQURcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQT1NUXCJdID0gM10gPSBcIlBPU1RcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQVVRcIl0gPSA0XSA9IFwiUFVUXCI7XG4gICAgLyogcGF0aG9sb2dpY2FsICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQ09OTkVDVFwiXSA9IDVdID0gXCJDT05ORUNUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiT1BUSU9OU1wiXSA9IDZdID0gXCJPUFRJT05TXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVFJBQ0VcIl0gPSA3XSA9IFwiVFJBQ0VcIjtcbiAgICAvKiBXZWJEQVYgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDT1BZXCJdID0gOF0gPSBcIkNPUFlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJMT0NLXCJdID0gOV0gPSBcIkxPQ0tcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNS0NPTFwiXSA9IDEwXSA9IFwiTUtDT0xcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNT1ZFXCJdID0gMTFdID0gXCJNT1ZFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJPUEZJTkRcIl0gPSAxMl0gPSBcIlBST1BGSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJPUFBBVENIXCJdID0gMTNdID0gXCJQUk9QUEFUQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTRUFSQ0hcIl0gPSAxNF0gPSBcIlNFQVJDSFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOTE9DS1wiXSA9IDE1XSA9IFwiVU5MT0NLXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQklORFwiXSA9IDE2XSA9IFwiQklORFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFQklORFwiXSA9IDE3XSA9IFwiUkVCSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5CSU5EXCJdID0gMThdID0gXCJVTkJJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJBQ0xcIl0gPSAxOV0gPSBcIkFDTFwiO1xuICAgIC8qIHN1YnZlcnNpb24gKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJSRVBPUlRcIl0gPSAyMF0gPSBcIlJFUE9SVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1LQUNUSVZJVFlcIl0gPSAyMV0gPSBcIk1LQUNUSVZJVFlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDSEVDS09VVFwiXSA9IDIyXSA9IFwiQ0hFQ0tPVVRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNRVJHRVwiXSA9IDIzXSA9IFwiTUVSR0VcIjtcbiAgICAvKiB1cG5wICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTS1TRUFSQ0hcIl0gPSAyNF0gPSBcIk0tU0VBUkNIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTk9USUZZXCJdID0gMjVdID0gXCJOT1RJRllcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTVUJTQ1JJQkVcIl0gPSAyNl0gPSBcIlNVQlNDUklCRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOU1VCU0NSSUJFXCJdID0gMjddID0gXCJVTlNVQlNDUklCRVwiO1xuICAgIC8qIFJGQy01Nzg5ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUEFUQ0hcIl0gPSAyOF0gPSBcIlBBVENIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFVSR0VcIl0gPSAyOV0gPSBcIlBVUkdFXCI7XG4gICAgLyogQ2FsREFWICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTUtDQUxFTkRBUlwiXSA9IDMwXSA9IFwiTUtDQUxFTkRBUlwiO1xuICAgIC8qIFJGQy0yMDY4LCBzZWN0aW9uIDE5LjYuMS4yICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTElOS1wiXSA9IDMxXSA9IFwiTElOS1wiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOTElOS1wiXSA9IDMyXSA9IFwiVU5MSU5LXCI7XG4gICAgLyogaWNlY2FzdCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNPVVJDRVwiXSA9IDMzXSA9IFwiU09VUkNFXCI7XG4gICAgLyogUkZDLTc1NDAsIHNlY3Rpb24gMTEuNiAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBSSVwiXSA9IDM0XSA9IFwiUFJJXCI7XG4gICAgLyogUkZDLTIzMjYgUlRTUCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkRFU0NSSUJFXCJdID0gMzVdID0gXCJERVNDUklCRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkFOTk9VTkNFXCJdID0gMzZdID0gXCJBTk5PVU5DRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNFVFVQXCJdID0gMzddID0gXCJTRVRVUFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBMQVlcIl0gPSAzOF0gPSBcIlBMQVlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQQVVTRVwiXSA9IDM5XSA9IFwiUEFVU0VcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJURUFSRE9XTlwiXSA9IDQwXSA9IFwiVEVBUkRPV05cIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJHRVRfUEFSQU1FVEVSXCJdID0gNDFdID0gXCJHRVRfUEFSQU1FVEVSXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU0VUX1BBUkFNRVRFUlwiXSA9IDQyXSA9IFwiU0VUX1BBUkFNRVRFUlwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFRElSRUNUXCJdID0gNDNdID0gXCJSRURJUkVDVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFQ09SRFwiXSA9IDQ0XSA9IFwiUkVDT1JEXCI7XG4gICAgLyogUkFPUCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkZMVVNIXCJdID0gNDVdID0gXCJGTFVTSFwiO1xufSkoTUVUSE9EUyA9IGV4cG9ydHMuTUVUSE9EUyB8fCAoZXhwb3J0cy5NRVRIT0RTID0ge30pKTtcbmV4cG9ydHMuTUVUSE9EU19IVFRQID0gW1xuICAgIE1FVEhPRFMuREVMRVRFLFxuICAgIE1FVEhPRFMuR0VULFxuICAgIE1FVEhPRFMuSEVBRCxcbiAgICBNRVRIT0RTLlBPU1QsXG4gICAgTUVUSE9EUy5QVVQsXG4gICAgTUVUSE9EUy5DT05ORUNULFxuICAgIE1FVEhPRFMuT1BUSU9OUyxcbiAgICBNRVRIT0RTLlRSQUNFLFxuICAgIE1FVEhPRFMuQ09QWSxcbiAgICBNRVRIT0RTLkxPQ0ssXG4gICAgTUVUSE9EUy5NS0NPTCxcbiAgICBNRVRIT0RTLk1PVkUsXG4gICAgTUVUSE9EUy5QUk9QRklORCxcbiAgICBNRVRIT0RTLlBST1BQQVRDSCxcbiAgICBNRVRIT0RTLlNFQVJDSCxcbiAgICBNRVRIT0RTLlVOTE9DSyxcbiAgICBNRVRIT0RTLkJJTkQsXG4gICAgTUVUSE9EUy5SRUJJTkQsXG4gICAgTUVUSE9EUy5VTkJJTkQsXG4gICAgTUVUSE9EUy5BQ0wsXG4gICAgTUVUSE9EUy5SRVBPUlQsXG4gICAgTUVUSE9EUy5NS0FDVElWSVRZLFxuICAgIE1FVEhPRFMuQ0hFQ0tPVVQsXG4gICAgTUVUSE9EUy5NRVJHRSxcbiAgICBNRVRIT0RTWydNLVNFQVJDSCddLFxuICAgIE1FVEhPRFMuTk9USUZZLFxuICAgIE1FVEhPRFMuU1VCU0NSSUJFLFxuICAgIE1FVEhPRFMuVU5TVUJTQ1JJQkUsXG4gICAgTUVUSE9EUy5QQVRDSCxcbiAgICBNRVRIT0RTLlBVUkdFLFxuICAgIE1FVEhPRFMuTUtDQUxFTkRBUixcbiAgICBNRVRIT0RTLkxJTkssXG4gICAgTUVUSE9EUy5VTkxJTkssXG4gICAgTUVUSE9EUy5QUkksXG4gICAgLy8gVE9ETyhpbmR1dG55KTogc2hvdWxkIHdlIGFsbG93IGl0IHdpdGggSFRUUD9cbiAgICBNRVRIT0RTLlNPVVJDRSxcbl07XG5leHBvcnRzLk1FVEhPRFNfSUNFID0gW1xuICAgIE1FVEhPRFMuU09VUkNFLFxuXTtcbmV4cG9ydHMuTUVUSE9EU19SVFNQID0gW1xuICAgIE1FVEhPRFMuT1BUSU9OUyxcbiAgICBNRVRIT0RTLkRFU0NSSUJFLFxuICAgIE1FVEhPRFMuQU5OT1VOQ0UsXG4gICAgTUVUSE9EUy5TRVRVUCxcbiAgICBNRVRIT0RTLlBMQVksXG4gICAgTUVUSE9EUy5QQVVTRSxcbiAgICBNRVRIT0RTLlRFQVJET1dOLFxuICAgIE1FVEhPRFMuR0VUX1BBUkFNRVRFUixcbiAgICBNRVRIT0RTLlNFVF9QQVJBTUVURVIsXG4gICAgTUVUSE9EUy5SRURJUkVDVCxcbiAgICBNRVRIT0RTLlJFQ09SRCxcbiAgICBNRVRIT0RTLkZMVVNILFxuICAgIC8vIEZvciBBaXJQbGF5XG4gICAgTUVUSE9EUy5HRVQsXG4gICAgTUVUSE9EUy5QT1NULFxuXTtcbmV4cG9ydHMuTUVUSE9EX01BUCA9IHV0aWxzXzEuZW51bVRvTWFwKE1FVEhPRFMpO1xuZXhwb3J0cy5IX01FVEhPRF9NQVAgPSB7fTtcbk9iamVjdC5rZXlzKGV4cG9ydHMuTUVUSE9EX01BUCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKC9eSC8udGVzdChrZXkpKSB7XG4gICAgICAgIGV4cG9ydHMuSF9NRVRIT0RfTUFQW2tleV0gPSBleHBvcnRzLk1FVEhPRF9NQVBba2V5XTtcbiAgICB9XG59KTtcbnZhciBGSU5JU0g7XG4oZnVuY3Rpb24gKEZJTklTSCkge1xuICAgIEZJTklTSFtGSU5JU0hbXCJTQUZFXCJdID0gMF0gPSBcIlNBRkVcIjtcbiAgICBGSU5JU0hbRklOSVNIW1wiU0FGRV9XSVRIX0NCXCJdID0gMV0gPSBcIlNBRkVfV0lUSF9DQlwiO1xuICAgIEZJTklTSFtGSU5JU0hbXCJVTlNBRkVcIl0gPSAyXSA9IFwiVU5TQUZFXCI7XG59KShGSU5JU0ggPSBleHBvcnRzLkZJTklTSCB8fCAoZXhwb3J0cy5GSU5JU0ggPSB7fSkpO1xuZXhwb3J0cy5BTFBIQSA9IFtdO1xuZm9yIChsZXQgaSA9ICdBJy5jaGFyQ29kZUF0KDApOyBpIDw9ICdaJy5jaGFyQ29kZUF0KDApOyBpKyspIHtcbiAgICAvLyBVcHBlciBjYXNlXG4gICAgZXhwb3J0cy5BTFBIQS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuICAgIC8vIExvd2VyIGNhc2VcbiAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMHgyMCkpO1xufVxuZXhwb3J0cy5OVU1fTUFQID0ge1xuICAgIDA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsXG4gICAgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSxcbn07XG5leHBvcnRzLkhFWF9NQVAgPSB7XG4gICAgMDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCxcbiAgICA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LFxuICAgIEE6IDBYQSwgQjogMFhCLCBDOiAwWEMsIEQ6IDBYRCwgRTogMFhFLCBGOiAwWEYsXG4gICAgYTogMHhhLCBiOiAweGIsIGM6IDB4YywgZDogMHhkLCBlOiAweGUsIGY6IDB4Zixcbn07XG5leHBvcnRzLk5VTSA9IFtcbiAgICAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG5dO1xuZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuQUxQSEEuY29uY2F0KGV4cG9ydHMuTlVNKTtcbmV4cG9ydHMuTUFSSyA9IFsnLScsICdfJywgJy4nLCAnIScsICd+JywgJyonLCAnXFwnJywgJygnLCAnKSddO1xuZXhwb3J0cy5VU0VSSU5GT19DSEFSUyA9IGV4cG9ydHMuQUxQSEFOVU1cbiAgICAuY29uY2F0KGV4cG9ydHMuTUFSSylcbiAgICAuY29uY2F0KFsnJScsICc7JywgJzonLCAnJicsICc9JywgJysnLCAnJCcsICcsJ10pO1xuLy8gVE9ETyhpbmR1dG55KTogdXNlIFJGQ1xuZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVIgPSBbXG4gICAgJyEnLCAnXCInLCAnJCcsICclJywgJyYnLCAnXFwnJyxcbiAgICAnKCcsICcpJywgJyonLCAnKycsICcsJywgJy0nLCAnLicsICcvJyxcbiAgICAnOicsICc7JywgJzwnLCAnPScsICc+JyxcbiAgICAnQCcsICdbJywgJ1xcXFwnLCAnXScsICdeJywgJ18nLFxuICAgICdgJyxcbiAgICAneycsICd8JywgJ30nLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbmV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlNUUklDVF9VUkxfQ0hBUlxuICAgIC5jb25jYXQoWydcXHQnLCAnXFxmJ10pO1xuLy8gQWxsIGNoYXJhY3RlcnMgd2l0aCAweDgwIGJpdCBzZXQgdG8gMVxuZm9yIChsZXQgaSA9IDB4ODA7IGkgPD0gMHhmZjsgaSsrKSB7XG4gICAgZXhwb3J0cy5VUkxfQ0hBUi5wdXNoKGkpO1xufVxuZXhwb3J0cy5IRVggPSBleHBvcnRzLk5VTS5jb25jYXQoWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRiddKTtcbi8qIFRva2VucyBhcyBkZWZpbmVkIGJ5IHJmYyAyNjE2LiBBbHNvIGxvd2VyY2FzZXMgdGhlbS5cbiAqICAgICAgICB0b2tlbiAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gKiAgICAgc2VwYXJhdG9ycyAgICAgPSBcIihcIiB8IFwiKVwiIHwgXCI8XCIgfCBcIj5cIiB8IFwiQFwiXG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIixcIiB8IFwiO1wiIHwgXCI6XCIgfCBcIlxcXCIgfCA8XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIntcIiB8IFwifVwiIHwgU1AgfCBIVFxuICovXG5leHBvcnRzLlNUUklDVF9UT0tFTiA9IFtcbiAgICAnIScsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsXG4gICAgJyonLCAnKycsICctJywgJy4nLFxuICAgICdeJywgJ18nLCAnYCcsXG4gICAgJ3wnLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbmV4cG9ydHMuVE9LRU4gPSBleHBvcnRzLlNUUklDVF9UT0tFTi5jb25jYXQoWycgJ10pO1xuLypcbiAqIFZlcmlmeSB0aGF0IGEgY2hhciBpcyBhIHZhbGlkIHZpc2libGUgKHByaW50YWJsZSkgVVMtQVNDSUlcbiAqIGNoYXJhY3RlciBvciAleDgwLUZGXG4gKi9cbmV4cG9ydHMuSEVBREVSX0NIQVJTID0gWydcXHQnXTtcbmZvciAobGV0IGkgPSAzMjsgaSA8PSAyNTU7IGkrKykge1xuICAgIGlmIChpICE9PSAxMjcpIHtcbiAgICAgICAgZXhwb3J0cy5IRUFERVJfQ0hBUlMucHVzaChpKTtcbiAgICB9XG59XG4vLyAnLCcgPSBcXHg0NFxuZXhwb3J0cy5DT05ORUNUSU9OX1RPS0VOX0NIQVJTID0gZXhwb3J0cy5IRUFERVJfQ0hBUlMuZmlsdGVyKChjKSA9PiBjICE9PSA0NCk7XG5leHBvcnRzLk1BSk9SID0gZXhwb3J0cy5OVU1fTUFQO1xuZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1I7XG52YXIgSEVBREVSX1NUQVRFO1xuKGZ1bmN0aW9uIChIRUFERVJfU1RBVEUpIHtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiR0VORVJBTFwiXSA9IDBdID0gXCJHRU5FUkFMXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTk5FQ1RJT05cIl0gPSAxXSA9IFwiQ09OTkVDVElPTlwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05URU5UX0xFTkdUSFwiXSA9IDJdID0gXCJDT05URU5UX0xFTkdUSFwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJUUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDNdID0gXCJUUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJVUEdSQURFXCJdID0gNF0gPSBcIlVQR1JBREVcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCJdID0gNV0gPSBcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX0NMT1NFXCJdID0gNl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTl9VUEdSQURFXCJdID0gN10gPSBcIkNPTk5FQ1RJT05fVVBHUkFERVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJUUkFOU0ZFUl9FTkNPRElOR19DSFVOS0VEXCJdID0gOF0gPSBcIlRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRURcIjtcbn0pKEhFQURFUl9TVEFURSA9IGV4cG9ydHMuSEVBREVSX1NUQVRFIHx8IChleHBvcnRzLkhFQURFUl9TVEFURSA9IHt9KSk7XG5leHBvcnRzLlNQRUNJQUxfSEVBREVSUyA9IHtcbiAgICAnY29ubmVjdGlvbic6IEhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICdjb250ZW50LWxlbmd0aCc6IEhFQURFUl9TVEFURS5DT05URU5UX0xFTkdUSCxcbiAgICAncHJveHktY29ubmVjdGlvbic6IEhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IEhFQURFUl9TVEFURS5UUkFOU0ZFUl9FTkNPRElORyxcbiAgICAndXBncmFkZSc6IEhFQURFUl9TVEFURS5VUEdSQURFLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8='\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLXdhc20uanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLXdhc20uanM/YWJhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9ICdBR0Z6YlFFQUFBQUJNQWhnQVg4QmYyQURmMzkvQVg5Z0JIOS9mMzhCZjJBQUFHQURmMzkvQUdBQmZ3QmdBbjkvQUdBR2YzOS9mMzkvQUFMTEFRZ0RaVzUyR0hkaGMyMWZiMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUFDQTJWdWRoVjNZWE50WDI5dVgyMWxjM05oWjJWZlltVm5hVzRBQUFObGJuWUxkMkZ6YlY5dmJsOTFjbXdBQVFObGJuWU9kMkZ6YlY5dmJsOXpkR0YwZFhNQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZabWxsYkdRQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZkbUZzZFdVQUFRTmxibllNZDJGemJWOXZibDlpYjJSNUFBRURaVzUyR0hkaGMyMWZiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaUUFBQTBaRkF3TUVBQUFGQUFBQUFBQUFCUUVGQUFVRkJRQUFCZ0FBQUFBR0JnWUdBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBQUFCQVFjQUFBVUZBd0FCQkFVQmNBRVNFZ1VEQVFBQ0JnZ0Jmd0ZCZ05RRUN3ZlJCU0lHYldWdGIzSjVBZ0FMWDJsdWFYUnBZV3hwZW1VQUNSbGZYMmx1WkdseVpXTjBYMloxYm1OMGFXOXVYM1JoWW14bEFRQUxiR3hvZEhSd1gybHVhWFFBQ2hoc2JHaDBkSEJmYzJodmRXeGtYMnRsWlhCZllXeHBkbVVBUVF4c2JHaDBkSEJmWVd4c2IyTUFEQVp0WVd4c2IyTUFSZ3RzYkdoMGRIQmZabkpsWlFBTkJHWnlaV1VBU0E5c2JHaDBkSEJmWjJWMFgzUjVjR1VBRGhWc2JHaDBkSEJmWjJWMFgyaDBkSEJmYldGcWIzSUFEeFZzYkdoMGRIQmZaMlYwWDJoMGRIQmZiV2x1YjNJQUVCRnNiR2gwZEhCZloyVjBYMjFsZEdodlpBQVJGbXhzYUhSMGNGOW5aWFJmYzNSaGRIVnpYMk52WkdVQUVoSnNiR2gwZEhCZloyVjBYM1Z3WjNKaFpHVUFFd3hzYkdoMGRIQmZjbVZ6WlhRQUZBNXNiR2gwZEhCZlpYaGxZM1YwWlFBVkZHeHNhSFIwY0Y5elpYUjBhVzVuYzE5cGJtbDBBQllOYkd4b2RIUndYMlpwYm1semFBQVhER3hzYUhSMGNGOXdZWFZ6WlFBWURXeHNhSFIwY0Y5eVpYTjFiV1VBR1J0c2JHaDBkSEJmY21WemRXMWxYMkZtZEdWeVgzVndaM0poWkdVQUdoQnNiR2gwZEhCZloyVjBYMlZ5Y201dkFCc1hiR3hvZEhSd1gyZGxkRjlsY25KdmNsOXlaV0Z6YjI0QUhCZHNiR2gwZEhCZmMyVjBYMlZ5Y205eVgzSmxZWE52YmdBZEZHeHNhSFIwY0Y5blpYUmZaWEp5YjNKZmNHOXpBQjRSYkd4b2RIUndYMlZ5Y201dlgyNWhiV1VBSHhKc2JHaDBkSEJmYldWMGFHOWtYMjVoYldVQUlCSnNiR2gwZEhCZmMzUmhkSFZ6WDI1aGJXVUFJUnBzYkdoMGRIQmZjMlYwWDJ4bGJtbGxiblJmYUdWaFpHVnljd0FpSVd4c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5amFIVnVhMlZrWDJ4bGJtZDBhQUFqSFd4c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5clpXVndYMkZzYVhabEFDUWtiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYM1J5WVc1elptVnlYMlZ1WTI5a2FXNW5BQ1VZYkd4b2RIUndYMjFsYzNOaFoyVmZibVZsWkhOZlpXOW1BRDhKRndFQVFRRUxFUUVDQXdRRkN3WUhOVGszTVM4dEp5c3BDc0xnQWtVQ0FBc0lBQkNJZ0lDQUFBc1pBQ0FBRU1LQWdJQUFHaUFBSUFJMkFqZ2dBQ0FCT2dBb0N4d0FJQUFnQUM4Qk1pQUFMUUF1SUFBUXdZQ0FnQUFRZ0lDQWdBQUxLZ0VCZjBIQUFCREdnSUNBQUNJQkVNS0FnSUFBR2lBQlFZQ0lnSUFBTmdJNElBRWdBRG9BS0NBQkN3b0FJQUFReUlDQWdBQUxCd0FnQUMwQUtBc0hBQ0FBTFFBcUN3Y0FJQUF0QUNzTEJ3QWdBQzBBS1FzSEFDQUFMd0V5Q3djQUlBQXRBQzRMUlFFRWZ5QUFLQUlZSVFFZ0FDMEFMU0VDSUFBdEFDZ2hBeUFBS0FJNElRUWdBQkRDZ0lDQUFCb2dBQ0FFTmdJNElBQWdBem9BS0NBQUlBSTZBQzBnQUNBQk5nSVlDeEVBSUFBZ0FTQUJJQUpxRU1PQWdJQUFDeEFBSUFCQkFFSGNBQkRNZ0lDQUFCb0xad0VCZjBFQUlRRUNRQ0FBS0FJTURRQUNRQUpBQWtBQ1FDQUFMUUF2RGdNQkFBTUNDeUFBS0FJNElnRkZEUUFnQVNnQ0xDSUJSUTBBSUFBZ0FSR0FnSUNBQUFBaUFRMERDMEVBRHdzUXlvQ0FnQUFBQ3lBQVFjT1dnSUFBTmdJUVFRNGhBUXNnQVFzZUFBSkFJQUFvQWd3TkFDQUFRZEdiZ0lBQU5nSVFJQUJCRlRZQ0RBc0xGZ0FDUUNBQUtBSU1RUlZIRFFBZ0FFRUFOZ0lNQ3dzV0FBSkFJQUFvQWd4QkZrY05BQ0FBUVFBMkFnd0xDd2NBSUFBb0Fnd0xCd0FnQUNnQ0VBc0pBQ0FBSUFFMkFoQUxCd0FnQUNnQ0ZBc2lBQUpBSUFCQkpFa05BQkRLZ0lDQUFBQUxJQUJCQW5SQm9MT0FnQUJxS0FJQUN5SUFBa0FnQUVFdVNRMEFFTXFBZ0lBQUFBc2dBRUVDZEVHd3RJQ0FBR29vQWdBTDdnc0JBWDlCNjZpQWdBQWhBUUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQm5IOXFEdlFEWTJJQUFXRmhZV0ZoWVFJREJBVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoQmdjSUNRb0xEQTBPRDJGaFlXRmhFR0ZoWVdGaFlXRmhZV0ZoRVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVJJVEZCVVdGeGdaR2h0aFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEhCMGVIeUFoSWlNa0pTWW5LQ2txS3l3dExpOHdNVEl6TkRVMllUYzRPVHBoWVdGaFlXRmhZVHRoWVdFOFlXRmhZVDArUDJGaFlXRmhZV0ZoUUdGaFFXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZVUpEUkVWR1IwaEpTa3RNVFU1UFVGRlNVMkZoWVdGaFlXRmhWRlZXVjFoWldsdGhYRjFoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGZVlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFgyQmhDMEhocDRDQUFBOExRYVNoZ0lBQUR3dEJ5NnlBZ0FBUEMwSCtzWUNBQUE4TFFjQ2tnSUFBRHd0QnE2U0FnQUFQQzBHTnFJQ0FBQThMUWVLbWdJQUFEd3RCZ0xDQWdBQVBDMEc1cjRDQUFBOExRZGVrZ0lBQUR3dEI3NStBZ0FBUEMwSGhuNENBQUE4TFFmcWZnSUFBRHd0QjhxQ0FnQUFQQzBHb3I0Q0FBQThMUWE2eWdJQUFEd3RCaUxDQWdBQVBDMEhzcDRDQUFBOExRWUtpZ0lBQUR3dEJqcDJBZ0FBUEMwSFFyb0NBQUE4TFFjcWpnSUFBRHd0QnhiS0FnQUFQQzBIZm5JQ0FBQThMUWRLY2dJQUFEd3RCeEtDQWdBQVBDMEhYb0lDQUFBOExRYUtmZ0lBQUR3dEI3YTZBZ0FBUEMwR3JzSUNBQUE4TFFkU2xnSUFBRHd0QnpLNkFnQUFQQzBINnJvQ0FBQThMUWZ5cmdJQUFEd3RCMHJDQWdBQVBDMEh4bllDQUFBOExRYnVnZ0lBQUR3dEI5NnVBZ0FBUEMwR1FzWUNBQUE4TFFkZXhnSUFBRHd0Qm9xMkFnQUFQQzBIVXA0Q0FBQThMUWVDcmdJQUFEd3RCbjZ5QWdBQVBDMEhyc1lDQUFBOExRZFdmZ0lBQUR3dEJ5ckdBZ0FBUEMwSGVwWUNBQUE4TFFkU2VnSUFBRHd0QjlKeUFnQUFQQzBHbnNvQ0FBQThMUWJHZGdJQUFEd3RCb0oyQWdBQVBDMEc1c1lDQUFBOExRYnl3Z0lBQUR3dEJrcUdBZ0FBUEMwR3pwb0NBQUE4TFFlbXNnSUFBRHd0QnJKNkFnQUFQQzBIVXE0Q0FBQThMUWZlbWdJQUFEd3RCZ0thQWdBQVBDMEd3b1lDQUFBOExRZjZlZ0lBQUR3dEJqYU9BZ0FBUEMwR0pyWUNBQUE4TFFmZWlnSUFBRHd0Qm9MR0FnQUFQQzBHdW40Q0FBQThMUWNhbGdJQUFEd3RCNko2QWdBQVBDMEdUb29DQUFBOExRY0t2Z0lBQUR3dEJ3NTJBZ0FBUEMwR0xySUNBQUE4TFFlR2RnSUFBRHd0QmphK0FnQUFQQzBIcW9ZQ0FBQThMUWJTdGdJQUFEd3RCMHErQWdBQVBDMEhmc29DQUFBOExRZEt5Z0lBQUR3dEI4TENBZ0FBUEMwR3Bvb0NBQUE4TFFmbWpnSUFBRHd0Qm1aNkFnQUFQQzBHMXJJQ0FBQThMUVp1d2dJQUFEd3RCa3JLQWdBQVBDMEcycTRDQUFBOExRY0tpZ0lBQUR3dEIrTEtBZ0FBUEMwR2VwWUNBQUE4TFFkQ2lnSUFBRHd0QnVwNkFnQUFQQzBHQm5vQ0FBQThMRU1xQWdJQUFBQXRCMXFHQWdBQWhBUXNnQVFzV0FDQUFJQUF0QUMxQi9nRnhJQUZCQUVkeU9nQXRDeGtBSUFBZ0FDMEFMVUg5QVhFZ0FVRUFSMEVCZEhJNkFDMExHUUFnQUNBQUxRQXRRZnNCY1NBQlFRQkhRUUowY2pvQUxRc1pBQ0FBSUFBdEFDMUI5d0Z4SUFGQkFFZEJBM1J5T2dBdEN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWdBaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxTUUVDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0JDSUVSUTBBSUFBZ0FTQUNJQUZySUFRUmdZQ0FnQUFBSWdOQmYwY05BQ0FBUWNhUmdJQUFOZ0lRUVJnaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSXdJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BZ2dpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFSDJpb0NBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDTkNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJTUlnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCN1pxQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FqZ2lCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NFQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFaV1FnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUk4SWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWhRaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUdxbTRDQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1FDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSVlJZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQjdaT0FnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9Ba1FpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDSkNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJc0lnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FpZ2lCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVIMmlJQ0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NVQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUljSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkJ3cG1BZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWtnaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxTUUVDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0lDSUVSUTBBSUFBZ0FTQUNJQUZySUFRUmdZQ0FnQUFBSWdOQmYwY05BQ0FBUVpTVWdJQUFOZ0lRUVJnaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSk1JZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BbFFpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDV0NJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEZBUUYvQWtBQ1FDQUFMd0V3UVJSeFFSUkhEUUJCQVNFRElBQXRBQ2hCQVVZTkFTQUFMd0V5UWVVQVJpRUREQUVMSUFBdEFDbEJCVVloQXdzZ0FDQURPZ0F1UVFBTC9nRUJBMzlCQVNFREFrQWdBQzhCTUNJRVFRaHhEUUFnQUNrRElFSUFVaUVEQ3dKQUFrQWdBQzBBTGtVTkFFRUJJUVVnQUMwQUtVRUZSZzBCUVFFaEJTQUVRY0FBY1VVZ0EzRkJBVWNOQVF0QkFDRUZJQVJCd0FCeERRQkJBaUVGSUFSQi8vOERjU0lEUVFoeERRQUNRQ0FEUVlBRWNVVU5BQUpBSUFBdEFDaEJBVWNOQUNBQUxRQXRRUXB4RFFCQkJROExRUVFQQ3dKQUlBTkJJSEVOQUFKQUlBQXRBQ2hCQVVZTkFDQUFMd0V5UWYvL0EzRWlBRUdjZjJwQjVBQkpEUUFnQUVITUFVWU5BQ0FBUWJBQ1JnMEFRUVFoQlNBRVFTaHhSUTBDSUFOQmlBUnhRWUFFUmcwQ0MwRUFEd3RCQUVFRElBQXBBeUJRR3lFRkN5QUZDMklCQW45QkFDRUJBa0FnQUMwQUtFRUJSZzBBSUFBdkFUSkIvLzhEY1NJQ1FaeC9ha0hrQUVrTkFDQUNRY3dCUmcwQUlBSkJzQUpHRFFBZ0FDOEJNQ0lBUWNBQWNRMEFRUUVoQVNBQVFZZ0VjVUdBQkVZTkFDQUFRU2h4UlNFQkN5QUJDNmNCQVFOL0FrQUNRQUpBSUFBdEFDcEZEUUFnQUMwQUswVU5BRUVBSVFNZ0FDOEJNQ0lFUVFKeFJRMEJEQUlMUVFBaEF5QUFMd0V3SWdSQkFYRkZEUUVMUVFFaEF5QUFMUUFvUVFGR0RRQWdBQzhCTWtILy93TnhJZ1ZCbkg5cVFlUUFTUTBBSUFWQnpBRkdEUUFnQlVHd0FrWU5BQ0FFUWNBQWNRMEFRUUFoQXlBRVFZZ0VjVUdBQkVZTkFDQUVRU2h4UVFCSElRTUxJQUJCQURzQk1DQUFRUUE2QUM4Z0F3dVpBUUVDZndKQUFrQUNRQ0FBTFFBcVJRMEFJQUF0QUN0RkRRQkJBQ0VCSUFBdkFUQWlBa0VDY1VVTkFRd0NDMEVBSVFFZ0FDOEJNQ0lDUVFGeFJRMEJDMEVCSVFFZ0FDMEFLRUVCUmcwQUlBQXZBVEpCLy84RGNTSUFRWngvYWtIa0FFa05BQ0FBUWN3QlJnMEFJQUJCc0FKR0RRQWdBa0hBQUhFTkFFRUFJUUVnQWtHSUJIRkJnQVJHRFFBZ0FrRW9jVUVBUnlFQkN5QUJDMWtBSUFCQkdHcENBRGNEQUNBQVFnQTNBd0FnQUVFNGFrSUFOd01BSUFCQk1HcENBRGNEQUNBQVFTaHFRZ0EzQXdBZ0FFRWdha0lBTndNQUlBQkJFR3BDQURjREFDQUFRUWhxUWdBM0F3QWdBRUhkQVRZQ0hFRUFDM3NCQVg4Q1FDQUFLQUlNSWdNTkFBSkFJQUFvQWdSRkRRQWdBQ0FCTmdJRUN3SkFJQUFnQVNBQ0VNU0FnSUFBSWdNTkFDQUFLQUlNRHdzZ0FDQUROZ0ljUVFBaEF5QUFLQUlFSWdGRkRRQWdBQ0FCSUFJZ0FDZ0NDQkdCZ0lDQUFBQWlBVVVOQUNBQUlBSTJBaFFnQUNBQk5nSU1JQUVoQXdzZ0F3dms4d0VERG44RGZnUi9JNENBZ0lBQVFSQnJJZ01rZ0lDQWdBQWdBU0VFSUFFaEJTQUJJUVlnQVNFSElBRWhDQ0FCSVFrZ0FTRUtJQUVoQ3lBQklRd2dBU0VOSUFFaERpQUJJUThDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQUNnQ0hDSVFRWDlxRHQwQjJnRUIyUUVDQXdRRkJnY0lDUW9MREEwTzJBRVBFTmNCRVJMV0FSTVVGUllYR0JrYUcrQUIzd0VjSFI3VkFSOGdJU0lqSkNYVUFTWW5LQ2txS3l6VEFkSUJMUzdSQWRBQkx6QXhNak0wTlRZM09EazZPenc5UGo5QVFVSkRSRVZHMndGSFNFbEt6d0hPQVV2TkFVek1BVTFPVDFCUlVsTlVWVlpYV0ZsYVcxeGRYbDlnWVdKalpHVm1aMmhwYW10c2JXNXZjSEZ5YzNSMWRuZDRlWHA3ZkgxK2Y0QUJnUUdDQVlNQmhBR0ZBWVlCaHdHSUFZa0JpZ0dMQVl3QmpRR09BWThCa0FHUkFaSUJrd0dVQVpVQmxnR1hBWmdCbVFHYUFac0JuQUdkQVo0Qm53R2dBYUVCb2dHakFhUUJwUUdtQWFjQnFBR3BBYW9CcXdHc0FhMEJyZ0d2QWJBQnNRR3lBYk1CdEFHMUFiWUJ0d0hMQWNvQnVBSEpBYmtCeUFHNkFic0J2QUc5QWI0QnZ3SEFBY0VCd2dIREFjUUJ4UUhHQVFEY0FRdEJBQ0VRRE1ZQkMwRU9JUkFNeFFFTFFRMGhFQXpFQVF0QkR5RVFETU1CQzBFUUlSQU13Z0VMUVJNaEVBekJBUXRCRkNFUURNQUJDMEVWSVJBTXZ3RUxRUlloRUF5K0FRdEJGeUVRREwwQkMwRVlJUkFNdkFFTFFSa2hFQXk3QVF0QkdpRVFETG9CQzBFYklSQU11UUVMUVJ3aEVBeTRBUXRCQ0NFUURMY0JDMEVkSVJBTXRnRUxRU0FoRUF5MUFRdEJIeUVRRExRQkMwRUhJUkFNc3dFTFFTRWhFQXl5QVF0QklpRVFETEVCQzBFZUlSQU1zQUVMUVNNaEVBeXZBUXRCRWlFUURLNEJDMEVSSVJBTXJRRUxRU1FoRUF5c0FRdEJKU0VRREtzQkMwRW1JUkFNcWdFTFFTY2hFQXlwQVF0Qnd3RWhFQXlvQVF0QktTRVFES2NCQzBFcklSQU1wZ0VMUVN3aEVBeWxBUXRCTFNFUURLUUJDMEV1SVJBTW93RUxRUzhoRUF5aUFRdEJ4QUVoRUF5aEFRdEJNQ0VRREtBQkMwRTBJUkFNbndFTFFRd2hFQXllQVF0Qk1TRVFESjBCQzBFeUlSQU1uQUVMUVRNaEVBeWJBUXRCT1NFUURKb0JDMEUxSVJBTW1RRUxRY1VCSVJBTW1BRUxRUXNoRUF5WEFRdEJPaUVRREpZQkMwRTJJUkFNbFFFTFFRb2hFQXlVQVF0Qk55RVFESk1CQzBFNElSQU1rZ0VMUVR3aEVBeVJBUXRCT3lFUURKQUJDMEU5SVJBTWp3RUxRUWtoRUF5T0FRdEJLQ0VRREkwQkMwRStJUkFNakFFTFFUOGhFQXlMQVF0QndBQWhFQXlLQVF0QndRQWhFQXlKQVF0QndnQWhFQXlJQVF0Qnd3QWhFQXlIQVF0QnhBQWhFQXlHQVF0QnhRQWhFQXlGQVF0QnhnQWhFQXlFQVF0QktpRVFESU1CQzBISEFDRVFESUlCQzBISUFDRVFESUVCQzBISkFDRVFESUFCQzBIS0FDRVFESDhMUWNzQUlSQU1mZ3RCelFBaEVBeDlDMEhNQUNFUURId0xRYzRBSVJBTWV3dEJ6d0FoRUF4NkMwSFFBQ0VRREhrTFFkRUFJUkFNZUF0QjBnQWhFQXgzQzBIVEFDRVFESFlMUWRRQUlSQU1kUXRCMWdBaEVBeDBDMEhWQUNFUURITUxRUVloRUF4eUMwSFhBQ0VRREhFTFFRVWhFQXh3QzBIWUFDRVFERzhMUVFRaEVBeHVDMEhaQUNFUURHMExRZG9BSVJBTWJBdEIyd0FoRUF4ckMwSGNBQ0VRREdvTFFRTWhFQXhwQzBIZEFDRVFER2dMUWQ0QUlSQU1ad3RCM3dBaEVBeG1DMEhoQUNFUURHVUxRZUFBSVJBTVpBdEI0Z0FoRUF4akMwSGpBQ0VRREdJTFFRSWhFQXhoQzBIa0FDRVFER0FMUWVVQUlSQU1Yd3RCNWdBaEVBeGVDMEhuQUNFUURGMExRZWdBSVJBTVhBdEI2UUFoRUF4YkMwSHFBQ0VRREZvTFFlc0FJUkFNV1F0QjdBQWhFQXhZQzBIdEFDRVFERmNMUWU0QUlSQU1WZ3RCN3dBaEVBeFZDMEh3QUNFUURGUUxRZkVBSVJBTVV3dEI4Z0FoRUF4U0MwSHpBQ0VRREZFTFFmUUFJUkFNVUF0QjlRQWhFQXhQQzBIMkFDRVFERTRMUWZjQUlSQU1UUXRCK0FBaEVBeE1DMEg1QUNFUURFc0xRZm9BSVJBTVNndEIrd0FoRUF4SkMwSDhBQ0VRREVnTFFmMEFJUkFNUnd0Qi9nQWhFQXhHQzBIL0FDRVFERVVMUVlBQklSQU1SQXRCZ1FFaEVBeERDMEdDQVNFUURFSUxRWU1CSVJBTVFRdEJoQUVoRUF4QUMwR0ZBU0VRREQ4TFFZWUJJUkFNUGd0Qmh3RWhFQXc5QzBHSUFTRVFERHdMUVlrQklSQU1Pd3RCaWdFaEVBdzZDMEdMQVNFUUREa0xRWXdCSVJBTU9BdEJqUUVoRUF3M0MwR09BU0VRRERZTFFZOEJJUkFNTlF0QmtBRWhFQXcwQzBHUkFTRVFERE1MUVpJQklSQU1NZ3RCa3dFaEVBd3hDMEdVQVNFUUREQUxRWlVCSVJBTUx3dEJsZ0VoRUF3dUMwR1hBU0VRREMwTFFaZ0JJUkFNTEF0Qm1RRWhFQXdyQzBHYUFTRVFEQ29MUVpzQklSQU1LUXRCbkFFaEVBd29DMEdkQVNFUURDY0xRWjRCSVJBTUpndEJud0VoRUF3bEMwR2dBU0VRRENRTFFhRUJJUkFNSXd0Qm9nRWhFQXdpQzBHakFTRVFEQ0VMUWFRQklSQU1JQXRCcFFFaEVBd2ZDMEdtQVNFUURCNExRYWNCSVJBTUhRdEJxQUVoRUF3Y0MwR3BBU0VRREJzTFFhb0JJUkFNR2d0QnF3RWhFQXdaQzBHc0FTRVFEQmdMUWEwQklSQU1Gd3RCcmdFaEVBd1dDMEVCSVJBTUZRdEJyd0VoRUF3VUMwR3dBU0VRREJNTFFiRUJJUkFNRWd0QnN3RWhFQXdSQzBHeUFTRVFEQkFMUWJRQklSQU1Ed3RCdFFFaEVBd09DMEcyQVNFUURBMExRYmNCSVJBTURBdEJ1QUVoRUF3TEMwRzVBU0VRREFvTFFib0JJUkFNQ1F0QnV3RWhFQXdJQzBIR0FTRVFEQWNMUWJ3QklSQU1CZ3RCdlFFaEVBd0ZDMEcrQVNFUURBUUxRYjhCSVJBTUF3dEJ3QUVoRUF3Q0MwSENBU0VRREFFTFFjRUJJUkFMQTBBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQVFEc2NCQUFFQ0F3UUZCZ2NJQ1FvTERBME9EeEFSRWhNVUZSWVhHQmthR3h3ZUh5QWhJeVVvUDBCQlJFVkdSMGhKU2t0TVRVOVFVVkpUM2dOWFdWdGNYV0JpWldabmFHbHFhMnh0YjNCeGNuTjBkWFozZUhsNmUzeDlmb0FCZ2dHRkFZWUJod0dKQVlzQmpBR05BWTRCandHUUFaRUJsQUdWQVpZQmx3R1lBWmtCbWdHYkFad0JuUUdlQVo4Qm9BR2hBYUlCb3dHa0FhVUJwZ0duQWFnQnFRR3FBYXNCckFHdEFhNEJyd0d3QWJFQnNnR3pBYlFCdFFHMkFiY0J1QUc1QWJvQnV3RzhBYjBCdmdHL0FjQUJ3UUhDQWNNQnhBSEZBY1lCeHdISUFja0J5Z0hMQWN3QnpRSE9BYzhCMEFIUkFkSUIwd0hVQWRVQjFnSFhBZGdCMlFIYUFkc0IzQUhkQWQ0QjRBSGhBZUlCNHdIa0FlVUI1Z0huQWVnQjZRSHFBZXNCN0FIdEFlNEI3d0h3QWZFQjhnSHpBWmtDcEFLd0F2NEMvZ0lMSUFFaUJDQUNSdzN6QVVIZEFTRVFEUDhEQ3lBQkloQWdBa2NOM1FGQnd3RWhFQXorQXdzZ0FTSUJJQUpIRFpBQlFmY0FJUkFNL1FNTElBRWlBU0FDUncyR0FVSHZBQ0VRRFB3REN5QUJJZ0VnQWtjTmYwSHFBQ0VRRFBzREN5QUJJZ0VnQWtjTmUwSG9BQ0VRRFBvREN5QUJJZ0VnQWtjTmVFSG1BQ0VRRFBrREN5QUJJZ0VnQWtjTkdrRVlJUkFNK0FNTElBRWlBU0FDUncwVVFSSWhFQXozQXdzZ0FTSUJJQUpIRFZsQnhRQWhFQXoyQXdzZ0FTSUJJQUpIRFVwQlB5RVFEUFVEQ3lBQklnRWdBa2NOU0VFOElSQU05QU1MSUFFaUFTQUNSdzFCUVRFaEVBenpBd3NnQUMwQUxrRUJSZzNyQXd5SEFnc2dBQ0FCSWdFZ0FoREFnSUNBQUVFQlJ3M21BU0FBUWdBM0F5QU01d0VMSUFBZ0FTSUJJQUlRdElDQWdBQWlFQTNuQVNBQklRRU05UUlMQWtBZ0FTSUJJQUpIRFFCQkJpRVFEUEFEQ3lBQUlBRkJBV29pQVNBQ0VMdUFnSUFBSWhBTjZBRWdBU0VCRERFTElBQkNBRGNESUVFU0lSQU0xUU1MSUFFaUVDQUNSdzByUVIwaEVBenRBd3NDUUNBQklnRWdBa1lOQUNBQlFRRnFJUUZCRUNFUUROUURDMEVISVJBTTdBTUxJQUJDQUNBQUtRTWdJaEVnQWlBQkloQnJyU0lTZlNJVElCTWdFVlliTndNZ0lCRWdFbFlpRkVVTjVRRkJDQ0VRRE9zREN3SkFJQUVpQVNBQ1JnMEFJQUJCaVlDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVFVUlSQU0wZ01MUVFraEVBenFBd3NnQVNFQklBQXBBeUJRRGVRQklBRWhBUXp5QWdzQ1FDQUJJZ0VnQWtjTkFFRUxJUkFNNlFNTElBQWdBVUVCYWlJQklBSVF0b0NBZ0FBaUVBM2xBU0FCSVFFTThnSUxJQUFnQVNJQklBSVF1SUNBZ0FBaUVBM2xBU0FCSVFFTThnSUxJQUFnQVNJQklBSVF1SUNBZ0FBaUVBM21BU0FCSVFFTURRc2dBQ0FCSWdFZ0FoQzZnSUNBQUNJUURlY0JJQUVoQVF6d0Fnc0NRQ0FCSWdFZ0FrY05BRUVQSVJBTTVRTUxJQUV0QUFBaUVFRTdSZzBJSUJCQkRVY042QUVnQVVFQmFpRUJETzhDQ3lBQUlBRWlBU0FDRUxxQWdJQUFJaEFONkFFZ0FTRUJEUElDQ3dOQUFrQWdBUzBBQUVId3RZQ0FBR290QUFBaUVFRUJSZzBBSUJCQkFrY042d0VnQUNnQ0JDRVFJQUJCQURZQ0JDQUFJQkFnQVVFQmFpSUJFTG1BZ0lBQUloQU42Z0VnQVNFQkRQUUNDeUFCUVFGcUlnRWdBa2NOQUF0QkVpRVFET0lEQ3lBQUlBRWlBU0FDRUxxQWdJQUFJaEFONlFFZ0FTRUJEQW9MSUFFaUFTQUNSdzBHUVJzaEVBemdBd3NDUUNBQklnRWdBa2NOQUVFV0lSQU00QU1MSUFCQmlvQ0FnQUEyQWdnZ0FDQUJOZ0lFSUFBZ0FTQUNFTGlBZ0lBQUloQU42Z0VnQVNFQlFTQWhFQXpHQXdzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFFSHd0NENBQUdvdEFBQWlFRUVDUmcwQUFrQWdFRUYvYWc0RTVRSHNBUURyQWV3QkN5QUJRUUZxSVFGQkNDRVFETWdEQ3lBQlFRRnFJZ0VnQWtjTkFBdEJGU0VRRE44REMwRVZJUkFNM2dNTEEwQUNRQ0FCTFFBQVFmQzVnSUFBYWkwQUFDSVFRUUpHRFFBZ0VFRi9hZzRFM2dIc0FlQUI2d0hzQVFzZ0FVRUJhaUlCSUFKSERRQUxRUmdoRUF6ZEF3c0NRQ0FCSWdFZ0FrWU5BQ0FBUVl1QWdJQUFOZ0lJSUFBZ0FUWUNCQ0FCSVFGQkJ5RVFETVFEQzBFWklSQU0zQU1MSUFGQkFXb2hBUXdDQ3dKQUlBRWlGQ0FDUncwQVFSb2hFQXpiQXdzZ0ZDRUJBa0FnRkMwQUFFRnphZzRVM1FMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dJQTdnSUxRUUFoRUNBQVFRQTJBaHdnQUVHdmk0Q0FBRFlDRUNBQVFRSTJBZ3dnQUNBVVFRRnFOZ0lVRE5vREN3SkFJQUV0QUFBaUVFRTdSZzBBSUJCQkRVY042QUVnQVVFQmFpRUJET1VDQ3lBQlFRRnFJUUVMUVNJaEVBeS9Bd3NDUUNBQkloQWdBa2NOQUVFY0lSQU0yQU1MUWdBaEVTQVFJUUVnRUMwQUFFRlFhZzQzNXdIbUFRRUNBd1FGQmdjSUFBQUFBQUFBQUFrS0N3d05EZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEeEFSRWhNVUFBdEJIaUVRREwwREMwSUNJUkVNNVFFTFFnTWhFUXprQVF0Q0JDRVJET01CQzBJRklSRU00Z0VMUWdZaEVRemhBUXRDQnlFUkRPQUJDMElJSVJFTTN3RUxRZ2toRVF6ZUFRdENDaUVSRE4wQkMwSUxJUkVNM0FFTFFnd2hFUXpiQVF0Q0RTRVJETm9CQzBJT0lSRU0yUUVMUWc4aEVRellBUXRDQ2lFUkROY0JDMElMSVJFTTFnRUxRZ3doRVF6VkFRdENEU0VSRE5RQkMwSU9JUkVNMHdFTFFnOGhFUXpTQVF0Q0FDRVJBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBUUxRQUFRVkJxRGpmbEFlUUJBQUVDQXdRRkJnZm1BZVlCNWdIbUFlWUI1Z0htQVFnSkNnc01EZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnRU9EeEFSRWhQbUFRdENBaUVSRE9RQkMwSURJUkVNNHdFTFFnUWhFUXppQVF0Q0JTRVJET0VCQzBJR0lSRU00QUVMUWdjaEVRemZBUXRDQ0NFUkRONEJDMElKSVJFTTNRRUxRZ29oRVF6Y0FRdENDeUVSRE5zQkMwSU1JUkVNMmdFTFFnMGhFUXpaQVF0Q0RpRVJETmdCQzBJUElSRU0xd0VMUWdvaEVReldBUXRDQ3lFUkROVUJDMElNSVJFTTFBRUxRZzBoRVF6VEFRdENEaUVSRE5JQkMwSVBJUkVNMFFFTElBQkNBQ0FBS1FNZ0loRWdBaUFCSWhCcnJTSVNmU0lUSUJNZ0VWWWJOd01nSUJFZ0VsWWlGRVVOMGdGQkh5RVFETUFEQ3dKQUlBRWlBU0FDUmcwQUlBQkJpWUNBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUVrSVJBTXB3TUxRU0FoRUF5L0F3c2dBQ0FCSWhBZ0FoQytnSUNBQUVGL2FnNEZ0Z0VBeFFJQjBRSFNBUXRCRVNFUURLUURDeUFBUVFFNkFDOGdFQ0VCRExzREN5QUJJZ0VnQWtjTjBnRkJKQ0VRRExzREN5QUJJZzBnQWtjTkhrSEdBQ0VRRExvREN5QUFJQUVpQVNBQ0VMS0FnSUFBSWhBTjFBRWdBU0VCRExVQkN5QUJJaEFnQWtjTkprSFFBQ0VRRExnREN3SkFJQUVpQVNBQ1J3MEFRU2doRUF5NEF3c2dBRUVBTmdJRUlBQkJqSUNBZ0FBMkFnZ2dBQ0FCSUFFUXNZQ0FnQUFpRUEzVEFTQUJJUUVNMkFFTEFrQWdBU0lRSUFKSERRQkJLU0VRRExjREN5QVFMUUFBSWdGQklFWU5GQ0FCUVFsSERkTUJJQkJCQVdvaEFRd1ZDd0pBSUFFaUFTQUNSZzBBSUFGQkFXb2hBUXdYQzBFcUlSQU10UU1MQWtBZ0FTSVFJQUpIRFFCQkt5RVFETFVEQ3dKQUlCQXRBQUFpQVVFSlJnMEFJQUZCSUVjTjFRRUxJQUF0QUN4QkNFWU4wd0VnRUNFQkRKRURDd0pBSUFFaUFTQUNSdzBBUVN3aEVBeTBBd3NnQVMwQUFFRUtSdzNWQVNBQlFRRnFJUUVNeVFJTElBRWlEaUFDUnczVkFVRXZJUkFNc2dNTEEwQUNRQ0FCTFFBQUloQkJJRVlOQUFKQUlCQkJkbW9PQkFEY0Fkd0JBTm9CQ3lBQklRRU00QUVMSUFGQkFXb2lBU0FDUncwQUMwRXhJUkFNc1FNTFFUSWhFQ0FCSWhRZ0FrWU5zQU1nQWlBVWF5QUFLQUlBSWdGcUlSVWdGQ0FCYTBFRGFpRVdBa0FEUUNBVUxRQUFJaGRCSUhJZ0Z5QVhRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRZkM3Z0lBQWFpMEFBRWNOQVFKQUlBRkJBMGNOQUVFR0lRRU1sZ01MSUFGQkFXb2hBU0FVUVFGcUloUWdBa2NOQUFzZ0FDQVZOZ0lBRExFREN5QUFRUUEyQWdBZ0ZDRUJETmtCQzBFeklSQWdBU0lVSUFKR0RhOERJQUlnRkdzZ0FDZ0NBQ0lCYWlFVklCUWdBV3RCQ0dvaEZnSkFBMEFnRkMwQUFDSVhRU0J5SUJjZ0YwRy9mMnBCL3dGeFFScEpHMEgvQVhFZ0FVSDB1NENBQUdvdEFBQkhEUUVDUUNBQlFRaEhEUUJCQlNFQkRKVURDeUFCUVFGcUlRRWdGRUVCYWlJVUlBSkhEUUFMSUFBZ0ZUWUNBQXl3QXdzZ0FFRUFOZ0lBSUJRaEFRellBUXRCTkNFUUlBRWlGQ0FDUmcydUF5QUNJQlJySUFBb0FnQWlBV29oRlNBVUlBRnJRUVZxSVJZQ1FBTkFJQlF0QUFBaUYwRWdjaUFYSUJkQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQjBNS0FnQUJxTFFBQVJ3MEJBa0FnQVVFRlJ3MEFRUWNoQVF5VUF3c2dBVUVCYWlFQklCUkJBV29pRkNBQ1J3MEFDeUFBSUJVMkFnQU1yd01MSUFCQkFEWUNBQ0FVSVFFTTF3RUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUJCZ0w2QWdBQnFMUUFBSWhCQkFVWU5BQ0FRUVFKR0RRb2dBU0VCRE4wQkN5QUJRUUZxSWdFZ0FrY05BQXRCTUNFUURLNERDMEV3SVJBTXJRTUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUFpRUVFZ1JnMEFJQkJCZG1vT0JOa0IyZ0hhQWRrQjJnRUxJQUZCQVdvaUFTQUNSdzBBQzBFNElSQU1yUU1MUVRnaEVBeXNBd3NEUUFKQUlBRXRBQUFpRUVFZ1JnMEFJQkJCQ1VjTkF3c2dBVUVCYWlJQklBSkhEUUFMUVR3aEVBeXJBd3NEUUFKQUlBRXRBQUFpRUVFZ1JnMEFBa0FDUUNBUVFYWnFEZ1RhQVFFQjJnRUFDeUFRUVN4R0Rkc0JDeUFCSVFFTUJBc2dBVUVCYWlJQklBSkhEUUFMUVQ4aEVBeXFBd3NnQVNFQkROc0JDMEhBQUNFUUlBRWlGQ0FDUmcyb0F5QUNJQlJySUFBb0FnQWlBV29oRmlBVUlBRnJRUVpxSVJjQ1FBTkFJQlF0QUFCQklISWdBVUdBd0lDQUFHb3RBQUJIRFFFZ0FVRUdSZzJPQXlBQlFRRnFJUUVnRkVFQmFpSVVJQUpIRFFBTElBQWdGallDQUF5cEF3c2dBRUVBTmdJQUlCUWhBUXRCTmlFUURJNERDd0pBSUFFaUR5QUNSdzBBUWNFQUlSQU1wd01MSUFCQmpJQ0FnQUEyQWdnZ0FDQVBOZ0lFSUE4aEFTQUFMUUFzUVg5cURnVE5BZFVCMXdIWkFZY0RDeUFCUVFGcUlRRU16QUVMQWtBZ0FTSUJJQUpHRFFBRFFBSkFJQUV0QUFBaUVFRWdjaUFRSUJCQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SWhCQkNVWU5BQ0FRUVNCR0RRQUNRQUpBQWtBQ1FDQVFRWjEvYWc0VEFBTURBd01EQXdNQkF3TURBd01EQXdNREFnTUxJQUZCQVdvaEFVRXhJUkFNa1FNTElBRkJBV29oQVVFeUlSQU1rQU1MSUFGQkFXb2hBVUV6SVJBTWp3TUxJQUVoQVF6UUFRc2dBVUVCYWlJQklBSkhEUUFMUVRVaEVBeWxBd3RCTlNFUURLUURDd0pBSUFFaUFTQUNSZzBBQTBBQ1FDQUJMUUFBUVlDOGdJQUFhaTBBQUVFQlJnMEFJQUVoQVF6VEFRc2dBVUVCYWlJQklBSkhEUUFMUVQwaEVBeWtBd3RCUFNFUURLTURDeUFBSUFFaUFTQUNFTENBZ0lBQUloQU4xZ0VnQVNFQkRBRUxJQkJCQVdvaEFRdEJQQ0VRREljREN3SkFJQUVpQVNBQ1J3MEFRY0lBSVJBTW9BTUxBa0FEUUFKQUlBRXRBQUJCZDJvT0dBQUMvZ0wrQW9RRC9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Q0FQNENDeUFCUVFGcUlnRWdBa2NOQUF0QndnQWhFQXlnQXdzZ0FVRUJhaUVCSUFBdEFDMUJBWEZGRGIwQklBRWhBUXRCTENFUURJVURDeUFCSWdFZ0FrY04wd0ZCeEFBaEVBeWRBd3NEUUFKQUlBRXRBQUJCa01DQWdBQnFMUUFBUVFGR0RRQWdBU0VCRExjQ0N5QUJRUUZxSWdFZ0FrY05BQXRCeFFBaEVBeWNBd3NnRFMwQUFDSVFRU0JHRGJNQklCQkJPa2NOZ1FNZ0FDZ0NCQ0VCSUFCQkFEWUNCQ0FBSUFFZ0RSQ3ZnSUNBQUNJQkRkQUJJQTFCQVdvaEFReXpBZ3RCeHdBaEVDQUJJZzBnQWtZTm1nTWdBaUFOYXlBQUtBSUFJZ0ZxSVJZZ0RTQUJhMEVGYWlFWEEwQWdEUzBBQUNJVVFTQnlJQlFnRkVHL2YycEIvd0Z4UVJwSkcwSC9BWEVnQVVHUXdvQ0FBR290QUFCSERZQURJQUZCQlVZTjlBSWdBVUVCYWlFQklBMUJBV29pRFNBQ1J3MEFDeUFBSUJZMkFnQU1tZ01MUWNnQUlSQWdBU0lOSUFKR0Raa0RJQUlnRFdzZ0FDZ0NBQ0lCYWlFV0lBMGdBV3RCQ1dvaEZ3TkFJQTB0QUFBaUZFRWdjaUFVSUJSQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQmxzS0FnQUJxTFFBQVJ3My9BZ0pBSUFGQkNVY05BRUVDSVFFTTlRSUxJQUZCQVdvaEFTQU5RUUZxSWcwZ0FrY05BQXNnQUNBV05nSUFESmtEQ3dKQUlBRWlEU0FDUncwQVFja0FJUkFNbVFNTEFrQUNRQ0FOTFFBQUlnRkJJSElnQVNBQlFiOS9ha0gvQVhGQkdra2JRZjhCY1VHU2Yyb09Cd0NBQTRBRGdBT0FBNEFEQVlBREN5QU5RUUZxSVFGQlBpRVFESUFEQ3lBTlFRRnFJUUZCUHlFUURQOENDMEhLQUNFUUlBRWlEU0FDUmcyWEF5QUNJQTFySUFBb0FnQWlBV29oRmlBTklBRnJRUUZxSVJjRFFDQU5MUUFBSWhSQklISWdGQ0FVUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWFEQ2dJQUFhaTBBQUVjTi9RSWdBVUVCUmczd0FpQUJRUUZxSVFFZ0RVRUJhaUlOSUFKSERRQUxJQUFnRmpZQ0FBeVhBd3RCeXdBaEVDQUJJZzBnQWtZTmxnTWdBaUFOYXlBQUtBSUFJZ0ZxSVJZZ0RTQUJhMEVPYWlFWEEwQWdEUzBBQUNJVVFTQnlJQlFnRkVHL2YycEIvd0Z4UVJwSkcwSC9BWEVnQVVHaXdvQ0FBR290QUFCSERmd0NJQUZCRGtZTjhBSWdBVUVCYWlFQklBMUJBV29pRFNBQ1J3MEFDeUFBSUJZMkFnQU1sZ01MUWN3QUlSQWdBU0lOSUFKR0RaVURJQUlnRFdzZ0FDZ0NBQ0lCYWlFV0lBMGdBV3RCRDJvaEZ3TkFJQTB0QUFBaUZFRWdjaUFVSUJSQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQndNS0FnQUJxTFFBQVJ3MzdBZ0pBSUFGQkQwY05BRUVESVFFTThRSUxJQUZCQVdvaEFTQU5RUUZxSWcwZ0FrY05BQXNnQUNBV05nSUFESlVEQzBITkFDRVFJQUVpRFNBQ1JnMlVBeUFDSUExcklBQW9BZ0FpQVdvaEZpQU5JQUZyUVFWcUlSY0RRQ0FOTFFBQUloUkJJSElnRkNBVVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFkRENnSUFBYWkwQUFFY04rZ0lDUUNBQlFRVkhEUUJCQkNFQkRQQUNDeUFCUVFGcUlRRWdEVUVCYWlJTklBSkhEUUFMSUFBZ0ZqWUNBQXlVQXdzQ1FDQUJJZzBnQWtjTkFFSE9BQ0VRREpRREN3SkFBa0FDUUFKQUlBMHRBQUFpQVVFZ2NpQUJJQUZCdjM5cVFmOEJjVUVhU1J0Qi93RnhRWjEvYWc0VEFQMEMvUUw5QXYwQy9RTDlBdjBDL1FMOUF2MEMvUUw5QWdIOUF2MEMvUUlDQS8wQ0N5QU5RUUZxSVFGQndRQWhFQXo5QWdzZ0RVRUJhaUVCUWNJQUlSQU0vQUlMSUExQkFXb2hBVUhEQUNFUURQc0NDeUFOUVFGcUlRRkJ4QUFoRUF6NkFnc0NRQ0FCSWdFZ0FrWU5BQ0FBUVkyQWdJQUFOZ0lJSUFBZ0FUWUNCQ0FCSVFGQnhRQWhFQXo2QWd0Qnp3QWhFQXlTQXdzZ0VDRUJBa0FDUUNBUUxRQUFRWFpxRGdRQnFBS29BZ0NvQWdzZ0VFRUJhaUVCQzBFbklSQU0rQUlMQWtBZ0FTSUJJQUpIRFFCQjBRQWhFQXlSQXdzQ1FDQUJMUUFBUVNCR0RRQWdBU0VCREkwQkN5QUJRUUZxSVFFZ0FDMEFMVUVCY1VVTnh3RWdBU0VCREl3QkN5QUJJaGNnQWtjTnlBRkIwZ0FoRUF5UEF3dEIwd0FoRUNBQkloUWdBa1lOamdNZ0FpQVVheUFBS0FJQUlnRnFJUllnRkNBQmEwRUJhaUVYQTBBZ0ZDMEFBQ0FCUWRiQ2dJQUFhaTBBQUVjTnpBRWdBVUVCUmczSEFTQUJRUUZxSVFFZ0ZFRUJhaUlVSUFKSERRQUxJQUFnRmpZQ0FBeU9Bd3NDUUNBQklnRWdBa2NOQUVIVkFDRVFESTREQ3lBQkxRQUFRUXBIRGN3QklBRkJBV29oQVF6SEFRc0NRQ0FCSWdFZ0FrY05BRUhXQUNFUURJMERDd0pBQWtBZ0FTMEFBRUYyYWc0RUFNMEJ6UUVCelFFTElBRkJBV29oQVF6SEFRc2dBVUVCYWlFQlFjb0FJUkFNOHdJTElBQWdBU0lCSUFJUXJvQ0FnQUFpRUEzTEFTQUJJUUZCelFBaEVBenlBZ3NnQUMwQUtVRWlSZzJGQXd5bUFnc0NRQ0FCSWdFZ0FrY05BRUhiQUNFUURJb0RDMEVBSVJSQkFTRVhRUUVoRmtFQUlSQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUzBBQUVGUWFnNEsxQUhUQVFBQkFnTUVCUVlJMVFFTFFRSWhFQXdHQzBFRElSQU1CUXRCQkNFUURBUUxRUVVoRUF3REMwRUdJUkFNQWd0QkJ5RVFEQUVMUVFnaEVBdEJBQ0VYUVFBaEZrRUFJUlFNekFFTFFRa2hFRUVCSVJSQkFDRVhRUUFoRmd6TEFRc0NRQ0FCSWdFZ0FrY05BRUhkQUNFUURJa0RDeUFCTFFBQVFTNUhEY3dCSUFGQkFXb2hBUXltQWdzZ0FTSUJJQUpIRGN3QlFkOEFJUkFNaHdNTEFrQWdBU0lCSUFKR0RRQWdBRUdPZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCUWRBQUlSQU03Z0lMUWVBQUlSQU1oZ01MUWVFQUlSQWdBU0lCSUFKR0RZVURJQUlnQVdzZ0FDZ0NBQ0lVYWlFV0lBRWdGR3RCQTJvaEZ3TkFJQUV0QUFBZ0ZFSGl3b0NBQUdvdEFBQkhEYzBCSUJSQkEwWU56QUVnRkVFQmFpRVVJQUZCQVdvaUFTQUNSdzBBQ3lBQUlCWTJBZ0FNaFFNTFFlSUFJUkFnQVNJQklBSkdEWVFESUFJZ0FXc2dBQ2dDQUNJVWFpRVdJQUVnRkd0QkFtb2hGd05BSUFFdEFBQWdGRUhtd29DQUFHb3RBQUJIRGN3QklCUkJBa1lOemdFZ0ZFRUJhaUVVSUFGQkFXb2lBU0FDUncwQUN5QUFJQlkyQWdBTWhBTUxRZU1BSVJBZ0FTSUJJQUpHRFlNRElBSWdBV3NnQUNnQ0FDSVVhaUVXSUFFZ0ZHdEJBMm9oRndOQUlBRXRBQUFnRkVIcHdvQ0FBR290QUFCSERjc0JJQlJCQTBZTnpnRWdGRUVCYWlFVUlBRkJBV29pQVNBQ1J3MEFDeUFBSUJZMkFnQU1nd01MQWtBZ0FTSUJJQUpIRFFCQjVRQWhFQXlEQXdzZ0FDQUJRUUZxSWdFZ0FoQ29nSUNBQUNJUURjMEJJQUVoQVVIV0FDRVFET2tDQ3dKQUlBRWlBU0FDUmcwQUEwQUNRQ0FCTFFBQUloQkJJRVlOQUFKQUFrQUNRQ0FRUWJoL2FnNExBQUhQQWM4Qnp3SFBBYzhCendIUEFjOEJBczhCQ3lBQlFRRnFJUUZCMGdBaEVBenRBZ3NnQVVFQmFpRUJRZE1BSVJBTTdBSUxJQUZCQVdvaEFVSFVBQ0VRRE9zQ0N5QUJRUUZxSWdFZ0FrY05BQXRCNUFBaEVBeUNBd3RCNUFBaEVBeUJBd3NEUUFKQUlBRXRBQUJCOE1LQWdBQnFMUUFBSWhCQkFVWU5BQ0FRUVg1cURnUFBBZEFCMFFIU0FRc2dBVUVCYWlJQklBSkhEUUFMUWVZQUlSQU1nQU1MQWtBZ0FTSUJJQUpHRFFBZ0FVRUJhaUVCREFNTFFlY0FJUkFNL3dJTEEwQUNRQ0FCTFFBQVFmREVnSUFBYWkwQUFDSVFRUUZHRFFBQ1FDQVFRWDVxRGdUU0FkTUIxQUVBMVFFTElBRWhBVUhYQUNFUURPY0NDeUFCUVFGcUlnRWdBa2NOQUF0QjZBQWhFQXorQWdzQ1FDQUJJZ0VnQWtjTkFFSHBBQ0VRRFA0Q0N3SkFJQUV0QUFBaUVFRjJhZzRhdWdIVkFkVUJ2QUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhLQWRVQjFRRUEwd0VMSUFGQkFXb2hBUXRCQmlFUURPTUNDd05BQWtBZ0FTMEFBRUh3eG9DQUFHb3RBQUJCQVVZTkFDQUJJUUVNbmdJTElBRkJBV29pQVNBQ1J3MEFDMEhxQUNFUURQc0NDd0pBSUFFaUFTQUNSZzBBSUFGQkFXb2hBUXdEQzBIckFDRVFEUG9DQ3dKQUlBRWlBU0FDUncwQVFld0FJUkFNK2dJTElBRkJBV29oQVF3QkN3SkFJQUVpQVNBQ1J3MEFRZTBBSVJBTStRSUxJQUZCQVdvaEFRdEJCQ0VRRE40Q0N3SkFJQUVpRkNBQ1J3MEFRZTRBSVJBTTl3SUxJQlFoQVFKQUFrQUNRQ0FVTFFBQVFmRElnSUFBYWkwQUFFRi9hZzRIMUFIVkFkWUJBSndDQVFMWEFRc2dGRUVCYWlFQkRBb0xJQlJCQVdvaEFRek5BUXRCQUNFUUlBQkJBRFlDSENBQVFadVNnSUFBTmdJUUlBQkJCellDRENBQUlCUkJBV28yQWhRTTlnSUxBa0FEUUFKQUlBRXRBQUJCOE1pQWdBQnFMUUFBSWhCQkJFWU5BQUpBQWtBZ0VFRi9hZzRIMGdIVEFkUUIyUUVBQkFIWkFRc2dBU0VCUWRvQUlSQU00QUlMSUFGQkFXb2hBVUhjQUNFUUROOENDeUFCUVFGcUlnRWdBa2NOQUF0Qjd3QWhFQXoyQWdzZ0FVRUJhaUVCRE1zQkN3SkFJQUVpRkNBQ1J3MEFRZkFBSVJBTTlRSUxJQlF0QUFCQkwwY04xQUVnRkVFQmFpRUJEQVlMQWtBZ0FTSVVJQUpIRFFCQjhRQWhFQXowQWdzQ1FDQVVMUUFBSWdGQkwwY05BQ0FVUVFGcUlRRkIzUUFoRUF6YkFnc2dBVUYyYWlJRVFSWkxEZE1CUVFFZ0JIUkJpWUNBQW5GRkRkTUJETW9DQ3dKQUlBRWlBU0FDUmcwQUlBRkJBV29oQVVIZUFDRVFETm9DQzBIeUFDRVFEUElDQ3dKQUlBRWlGQ0FDUncwQVFmUUFJUkFNOGdJTElCUWhBUUpBSUJRdEFBQkI4TXlBZ0FCcUxRQUFRWDlxRGdQSkFwUUNBTlFCQzBIaEFDRVFETmdDQ3dKQUlBRWlGQ0FDUmcwQUEwQUNRQ0FVTFFBQVFmREtnSUFBYWkwQUFDSUJRUU5HRFFBQ1FDQUJRWDlxRGdMTEFnRFZBUXNnRkNFQlFkOEFJUkFNMmdJTElCUkJBV29pRkNBQ1J3MEFDMEh6QUNFUURQRUNDMEh6QUNFUURQQUNDd0pBSUFFaUFTQUNSZzBBSUFCQmo0Q0FnQUEyQWdnZ0FDQUJOZ0lFSUFFaEFVSGdBQ0VRRE5jQ0MwSDFBQ0VRRE84Q0N3SkFJQUVpQVNBQ1J3MEFRZllBSVJBTTd3SUxJQUJCajRDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVF0QkF5RVFETlFDQ3dOQUlBRXRBQUJCSUVjTnd3SWdBVUVCYWlJQklBSkhEUUFMUWZjQUlSQU03QUlMQWtBZ0FTSUJJQUpIRFFCQitBQWhFQXpzQWdzZ0FTMEFBRUVnUnczT0FTQUJRUUZxSVFFTTd3RUxJQUFnQVNJQklBSVFySUNBZ0FBaUVBM09BU0FCSVFFTWpnSUxBa0FnQVNJRUlBSkhEUUJCK2dBaEVBenFBZ3NnQkMwQUFFSE1BRWNOMFFFZ0JFRUJhaUVCUVJNaEVBelBBUXNDUUNBQklnUWdBa2NOQUVIN0FDRVFET2tDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRVnFJUkFEUUNBRUxRQUFJQUZCOE02QWdBQnFMUUFBUnczUUFTQUJRUVZHRGM0QklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFmc0FJUkFNNkFJTEFrQWdBU0lFSUFKSERRQkIvQUFoRUF6b0Fnc0NRQUpBSUFRdEFBQkJ2WDlxRGd3QTBRSFJBZEVCMFFIUkFkRUIwUUhSQWRFQjBRRUIwUUVMSUFSQkFXb2hBVUhtQUNFUURNOENDeUFFUVFGcUlRRkI1d0FoRUF6T0Fnc0NRQ0FCSWdRZ0FrY05BRUg5QUNFUURPY0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUh0ejRDQUFHb3RBQUJIRGM4QklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVIOUFDRVFET2NDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUkFoRUF6TUFRc0NRQ0FCSWdRZ0FrY05BRUgrQUNFUURPWUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQUNRQU5BSUFRdEFBQWdBVUgyem9DQUFHb3RBQUJIRGM0QklBRkJCVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVIK0FDRVFET1lDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUlloRUF6TEFRc0NRQ0FCSWdRZ0FrY05BRUgvQUNFUURPVUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFOcUlSQUNRQU5BSUFRdEFBQWdBVUg4em9DQUFHb3RBQUJIRGMwQklBRkJBMFlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVIL0FDRVFET1VDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUVVoRUF6S0FRc0NRQ0FCSWdRZ0FrY05BRUdBQVNFUURPUUNDeUFFTFFBQVFka0FSdzNMQVNBRVFRRnFJUUZCQ0NFUURNa0JDd0pBSUFFaUJDQUNSdzBBUVlFQklSQU00d0lMQWtBQ1FDQUVMUUFBUWJKL2FnNERBTXdCQWN3QkN5QUVRUUZxSVFGQjZ3QWhFQXpLQWdzZ0JFRUJhaUVCUWV3QUlSQU15UUlMQWtBZ0FTSUVJQUpIRFFCQmdnRWhFQXppQWdzQ1FBSkFJQVF0QUFCQnVIOXFEZ2dBeXdITEFjc0J5d0hMQWNzQkFjc0JDeUFFUVFGcUlRRkI2Z0FoRUF6SkFnc2dCRUVCYWlFQlFlMEFJUkFNeUFJTEFrQWdBU0lFSUFKSERRQkJnd0VoRUF6aEFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJBZ0JDQUJhMEVDYWlFVUFrQURRQ0FFTFFBQUlBRkJnTStBZ0FCcUxRQUFSdzNKQVNBQlFRSkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCQTJBZ0JCZ3dFaEVBemhBZ3RCQUNFUUlBQkJBRFlDQUNBVVFRRnFJUUVNeGdFTEFrQWdBU0lFSUFKSERRQkJoQUVoRUF6Z0Fnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVFYWlFUUFrQURRQ0FFTFFBQUlBRkJnOCtBZ0FCcUxRQUFSdzNJQVNBQlFRUkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCaEFFaEVBemdBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRWpJUkFNeFFFTEFrQWdBU0lFSUFKSERRQkJoUUVoRUF6ZkFnc0NRQUpBSUFRdEFBQkJ0SDlxRGdnQXlBSElBY2dCeUFISUFjZ0JBY2dCQ3lBRVFRRnFJUUZCN3dBaEVBekdBZ3NnQkVFQmFpRUJRZkFBSVJBTXhRSUxBa0FnQVNJRUlBSkhEUUJCaGdFaEVBemVBZ3NnQkMwQUFFSEZBRWNOeFFFZ0JFRUJhaUVCRElNQ0N3SkFJQUVpQkNBQ1J3MEFRWWNCSVJBTTNRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQTJvaEVBSkFBMEFnQkMwQUFDQUJRWWpQZ0lBQWFpMEFBRWNOeFFFZ0FVRURSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVljQklSQU0zUUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJMU0VRRE1JQkN3SkFJQUVpQkNBQ1J3MEFRWWdCSVJBTTNBSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQ0dvaEVBSkFBMEFnQkMwQUFDQUJRZERQZ0lBQWFpMEFBRWNOeEFFZ0FVRUlSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVlnQklSQU0zQUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJLU0VRRE1FQkN3SkFJQUVpQVNBQ1J3MEFRWWtCSVJBTTJ3SUxRUUVoRUNBQkxRQUFRZDhBUnczQUFTQUJRUUZxSVFFTWdRSUxBa0FnQVNJRUlBSkhEUUJCaWdFaEVBemFBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBMEFnQkMwQUFDQUJRWXpQZ0lBQWFpMEFBRWNOd1FFZ0FVRUJSZzJ2QWlBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHS0FTRVFETmtDQ3dKQUlBRWlCQ0FDUncwQVFZc0JJUkFNMlFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBbW9oRUFKQUEwQWdCQzBBQUNBQlFZN1BnSUFBYWkwQUFFY053UUVnQVVFQ1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWXNCSVJBTTJRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkFpRVFETDRCQ3dKQUlBRWlCQ0FDUncwQVFZd0JJUkFNMkFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFmRFBnSUFBYWkwQUFFY053QUVnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWXdCSVJBTTJBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkh5RVFETDBCQ3dKQUlBRWlCQ0FDUncwQVFZMEJJUkFNMXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFmTFBnSUFBYWkwQUFFY052d0VnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWTBCSVJBTTF3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQkNTRVFETHdCQ3dKQUlBRWlCQ0FDUncwQVFZNEJJUkFNMWdJTEFrQUNRQ0FFTFFBQVFiZC9hZzRIQUw4QnZ3Ry9BYjhCdndFQnZ3RUxJQVJCQVdvaEFVSDRBQ0VRREwwQ0N5QUVRUUZxSVFGQitRQWhFQXk4QWdzQ1FDQUJJZ1FnQWtjTkFFR1BBU0VRRE5VQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBQ1FBTkFJQVF0QUFBZ0FVR1J6NENBQUdvdEFBQkhEYjBCSUFGQkJVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdQQVNFUUROVUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSZ2hFQXk2QVFzQ1FDQUJJZ1FnQWtjTkFFR1FBU0VRRE5RQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVR1h6NENBQUdvdEFBQkhEYndCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdRQVNFUUROUUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSY2hFQXk1QVFzQ1FDQUJJZ1FnQWtjTkFFR1JBU0VRRE5NQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVpxSVJBQ1FBTkFJQVF0QUFBZ0FVR2F6NENBQUdvdEFBQkhEYnNCSUFGQkJrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdSQVNFUUROTUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSVWhFQXk0QVFzQ1FDQUJJZ1FnQWtjTkFFR1NBU0VRRE5JQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBQ1FBTkFJQVF0QUFBZ0FVR2h6NENBQUdvdEFBQkhEYm9CSUFGQkJVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdTQVNFUUROSUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSNGhFQXkzQVFzQ1FDQUJJZ1FnQWtjTkFFR1RBU0VRRE5FQ0N5QUVMUUFBUWN3QVJ3MjRBU0FFUVFGcUlRRkJDaUVRRExZQkN3SkFJQVFnQWtjTkFFR1VBU0VRRE5BQ0N3SkFBa0FnQkMwQUFFRy9mMm9PRHdDNUFia0J1UUc1QWJrQnVRRzVBYmtCdVFHNUFia0J1UUc1QVFHNUFRc2dCRUVCYWlFQlFmNEFJUkFNdHdJTElBUkJBV29oQVVIL0FDRVFETFlDQ3dKQUlBUWdBa2NOQUVHVkFTRVFETThDQ3dKQUFrQWdCQzBBQUVHL2Yyb09Bd0M0QVFHNEFRc2dCRUVCYWlFQlFmMEFJUkFNdGdJTElBUkJBV29oQkVHQUFTRVFETFVDQ3dKQUlBUWdBa2NOQUVHV0FTRVFETTRDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVHbno0Q0FBR290QUFCSERiWUJJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1dBU0VRRE00Q0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVFzaEVBeXpBUXNDUUNBRUlBSkhEUUJCbHdFaEVBek5BZ3NDUUFKQUFrQUNRQ0FFTFFBQVFWTnFEaU1BdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QVFHNEFiZ0J1QUc0QWJnQkFyZ0J1QUc0QVFPNEFRc2dCRUVCYWlFQlFmc0FJUkFNdGdJTElBUkJBV29oQVVIOEFDRVFETFVDQ3lBRVFRRnFJUVJCZ1FFaEVBeTBBZ3NnQkVFQmFpRUVRWUlCSVJBTXN3SUxBa0FnQkNBQ1J3MEFRWmdCSVJBTXpBSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQkdvaEVBSkFBMEFnQkMwQUFDQUJRYW5QZ0lBQWFpMEFBRWNOdEFFZ0FVRUVSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVpnQklSQU16QUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJHU0VRRExFQkN3SkFJQVFnQWtjTkFFR1pBU0VRRE1zQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBQ1FBTkFJQVF0QUFBZ0FVR3V6NENBQUdvdEFBQkhEYk1CSUFGQkJVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdaQVNFUURNc0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFRWWhFQXl3QVFzQ1FDQUVJQUpIRFFCQm1nRWhFQXpLQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQnRNK0FnQUJxTFFBQVJ3MnlBU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJtZ0VoRUF6S0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFY0lSQU1yd0VMQWtBZ0JDQUNSdzBBUVpzQklSQU15UUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWJiUGdJQUFhaTBBQUVjTnNRRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFac0JJUkFNeVFJTElBQkJBRFlDQUNBUVFRRnFJUUZCSnlFUURLNEJDd0pBSUFRZ0FrY05BRUdjQVNFUURNZ0NDd0pBQWtBZ0JDMEFBRUdzZjJvT0FnQUJzUUVMSUFSQkFXb2hCRUdHQVNFUURLOENDeUFFUVFGcUlRUkJod0VoRUF5dUFnc0NRQ0FFSUFKSERRQkJuUUVoRUF6SEFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUFrQURRQ0FFTFFBQUlBRkJ1TStBZ0FCcUxRQUFSdzJ2QVNBQlFRRkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCblFFaEVBekhBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRW1JUkFNckFFTEFrQWdCQ0FDUncwQVFaNEJJUkFNeGdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFiclBnSUFBYWkwQUFFY05yZ0VnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWjRCSVJBTXhnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkF5RVFES3NCQ3dKQUlBUWdBa2NOQUVHZkFTRVFETVVDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRSnFJUkFDUUFOQUlBUXRBQUFnQVVIdHo0Q0FBR290QUFCSERhMEJJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR2ZBU0VRRE1VQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVF3aEVBeXFBUXNDUUNBRUlBSkhEUUJCb0FFaEVBekVBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFRGFpRVFBa0FEUUNBRUxRQUFJQUZCdk0rQWdBQnFMUUFBUncyc0FTQUJRUU5HRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm9BRWhFQXpFQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVOSVJBTXFRRUxBa0FnQkNBQ1J3MEFRYUVCSVJBTXd3SUxBa0FDUUNBRUxRQUFRYnAvYWc0TEFLd0JyQUdzQWF3QnJBR3NBYXdCckFHc0FRR3NBUXNnQkVFQmFpRUVRWXNCSVJBTXFnSUxJQVJCQVdvaEJFR01BU0VRREtrQ0N3SkFJQVFnQWtjTkFFR2lBU0VRRE1JQ0N5QUVMUUFBUWRBQVJ3MnBBU0FFUVFGcUlRUU02UUVMQWtBZ0JDQUNSdzBBUWFNQklSQU13UUlMQWtBQ1FDQUVMUUFBUWJkL2FnNEhBYW9CcWdHcUFhb0JxZ0VBcWdFTElBUkJBV29oQkVHT0FTRVFES2dDQ3lBRVFRRnFJUUZCSWlFUURLWUJDd0pBSUFRZ0FrY05BRUdrQVNFUURNQUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQUNRQU5BSUFRdEFBQWdBVUhBejRDQUFHb3RBQUJIRGFnQklBRkJBVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHa0FTRVFETUFDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUjBoRUF5bEFRc0NRQ0FFSUFKSERRQkJwUUVoRUF5L0Fnc0NRQUpBSUFRdEFBQkJybjlxRGdNQXFBRUJxQUVMSUFSQkFXb2hCRUdRQVNFUURLWUNDeUFFUVFGcUlRRkJCQ0VRREtRQkN3SkFJQVFnQWtjTkFFR21BU0VRREw0Q0N3SkFBa0FDUUFKQUFrQWdCQzBBQUVHL2Yyb09GUUNxQWFvQnFnR3FBYW9CcWdHcUFhb0JxZ0dxQVFHcUFhb0JBcW9CcWdFRHFnR3FBUVNxQVFzZ0JFRUJhaUVFUVlnQklSQU1xQUlMSUFSQkFXb2hCRUdKQVNFUURLY0NDeUFFUVFGcUlRUkJpZ0VoRUF5bUFnc2dCRUVCYWlFRVFZOEJJUkFNcFFJTElBUkJBV29oQkVHUkFTRVFES1FDQ3dKQUlBUWdBa2NOQUVHbkFTRVFETDBDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRSnFJUkFDUUFOQUlBUXRBQUFnQVVIdHo0Q0FBR290QUFCSERhVUJJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR25BU0VRREwwQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJFaEVBeWlBUXNDUUNBRUlBSkhEUUJCcUFFaEVBeThBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQ2FpRVFBa0FEUUNBRUxRQUFJQUZCd3MrQWdBQnFMUUFBUncya0FTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnFBRWhFQXk4QWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVzSVJBTW9RRUxBa0FnQkNBQ1J3MEFRYWtCSVJBTXV3SUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQkdvaEVBSkFBMEFnQkMwQUFDQUJRY1hQZ0lBQWFpMEFBRWNOb3dFZ0FVRUVSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWFrQklSQU11d0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJLeUVRREtBQkN3SkFJQVFnQWtjTkFFR3FBU0VRRExvQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSEt6NENBQUdvdEFBQkhEYUlCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdxQVNFUURMb0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFSUWhFQXlmQVFzQ1FDQUVJQUpIRFFCQnF3RWhFQXk1QWdzQ1FBSkFBa0FDUUNBRUxRQUFRYjUvYWc0UEFBRUNwQUdrQWFRQnBBR2tBYVFCcEFHa0FhUUJwQUdrQVFPa0FRc2dCRUVCYWlFRVFaTUJJUkFNb2dJTElBUkJBV29oQkVHVUFTRVFES0VDQ3lBRVFRRnFJUVJCbFFFaEVBeWdBZ3NnQkVFQmFpRUVRWllCSVJBTW53SUxBa0FnQkNBQ1J3MEFRYXdCSVJBTXVBSUxJQVF0QUFCQnhRQkhEWjhCSUFSQkFXb2hCQXpnQVFzQ1FDQUVJQUpIRFFCQnJRRWhFQXkzQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQnpjK0FnQUJxTFFBQVJ3MmZBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJyUUVoRUF5M0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFT0lSQU1uQUVMQWtBZ0JDQUNSdzBBUWE0QklSQU10Z0lMSUFRdEFBQkIwQUJIRFowQklBUkJBV29oQVVFbElSQU1td0VMQWtBZ0JDQUNSdzBBUWE4QklSQU10UUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkNHb2hFQUpBQTBBZ0JDMEFBQ0FCUWREUGdJQUFhaTBBQUVjTm5RRWdBVUVJUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFhOEJJUkFNdFFJTElBQkJBRFlDQUNBUVFRRnFJUUZCS2lFUURKb0JDd0pBSUFRZ0FrY05BRUd3QVNFUURMUUNDd0pBQWtBZ0JDMEFBRUdyZjJvT0N3Q2RBWjBCblFHZEFaMEJuUUdkQVowQm5RRUJuUUVMSUFSQkFXb2hCRUdhQVNFUURKc0NDeUFFUVFGcUlRUkJtd0VoRUF5YUFnc0NRQ0FFSUFKSERRQkJzUUVoRUF5ekFnc0NRQUpBSUFRdEFBQkJ2MzlxRGhRQW5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3QkFad0JDeUFFUVFGcUlRUkJtUUVoRUF5YUFnc2dCRUVCYWlFRVFad0JJUkFNbVFJTEFrQWdCQ0FDUncwQVFiSUJJUkFNc2dJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBMm9oRUFKQUEwQWdCQzBBQUNBQlFkblBnSUFBYWkwQUFFY05tZ0VnQVVFRFJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYklCSVJBTXNnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQklTRVFESmNCQ3dKQUlBUWdBa2NOQUVHekFTRVFETEVDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRWnFJUkFDUUFOQUlBUXRBQUFnQVVIZHo0Q0FBR290QUFCSERaa0JJQUZCQmtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR3pBU0VRRExFQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJvaEVBeVdBUXNDUUNBRUlBSkhEUUJCdEFFaEVBeXdBZ3NDUUFKQUFrQWdCQzBBQUVHN2Yyb09FUUNhQVpvQm1nR2FBWm9CbWdHYUFab0JtZ0VCbWdHYUFab0JtZ0dhQVFLYUFRc2dCRUVCYWlFRVFaMEJJUkFNbUFJTElBUkJBV29oQkVHZUFTRVFESmNDQ3lBRVFRRnFJUVJCbndFaEVBeVdBZ3NDUUNBRUlBSkhEUUJCdFFFaEVBeXZBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFRmFpRVFBa0FEUUNBRUxRQUFJQUZCNU0rQWdBQnFMUUFBUncyWEFTQUJRUVZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnRRRWhFQXl2QWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVvSVJBTWxBRUxBa0FnQkNBQ1J3MEFRYllCSVJBTXJnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZXJQZ0lBQWFpMEFBRWNObGdFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJZQklSQU1yZ0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJCeUVRREpNQkN3SkFJQVFnQWtjTkFFRzNBU0VRREswQ0N3SkFBa0FnQkMwQUFFRzdmMm9PRGdDV0FaWUJsZ0dXQVpZQmxnR1dBWllCbGdHV0FaWUJsZ0VCbGdFTElBUkJBV29oQkVHaEFTRVFESlFDQ3lBRVFRRnFJUVJCb2dFaEVBeVRBZ3NDUUNBRUlBSkhEUUJCdUFFaEVBeXNBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQ2FpRVFBa0FEUUNBRUxRQUFJQUZCN2MrQWdBQnFMUUFBUncyVUFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnVBRWhFQXlzQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVTSVJBTWtRRUxBa0FnQkNBQ1J3MEFRYmtCSVJBTXF3SUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRZkRQZ0lBQWFpMEFBRWNOa3dFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJrQklSQU1xd0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJJQ0VRREpBQkN3SkFJQVFnQWtjTkFFRzZBU0VRREtvQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBQ1FBTkFJQVF0QUFBZ0FVSHl6NENBQUdvdEFBQkhEWklCSUFGQkFVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUc2QVNFUURLb0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFROGhFQXlQQVFzQ1FDQUVJQUpIRFFCQnV3RWhFQXlwQWdzQ1FBSkFJQVF0QUFCQnQzOXFEZ2NBa2dHU0FaSUJrZ0dTQVFHU0FRc2dCRUVCYWlFRVFhVUJJUkFNa0FJTElBUkJBV29oQkVHbUFTRVFESThDQ3dKQUlBUWdBa2NOQUVHOEFTRVFES2dDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRZHFJUkFDUUFOQUlBUXRBQUFnQVVIMHo0Q0FBR290QUFCSERaQUJJQUZCQjBZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFRzhBU0VRREtnQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJzaEVBeU5BUXNDUUNBRUlBSkhEUUJCdlFFaEVBeW5BZ3NDUUFKQUFrQWdCQzBBQUVHK2Yyb09FZ0NSQVpFQmtRR1JBWkVCa1FHUkFaRUJrUUVCa1FHUkFaRUJrUUdSQVpFQkFwRUJDeUFFUVFGcUlRUkJwQUVoRUF5UEFnc2dCRUVCYWlFRVFhY0JJUkFNamdJTElBUkJBV29oQkVHb0FTRVFESTBDQ3dKQUlBUWdBa2NOQUVHK0FTRVFES1lDQ3lBRUxRQUFRYzRBUncyTkFTQUVRUUZxSVFRTXp3RUxBa0FnQkNBQ1J3MEFRYjhCSVJBTXBRSUxBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0JDMEFBRUcvZjJvT0ZRQUJBZ09jQVFRRkJwd0JuQUdjQVFjSUNRb0xuQUVNRFE0UG5BRUxJQVJCQVdvaEFVSG9BQ0VRREpvQ0N5QUVRUUZxSVFGQjZRQWhFQXlaQWdzZ0JFRUJhaUVCUWU0QUlSQU1tQUlMSUFSQkFXb2hBVUh5QUNFUURKY0NDeUFFUVFGcUlRRkI4d0FoRUF5V0Fnc2dCRUVCYWlFQlFmWUFJUkFNbFFJTElBUkJBV29oQVVIM0FDRVFESlFDQ3lBRVFRRnFJUUZCK2dBaEVBeVRBZ3NnQkVFQmFpRUVRWU1CSVJBTWtnSUxJQVJCQVdvaEJFR0VBU0VRREpFQ0N5QUVRUUZxSVFSQmhRRWhFQXlRQWdzZ0JFRUJhaUVFUVpJQklSQU1qd0lMSUFSQkFXb2hCRUdZQVNFUURJNENDeUFFUVFGcUlRUkJvQUVoRUF5TkFnc2dCRUVCYWlFRVFhTUJJUkFNakFJTElBUkJBV29oQkVHcUFTRVFESXNDQ3dKQUlBUWdBa1lOQUNBQVFaQ0FnSUFBTmdJSUlBQWdCRFlDQkVHckFTRVFESXNDQzBIQUFTRVFES01DQ3lBQUlBVWdBaENxZ0lDQUFDSUJEWXNCSUFVaEFReGNDd0pBSUFZZ0FrWU5BQ0FHUVFGcUlRVU1qUUVMUWNJQklSQU1vUUlMQTBBQ1FDQVFMUUFBUVhacURnU01BUUFBandFQUN5QVFRUUZxSWhBZ0FrY05BQXRCd3dFaEVBeWdBZ3NDUUNBSElBSkdEUUFnQUVHUmdJQ0FBRFlDQ0NBQUlBYzJBZ1FnQnlFQlFRRWhFQXlIQWd0QnhBRWhFQXlmQWdzQ1FDQUhJQUpIRFFCQnhRRWhFQXlmQWdzQ1FBSkFJQWN0QUFCQmRtb09CQUhPQWM0QkFNNEJDeUFIUVFGcUlRWU1qUUVMSUFkQkFXb2hCUXlKQVFzQ1FDQUhJQUpIRFFCQnhnRWhFQXllQWdzQ1FBSkFJQWN0QUFCQmRtb09Gd0dQQVk4QkFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFRQ1BBUXNnQjBFQmFpRUhDMEd3QVNFUURJUUNDd0pBSUFnZ0FrY05BRUhJQVNFUURKMENDeUFJTFFBQVFTQkhEWTBCSUFCQkFEc0JNaUFJUVFGcUlRRkJzd0VoRUF5REFnc2dBU0VYQWtBRFFDQVhJZ2NnQWtZTkFTQUhMUUFBUVZCcVFmOEJjU0lRUVFwUERjd0JBa0FnQUM4Qk1pSVVRWmt6U3cwQUlBQWdGRUVLYkNJVU93RXlJQkJCLy84RGN5QVVRZjcvQTNGSkRRQWdCMEVCYWlFWElBQWdGQ0FRYWlJUU93RXlJQkJCLy84RGNVSG9CMGtOQVFzTFFRQWhFQ0FBUVFBMkFod2dBRUhCaVlDQUFEWUNFQ0FBUVEwMkFnd2dBQ0FIUVFGcU5nSVVESndDQzBISEFTRVFESnNDQ3lBQUlBZ2dBaEN1Z0lDQUFDSVFSUTNLQVNBUVFSVkhEWXdCSUFCQnlBRTJBaHdnQUNBSU5nSVVJQUJCeVplQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF5YUFnc0NRQ0FKSUFKSERRQkJ6QUVoRUF5YUFndEJBQ0VVUVFFaEYwRUJJUlpCQUNFUUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBa3RBQUJCVUdvT0NwWUJsUUVBQVFJREJBVUdDSmNCQzBFQ0lSQU1CZ3RCQXlFUURBVUxRUVFoRUF3RUMwRUZJUkFNQXd0QkJpRVFEQUlMUVFjaEVBd0JDMEVJSVJBTFFRQWhGMEVBSVJaQkFDRVVESTRCQzBFSklSQkJBU0VVUVFBaEYwRUFJUllNalFFTEFrQWdDaUFDUncwQVFjNEJJUkFNbVFJTElBb3RBQUJCTGtjTmpnRWdDa0VCYWlFSkRNb0JDeUFMSUFKSERZNEJRZEFCSVJBTWx3SUxBa0FnQ3lBQ1JnMEFJQUJCam9DQWdBQTJBZ2dnQUNBTE5nSUVRYmNCSVJBTS9nRUxRZEVCSVJBTWxnSUxBa0FnQkNBQ1J3MEFRZElCSVJBTWxnSUxJQUlnQkdzZ0FDZ0NBQ0lRYWlFVUlBUWdFR3RCQkdvaEN3TkFJQVF0QUFBZ0VFSDh6NENBQUdvdEFBQkhEWTRCSUJCQkJFWU42UUVnRUVFQmFpRVFJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCMGdFaEVBeVZBZ3NnQUNBTUlBSVFySUNBZ0FBaUFRMk5BU0FNSVFFTXVBRUxBa0FnQkNBQ1J3MEFRZFFCSVJBTWxBSUxJQUlnQkdzZ0FDZ0NBQ0lRYWlFVUlBUWdFR3RCQVdvaERBTkFJQVF0QUFBZ0VFR0IwSUNBQUdvdEFBQkhEWThCSUJCQkFVWU5qZ0VnRUVFQmFpRVFJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCMUFFaEVBeVRBZ3NDUUNBRUlBSkhEUUJCMWdFaEVBeVRBZ3NnQWlBRWF5QUFLQUlBSWhCcUlSUWdCQ0FRYTBFQ2FpRUxBMEFnQkMwQUFDQVFRWVBRZ0lBQWFpMEFBRWNOamdFZ0VFRUNSZzJRQVNBUVFRRnFJUkFnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVIV0FTRVFESklDQ3dKQUlBUWdBa2NOQUVIWEFTRVFESklDQ3dKQUFrQWdCQzBBQUVHN2Yyb09FQUNQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCQVk4QkN5QUVRUUZxSVFSQnV3RWhFQXo1QVFzZ0JFRUJhaUVFUWJ3QklSQU0rQUVMQWtBZ0JDQUNSdzBBUWRnQklSQU1rUUlMSUFRdEFBQkJ5QUJIRFl3QklBUkJBV29oQkF6RUFRc0NRQ0FFSUFKR0RRQWdBRUdRZ0lDQUFEWUNDQ0FBSUFRMkFnUkJ2Z0VoRUF6M0FRdEIyUUVoRUF5UEFnc0NRQ0FFSUFKSERRQkIyZ0VoRUF5UEFnc2dCQzBBQUVISUFFWU53d0VnQUVFQk9nQW9ETGtCQ3lBQVFRSTZBQzhnQUNBRUlBSVFwb0NBZ0FBaUVBMk5BVUhDQVNFUURQUUJDeUFBTFFBb1FYOXFEZ0szQWJrQnVBRUxBMEFDUUNBRUxRQUFRWFpxRGdRQWpnR09BUUNPQVFzZ0JFRUJhaUlFSUFKSERRQUxRZDBCSVJBTWl3SUxJQUJCQURvQUx5QUFMUUF0UVFSeFJRMkVBZ3NnQUVFQU9nQXZJQUJCQVRvQU5DQUJJUUVNakFFTElCQkJGVVlOMmdFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWFlT2dJQUFOZ0lRSUFCQkVqWUNERUVBSVJBTWlBSUxBa0FnQUNBUUlBSVF0SUNBZ0FBaUJBMEFJQkFoQVF5QkFnc0NRQ0FFUVJWSERRQWdBRUVETmdJY0lBQWdFRFlDRkNBQVFiQ1lnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1pQUlMSUFCQkFEWUNIQ0FBSUJBMkFoUWdBRUduam9DQUFEWUNFQ0FBUVJJMkFneEJBQ0VRREljQ0N5QVFRUlZHRGRZQklBQkJBRFlDSENBQUlBRTJBaFFnQUVIYWpZQ0FBRFlDRUNBQVFSUTJBZ3hCQUNFUURJWUNDeUFBS0FJRUlSY2dBRUVBTmdJRUlCQWdFYWRxSWhZaEFTQUFJQmNnRUNBV0lCUWJJaEFRdFlDQWdBQWlGRVVOalFFZ0FFRUhOZ0ljSUFBZ0VEWUNGQ0FBSUJRMkFneEJBQ0VRRElVQ0N5QUFJQUF2QVRCQmdBRnlPd0V3SUFFaEFRdEJLaUVRRE9vQkN5QVFRUlZHRGRFQklBQkJBRFlDSENBQUlBRTJBaFFnQUVHRGpJQ0FBRFlDRUNBQVFSTTJBZ3hCQUNFUURJSUNDeUFRUVJWR0RjOEJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2FqNENBQURZQ0VDQUFRU0kyQWd4QkFDRVFESUVDQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVF0NENBZ0FBaUVBMEFJQUZCQVdvaEFReU5BUXNnQUVFTU5nSWNJQUFnRURZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRElBQ0N5QVFRUlZHRGN3QklBQkJBRFlDSENBQUlBRTJBaFFnQUVHYWo0Q0FBRFlDRUNBQVFTSTJBZ3hCQUNFUURQOEJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXQ0Q0FnQUFpRUEwQUlBRkJBV29oQVF5TUFRc2dBRUVOTmdJY0lBQWdFRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUDRCQ3lBUVFSVkdEY2tCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhHaklDQUFEWUNFQ0FBUVNNMkFneEJBQ0VRRFAwQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRdVlDQWdBQWlFQTBBSUFGQkFXb2hBUXlMQVFzZ0FFRU9OZ0ljSUFBZ0VEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQd0JDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ3SldBZ0FBMkFoQWdBRUVDTmdJTVFRQWhFQXo3QVFzZ0VFRVZSZzNGQVNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCeG95QWdBQTJBaEFnQUVFak5nSU1RUUFoRUF6NkFRc2dBRUVRTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURQa0JDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXVZQ0FnQUFpQkEwQUlBRkJBV29oQVF6eEFRc2dBRUVSTmdJY0lBQWdCRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUGdCQ3lBUVFSVkdEY0VCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhHaklDQUFEWUNFQ0FBUVNNMkFneEJBQ0VRRFBjQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRdVlDQWdBQWlFQTBBSUFGQkFXb2hBUXlJQVFzZ0FFRVROZ0ljSUFBZ0VEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQWUJDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXVZQ0FnQUFpQkEwQUlBRkJBV29oQVF6dEFRc2dBRUVVTmdJY0lBQWdCRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUFVCQ3lBUVFSVkdEYjBCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdhajRDQUFEWUNFQ0FBUVNJMkFneEJBQ0VRRFBRQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRdDRDQWdBQWlFQTBBSUFGQkFXb2hBUXlHQVFzZ0FFRVdOZ0ljSUFBZ0VEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQTUJDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXQ0Q0FnQUFpQkEwQUlBRkJBV29oQVF6cEFRc2dBRUVYTmdJY0lBQWdCRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUElCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCelpPQWdBQTJBaEFnQUVFTU5nSU1RUUFoRUF6eEFRdENBU0VSQ3lBUVFRRnFJUUVDUUNBQUtRTWdJaEpDLy8vLy8vLy8vLzhQVmcwQUlBQWdFa0lFaGlBUmhEY0RJQ0FCSVFFTWhBRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR3RpWUNBQURZQ0VDQUFRUXcyQWd4QkFDRVFETzhCQ3lBQVFRQTJBaHdnQUNBUU5nSVVJQUJCelpPQWdBQTJBaEFnQUVFTU5nSU1RUUFoRUF6dUFRc2dBQ2dDQkNFWElBQkJBRFlDQkNBUUlCR25haUlXSVFFZ0FDQVhJQkFnRmlBVUd5SVFFTFdBZ0lBQUloUkZEWE1nQUVFRk5nSWNJQUFnRURZQ0ZDQUFJQlEyQWd4QkFDRVFETzBCQ3lBQVFRQTJBaHdnQUNBUU5nSVVJQUJCcXB5QWdBQTJBaEFnQUVFUE5nSU1RUUFoRUF6c0FRc2dBQ0FRSUFJUXRJQ0FnQUFpQVEwQklCQWhBUXRCRGlFUURORUJDd0pBSUFGQkZVY05BQ0FBUVFJMkFod2dBQ0FRTmdJVUlBQkJzSmlBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXpxQVFzZ0FFRUFOZ0ljSUFBZ0VEWUNGQ0FBUWFlT2dJQUFOZ0lRSUFCQkVqWUNERUVBSVJBTTZRRUxJQUZCQVdvaEVBSkFJQUF2QVRBaUFVR0FBWEZGRFFBQ1FDQUFJQkFnQWhDN2dJQ0FBQ0lCRFFBZ0VDRUJESEFMSUFGQkZVY051Z0VnQUVFRk5nSWNJQUFnRURZQ0ZDQUFRZm1YZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNNlFFTEFrQWdBVUdnQkhGQm9BUkhEUUFnQUMwQUxVRUNjUTBBSUFCQkFEWUNIQ0FBSUJBMkFoUWdBRUdXazRDQUFEWUNFQ0FBUVFRMkFneEJBQ0VRRE9rQkN5QUFJQkFnQWhDOWdJQ0FBQm9nRUNFQkFrQUNRQUpBQWtBQ1FDQUFJQkFnQWhDemdJQ0FBQTRXQWdFQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUF3UUxJQUJCQVRvQUxnc2dBQ0FBTHdFd1FjQUFjanNCTUNBUUlRRUxRU1loRUF6UkFRc2dBRUVqTmdJY0lBQWdFRFlDRkNBQVFhV1dnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU02UUVMSUFCQkFEWUNIQ0FBSUJBMkFoUWdBRUhWaTRDQUFEWUNFQ0FBUVJFMkFneEJBQ0VRRE9nQkN5QUFMUUF0UVFGeFJRMEJRY01CSVJBTXpnRUxBa0FnRFNBQ1JnMEFBMEFDUUNBTkxRQUFRU0JHRFFBZ0RTRUJETVFCQ3lBTlFRRnFJZzBnQWtjTkFBdEJKU0VRRE9jQkMwRWxJUkFNNWdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FnQUNBRUlBMFFyNENBZ0FBaUJFVU5yUUVnQUVFbU5nSWNJQUFnQkRZQ0RDQUFJQTFCQVdvMkFoUkJBQ0VRRE9VQkN5QVFRUlZHRGFzQklBQkJBRFlDSENBQUlBRTJBaFFnQUVIOWpZQ0FBRFlDRUNBQVFSMDJBZ3hCQUNFUURPUUJDeUFBUVNjMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU00d0VMSUJBaEFVRUJJUlFDUUFKQUFrQUNRQUpBQWtBQ1FDQUFMUUFzUVg1cURnY0dCUVVEQVFJQUJRc2dBQ0FBTHdFd1FRaHlPd0V3REFNTFFRSWhGQXdCQzBFRUlSUUxJQUJCQVRvQUxDQUFJQUF2QVRBZ0ZISTdBVEFMSUJBaEFRdEJLeUVRRE1vQkN5QUFRUUEyQWh3Z0FDQVFOZ0lVSUFCQnE1S0FnQUEyQWhBZ0FFRUxOZ0lNUVFBaEVBemlBUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZUdQZ0lBQU5nSVFJQUJCQ2pZQ0RFRUFJUkFNNFFFTElBQkJBRG9BTENBUUlRRU12UUVMSUJBaEFVRUJJUlFDUUFKQUFrQUNRQUpBSUFBdEFDeEJlMm9PQkFNQkFnQUZDeUFBSUFBdkFUQkJDSEk3QVRBTUF3dEJBaUVVREFFTFFRUWhGQXNnQUVFQk9nQXNJQUFnQUM4Qk1DQVVjanNCTUFzZ0VDRUJDMEVwSVJBTXhRRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSHdsSUNBQURZQ0VDQUFRUU0yQWd4QkFDRVFETjBCQ3dKQUlBNHRBQUJCRFVjTkFDQUFLQUlFSVFFZ0FFRUFOZ0lFQWtBZ0FDQUJJQTRRc1lDQWdBQWlBUTBBSUE1QkFXb2hBUXgxQ3lBQVFTdzJBaHdnQUNBQk5nSU1JQUFnRGtFQmFqWUNGRUVBSVJBTTNRRUxJQUF0QUMxQkFYRkZEUUZCeEFFaEVBekRBUXNDUUNBT0lBSkhEUUJCTFNFUUROd0JDd0pBQWtBRFFBSkFJQTR0QUFCQmRtb09CQUlBQUFNQUN5QU9RUUZxSWc0Z0FrY05BQXRCTFNFUUROMEJDeUFBS0FJRUlRRWdBRUVBTmdJRUFrQWdBQ0FCSUE0UXNZQ0FnQUFpQVEwQUlBNGhBUXgwQ3lBQVFTdzJBaHdnQUNBT05nSVVJQUFnQVRZQ0RFRUFJUkFNM0FFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdEaEN4Z0lDQUFDSUJEUUFnRGtFQmFpRUJESE1MSUFCQkxEWUNIQ0FBSUFFMkFnd2dBQ0FPUVFGcU5nSVVRUUFoRUF6YkFRc2dBQ2dDQkNFRUlBQkJBRFlDQkNBQUlBUWdEaEN4Z0lDQUFDSUVEYUFCSUE0aEFRek9BUXNnRUVFc1J3MEJJQUZCQVdvaEVFRUJJUUVDUUFKQUFrQUNRQUpBSUFBdEFDeEJlMm9PQkFNQkFnUUFDeUFRSVFFTUJBdEJBaUVCREFFTFFRUWhBUXNnQUVFQk9nQXNJQUFnQUM4Qk1DQUJjanNCTUNBUUlRRU1BUXNnQUNBQUx3RXdRUWh5T3dFd0lCQWhBUXRCT1NFUURMOEJDeUFBUVFBNkFDd2dBU0VCQzBFMElSQU12UUVMSUFBZ0FDOEJNRUVnY2pzQk1DQUJJUUVNQWdzZ0FDZ0NCQ0VFSUFCQkFEWUNCQUpBSUFBZ0JDQUJFTEdBZ0lBQUlnUU5BQ0FCSVFFTXh3RUxJQUJCTnpZQ0hDQUFJQUUyQWhRZ0FDQUVOZ0lNUVFBaEVBelVBUXNnQUVFSU9nQXNJQUVoQVF0Qk1DRVFETGtCQ3dKQUlBQXRBQ2hCQVVZTkFDQUJJUUVNQkFzZ0FDMEFMVUVJY1VVTmt3RWdBU0VCREFNTElBQXRBREJCSUhFTmxBRkJ4UUVoRUF5M0FRc0NRQ0FQSUFKR0RRQUNRQU5BQWtBZ0R5MEFBRUZRYWlJQlFmOEJjVUVLU1EwQUlBOGhBVUUxSVJBTXVnRUxJQUFwQXlBaUVVS1pzK2JNbWJQbXpCbFdEUUVnQUNBUlFncCtJaEUzQXlBZ0VTQUJyVUwvQVlNaUVrSi9oVllOQVNBQUlCRWdFbnczQXlBZ0QwRUJhaUlQSUFKSERRQUxRVGtoRUF6UkFRc2dBQ2dDQkNFQ0lBQkJBRFlDQkNBQUlBSWdEMEVCYWlJRUVMR0FnSUFBSWdJTmxRRWdCQ0VCRE1NQkMwRTVJUkFNendFTEFrQWdBQzhCTUNJQlFRaHhSUTBBSUFBdEFDaEJBVWNOQUNBQUxRQXRRUWh4UlEyUUFRc2dBQ0FCUWZmN0EzRkJnQVJ5T3dFd0lBOGhBUXRCTnlFUURMUUJDeUFBSUFBdkFUQkJFSEk3QVRBTXF3RUxJQkJCRlVZTml3RWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFmQ09nSUFBTmdJUUlBQkJIRFlDREVFQUlSQU15d0VMSUFCQnd3QTJBaHdnQUNBQk5nSU1JQUFnRFVFQmFqWUNGRUVBSVJBTXlnRUxBa0FnQVMwQUFFRTZSdzBBSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ3ZnSUNBQUNJUURRQWdBVUVCYWlFQkRHTUxJQUJCd3dBMkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNeWdFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHeGtZQ0FBRFlDRUNBQVFRbzJBZ3hCQUNFUURNa0JDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJvSm1BZ0FBMkFoQWdBRUVlTmdJTVFRQWhFQXpJQVFzZ0FFRUFOZ0lBQ3lBQVFZQVNPd0VxSUFBZ0YwRUJhaUlCSUFJUXFJQ0FnQUFpRUEwQklBRWhBUXRCeHdBaEVBeXNBUXNnRUVFVlJ3MkRBU0FBUWRFQU5nSWNJQUFnQVRZQ0ZDQUFRZU9YZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNeEFFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRGNExJQUJCMGdBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU13d0VMSUFCQkFEWUNIQ0FBSUJRMkFoUWdBRUhCcUlDQUFEWUNFQ0FBUVFjMkFnd2dBRUVBTmdJQVFRQWhFQXpDQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVhRc2dBRUhUQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBekJBUXRCQUNFUUlBQkJBRFlDSENBQUlBRTJBaFFnQUVHQWtZQ0FBRFlDRUNBQVFRazJBZ3dNd0FFTElCQkJGVVlOZlNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCbEkyQWdBQTJBaEFnQUVFaE5nSU1RUUFoRUF5L0FRdEJBU0VXUVFBaEYwRUFJUlJCQVNFUUN5QUFJQkE2QUNzZ0FVRUJhaUVCQWtBQ1FDQUFMUUF0UVJCeERRQUNRQUpBQWtBZ0FDMEFLZzREQVFBQ0JBc2dGa1VOQXd3Q0N5QVVEUUVNQWdzZ0YwVU5BUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLMkFnSUFBSWhBTkFDQUJJUUVNWEFzZ0FFSFlBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5K0FRc2dBQ2dDQkNFRUlBQkJBRFlDQkFKQUlBQWdCQ0FCRUsyQWdJQUFJZ1FOQUNBQklRRU1yUUVMSUFCQjJRQTJBaHdnQUNBQk5nSVVJQUFnQkRZQ0RFRUFJUkFNdlFFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkN0Z0lDQUFDSUVEUUFnQVNFQkRLc0JDeUFBUWRvQU5nSWNJQUFnQVRZQ0ZDQUFJQVEyQWd4QkFDRVFETHdCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVFyWUNBZ0FBaUJBMEFJQUVoQVF5cEFRc2dBRUhjQURZQ0hDQUFJQUUyQWhRZ0FDQUVOZ0lNUVFBaEVBeTdBUXNDUUNBQkxRQUFRVkJxSWhCQi93RnhRUXBQRFFBZ0FDQVFPZ0FxSUFGQkFXb2hBVUhQQUNFUURLSUJDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXJZQ0FnQUFpQkEwQUlBRWhBUXluQVFzZ0FFSGVBRFlDSENBQUlBRTJBaFFnQUNBRU5nSU1RUUFoRUF5NkFRc2dBRUVBTmdJQUlCZEJBV29oQVFKQUlBQXRBQ2xCSTA4TkFDQUJJUUVNV1FzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWRPSmdJQUFOZ0lRSUFCQkNEWUNERUVBSVJBTXVRRUxJQUJCQURZQ0FBdEJBQ0VRSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdRczRDQUFEWUNFQ0FBUVFnMkFnd010d0VMSUFCQkFEWUNBQ0FYUVFGcUlRRUNRQ0FBTFFBcFFTRkhEUUFnQVNFQkRGWUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2Jpb0NBQURZQ0VDQUFRUWcyQWd4QkFDRVFETFlCQ3lBQVFRQTJBZ0FnRjBFQmFpRUJBa0FnQUMwQUtTSVFRVjFxUVF0UERRQWdBU0VCREZVTEFrQWdFRUVHU3cwQVFRRWdFSFJCeWdCeFJRMEFJQUVoQVF4VkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZmVKZ0lBQU5nSVFJQUJCQ0RZQ0RBeTFBUXNnRUVFVlJnMXhJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFRzVqWUNBQURZQ0VDQUFRUm8yQWd4QkFDRVFETFFCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4VUN5QUFRZVVBTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURMTUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhOQ3lBQVFkSUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRExJQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReE5DeUFBUWRNQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETEVCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4UkN5QUFRZVVBTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURMQUJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ4b3FBZ0FBMkFoQWdBRUVITmdJTVFRQWhFQXl2QVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVNRc2dBRUhTQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeXVBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNU1FzZ0FFSFRBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5dEFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1UUXNnQUVIbEFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXlzQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWR5SWdJQUFOZ0lRSUFCQkJ6WUNERUVBSVJBTXF3RUxJQkJCUDBjTkFTQUJRUUZxSVFFTFFRVWhFQXlRQVF0QkFDRVFJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSDlrb0NBQURZQ0VDQUFRUWMyQWd3TXFBRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERUlMSUFCQjBnQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNcHdFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFSUxJQUJCMHdBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1wZ0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREVZTElBQkI1UUEyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXBRRUxJQUFvQWdRaEFTQUFRUUEyQWdRQ1FDQUFJQUVnRkJDbmdJQ0FBQ0lCRFFBZ0ZDRUJERDhMSUFCQjBnQTJBaHdnQUNBVU5nSVVJQUFnQVRZQ0RFRUFJUkFNcEFFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdGQkNuZ0lDQUFDSUJEUUFnRkNFQkREOExJQUJCMHdBMkFod2dBQ0FVTmdJVUlBQWdBVFlDREVFQUlSQU1vd0VMSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0ZCQ25nSUNBQUNJQkRRQWdGQ0VCREVNTElBQkI1UUEyQWh3Z0FDQVVOZ0lVSUFBZ0FUWUNERUVBSVJBTW9nRUxJQUJCQURZQ0hDQUFJQlEyQWhRZ0FFSERqNENBQURZQ0VDQUFRUWMyQWd4QkFDRVFES0VCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCdzQrQWdBQTJBaEFnQUVFSE5nSU1RUUFoRUF5Z0FRdEJBQ0VRSUFCQkFEWUNIQ0FBSUJRMkFoUWdBRUdNbklDQUFEWUNFQ0FBUVFjMkFnd01ud0VMSUFCQkFEWUNIQ0FBSUJRMkFoUWdBRUdNbklDQUFEWUNFQ0FBUVFjMkFneEJBQ0VRREo0QkN5QUFRUUEyQWh3Z0FDQVVOZ0lVSUFCQi9wR0FnQUEyQWhBZ0FFRUhOZ0lNUVFBaEVBeWRBUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWTZiZ0lBQU5nSVFJQUJCQmpZQ0RFRUFJUkFNbkFFTElCQkJGVVlOVnlBQVFRQTJBaHdnQUNBQk5nSVVJQUJCekk2QWdBQTJBaEFnQUVFZ05nSU1RUUFoRUF5YkFRc2dBRUVBTmdJQUlCQkJBV29oQVVFa0lSQUxJQUFnRURvQUtTQUFLQUlFSVJBZ0FFRUFOZ0lFSUFBZ0VDQUJFS3VBZ0lBQUloQU5WQ0FCSVFFTVBnc2dBRUVBTmdJQUMwRUFJUkFnQUVFQU5nSWNJQUFnQkRZQ0ZDQUFRZkdiZ0lBQU5nSVFJQUJCQmpZQ0RBeVhBUXNnQVVFVlJnMVFJQUJCQURZQ0hDQUFJQVUyQWhRZ0FFSHdqSUNBQURZQ0VDQUFRUnMyQWd4QkFDRVFESllCQ3lBQUtBSUVJUVVnQUVFQU5nSUVJQUFnQlNBUUVLbUFnSUFBSWdVTkFTQVFRUUZxSVFVTFFhMEJJUkFNZXdzZ0FFSEJBVFlDSENBQUlBVTJBZ3dnQUNBUVFRRnFOZ0lVUVFBaEVBeVRBUXNnQUNnQ0JDRUdJQUJCQURZQ0JDQUFJQVlnRUJDcGdJQ0FBQ0lHRFFFZ0VFRUJhaUVHQzBHdUFTRVFESGdMSUFCQndnRTJBaHdnQUNBR05nSU1JQUFnRUVFQmFqWUNGRUVBSVJBTWtBRUxJQUJCQURZQ0hDQUFJQWMyQWhRZ0FFR1hpNENBQURZQ0VDQUFRUTAyQWd4QkFDRVFESThCQ3lBQVFRQTJBaHdnQUNBSU5nSVVJQUJCNDVDQWdBQTJBaEFnQUVFSk5nSU1RUUFoRUF5T0FRc2dBRUVBTmdJY0lBQWdDRFlDRkNBQVFaU05nSUFBTmdJUUlBQkJJVFlDREVFQUlSQU1qUUVMUVFFaEZrRUFJUmRCQUNFVVFRRWhFQXNnQUNBUU9nQXJJQWxCQVdvaENBSkFBa0FnQUMwQUxVRVFjUTBBQWtBQ1FBSkFJQUF0QUNvT0F3RUFBZ1FMSUJaRkRRTU1BZ3NnRkEwQkRBSUxJQmRGRFFFTElBQW9BZ1FoRUNBQVFRQTJBZ1FnQUNBUUlBZ1FyWUNBZ0FBaUVFVU5QU0FBUWNrQk5nSWNJQUFnQ0RZQ0ZDQUFJQkEyQWd4QkFDRVFESXdCQ3lBQUtBSUVJUVFnQUVFQU5nSUVJQUFnQkNBSUVLMkFnSUFBSWdSRkRYWWdBRUhLQVRZQ0hDQUFJQWcyQWhRZ0FDQUVOZ0lNUVFBaEVBeUxBUXNnQUNnQ0JDRUVJQUJCQURZQ0JDQUFJQVFnQ1JDdGdJQ0FBQ0lFUlExMElBQkJ5d0UyQWh3Z0FDQUpOZ0lVSUFBZ0JEWUNERUVBSVJBTWlnRUxJQUFvQWdRaEJDQUFRUUEyQWdRZ0FDQUVJQW9RcllDQWdBQWlCRVVOY2lBQVFjMEJOZ0ljSUFBZ0NqWUNGQ0FBSUFRMkFneEJBQ0VRRElrQkN3SkFJQXN0QUFCQlVHb2lFRUgvQVhGQkNrOE5BQ0FBSUJBNkFDb2dDMEVCYWlFS1FiWUJJUkFNY0FzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0N4Q3RnSUNBQUNJRVJRMXdJQUJCendFMkFod2dBQ0FMTmdJVUlBQWdCRFlDREVFQUlSQU1pQUVMSUFCQkFEWUNIQ0FBSUFRMkFoUWdBRUdRczRDQUFEWUNFQ0FBUVFnMkFnd2dBRUVBTmdJQVFRQWhFQXlIQVFzZ0FVRVZSZzAvSUFCQkFEWUNIQ0FBSUF3MkFoUWdBRUhNam9DQUFEWUNFQ0FBUVNBMkFneEJBQ0VRRElZQkN5QUFRWUVFT3dFb0lBQW9BZ1FoRUNBQVFnQTNBd0FnQUNBUUlBeEJBV29pREJDcmdJQ0FBQ0lRUlEwNElBQkIwd0UyQWh3Z0FDQU1OZ0lVSUFBZ0VEWUNERUVBSVJBTWhRRUxJQUJCQURZQ0FBdEJBQ0VRSUFCQkFEWUNIQ0FBSUFRMkFoUWdBRUhZbTRDQUFEWUNFQ0FBUVFnMkFnd01nd0VMSUFBb0FnUWhFQ0FBUWdBM0F3QWdBQ0FRSUF0QkFXb2lDeENyZ0lDQUFDSVFEUUZCeGdFaEVBeHBDeUFBUVFJNkFDZ01WUXNnQUVIVkFUWUNIQ0FBSUFzMkFoUWdBQ0FRTmdJTVFRQWhFQXlBQVFzZ0VFRVZSZzAzSUFCQkFEWUNIQ0FBSUFRMkFoUWdBRUdraklDQUFEWUNFQ0FBUVJBMkFneEJBQ0VRREg4TElBQXRBRFJCQVVjTk5DQUFJQVFnQWhDOGdJQ0FBQ0lRUlEwMElCQkJGVWNOTlNBQVFkd0JOZ0ljSUFBZ0JEWUNGQ0FBUWRXV2dJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTWZndEJBQ0VRSUFCQkFEWUNIQ0FBUWErTGdJQUFOZ0lRSUFCQkFqWUNEQ0FBSUJSQkFXbzJBaFFNZlF0QkFDRVFER01MUVFJaEVBeGlDMEVOSVJBTVlRdEJEeUVRREdBTFFTVWhFQXhmQzBFVElSQU1YZ3RCRlNFUURGMExRUlloRUF4Y0MwRVhJUkFNV3d0QkdDRVFERm9MUVJraEVBeFpDMEVhSVJBTVdBdEJHeUVRREZjTFFSd2hFQXhXQzBFZElSQU1WUXRCSHlFUURGUUxRU0VoRUF4VEMwRWpJUkFNVWd0QnhnQWhFQXhSQzBFdUlSQU1VQXRCTHlFUURFOExRVHNoRUF4T0MwRTlJUkFNVFF0QnlBQWhFQXhNQzBISkFDRVFERXNMUWNzQUlSQU1TZ3RCekFBaEVBeEpDMEhPQUNFUURFZ0xRZEVBSVJBTVJ3dEIxUUFoRUF4R0MwSFlBQ0VRREVVTFFka0FJUkFNUkF0QjJ3QWhFQXhEQzBIa0FDRVFERUlMUWVVQUlSQU1RUXRCOFFBaEVBeEFDMEgwQUNFUUREOExRWTBCSVJBTVBndEJsd0VoRUF3OUMwR3BBU0VRRER3TFFhd0JJUkFNT3d0QndBRWhFQXc2QzBHNUFTRVFERGtMUWE4QklSQU1PQXRCc1FFaEVBdzNDMEd5QVNFUUREWUxRYlFCSVJBTU5RdEJ0UUVoRUF3MEMwRzZBU0VRRERNTFFiMEJJUkFNTWd0QnZ3RWhFQXd4QzBIQkFTRVFEREFMSUFCQkFEWUNIQ0FBSUFRMkFoUWdBRUhwaTRDQUFEWUNFQ0FBUVI4MkFneEJBQ0VRREVnTElBQkIyd0UyQWh3Z0FDQUVOZ0lVSUFCQitwYUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeEhDeUFBUWZnQU5nSWNJQUFnRERZQ0ZDQUFRY3FZZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNUmdzZ0FFSFJBRFlDSENBQUlBVTJBaFFnQUVHd2w0Q0FBRFlDRUNBQVFSVTJBZ3hCQUNFUURFVUxJQUJCK1FBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1SQXNnQUVINEFEWUNIQ0FBSUFFMkFoUWdBRUhLbUlDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVNTElBQkI1QUEyQWh3Z0FDQUJOZ0lVSUFCQjQ1ZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeENDeUFBUWRjQU5nSWNJQUFnQVRZQ0ZDQUFRY21YZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNUVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWJtTmdJQUFOZ0lRSUFCQkdqWUNERUVBSVJBTVFBc2dBRUhDQURZQ0hDQUFJQUUyQWhRZ0FFSGptSUNBQURZQ0VDQUFRUlUyQWd4QkFDRVFERDhMSUFCQkFEWUNCQ0FBSUE4Z0R4Q3hnSUNBQUNJRVJRMEJJQUJCT2pZQ0hDQUFJQVEyQWd3Z0FDQVBRUUZxTmdJVVFRQWhFQXcrQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVFzWUNBZ0FBaUJFVU5BQ0FBUVRzMkFod2dBQ0FFTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNUGdzZ0FVRUJhaUVCREMwTElBOUJBV29oQVF3dEN5QUFRUUEyQWh3Z0FDQVBOZ0lVSUFCQjVKS0FnQUEyQWhBZ0FFRUVOZ0lNUVFBaEVBdzdDeUFBUVRZMkFod2dBQ0FFTmdJVUlBQWdBallDREVFQUlSQU1PZ3NnQUVFdU5nSWNJQUFnRGpZQ0ZDQUFJQVEyQWd4QkFDRVFERGtMSUFCQjBBQTJBaHdnQUNBQk5nSVVJQUJCa1ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3NEN5QU5RUUZxSVFFTUxBc2dBRUVWTmdJY0lBQWdBVFlDRkNBQVFZS1pnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1OZ3NnQUVFYk5nSWNJQUFnQVRZQ0ZDQUFRWkdYZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTlFzZ0FFRVBOZ0ljSUFBZ0FUWUNGQ0FBUVpHWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU5Bc2dBRUVMTmdJY0lBQWdBVFlDRkNBQVFaR1hnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1Nd3NnQUVFYU5nSWNJQUFnQVRZQ0ZDQUFRWUtaZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTWdzZ0FFRUxOZ0ljSUFBZ0FUWUNGQ0FBUVlLWmdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU1Rc2dBRUVLTmdJY0lBQWdBVFlDRkNBQVFlU1dnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1NQXNnQUVFZU5nSWNJQUFnQVRZQ0ZDQUFRZm1YZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTHdzZ0FFRUFOZ0ljSUFBZ0VEWUNGQ0FBUWRxTmdJQUFOZ0lRSUFCQkZEWUNERUVBSVJBTUxnc2dBRUVFTmdJY0lBQWdBVFlDRkNBQVFiQ1lnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1MUXNnQUVFQU5nSUFJQXRCQVdvaEN3dEJ1QUVoRUF3U0N5QUFRUUEyQWdBZ0VFRUJhaUVCUWZVQUlSQU1FUXNnQVNFQkFrQWdBQzBBS1VFRlJ3MEFRZU1BSVJBTUVRdEI0Z0FoRUF3UUMwRUFJUkFnQUVFQU5nSWNJQUJCNUpHQWdBQTJBaEFnQUVFSE5nSU1JQUFnRkVFQmFqWUNGQXdvQ3lBQVFRQTJBZ0FnRjBFQmFpRUJRY0FBSVJBTURndEJBU0VCQ3lBQUlBRTZBQ3dnQUVFQU5nSUFJQmRCQVdvaEFRdEJLQ0VRREFzTElBRWhBUXRCT0NFUURBa0xBa0FnQVNJUElBSkdEUUFEUUFKQUlBOHRBQUJCZ0w2QWdBQnFMUUFBSWdGQkFVWU5BQ0FCUVFKSERRTWdEMEVCYWlFQkRBUUxJQTlCQVdvaUR5QUNSdzBBQzBFK0lSQU1JZ3RCUGlFUURDRUxJQUJCQURvQUxDQVBJUUVNQVF0QkN5RVFEQVlMUVRvaEVBd0ZDeUFCUVFGcUlRRkJMU0VRREFRTElBQWdBVG9BTENBQVFRQTJBZ0FnRmtFQmFpRUJRUXdoRUF3REN5QUFRUUEyQWdBZ0YwRUJhaUVCUVFvaEVBd0NDeUFBUVFBMkFnQUxJQUJCQURvQUxDQU5JUUZCQ1NFUURBQUxDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0N6WUNGQ0FBUWMyUWdJQUFOZ0lRSUFCQkNUWUNEQXdYQzBFQUlSQWdBRUVBTmdJY0lBQWdDallDRkNBQVFlbUtnSUFBTmdJUUlBQkJDVFlDREF3V0MwRUFJUkFnQUVFQU5nSWNJQUFnQ1RZQ0ZDQUFRYmVRZ0lBQU5nSVFJQUJCQ1RZQ0RBd1ZDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0NEWUNGQ0FBUVp5UmdJQUFOZ0lRSUFCQkNUWUNEQXdVQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjMlFnSUFBTmdJUUlBQkJDVFlDREF3VEMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZW1LZ0lBQU5nSVFJQUJCQ1RZQ0RBd1NDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWJlUWdJQUFOZ0lRSUFCQkNUWUNEQXdSQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaeVJnSUFBTmdJUUlBQkJDVFlDREF3UUMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWmVWZ0lBQU5nSVFJQUJCRHpZQ0RBd1BDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVplVmdJQUFOZ0lRSUFCQkR6WUNEQXdPQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjQ1NnSUFBTmdJUUlBQkJDellDREF3TkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWldKZ0lBQU5nSVFJQUJCQ3pZQ0RBd01DMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWVHUGdJQUFOZ0lRSUFCQkNqWUNEQXdMQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFmdVBnSUFBTmdJUUlBQkJDallDREF3S0MwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZkdaZ0lBQU5nSVFJQUJCQWpZQ0RBd0pDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWNTVWdJQUFOZ0lRSUFCQkFqWUNEQXdJQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFmS1ZnSUFBTmdJUUlBQkJBallDREF3SEN5QUFRUUkyQWh3Z0FDQUJOZ0lVSUFCQm5KcUFnQUEyQWhBZ0FFRVdOZ0lNUVFBaEVBd0dDMEVCSVJBTUJRdEIxQUFoRUNBQklnUWdBa1lOQkNBRFFRaHFJQUFnQkNBQ1FkakNnSUFBUVFvUXhZQ0FnQUFnQXlnQ0RDRUVJQU1vQWdnT0F3RUVBZ0FMRU1xQWdJQUFBQXNnQUVFQU5nSWNJQUJCdFpxQWdBQTJBaEFnQUVFWE5nSU1JQUFnQkVFQmFqWUNGRUVBSVJBTUFnc2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFjcWFnSUFBTmdJUUlBQkJDVFlDREVFQUlSQU1BUXNDUUNBQklnUWdBa2NOQUVFaUlSQU1BUXNnQUVHSmdJQ0FBRFlDQ0NBQUlBUTJBZ1JCSVNFUUN5QURRUkJxSklDQWdJQUFJQkFMcndFQkFuOGdBU2dDQUNFR0FrQUNRQ0FDSUFOR0RRQWdCQ0FHYWlFRUlBWWdBMm9nQW1zaEJ5QUNJQVpCZjNNZ0JXb2lCbW9oQlFOQUFrQWdBaTBBQUNBRUxRQUFSZzBBUVFJaEJBd0RDd0pBSUFZTkFFRUFJUVFnQlNFQ0RBTUxJQVpCZjJvaEJpQUVRUUZxSVFRZ0FrRUJhaUlDSUFOSERRQUxJQWNoQmlBRElRSUxJQUJCQVRZQ0FDQUJJQVkyQWdBZ0FDQUNOZ0lFRHdzZ0FVRUFOZ0lBSUFBZ0JEWUNBQ0FBSUFJMkFnUUxDZ0FnQUJESGdJQ0FBQXZ5TmdFTGZ5T0FnSUNBQUVFUWF5SUJKSUNBZ0lBQUFrQkJBQ2dDb05DQWdBQU5BRUVBRU11QWdJQUFRWURVaElBQWF5SUNRZGtBU1EwQVFRQWhBd0pBUVFBb0F1RFRnSUFBSWdRTkFFRUFRbjgzQXV6VGdJQUFRUUJDZ0lDRWdJQ0F3QUEzQXVUVGdJQUFRUUFnQVVFSWFrRndjVUhZcXRXcUJYTWlCRFlDNE5PQWdBQkJBRUVBTmdMMDA0Q0FBRUVBUVFBMkFzVFRnSUFBQzBFQUlBSTJBc3pUZ0lBQVFRQkJnTlNFZ0FBMkFzalRnSUFBUVFCQmdOU0VnQUEyQXBqUWdJQUFRUUFnQkRZQ3JOQ0FnQUJCQUVGL05nS28wSUNBQUFOQUlBTkJ4TkNBZ0FCcUlBTkJ1TkNBZ0FCcUlnUTJBZ0FnQkNBRFFiRFFnSUFBYWlJRk5nSUFJQU5Cdk5DQWdBQnFJQVUyQWdBZ0EwSE0wSUNBQUdvZ0EwSEEwSUNBQUdvaUJUWUNBQ0FGSUFRMkFnQWdBMEhVMElDQUFHb2dBMEhJMElDQUFHb2lCRFlDQUNBRUlBVTJBZ0FnQTBIUTBJQ0FBR29nQkRZQ0FDQURRU0JxSWdOQmdBSkhEUUFMUVlEVWhJQUFRWGhCZ05TRWdBQnJRUTl4UVFCQmdOU0VnQUJCQ0dwQkQzRWJJZ05xSWdSQkJHb2dBa0ZJYWlJRklBTnJJZ05CQVhJMkFnQkJBRUVBS0FMdzA0Q0FBRFlDcE5DQWdBQkJBQ0FETmdLVTBJQ0FBRUVBSUFRMkFxRFFnSUFBUVlEVWhJQUFJQVZxUVRnMkFnUUxBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkI3QUZMRFFBQ1FFRUFLQUtJMElDQUFDSUdRUkFnQUVFVGFrRndjU0FBUVF0Skd5SUNRUU4ySWdSMklnTkJBM0ZGRFFBQ1FBSkFJQU5CQVhFZ0JISkJBWE1pQlVFRGRDSUVRYkRRZ0lBQWFpSURJQVJCdU5DQWdBQnFLQUlBSWdRb0FnZ2lBa2NOQUVFQUlBWkJmaUFGZDNFMkFvalFnSUFBREFFTElBTWdBallDQ0NBQ0lBTTJBZ3dMSUFSQkNHb2hBeUFFSUFWQkEzUWlCVUVEY2pZQ0JDQUVJQVZxSWdRZ0JDZ0NCRUVCY2pZQ0JBd01DeUFDUVFBb0FwRFFnSUFBSWdkTkRRRUNRQ0FEUlEwQUFrQUNRQ0FESUFSMFFRSWdCSFFpQTBFQUlBTnJjbkVpQTBFQUlBTnJjVUYvYWlJRElBTkJESFpCRUhFaUEzWWlCRUVGZGtFSWNTSUZJQU55SUFRZ0JYWWlBMEVDZGtFRWNTSUVjaUFESUFSMklnTkJBWFpCQW5FaUJISWdBeUFFZGlJRFFRRjJRUUZ4SWdSeUlBTWdCSFpxSWdSQkEzUWlBMEd3MElDQUFHb2lCU0FEUWJqUWdJQUFhaWdDQUNJREtBSUlJZ0JIRFFCQkFDQUdRWDRnQkhkeElnWTJBb2pRZ0lBQURBRUxJQVVnQURZQ0NDQUFJQVUyQWd3TElBTWdBa0VEY2pZQ0JDQURJQVJCQTNRaUJHb2dCQ0FDYXlJRk5nSUFJQU1nQW1vaUFDQUZRUUZ5TmdJRUFrQWdCMFVOQUNBSFFYaHhRYkRRZ0lBQWFpRUNRUUFvQXB6UWdJQUFJUVFDUUFKQUlBWkJBU0FIUVFOMmRDSUljUTBBUVFBZ0JpQUljallDaU5DQWdBQWdBaUVJREFFTElBSW9BZ2doQ0FzZ0NDQUVOZ0lNSUFJZ0JEWUNDQ0FFSUFJMkFnd2dCQ0FJTmdJSUN5QURRUWhxSVFOQkFDQUFOZ0tjMElDQUFFRUFJQVUyQXBEUWdJQUFEQXdMUVFBb0FvelFnSUFBSWdsRkRRRWdDVUVBSUFscmNVRi9haUlESUFOQkRIWkJFSEVpQTNZaUJFRUZka0VJY1NJRklBTnlJQVFnQlhZaUEwRUNka0VFY1NJRWNpQURJQVIySWdOQkFYWkJBbkVpQkhJZ0F5QUVkaUlEUVFGMlFRRnhJZ1J5SUFNZ0JIWnFRUUowUWJqU2dJQUFhaWdDQUNJQUtBSUVRWGh4SUFKcklRUWdBQ0VGQWtBRFFBSkFJQVVvQWhBaUF3MEFJQVZCRkdvb0FnQWlBMFVOQWdzZ0F5Z0NCRUY0Y1NBQ2F5SUZJQVFnQlNBRVNTSUZHeUVFSUFNZ0FDQUZHeUVBSUFNaEJRd0FDd3NnQUNnQ0dDRUtBa0FnQUNnQ0RDSUlJQUJHRFFBZ0FDZ0NDQ0lEUVFBb0FwalFnSUFBU1JvZ0NDQUROZ0lJSUFNZ0NEWUNEQXdMQ3dKQUlBQkJGR29pQlNnQ0FDSUREUUFnQUNnQ0VDSURSUTBESUFCQkVHb2hCUXNEUUNBRklRc2dBeUlJUVJScUlnVW9BZ0FpQXcwQUlBaEJFR29oQlNBSUtBSVFJZ01OQUFzZ0MwRUFOZ0lBREFvTFFYOGhBaUFBUWI5L1N3MEFJQUJCRTJvaUEwRndjU0VDUVFBb0FvelFnSUFBSWdkRkRRQkJBQ0VMQWtBZ0FrR0FBa2tOQUVFZklRc2dBa0gvLy84SFN3MEFJQU5CQ0hZaUF5QURRWUQrUDJwQkVIWkJDSEVpQTNRaUJDQUVRWURnSDJwQkVIWkJCSEVpQkhRaUJTQUZRWUNBRDJwQkVIWkJBbkVpQlhSQkQzWWdBeUFFY2lBRmNtc2lBMEVCZENBQ0lBTkJGV3AyUVFGeGNrRWNhaUVMQzBFQUlBSnJJUVFDUUFKQUFrQUNRQ0FMUVFKMFFialNnSUFBYWlnQ0FDSUZEUUJCQUNFRFFRQWhDQXdCQzBFQUlRTWdBa0VBUVJrZ0MwRUJkbXNnQzBFZlJodDBJUUJCQUNFSUEwQUNRQ0FGS0FJRVFYaHhJQUpySWdZZ0JFOE5BQ0FHSVFRZ0JTRUlJQVlOQUVFQUlRUWdCU0VJSUFVaEF3d0RDeUFESUFWQkZHb29BZ0FpQmlBR0lBVWdBRUVkZGtFRWNXcEJFR29vQWdBaUJVWWJJQU1nQmhzaEF5QUFRUUYwSVFBZ0JRMEFDd3NDUUNBRElBaHlEUUJCQUNFSVFRSWdDM1FpQTBFQUlBTnJjaUFIY1NJRFJRMERJQU5CQUNBRGEzRkJmMm9pQXlBRFFReDJRUkJ4SWdOMklnVkJCWFpCQ0hFaUFDQURjaUFGSUFCMklnTkJBblpCQkhFaUJYSWdBeUFGZGlJRFFRRjJRUUp4SWdWeUlBTWdCWFlpQTBFQmRrRUJjU0lGY2lBRElBVjJha0VDZEVHNDBvQ0FBR29vQWdBaEF3c2dBMFVOQVFzRFFDQURLQUlFUVhoeElBSnJJZ1lnQkVraEFBSkFJQU1vQWhBaUJRMEFJQU5CRkdvb0FnQWhCUXNnQmlBRUlBQWJJUVFnQXlBSUlBQWJJUWdnQlNFRElBVU5BQXNMSUFoRkRRQWdCRUVBS0FLUTBJQ0FBQ0FDYTA4TkFDQUlLQUlZSVFzQ1FDQUlLQUlNSWdBZ0NFWU5BQ0FJS0FJSUlnTkJBQ2dDbU5DQWdBQkpHaUFBSUFNMkFnZ2dBeUFBTmdJTURBa0xBa0FnQ0VFVWFpSUZLQUlBSWdNTkFDQUlLQUlRSWdORkRRTWdDRUVRYWlFRkN3TkFJQVVoQmlBRElnQkJGR29pQlNnQ0FDSUREUUFnQUVFUWFpRUZJQUFvQWhBaUF3MEFDeUFHUVFBMkFnQU1DQXNDUUVFQUtBS1EwSUNBQUNJRElBSkpEUUJCQUNnQ25OQ0FnQUFoQkFKQUFrQWdBeUFDYXlJRlFSQkpEUUFnQkNBQ2FpSUFJQVZCQVhJMkFnUkJBQ0FGTmdLUTBJQ0FBRUVBSUFBMkFwelFnSUFBSUFRZ0Eyb2dCVFlDQUNBRUlBSkJBM0kyQWdRTUFRc2dCQ0FEUVFOeU5nSUVJQVFnQTJvaUF5QURLQUlFUVFGeU5nSUVRUUJCQURZQ25OQ0FnQUJCQUVFQU5nS1EwSUNBQUFzZ0JFRUlhaUVEREFvTEFrQkJBQ2dDbE5DQWdBQWlBQ0FDVFEwQVFRQW9BcURRZ0lBQUlnTWdBbW9pQkNBQUlBSnJJZ1ZCQVhJMkFnUkJBQ0FGTmdLVTBJQ0FBRUVBSUFRMkFxRFFnSUFBSUFNZ0FrRURjallDQkNBRFFRaHFJUU1NQ2dzQ1FBSkFRUUFvQXVEVGdJQUFSUTBBUVFBb0F1alRnSUFBSVFRTUFRdEJBRUovTndMczA0Q0FBRUVBUW9DQWhJQ0FnTUFBTndMazA0Q0FBRUVBSUFGQkRHcEJjSEZCMktyVnFnVnpOZ0xnMDRDQUFFRUFRUUEyQXZUVGdJQUFRUUJCQURZQ3hOT0FnQUJCZ0lBRUlRUUxRUUFoQXdKQUlBUWdBa0hIQUdvaUIyb2lCa0VBSUFScklndHhJZ2dnQWtzTkFFRUFRVEEyQXZqVGdJQUFEQW9MQWtCQkFDZ0N3Tk9BZ0FBaUEwVU5BQUpBUVFBb0FyalRnSUFBSWdRZ0NHb2lCU0FFVFEwQUlBVWdBMDBOQVF0QkFDRURRUUJCTURZQytOT0FnQUFNQ2d0QkFDMEF4Tk9BZ0FCQkJIRU5CQUpBQWtBQ1FFRUFLQUtnMElDQUFDSUVSUTBBUWNqVGdJQUFJUU1EUUFKQUlBTW9BZ0FpQlNBRVN3MEFJQVVnQXlnQ0JHb2dCRXNOQXdzZ0F5Z0NDQ0lERFFBTEMwRUFFTXVBZ0lBQUlnQkJmMFlOQlNBSUlRWUNRRUVBS0FMazA0Q0FBQ0lEUVg5cUlnUWdBSEZGRFFBZ0NDQUFheUFFSUFCcVFRQWdBMnR4YWlFR0N5QUdJQUpORFFVZ0JrSCsvLy8vQjBzTkJRSkFRUUFvQXNEVGdJQUFJZ05GRFFCQkFDZ0N1Tk9BZ0FBaUJDQUdhaUlGSUFSTkRRWWdCU0FEU3cwR0N5QUdFTXVBZ0lBQUlnTWdBRWNOQVF3SEN5QUdJQUJySUF0eElnWkIvdi8vL3dkTERRUWdCaERMZ0lDQUFDSUFJQU1vQWdBZ0F5Z0NCR3BHRFFNZ0FDRURDd0pBSUFOQmYwWU5BQ0FDUWNnQWFpQUdUUTBBQWtBZ0J5QUdhMEVBS0FMbzA0Q0FBQ0lFYWtFQUlBUnJjU0lFUWY3Ly8vOEhUUTBBSUFNaEFBd0hDd0pBSUFRUXk0Q0FnQUJCZjBZTkFDQUVJQVpxSVFZZ0F5RUFEQWNMUVFBZ0Jtc1F5NENBZ0FBYURBUUxJQU1oQUNBRFFYOUhEUVVNQXd0QkFDRUlEQWNMUVFBaEFBd0ZDeUFBUVg5SERRSUxRUUJCQUNnQ3hOT0FnQUJCQkhJMkFzVFRnSUFBQ3lBSVFmNy8vLzhIU3cwQklBZ1F5NENBZ0FBaEFFRUFFTXVBZ0lBQUlRTWdBRUYvUmcwQklBTkJmMFlOQVNBQUlBTlBEUUVnQXlBQWF5SUdJQUpCT0dwTkRRRUxRUUJCQUNnQ3VOT0FnQUFnQm1vaUF6WUN1Tk9BZ0FBQ1FDQURRUUFvQXJ6VGdJQUFUUTBBUVFBZ0F6WUN2Tk9BZ0FBTEFrQUNRQUpBQWtCQkFDZ0NvTkNBZ0FBaUJFVU5BRUhJMDRDQUFDRURBMEFnQUNBREtBSUFJZ1VnQXlnQ0JDSUlha1lOQWlBREtBSUlJZ01OQUF3REN3c0NRQUpBUVFBb0FwalFnSUFBSWdORkRRQWdBQ0FEVHcwQkMwRUFJQUEyQXBqUWdJQUFDMEVBSVFOQkFDQUdOZ0xNMDRDQUFFRUFJQUEyQXNqVGdJQUFRUUJCZnpZQ3FOQ0FnQUJCQUVFQUtBTGcwNENBQURZQ3JOQ0FnQUJCQUVFQU5nTFUwNENBQUFOQUlBTkJ4TkNBZ0FCcUlBTkJ1TkNBZ0FCcUlnUTJBZ0FnQkNBRFFiRFFnSUFBYWlJRk5nSUFJQU5Cdk5DQWdBQnFJQVUyQWdBZ0EwSE0wSUNBQUdvZ0EwSEEwSUNBQUdvaUJUWUNBQ0FGSUFRMkFnQWdBMEhVMElDQUFHb2dBMEhJMElDQUFHb2lCRFlDQUNBRUlBVTJBZ0FnQTBIUTBJQ0FBR29nQkRZQ0FDQURRU0JxSWdOQmdBSkhEUUFMSUFCQmVDQUFhMEVQY1VFQUlBQkJDR3BCRDNFYklnTnFJZ1FnQmtGSWFpSUZJQU5ySWdOQkFYSTJBZ1JCQUVFQUtBTHcwNENBQURZQ3BOQ0FnQUJCQUNBRE5nS1UwSUNBQUVFQUlBUTJBcURRZ0lBQUlBQWdCV3BCT0RZQ0JBd0NDeUFETFFBTVFRaHhEUUFnQkNBRlNRMEFJQVFnQUU4TkFDQUVRWGdnQkd0QkQzRkJBQ0FFUVFocVFROXhHeUlGYWlJQVFRQW9BcFRRZ0lBQUlBWnFJZ3NnQldzaUJVRUJjallDQkNBRElBZ2dCbW8yQWdSQkFFRUFLQUx3MDRDQUFEWUNwTkNBZ0FCQkFDQUZOZ0tVMElDQUFFRUFJQUEyQXFEUWdJQUFJQVFnQzJwQk9EWUNCQXdCQ3dKQUlBQkJBQ2dDbU5DQWdBQWlDRThOQUVFQUlBQTJBcGpRZ0lBQUlBQWhDQXNnQUNBR2FpRUZRY2pUZ0lBQUlRTUNRQUpBQWtBQ1FBSkFBa0FDUUFOQUlBTW9BZ0FnQlVZTkFTQURLQUlJSWdNTkFBd0NDd3NnQXkwQURFRUljVVVOQVF0QnlOT0FnQUFoQXdOQUFrQWdBeWdDQUNJRklBUkxEUUFnQlNBREtBSUVhaUlGSUFSTERRTUxJQU1vQWdnaEF3d0FDd3NnQXlBQU5nSUFJQU1nQXlnQ0JDQUdhallDQkNBQVFYZ2dBR3RCRDNGQkFDQUFRUWhxUVE5eEcyb2lDeUFDUVFOeU5nSUVJQVZCZUNBRmEwRVBjVUVBSUFWQkNHcEJEM0ViYWlJR0lBc2dBbW9pQW1zaEF3SkFJQVlnQkVjTkFFRUFJQUkyQXFEUWdJQUFRUUJCQUNnQ2xOQ0FnQUFnQTJvaUF6WUNsTkNBZ0FBZ0FpQURRUUZ5TmdJRURBTUxBa0FnQmtFQUtBS2MwSUNBQUVjTkFFRUFJQUkyQXB6UWdJQUFRUUJCQUNnQ2tOQ0FnQUFnQTJvaUF6WUNrTkNBZ0FBZ0FpQURRUUZ5TmdJRUlBSWdBMm9nQXpZQ0FBd0RDd0pBSUFZb0FnUWlCRUVEY1VFQlJ3MEFJQVJCZUhFaEJ3SkFBa0FnQkVIL0FVc05BQ0FHS0FJSUlnVWdCRUVEZGlJSVFRTjBRYkRRZ0lBQWFpSUFSaG9DUUNBR0tBSU1JZ1FnQlVjTkFFRUFRUUFvQW9qUWdJQUFRWDRnQ0hkeE5nS0kwSUNBQUF3Q0N5QUVJQUJHR2lBRUlBVTJBZ2dnQlNBRU5nSU1EQUVMSUFZb0FoZ2hDUUpBQWtBZ0JpZ0NEQ0lBSUFaR0RRQWdCaWdDQ0NJRUlBaEpHaUFBSUFRMkFnZ2dCQ0FBTmdJTURBRUxBa0FnQmtFVWFpSUVLQUlBSWdVTkFDQUdRUkJxSWdRb0FnQWlCUTBBUVFBaEFBd0JDd05BSUFRaENDQUZJZ0JCRkdvaUJDZ0NBQ0lGRFFBZ0FFRVFhaUVFSUFBb0FoQWlCUTBBQ3lBSVFRQTJBZ0FMSUFsRkRRQUNRQUpBSUFZZ0JpZ0NIQ0lGUVFKMFFialNnSUFBYWlJRUtBSUFSdzBBSUFRZ0FEWUNBQ0FBRFFGQkFFRUFLQUtNMElDQUFFRitJQVYzY1RZQ2pOQ0FnQUFNQWdzZ0NVRVFRUlFnQ1NnQ0VDQUdSaHRxSUFBMkFnQWdBRVVOQVFzZ0FDQUpOZ0lZQWtBZ0JpZ0NFQ0lFUlEwQUlBQWdCRFlDRUNBRUlBQTJBaGdMSUFZb0FoUWlCRVVOQUNBQVFSUnFJQVEyQWdBZ0JDQUFOZ0lZQ3lBSElBTnFJUU1nQmlBSGFpSUdLQUlFSVFRTElBWWdCRUYrY1RZQ0JDQUNJQU5xSUFNMkFnQWdBaUFEUVFGeU5nSUVBa0FnQTBIL0FVc05BQ0FEUVhoeFFiRFFnSUFBYWlFRUFrQUNRRUVBS0FLSTBJQ0FBQ0lGUVFFZ0EwRURkblFpQTNFTkFFRUFJQVVnQTNJMkFvalFnSUFBSUFRaEF3d0JDeUFFS0FJSUlRTUxJQU1nQWpZQ0RDQUVJQUkyQWdnZ0FpQUVOZ0lNSUFJZ0F6WUNDQXdEQzBFZklRUUNRQ0FEUWYvLy93ZExEUUFnQTBFSWRpSUVJQVJCZ1A0L2FrRVFka0VJY1NJRWRDSUZJQVZCZ09BZmFrRVFka0VFY1NJRmRDSUFJQUJCZ0lBUGFrRVFka0VDY1NJQWRFRVBkaUFFSUFWeUlBQnlheUlFUVFGMElBTWdCRUVWYW5aQkFYRnlRUnhxSVFRTElBSWdCRFlDSENBQ1FnQTNBaEFnQkVFQ2RFRzQwb0NBQUdvaEJRSkFRUUFvQW96UWdJQUFJZ0JCQVNBRWRDSUljUTBBSUFVZ0FqWUNBRUVBSUFBZ0NISTJBb3pRZ0lBQUlBSWdCVFlDR0NBQ0lBSTJBZ2dnQWlBQ05nSU1EQU1MSUFOQkFFRVpJQVJCQVhacklBUkJIMFliZENFRUlBVW9BZ0FoQUFOQUlBQWlCU2dDQkVGNGNTQURSZzBDSUFSQkhYWWhBQ0FFUVFGMElRUWdCU0FBUVFSeGFrRVFhaUlJS0FJQUlnQU5BQXNnQ0NBQ05nSUFJQUlnQlRZQ0dDQUNJQUkyQWd3Z0FpQUNOZ0lJREFJTElBQkJlQ0FBYTBFUGNVRUFJQUJCQ0dwQkQzRWJJZ05xSWdzZ0JrRklhaUlJSUFOcklnTkJBWEkyQWdRZ0FDQUlha0U0TmdJRUlBUWdCVUUzSUFWclFROXhRUUFnQlVGSmFrRVBjUnRxUVVGcUlnZ2dDQ0FFUVJCcVNSc2lDRUVqTmdJRVFRQkJBQ2dDOE5PQWdBQTJBcVRRZ0lBQVFRQWdBellDbE5DQWdBQkJBQ0FMTmdLZzBJQ0FBQ0FJUVJCcVFRQXBBdERUZ0lBQU53SUFJQWhCQUNrQ3lOT0FnQUEzQWdoQkFDQUlRUWhxTmdMUTA0Q0FBRUVBSUFZMkFzelRnSUFBUVFBZ0FEWUN5Tk9BZ0FCQkFFRUFOZ0xVMDRDQUFDQUlRU1JxSVFNRFFDQURRUWMyQWdBZ0EwRUVhaUlESUFWSkRRQUxJQWdnQkVZTkF5QUlJQWdvQWdSQmZuRTJBZ1FnQ0NBSUlBUnJJZ0EyQWdBZ0JDQUFRUUZ5TmdJRUFrQWdBRUgvQVVzTkFDQUFRWGh4UWJEUWdJQUFhaUVEQWtBQ1FFRUFLQUtJMElDQUFDSUZRUUVnQUVFRGRuUWlBSEVOQUVFQUlBVWdBSEkyQW9qUWdJQUFJQU1oQlF3QkN5QURLQUlJSVFVTElBVWdCRFlDRENBRElBUTJBZ2dnQkNBRE5nSU1JQVFnQlRZQ0NBd0VDMEVmSVFNQ1FDQUFRZi8vL3dkTERRQWdBRUVJZGlJRElBTkJnUDQvYWtFUWRrRUljU0lEZENJRklBVkJnT0FmYWtFUWRrRUVjU0lGZENJSUlBaEJnSUFQYWtFUWRrRUNjU0lJZEVFUGRpQURJQVZ5SUFoeWF5SURRUUYwSUFBZ0EwRVZhblpCQVhGeVFSeHFJUU1MSUFRZ0F6WUNIQ0FFUWdBM0FoQWdBMEVDZEVHNDBvQ0FBR29oQlFKQVFRQW9Bb3pRZ0lBQUlnaEJBU0FEZENJR2NRMEFJQVVnQkRZQ0FFRUFJQWdnQm5JMkFvelFnSUFBSUFRZ0JUWUNHQ0FFSUFRMkFnZ2dCQ0FFTmdJTURBUUxJQUJCQUVFWklBTkJBWFpySUFOQkgwWWJkQ0VESUFVb0FnQWhDQU5BSUFnaUJTZ0NCRUY0Y1NBQVJnMERJQU5CSFhZaENDQURRUUYwSVFNZ0JTQUlRUVJ4YWtFUWFpSUdLQUlBSWdnTkFBc2dCaUFFTmdJQUlBUWdCVFlDR0NBRUlBUTJBZ3dnQkNBRU5nSUlEQU1MSUFVb0FnZ2lBeUFDTmdJTUlBVWdBallDQ0NBQ1FRQTJBaGdnQWlBRk5nSU1JQUlnQXpZQ0NBc2dDMEVJYWlFRERBVUxJQVVvQWdnaUF5QUVOZ0lNSUFVZ0JEWUNDQ0FFUVFBMkFoZ2dCQ0FGTmdJTUlBUWdBellDQ0F0QkFDZ0NsTkNBZ0FBaUF5QUNUUTBBUVFBb0FxRFFnSUFBSWdRZ0Ftb2lCU0FESUFKcklnTkJBWEkyQWdSQkFDQUROZ0tVMElDQUFFRUFJQVUyQXFEUWdJQUFJQVFnQWtFRGNqWUNCQ0FFUVFocUlRTU1Bd3RCQUNFRFFRQkJNRFlDK05PQWdBQU1BZ3NDUUNBTFJRMEFBa0FDUUNBSUlBZ29BaHdpQlVFQ2RFRzQwb0NBQUdvaUF5Z0NBRWNOQUNBRElBQTJBZ0FnQUEwQlFRQWdCMEYrSUFWM2NTSUhOZ0tNMElDQUFBd0NDeUFMUVJCQkZDQUxLQUlRSUFoR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFzMkFoZ0NRQ0FJS0FJUUlnTkZEUUFnQUNBRE5nSVFJQU1nQURZQ0dBc2dDRUVVYWlnQ0FDSURSUTBBSUFCQkZHb2dBellDQUNBRElBQTJBaGdMQWtBQ1FDQUVRUTlMRFFBZ0NDQUVJQUpxSWdOQkEzSTJBZ1FnQ0NBRGFpSURJQU1vQWdSQkFYSTJBZ1FNQVFzZ0NDQUNhaUlBSUFSQkFYSTJBZ1FnQ0NBQ1FRTnlOZ0lFSUFBZ0JHb2dCRFlDQUFKQUlBUkIvd0ZMRFFBZ0JFRjRjVUd3MElDQUFHb2hBd0pBQWtCQkFDZ0NpTkNBZ0FBaUJVRUJJQVJCQTNaMElnUnhEUUJCQUNBRklBUnlOZ0tJMElDQUFDQURJUVFNQVFzZ0F5Z0NDQ0VFQ3lBRUlBQTJBZ3dnQXlBQU5nSUlJQUFnQXpZQ0RDQUFJQVEyQWdnTUFRdEJIeUVEQWtBZ0JFSC8vLzhIU3cwQUlBUkJDSFlpQXlBRFFZRCtQMnBCRUhaQkNIRWlBM1FpQlNBRlFZRGdIMnBCRUhaQkJIRWlCWFFpQWlBQ1FZQ0FEMnBCRUhaQkFuRWlBblJCRDNZZ0F5QUZjaUFDY21zaUEwRUJkQ0FFSUFOQkZXcDJRUUZ4Y2tFY2FpRURDeUFBSUFNMkFod2dBRUlBTndJUUlBTkJBblJCdU5LQWdBQnFJUVVDUUNBSFFRRWdBM1FpQW5FTkFDQUZJQUEyQWdCQkFDQUhJQUp5TmdLTTBJQ0FBQ0FBSUFVMkFoZ2dBQ0FBTmdJSUlBQWdBRFlDREF3QkN5QUVRUUJCR1NBRFFRRjJheUFEUVI5R0czUWhBeUFGS0FJQUlRSUNRQU5BSUFJaUJTZ0NCRUY0Y1NBRVJnMEJJQU5CSFhZaEFpQURRUUYwSVFNZ0JTQUNRUVJ4YWtFUWFpSUdLQUlBSWdJTkFBc2dCaUFBTmdJQUlBQWdCVFlDR0NBQUlBQTJBZ3dnQUNBQU5nSUlEQUVMSUFVb0FnZ2lBeUFBTmdJTUlBVWdBRFlDQ0NBQVFRQTJBaGdnQUNBRk5nSU1JQUFnQXpZQ0NBc2dDRUVJYWlFRERBRUxBa0FnQ2tVTkFBSkFBa0FnQUNBQUtBSWNJZ1ZCQW5SQnVOS0FnQUJxSWdNb0FnQkhEUUFnQXlBSU5nSUFJQWdOQVVFQUlBbEJmaUFGZDNFMkFvelFnSUFBREFJTElBcEJFRUVVSUFvb0FoQWdBRVliYWlBSU5nSUFJQWhGRFFFTElBZ2dDallDR0FKQUlBQW9BaEFpQTBVTkFDQUlJQU0yQWhBZ0F5QUlOZ0lZQ3lBQVFSUnFLQUlBSWdORkRRQWdDRUVVYWlBRE5nSUFJQU1nQ0RZQ0dBc0NRQUpBSUFSQkQwc05BQ0FBSUFRZ0Ftb2lBMEVEY2pZQ0JDQUFJQU5xSWdNZ0F5Z0NCRUVCY2pZQ0JBd0JDeUFBSUFKcUlnVWdCRUVCY2pZQ0JDQUFJQUpCQTNJMkFnUWdCU0FFYWlBRU5nSUFBa0FnQjBVTkFDQUhRWGh4UWJEUWdJQUFhaUVDUVFBb0FwelFnSUFBSVFNQ1FBSkFRUUVnQjBFRGRuUWlDQ0FHY1EwQVFRQWdDQ0FHY2pZQ2lOQ0FnQUFnQWlFSURBRUxJQUlvQWdnaENBc2dDQ0FETmdJTUlBSWdBellDQ0NBRElBSTJBZ3dnQXlBSU5nSUlDMEVBSUFVMkFwelFnSUFBUVFBZ0JEWUNrTkNBZ0FBTElBQkJDR29oQXdzZ0FVRVFhaVNBZ0lDQUFDQURDd29BSUFBUXlZQ0FnQUFMNGcwQkIzOENRQ0FBUlEwQUlBQkJlR29pQVNBQVFYeHFLQUlBSWdKQmVIRWlBR29oQXdKQUlBSkJBWEVOQUNBQ1FRTnhSUTBCSUFFZ0FTZ0NBQ0lDYXlJQlFRQW9BcGpRZ0lBQUlnUkpEUUVnQWlBQWFpRUFBa0FnQVVFQUtBS2MwSUNBQUVZTkFBSkFJQUpCL3dGTERRQWdBU2dDQ0NJRUlBSkJBM1lpQlVFRGRFR3cwSUNBQUdvaUJrWWFBa0FnQVNnQ0RDSUNJQVJIRFFCQkFFRUFLQUtJMElDQUFFRitJQVYzY1RZQ2lOQ0FnQUFNQXdzZ0FpQUdSaG9nQWlBRU5nSUlJQVFnQWpZQ0RBd0NDeUFCS0FJWUlRY0NRQUpBSUFFb0Fnd2lCaUFCUmcwQUlBRW9BZ2dpQWlBRVNSb2dCaUFDTmdJSUlBSWdCallDREF3QkN3SkFJQUZCRkdvaUFpZ0NBQ0lFRFFBZ0FVRVFhaUlDS0FJQUlnUU5BRUVBSVFZTUFRc0RRQ0FDSVFVZ0JDSUdRUlJxSWdJb0FnQWlCQTBBSUFaQkVHb2hBaUFHS0FJUUlnUU5BQXNnQlVFQU5nSUFDeUFIUlEwQkFrQUNRQ0FCSUFFb0Fod2lCRUVDZEVHNDBvQ0FBR29pQWlnQ0FFY05BQ0FDSUFZMkFnQWdCZzBCUVFCQkFDZ0NqTkNBZ0FCQmZpQUVkM0UyQW96UWdJQUFEQU1MSUFkQkVFRVVJQWNvQWhBZ0FVWWJhaUFHTmdJQUlBWkZEUUlMSUFZZ0J6WUNHQUpBSUFFb0FoQWlBa1VOQUNBR0lBSTJBaEFnQWlBR05nSVlDeUFCS0FJVUlnSkZEUUVnQmtFVWFpQUNOZ0lBSUFJZ0JqWUNHQXdCQ3lBREtBSUVJZ0pCQTNGQkEwY05BQ0FESUFKQmZuRTJBZ1JCQUNBQU5nS1EwSUNBQUNBQklBQnFJQUEyQWdBZ0FTQUFRUUZ5TmdJRUR3c2dBU0FEVHcwQUlBTW9BZ1FpQWtFQmNVVU5BQUpBQWtBZ0FrRUNjUTBBQWtBZ0EwRUFLQUtnMElDQUFFY05BRUVBSUFFMkFxRFFnSUFBUVFCQkFDZ0NsTkNBZ0FBZ0FHb2lBRFlDbE5DQWdBQWdBU0FBUVFGeU5nSUVJQUZCQUNnQ25OQ0FnQUJIRFFOQkFFRUFOZ0tRMElDQUFFRUFRUUEyQXB6UWdJQUFEd3NDUUNBRFFRQW9BcHpRZ0lBQVJ3MEFRUUFnQVRZQ25OQ0FnQUJCQUVFQUtBS1EwSUNBQUNBQWFpSUFOZ0tRMElDQUFDQUJJQUJCQVhJMkFnUWdBU0FBYWlBQU5nSUFEd3NnQWtGNGNTQUFhaUVBQWtBQ1FDQUNRZjhCU3cwQUlBTW9BZ2dpQkNBQ1FRTjJJZ1ZCQTNSQnNOQ0FnQUJxSWdaR0dnSkFJQU1vQWd3aUFpQUVSdzBBUVFCQkFDZ0NpTkNBZ0FCQmZpQUZkM0UyQW9qUWdJQUFEQUlMSUFJZ0JrWWFJQUlnQkRZQ0NDQUVJQUkyQWd3TUFRc2dBeWdDR0NFSEFrQUNRQ0FES0FJTUlnWWdBMFlOQUNBREtBSUlJZ0pCQUNnQ21OQ0FnQUJKR2lBR0lBSTJBZ2dnQWlBR05nSU1EQUVMQWtBZ0EwRVVhaUlDS0FJQUlnUU5BQ0FEUVJCcUlnSW9BZ0FpQkEwQVFRQWhCZ3dCQ3dOQUlBSWhCU0FFSWdaQkZHb2lBaWdDQUNJRURRQWdCa0VRYWlFQ0lBWW9BaEFpQkEwQUN5QUZRUUEyQWdBTElBZEZEUUFDUUFKQUlBTWdBeWdDSENJRVFRSjBRYmpTZ0lBQWFpSUNLQUlBUncwQUlBSWdCallDQUNBR0RRRkJBRUVBS0FLTTBJQ0FBRUYrSUFSM2NUWUNqTkNBZ0FBTUFnc2dCMEVRUVJRZ0J5Z0NFQ0FEUmh0cUlBWTJBZ0FnQmtVTkFRc2dCaUFITmdJWUFrQWdBeWdDRUNJQ1JRMEFJQVlnQWpZQ0VDQUNJQVkyQWhnTElBTW9BaFFpQWtVTkFDQUdRUlJxSUFJMkFnQWdBaUFHTmdJWUN5QUJJQUJxSUFBMkFnQWdBU0FBUVFGeU5nSUVJQUZCQUNnQ25OQ0FnQUJIRFFGQkFDQUFOZ0tRMElDQUFBOExJQU1nQWtGK2NUWUNCQ0FCSUFCcUlBQTJBZ0FnQVNBQVFRRnlOZ0lFQ3dKQUlBQkIvd0ZMRFFBZ0FFRjRjVUd3MElDQUFHb2hBZ0pBQWtCQkFDZ0NpTkNBZ0FBaUJFRUJJQUJCQTNaMElnQnhEUUJCQUNBRUlBQnlOZ0tJMElDQUFDQUNJUUFNQVFzZ0FpZ0NDQ0VBQ3lBQUlBRTJBZ3dnQWlBQk5nSUlJQUVnQWpZQ0RDQUJJQUEyQWdnUEMwRWZJUUlDUUNBQVFmLy8vd2RMRFFBZ0FFRUlkaUlDSUFKQmdQNC9ha0VRZGtFSWNTSUNkQ0lFSUFSQmdPQWZha0VRZGtFRWNTSUVkQ0lHSUFaQmdJQVBha0VRZGtFQ2NTSUdkRUVQZGlBQ0lBUnlJQVp5YXlJQ1FRRjBJQUFnQWtFVmFuWkJBWEZ5UVJ4cUlRSUxJQUVnQWpZQ0hDQUJRZ0EzQWhBZ0FrRUNkRUc0MG9DQUFHb2hCQUpBQWtCQkFDZ0NqTkNBZ0FBaUJrRUJJQUowSWdOeERRQWdCQ0FCTmdJQVFRQWdCaUFEY2pZQ2pOQ0FnQUFnQVNBRU5nSVlJQUVnQVRZQ0NDQUJJQUUyQWd3TUFRc2dBRUVBUVJrZ0FrRUJkbXNnQWtFZlJodDBJUUlnQkNnQ0FDRUdBa0FEUUNBR0lnUW9BZ1JCZUhFZ0FFWU5BU0FDUVIxMklRWWdBa0VCZENFQ0lBUWdCa0VFY1dwQkVHb2lBeWdDQUNJR0RRQUxJQU1nQVRZQ0FDQUJJQVEyQWhnZ0FTQUJOZ0lNSUFFZ0FUWUNDQXdCQ3lBRUtBSUlJZ0FnQVRZQ0RDQUVJQUUyQWdnZ0FVRUFOZ0lZSUFFZ0JEWUNEQ0FCSUFBMkFnZ0xRUUJCQUNnQ3FOQ0FnQUJCZjJvaUFVRi9JQUViTmdLbzBJQ0FBQXNMQkFBQUFBdE9BQUpBSUFBTkFEOEFRUkIwRHdzQ1FDQUFRZi8vQTNFTkFDQUFRWDlNRFFBQ1FDQUFRUkIyUUFBaUFFRi9SdzBBUVFCQk1EWUMrTk9BZ0FCQmZ3OExJQUJCRUhRUEN4REtnSUNBQUFBTDhnSUNBMzhCZmdKQUlBSkZEUUFnQUNBQk9nQUFJQUlnQUdvaUEwRi9haUFCT2dBQUlBSkJBMGtOQUNBQUlBRTZBQUlnQUNBQk9nQUJJQU5CZldvZ0FUb0FBQ0FEUVg1cUlBRTZBQUFnQWtFSFNRMEFJQUFnQVRvQUF5QURRWHhxSUFFNkFBQWdBa0VKU1EwQUlBQkJBQ0FBYTBFRGNTSUVhaUlESUFGQi93RnhRWUdDaEFoc0lnRTJBZ0FnQXlBQ0lBUnJRWHh4SWdScUlnSkJmR29nQVRZQ0FDQUVRUWxKRFFBZ0F5QUJOZ0lJSUFNZ0FUWUNCQ0FDUVhocUlBRTJBZ0FnQWtGMGFpQUJOZ0lBSUFSQkdVa05BQ0FESUFFMkFoZ2dBeUFCTmdJVUlBTWdBVFlDRUNBRElBRTJBZ3dnQWtGd2FpQUJOZ0lBSUFKQmJHb2dBVFlDQUNBQ1FXaHFJQUUyQWdBZ0FrRmthaUFCTmdJQUlBUWdBMEVFY1VFWWNpSUZheUlDUVNCSkRRQWdBYTFDZ1lDQWdCQitJUVlnQXlBRmFpRUJBMEFnQVNBR053TVlJQUVnQmpjREVDQUJJQVkzQXdnZ0FTQUdOd01BSUFGQklHb2hBU0FDUVdCcUlnSkJIMHNOQUFzTElBQUxDNDVJQVFCQmdBZ0xoa2dCQUFBQUFnQUFBQU1BQUFBQUFBQUFBQUFBQUFRQUFBQUZBQUFBQUFBQUFBQUFBQUFHQUFBQUJ3QUFBQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVsdWRtRnNhV1FnWTJoaGNpQnBiaUIxY213Z2NYVmxjbmtBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlpYjJSNUFFTnZiblJsYm5RdFRHVnVaM1JvSUc5MlpYSm1iRzkzQUVOb2RXNXJJSE5wZW1VZ2IzWmxjbVpzYjNjQVVtVnpjRzl1YzJVZ2IzWmxjbVpzYjNjQVNXNTJZV3hwWkNCdFpYUm9iMlFnWm05eUlFaFVWRkF2ZUM1NElISmxjWFZsYzNRQVNXNTJZV3hwWkNCdFpYUm9iMlFnWm05eUlGSlVVMUF2ZUM1NElISmxjWFZsYzNRQVJYaHdaV04wWldRZ1UwOVZVa05GSUcxbGRHaHZaQ0JtYjNJZ1NVTkZMM2d1ZUNCeVpYRjFaWE4wQUVsdWRtRnNhV1FnWTJoaGNpQnBiaUIxY213Z1puSmhaMjFsYm5RZ2MzUmhjblFBUlhod1pXTjBaV1FnWkc5MEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmMzUmhkSFZ6QUVsdWRtRnNhV1FnY21WemNHOXVjMlVnYzNSaGRIVnpBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1BVlhObGNpQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZjbVZ6WlhSZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5b1pXRmtaWEpnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5dFpYTnpZV2RsWDJKbFoybHVZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYM1poYkhWbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZjM1JoZEhWelgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZkbVZ5YzJsdmJsOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYM1Z5YkY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmFHVmhaR1Z5WDNaaGJIVmxYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDIxbGRHaHZaRjlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJobFlXUmxjbDltYVdWc1pGOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOXVZVzFsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JWYm1WNGNHVmpkR1ZrSUdOb1lYSWdhVzRnZFhKc0lITmxjblpsY2dCSmJuWmhiR2xrSUdobFlXUmxjaUIyWVd4MVpTQmphR0Z5QUVsdWRtRnNhV1FnYUdWaFpHVnlJR1pwWld4a0lHTm9ZWElBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDkyWlhKemFXOXVBRWx1ZG1Gc2FXUWdiV2x1YjNJZ2RtVnljMmx2YmdCSmJuWmhiR2xrSUcxaGFtOXlJSFpsY25OcGIyNEFSWGh3WldOMFpXUWdjM0JoWTJVZ1lXWjBaWElnZG1WeWMybHZiZ0JGZUhCbFkzUmxaQ0JEVWt4R0lHRm1kR1Z5SUhabGNuTnBiMjRBU1c1MllXeHBaQ0JJVkZSUUlIWmxjbk5wYjI0QVNXNTJZV3hwWkNCb1pXRmtaWElnZEc5clpXNEFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOTFjbXdBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWEp6SUdsdUlIVnliQUJWYm1WNGNHVmpkR1ZrSUhOMFlYSjBJR05vWVhJZ2FXNGdkWEpzQUVSdmRXSnNaU0JBSUdsdUlIVnliQUJGYlhCMGVTQkRiMjUwWlc1MExVeGxibWQwYUFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQkRiMjUwWlc1MExVeGxibWQwYUFCRWRYQnNhV05oZEdVZ1EyOXVkR1Z1ZEMxTVpXNW5kR2dBU1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCd1lYUm9BRU52Ym5SbGJuUXRUR1Z1WjNSb0lHTmhiaWQwSUdKbElIQnlaWE5sYm5RZ2QybDBhQ0JVY21GdWMyWmxjaTFGYm1OdlpHbHVad0JKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJ6YVhwbEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmFHVmhaR1Z5WDNaaGJIVmxBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgzWmhiSFZsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2RtRnNkV1VBVFdsemMybHVaeUJsZUhCbFkzUmxaQ0JNUmlCaFpuUmxjaUJvWldGa1pYSWdkbUZzZFdVQVNXNTJZV3hwWkNCZ1ZISmhibk5tWlhJdFJXNWpiMlJwYm1kZ0lHaGxZV1JsY2lCMllXeDFaUUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJsZUhSbGJuTnBiMjV6SUhGMWIzUmxJSFpoYkhWbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdjWFZ2ZEdWa0lIWmhiSFZsQUZCaGRYTmxaQ0JpZVNCdmJsOW9aV0ZrWlhKelgyTnZiWEJzWlhSbEFFbHVkbUZzYVdRZ1JVOUdJSE4wWVhSbEFHOXVYM0psYzJWMElIQmhkWE5sQUc5dVgyTm9kVzVyWDJobFlXUmxjaUJ3WVhWelpRQnZibDl0WlhOellXZGxYMkpsWjJsdUlIQmhkWE5sQUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5MllXeDFaU0J3WVhWelpRQnZibDl6ZEdGMGRYTmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZkbVZ5YzJsdmJsOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOTFjbXhmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmWTJoMWJtdGZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZhR1ZoWkdWeVgzWmhiSFZsWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDIxbGMzTmhaMlZmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYldWMGFHOWtYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMmhsWVdSbGNsOW1hV1ZzWkY5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmYm1GdFpTQndZWFZ6WlFCVmJtVjRjR1ZqZEdWa0lITndZV05sSUdGbWRHVnlJSE4wWVhKMElHeHBibVVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZibUZ0WlFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCbGVIUmxibk5wYjI1eklHNWhiV1VBVUdGMWMyVWdiMjRnUTA5T1RrVkRWQzlWY0dkeVlXUmxBRkJoZFhObElHOXVJRkJTU1M5VmNHZHlZV1JsQUVWNGNHVmpkR1ZrSUVoVVZGQXZNaUJEYjI1dVpXTjBhVzl1SUZCeVpXWmhZMlVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDl0WlhSb2IyUUFSWGh3WldOMFpXUWdjM0JoWTJVZ1lXWjBaWElnYldWMGFHOWtBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZhR1ZoWkdWeVgyWnBaV3hrQUZCaGRYTmxaQUJKYm5aaGJHbGtJSGR2Y21RZ1pXNWpiM1Z1ZEdWeVpXUUFTVzUyWVd4cFpDQnRaWFJvYjJRZ1pXNWpiM1Z1ZEdWeVpXUUFWVzVsZUhCbFkzUmxaQ0JqYUdGeUlHbHVJSFZ5YkNCelkyaGxiV0VBVW1WeGRXVnpkQ0JvWVhNZ2FXNTJZV3hwWkNCZ1ZISmhibk5tWlhJdFJXNWpiMlJwYm1kZ0FGTlhTVlJEU0Y5UVVrOVlXUUJWVTBWZlVGSlBXRmtBVFV0QlExUkpWa2xVV1FCVlRsQlNUME5GVTFOQlFreEZYMFZPVkVsVVdRQkRUMUJaQUUxUFZrVkVYMUJGVWsxQlRrVk9WRXhaQUZSUFQxOUZRVkpNV1FCT1QxUkpSbGtBUmtGSlRFVkVYMFJGVUVWT1JFVk9RMWtBUWtGRVgwZEJWRVZYUVZrQVVFeEJXUUJRVlZRQVEwaEZRMHRQVlZRQVIwRlVSVmRCV1Y5VVNVMUZUMVZVQUZKRlVWVkZVMVJmVkVsTlJVOVZWQUJPUlZSWFQxSkxYME5QVGs1RlExUmZWRWxOUlU5VlZBQkRUMDVPUlVOVVNVOU9YMVJKVFVWUFZWUUFURTlIU1U1ZlZFbE5SVTlWVkFCT1JWUlhUMUpMWDFKRlFVUmZWRWxOUlU5VlZBQlFUMU5VQUUxSlUwUkpVa1ZEVkVWRVgxSkZVVlZGVTFRQVEweEpSVTVVWDBOTVQxTkZSRjlTUlZGVlJWTlVBRU5NU1VWT1ZGOURURTlUUlVSZlRFOUJSRjlDUVV4QlRrTkZSRjlTUlZGVlJWTlVBRUpCUkY5U1JWRlZSVk5VQUVoVVZGQmZVa1ZSVlVWVFZGOVRSVTVVWDFSUFgwaFVWRkJUWDFCUFVsUUFVa1ZRVDFKVUFFbE5YMEZmVkVWQlVFOVVBRkpGVTBWVVgwTlBUbFJGVGxRQVRrOWZRMDlPVkVWT1ZBQlFRVkpVU1VGTVgwTlBUbFJGVGxRQVNGQkZYMGxPVmtGTVNVUmZRMDlPVTFSQlRsUUFTRkJGWDBOQ1gxSkZVMFZVQUVkRlZBQklVRVZmVTFSU1NVTlVBRU5QVGtaTVNVTlVBRlJGVFZCUFVrRlNXVjlTUlVSSlVrVkRWQUJRUlZKTlFVNUZUbFJmVWtWRVNWSkZRMVFBUTA5T1RrVkRWQUJOVlV4VVNWOVRWRUZVVlZNQVNGQkZYMGxPVmtGTVNVUmZVMVJCVkZWVEFGUlBUMTlOUVU1WlgxSkZVVlZGVTFSVEFFVkJVa3haWDBoSlRsUlRBRlZPUVZaQlNVeEJRa3hGWDBaUFVsOU1SVWRCVEY5U1JVRlRUMDVUQUU5UVZFbFBUbE1BVTFkSlZFTklTVTVIWDFCU1QxUlBRMDlNVXdCV1FWSkpRVTVVWDBGTVUwOWZUa1ZIVDFSSlFWUkZVd0JOVlV4VVNWQk1SVjlEU0U5SlEwVlRBRWxPVkVWU1RrRk1YMU5GVWxaRlVsOUZVbEpQVWdCWFJVSmZVMFZTVmtWU1gxVk9TMDVQVjA1ZlJWSlNUMUlBVWtGSlRFZFZUbDlGVWxKUFVnQkpSRVZPVkVsVVdWOVFVazlXU1VSRlVsOUJWVlJJUlU1VVNVTkJWRWxQVGw5RlVsSlBVZ0JUVTB4ZlEwVlNWRWxHU1VOQlZFVmZSVkpTVDFJQVNVNVdRVXhKUkY5WVgwWlBVbGRCVWtSRlJGOUdUMUlBVTBWVVgxQkJVa0ZOUlZSRlVnQkhSVlJmVUVGU1FVMUZWRVZTQUVoUVJWOVZVMFZTQUZORlJWOVBWRWhGVWdCSVVFVmZRMEpmUTBoVlRrdGZTRVZCUkVWU0FFMUxRMEZNUlU1RVFWSUFVMFZVVlZBQVYwVkNYMU5GVWxaRlVsOUpVMTlFVDFkT0FGUkZRVkpFVDFkT0FFaFFSVjlEVEU5VFJVUmZRMDlPVGtWRFZFbFBUZ0JJUlZWU1NWTlVTVU5mUlZoUVNWSkJWRWxQVGdCRVNWTkRUMDVPUlVOVVJVUmZUMUJGVWtGVVNVOU9BRTVQVGw5QlZWUklUMUpKVkVGVVNWWkZYMGxPUms5U1RVRlVTVTlPQUVoUVJWOUpUbFpCVEVsRVgxWkZVbE5KVDA0QVNGQkZYME5DWDAxRlUxTkJSMFZmUWtWSFNVNEFVMGxVUlY5SlUxOUdVazlhUlU0QVNGQkZYMGxPVmtGTVNVUmZTRVZCUkVWU1gxUlBTMFZPQUVsT1ZrRk1TVVJmVkU5TFJVNEFSazlTUWtsRVJFVk9BRVZPU0VGT1EwVmZXVTlWVWw5RFFVeE5BRWhRUlY5SlRsWkJURWxFWDFWU1RBQkNURTlEUzBWRVgwSlpYMUJCVWtWT1ZFRk1YME5QVGxSU1Qwd0FUVXREVDB3QVFVTk1BRWhRUlY5SlRsUkZVazVCVEFCU1JWRlZSVk5VWDBoRlFVUkZVbDlHU1VWTVJGTmZWRTlQWDB4QlVrZEZYMVZPVDBaR1NVTkpRVXdBU0ZCRlgwOUxBRlZPVEVsT1N3QlZUa3hQUTBzQVVGSkpBRkpGVkZKWlgxZEpWRWdBU0ZCRlgwbE9Wa0ZNU1VSZlEwOU9WRVZPVkY5TVJVNUhWRWdBU0ZCRlgxVk9SVmhRUlVOVVJVUmZRMDlPVkVWT1ZGOU1SVTVIVkVnQVJreFZVMGdBVUZKUFVGQkJWRU5JQUUwdFUwVkJVa05JQUZWU1NWOVVUMDlmVEU5T1J3QlFVazlEUlZOVFNVNUhBRTFKVTBORlRFeEJUa1ZQVlZOZlVFVlNVMGxUVkVWT1ZGOVhRVkpPU1U1SEFFMUpVME5GVEV4QlRrVlBWVk5mVjBGU1RrbE9Sd0JJVUVWZlNVNVdRVXhKUkY5VVVrRk9VMFpGVWw5RlRrTlBSRWxPUndCRmVIQmxZM1JsWkNCRFVreEdBRWhRUlY5SlRsWkJURWxFWDBOSVZVNUxYMU5KV2tVQVRVOVdSUUJEVDA1VVNVNVZSUUJJVUVWZlEwSmZVMVJCVkZWVFgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5SVJVRkVSVkpUWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlXUlZKVFNVOU9YME5QVFZCTVJWUkZBRWhRUlY5RFFsOVZVa3hmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYME5JVlU1TFgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5SVJVRkVSVkpmVmtGTVZVVmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwTklWVTVMWDBWWVZFVk9VMGxQVGw5V1FVeFZSVjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZRMGhWVGt0ZlJWaFVSVTVUU1U5T1gwNUJUVVZmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMDFGVTFOQlIwVmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwMUZWRWhQUkY5RFQwMVFURVZVUlFCSVVFVmZRMEpmU0VWQlJFVlNYMFpKUlV4RVgwTlBUVkJNUlZSRkFFUkZURVZVUlFCSVVFVmZTVTVXUVV4SlJGOUZUMFpmVTFSQlZFVUFTVTVXUVV4SlJGOVRVMHhmUTBWU1ZFbEdTVU5CVkVVQVVFRlZVMFVBVGs5ZlVrVlRVRTlPVTBVQVZVNVRWVkJRVDFKVVJVUmZUVVZFU1VGZlZGbFFSUUJIVDA1RkFFNVBWRjlCUTBORlVGUkJRa3hGQUZORlVsWkpRMFZmVlU1QlZrRkpURUZDVEVVQVVrRk9SMFZmVGs5VVgxTkJWRWxUUmtsQlFreEZBRTlTU1VkSlRsOUpVMTlWVGxKRlFVTklRVUpNUlFCU1JWTlFUMDVUUlY5SlUxOVRWRUZNUlFCUVZWSkhSUUJOUlZKSFJRQlNSVkZWUlZOVVgwaEZRVVJGVWw5R1NVVk1SRk5mVkU5UFgweEJVa2RGQUZKRlVWVkZVMVJmU0VWQlJFVlNYMVJQVDE5TVFWSkhSUUJRUVZsTVQwRkVYMVJQVDE5TVFWSkhSUUJKVGxOVlJrWkpRMGxGVGxSZlUxUlBVa0ZIUlFCSVVFVmZVRUZWVTBWRVgxVlFSMUpCUkVVQVNGQkZYMUJCVlZORlJGOUlNbDlWVUVkU1FVUkZBRk5QVlZKRFJRQkJUazVQVlU1RFJRQlVVa0ZEUlFCSVVFVmZWVTVGV0ZCRlExUkZSRjlUVUVGRFJRQkVSVk5EVWtsQ1JRQlZUbE5WUWxORFVrbENSUUJTUlVOUFVrUUFTRkJGWDBsT1ZrRk1TVVJmVFVWVVNFOUVBRTVQVkY5R1QxVk9SQUJRVWs5UVJrbE9SQUJWVGtKSlRrUUFVa1ZDU1U1RUFGVk9RVlZVU0U5U1NWcEZSQUJOUlZSSVQwUmZUazlVWDBGTVRFOVhSVVFBU0ZSVVVGOVdSVkpUU1U5T1gwNVBWRjlUVlZCUVQxSlVSVVFBUVV4U1JVRkVXVjlTUlZCUFVsUkZSQUJCUTBORlVGUkZSQUJPVDFSZlNVMVFURVZOUlU1VVJVUUFURTlQVUY5RVJWUkZRMVJGUkFCSVVFVmZRMUpmUlZoUVJVTlVSVVFBU0ZCRlgweEdYMFZZVUVWRFZFVkVBRU5TUlVGVVJVUUFTVTFmVlZORlJBQklVRVZmVUVGVlUwVkVBRlJKVFVWUFZWUmZUME5EVlZKRlJBQlFRVmxOUlU1VVgxSkZVVlZKVWtWRUFGQlNSVU5QVGtSSlZFbFBUbDlTUlZGVlNWSkZSQUJRVWs5WVdWOUJWVlJJUlU1VVNVTkJWRWxQVGw5U1JWRlZTVkpGUkFCT1JWUlhUMUpMWDBGVlZFaEZUbFJKUTBGVVNVOU9YMUpGVVZWSlVrVkVBRXhGVGtkVVNGOVNSVkZWU1ZKRlJBQlRVMHhmUTBWU1ZFbEdTVU5CVkVWZlVrVlJWVWxTUlVRQVZWQkhVa0ZFUlY5U1JWRlZTVkpGUkFCUVFVZEZYMFZZVUVsU1JVUUFVRkpGUTA5T1JFbFVTVTlPWDBaQlNVeEZSQUJGV0ZCRlExUkJWRWxQVGw5R1FVbE1SVVFBVWtWV1FVeEpSRUZVU1U5T1gwWkJTVXhGUkFCVFUweGZTRUZPUkZOSVFVdEZYMFpCU1V4RlJBQk1UME5MUlVRQVZGSkJUbE5HVDFKTlFWUkpUMDVmUVZCUVRFbEZSQUJPVDFSZlRVOUVTVVpKUlVRQVRrOVVYMFZZVkVWT1JFVkVBRUpCVGtSWFNVUlVTRjlNU1UxSlZGOUZXRU5GUlVSRlJBQlRTVlJGWDBsVFgwOVdSVkpNVDBGRVJVUUFTRVZCUkFCRmVIQmxZM1JsWkNCSVZGUlFMd0FBWGhNQUFDWVRBQUF3RUFBQThCY0FBSjBUQUFBVkVnQUFPUmNBQVBBU0FBQUtFQUFBZFJJQUFLMFNBQUNDRXdBQVR4UUFBSDhRQUFDZ0ZRQUFJeFFBQUlrU0FBQ0xGQUFBVFJVQUFOUVJBQURQRkFBQUVCZ0FBTWtXQUFEY0ZnQUF3UkVBQU9BWEFBQzdGQUFBZEJRQUFId1ZBQURsRkFBQUNCY0FBQjhRQUFCbEZRQUFveFFBQUNnVkFBQUNGUUFBbVJVQUFDd1FBQUNMR1FBQVR3OEFBTlFPQUFCcUVBQUF6aEFBQUFJWEFBQ0pEZ0FBYmhNQUFCd1RBQUJtRkFBQVZoY0FBTUVUQUFETkV3QUFiQk1BQUdnWEFBQm1Gd0FBWHhjQUFDSVRBQURPRHdBQWFRNEFBTmdPQUFCakZnQUF5eE1BQUtvT0FBQW9Gd0FBSmhjQUFNVVRBQUJkRmdBQTZCRUFBR2NUQUFCbEV3QUE4aFlBQUhNVEFBQWRGd0FBK1JZQUFQTVJBQURQRGdBQXpoVUFBQXdTQUFDekVRQUFwUkVBQUdFUUFBQXlGd0FBdXhNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQVFJQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSURBZ0lDQWdJQUFBSUNBQUlDQUFJQ0FnSUNBZ0lDQWdJQUJBQUFBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQUFBQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUNBQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUFJQ0FnSUNBQUFDQWdBQ0FnQUNBZ0lDQWdJQ0FnSUNBQU1BQkFBQUFBSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FBQUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFiRzl6WldWbGNDMWhiR2wyWlFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBUUVCQVFFQkFRRUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQlkyaDFibXRsWkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUVBQVFFQkFRRUFBQUVCQUFFQkFBRUJBUUVCQVFFQkFRRUFBQUFBQUFBQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmxZM1JwYjI1bGJuUXRiR1Z1WjNSb2IyNXliM2g1TFdOdmJtNWxZM1JwYjI0QUFBQUFBQUFBQUFBQUFBQUFBQUJ5WVc1elptVnlMV1Z1WTI5a2FXNW5jR2R5WVdSbERRb05DZzBLVTAwTkNnMEtWRlJRTDBORkwxUlRVQzhBQUFBQUFBQUFBQUFBQUFBQkFnQUJBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBQUFBUUlBQVFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFRRUZBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFBQUFFQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBQUFBQUFBQUFBQUFBUUFBQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNRUFBQUVCQVFFQkFRRUJBUUVCQVVFQkFRRUJBUUVCQVFFQkFRQUJBQUdCd1FFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQUFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFJQUFBQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJPVDFWT1EwVkZRMHRQVlZST1JVTlVSVlJGUTFKSlFrVk1WVk5JUlZSRlFVUlRSVUZTUTBoU1IwVkRWRWxXU1ZSWlRFVk9SRUZTVmtWUFZFbEdXVkJVU1U5T1UwTklVMFZCV1ZOVVFWUkRTRWRGVDFKRVNWSkZRMVJQVWxSU1EwaFFRVkpCVFVWVVJWSlZVa05GUWxORFVrbENSVUZTUkU5WFRrRkRSVWxPUkU1TFEwdFZRbE5EVWtsQ1JVaFVWRkF2UVVSVVVDOD0nXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \************************************************************/
/***/ ((module) => {

eval("module.exports = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw=='\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHBfc2ltZC13YXNtLmpzPzA3OWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAnQUdGemJRRUFBQUFCTUFoZ0FYOEJmMkFEZjM5L0FYOWdCSDkvZjM4QmYyQUFBR0FEZjM5L0FHQUJmd0JnQW45L0FHQUdmMzkvZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBQ0EyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUEwWkZBd01FQUFBRkFBQUFBQUFBQlFFRkFBVUZCUUFBQmdBQUFBQUdCZ1lHQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFBQkFRY0FBQVVGQXdBQkJBVUJjQUVTRWdVREFRQUNCZ2dCZndGQmdOUUVDd2ZSQlNJR2JXVnRiM0o1QWdBTFgybHVhWFJwWVd4cGVtVUFDUmxmWDJsdVpHbHlaV04wWDJaMWJtTjBhVzl1WDNSaFlteGxBUUFMYkd4b2RIUndYMmx1YVhRQUNoaHNiR2gwZEhCZmMyaHZkV3hrWDJ0bFpYQmZZV3hwZG1VQVFReHNiR2gwZEhCZllXeHNiMk1BREFadFlXeHNiMk1BUmd0c2JHaDBkSEJmWm5KbFpRQU5CR1p5WldVQVNBOXNiR2gwZEhCZloyVjBYM1I1Y0dVQURoVnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXRnFiM0lBRHhWc2JHaDBkSEJmWjJWMFgyaDBkSEJmYldsdWIzSUFFQkZzYkdoMGRIQmZaMlYwWDIxbGRHaHZaQUFSRm14c2FIUjBjRjluWlhSZmMzUmhkSFZ6WDJOdlpHVUFFaEpzYkdoMGRIQmZaMlYwWDNWd1ozSmhaR1VBRXd4c2JHaDBkSEJmY21WelpYUUFGQTVzYkdoMGRIQmZaWGhsWTNWMFpRQVZGR3hzYUhSMGNGOXpaWFIwYVc1bmMxOXBibWwwQUJZTmJHeG9kSFJ3WDJacGJtbHphQUFYREd4c2FIUjBjRjl3WVhWelpRQVlEV3hzYUhSMGNGOXlaWE4xYldVQUdSdHNiR2gwZEhCZmNtVnpkVzFsWDJGbWRHVnlYM1Z3WjNKaFpHVUFHaEJzYkdoMGRIQmZaMlYwWDJWeWNtNXZBQnNYYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl5WldGemIyNEFIQmRzYkdoMGRIQmZjMlYwWDJWeWNtOXlYM0psWVhOdmJnQWRGR3hzYUhSMGNGOW5aWFJmWlhKeWIzSmZjRzl6QUI0UmJHeG9kSFJ3WDJWeWNtNXZYMjVoYldVQUh4SnNiR2gwZEhCZmJXVjBhRzlrWDI1aGJXVUFJQkpzYkdoMGRIQmZjM1JoZEhWelgyNWhiV1VBSVJwc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmFHVmhaR1Z5Y3dBaUlXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOWphSFZ1YTJWa1gyeGxibWQwYUFBakhXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOXJaV1Z3WDJGc2FYWmxBQ1FrYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDNSeVlXNXpabVZ5WDJWdVkyOWthVzVuQUNVWWJHeG9kSFJ3WDIxbGMzTmhaMlZmYm1WbFpITmZaVzltQUQ4SkZ3RUFRUUVMRVFFQ0F3UUZDd1lITlRrM01TOHRKeXNwQ3JMZ0FrVUNBQXNJQUJDSWdJQ0FBQXNaQUNBQUVNS0FnSUFBR2lBQUlBSTJBamdnQUNBQk9nQW9DeHdBSUFBZ0FDOEJNaUFBTFFBdUlBQVF3WUNBZ0FBUWdJQ0FnQUFMS2dFQmYwSEFBQkRHZ0lDQUFDSUJFTUtBZ0lBQUdpQUJRWUNJZ0lBQU5nSTRJQUVnQURvQUtDQUJDd29BSUFBUXlJQ0FnQUFMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFJRRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJEQ2dJQ0FBQm9nQUNBRU5nSTRJQUFnQXpvQUtDQUFJQUk2QUMwZ0FDQUJOZ0lZQ3hFQUlBQWdBU0FCSUFKcUVNT0FnSUFBQ3hBQUlBQkJBRUhjQUJETWdJQ0FBQm9MWndFQmYwRUFJUUVDUUNBQUtBSU1EUUFDUUFKQUFrQUNRQ0FBTFFBdkRnTUJBQU1DQ3lBQUtBSTRJZ0ZGRFFBZ0FTZ0NMQ0lCUlEwQUlBQWdBUkdBZ0lDQUFBQWlBUTBEQzBFQUR3c1F5b0NBZ0FBQUN5QUFRY09XZ0lBQU5nSVFRUTRoQVFzZ0FRc2VBQUpBSUFBb0Fnd05BQ0FBUWRHYmdJQUFOZ0lRSUFCQkZUWUNEQXNMRmdBQ1FDQUFLQUlNUVJWSERRQWdBRUVBTmdJTUN3c1dBQUpBSUFBb0FneEJGa2NOQUNBQVFRQTJBZ3dMQ3djQUlBQW9BZ3dMQndBZ0FDZ0NFQXNKQUNBQUlBRTJBaEFMQndBZ0FDZ0NGQXNpQUFKQUlBQkJKRWtOQUJES2dJQ0FBQUFMSUFCQkFuUkJvTE9BZ0FCcUtBSUFDeUlBQWtBZ0FFRXVTUTBBRU1xQWdJQUFBQXNnQUVFQ2RFR3d0SUNBQUdvb0FnQUw3Z3NCQVg5QjY2aUFnQUFoQVFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkJuSDlxRHZRRFkySUFBV0ZoWVdGaFlRSURCQVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEJnY0lDUW9MREEwT0QyRmhZV0ZoRUdGaFlXRmhZV0ZoWVdGaEVXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlSSVRGQlVXRnhnWkdodGhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJZVGM0T1RwaFlXRmhZV0ZoWVR0aFlXRThZV0ZoWVQwK1AyRmhZV0ZoWVdGaFFHRmhRV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTJGaFlXRmhZV0ZoVkZWV1YxaFpXbHRoWEYxaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmVZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhYMkJoQzBIaHA0Q0FBQThMUWFTaGdJQUFEd3RCeTZ5QWdBQVBDMEgrc1lDQUFBOExRY0NrZ0lBQUR3dEJxNlNBZ0FBUEMwR05xSUNBQUE4TFFlS21nSUFBRHd0QmdMQ0FnQUFQQzBHNXI0Q0FBQThMUWRla2dJQUFEd3RCNzUrQWdBQVBDMEhobjRDQUFBOExRZnFmZ0lBQUR3dEI4cUNBZ0FBUEMwR29yNENBQUE4TFFhNnlnSUFBRHd0QmlMQ0FnQUFQQzBIc3A0Q0FBQThMUVlLaWdJQUFEd3RCanAyQWdBQVBDMEhRcm9DQUFBOExRY3FqZ0lBQUR3dEJ4YktBZ0FBUEMwSGZuSUNBQUE4TFFkS2NnSUFBRHd0QnhLQ0FnQUFQQzBIWG9JQ0FBQThMUWFLZmdJQUFEd3RCN2E2QWdBQVBDMEdyc0lDQUFBOExRZFNsZ0lBQUR3dEJ6SzZBZ0FBUEMwSDZyb0NBQUE4TFFmeXJnSUFBRHd0QjByQ0FnQUFQQzBIeG5ZQ0FBQThMUWJ1Z2dJQUFEd3RCOTZ1QWdBQVBDMEdRc1lDQUFBOExRZGV4Z0lBQUR3dEJvcTJBZ0FBUEMwSFVwNENBQUE4TFFlQ3JnSUFBRHd0Qm42eUFnQUFQQzBIcnNZQ0FBQThMUWRXZmdJQUFEd3RCeXJHQWdBQVBDMEhlcFlDQUFBOExRZFNlZ0lBQUR3dEI5SnlBZ0FBUEMwR25zb0NBQUE4TFFiR2RnSUFBRHd0Qm9KMkFnQUFQQzBHNXNZQ0FBQThMUWJ5d2dJQUFEd3RCa3FHQWdBQVBDMEd6cG9DQUFBOExRZW1zZ0lBQUR3dEJySjZBZ0FBUEMwSFVxNENBQUE4TFFmZW1nSUFBRHd0QmdLYUFnQUFQQzBHd29ZQ0FBQThMUWY2ZWdJQUFEd3RCamFPQWdBQVBDMEdKcllDQUFBOExRZmVpZ0lBQUR3dEJvTEdBZ0FBUEMwR3VuNENBQUE4TFFjYWxnSUFBRHd0QjZKNkFnQUFQQzBHVG9vQ0FBQThMUWNLdmdJQUFEd3RCdzUyQWdBQVBDMEdMcklDQUFBOExRZUdkZ0lBQUR3dEJqYStBZ0FBUEMwSHFvWUNBQUE4TFFiU3RnSUFBRHd0QjBxK0FnQUFQQzBIZnNvQ0FBQThMUWRLeWdJQUFEd3RCOExDQWdBQVBDMEdwb29DQUFBOExRZm1qZ0lBQUR3dEJtWjZBZ0FBUEMwRzFySUNBQUE4TFFadXdnSUFBRHd0QmtyS0FnQUFQQzBHMnE0Q0FBQThMUWNLaWdJQUFEd3RCK0xLQWdBQVBDMEdlcFlDQUFBOExRZENpZ0lBQUR3dEJ1cDZBZ0FBUEMwR0Jub0NBQUE4TEVNcUFnSUFBQUF0QjFxR0FnQUFoQVFzZ0FRc1dBQ0FBSUFBdEFDMUIvZ0Z4SUFGQkFFZHlPZ0F0Q3hrQUlBQWdBQzBBTFVIOUFYRWdBVUVBUjBFQmRISTZBQzBMR1FBZ0FDQUFMUUF0UWZzQmNTQUJRUUJIUVFKMGNqb0FMUXNaQUNBQUlBQXRBQzFCOXdGeElBRkJBRWRCQTNSeU9nQXRDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FnQWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NCQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFjYVJnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUl3SWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWdnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUgyaW9DQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ05DSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSU1JZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQjdacUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BamdpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDRUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRWldRZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJOElnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FoUWlCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVHcW00Q0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NRQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlZSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkI3Wk9BZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWtRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0pDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSXNJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BaWdpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFSDJpSUNBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDVUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJY0lnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCd3BtQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FrZ2lCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NJQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFaU1VnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUpNSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWxRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1dDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RGQVFGL0FrQUNRQ0FBTHdFd1FSUnhRUlJIRFFCQkFTRURJQUF0QUNoQkFVWU5BU0FBTHdFeVFlVUFSaUVEREFFTElBQXRBQ2xCQlVZaEF3c2dBQ0FET2dBdVFRQUwvZ0VCQTM5QkFTRURBa0FnQUM4Qk1DSUVRUWh4RFFBZ0FDa0RJRUlBVWlFREN3SkFBa0FnQUMwQUxrVU5BRUVCSVFVZ0FDMEFLVUVGUmcwQlFRRWhCU0FFUWNBQWNVVWdBM0ZCQVVjTkFRdEJBQ0VGSUFSQndBQnhEUUJCQWlFRklBUkIvLzhEY1NJRFFRaHhEUUFDUUNBRFFZQUVjVVVOQUFKQUlBQXRBQ2hCQVVjTkFDQUFMUUF0UVFweERRQkJCUThMUVFRUEN3SkFJQU5CSUhFTkFBSkFJQUF0QUNoQkFVWU5BQ0FBTHdFeVFmLy9BM0VpQUVHY2YycEI1QUJKRFFBZ0FFSE1BVVlOQUNBQVFiQUNSZzBBUVFRaEJTQUVRU2h4UlEwQ0lBTkJpQVJ4UVlBRVJnMENDMEVBRHd0QkFFRURJQUFwQXlCUUd5RUZDeUFGQzJJQkFuOUJBQ0VCQWtBZ0FDMEFLRUVCUmcwQUlBQXZBVEpCLy84RGNTSUNRWngvYWtIa0FFa05BQ0FDUWN3QlJnMEFJQUpCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFTQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUJDeUFCQzZjQkFRTi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUVFQUlRTWdBQzhCTUNJRVFRSnhSUTBCREFJTFFRQWhBeUFBTHdFd0lnUkJBWEZGRFFFTFFRRWhBeUFBTFFBb1FRRkdEUUFnQUM4Qk1rSC8vd054SWdWQm5IOXFRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRVFjQUFjUTBBUVFBaEF5QUVRWWdFY1VHQUJFWU5BQ0FFUVNoeFFRQkhJUU1MSUFCQkFEc0JNQ0FBUVFBNkFDOGdBd3VaQVFFQ2Z3SkFBa0FDUUNBQUxRQXFSUTBBSUFBdEFDdEZEUUJCQUNFQklBQXZBVEFpQWtFQ2NVVU5BUXdDQzBFQUlRRWdBQzhCTUNJQ1FRRnhSUTBCQzBFQklRRWdBQzBBS0VFQlJnMEFJQUF2QVRKQi8vOERjU0lBUVp4L2FrSGtBRWtOQUNBQVFjd0JSZzBBSUFCQnNBSkdEUUFnQWtIQUFIRU5BRUVBSVFFZ0FrR0lCSEZCZ0FSR0RRQWdBa0VvY1VFQVJ5RUJDeUFCQzBrQkFYc2dBRUVRYXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNJQi9Rc0RBQ0FBSUFIOUN3TUFJQUJCTUdvZ0FmMExBd0FnQUVFZ2FpQUIvUXNEQUNBQVFkMEJOZ0ljUVFBTGV3RUJmd0pBSUFBb0Fnd2lBdzBBQWtBZ0FDZ0NCRVVOQUNBQUlBRTJBZ1FMQWtBZ0FDQUJJQUlReElDQWdBQWlBdzBBSUFBb0Fnd1BDeUFBSUFNMkFoeEJBQ0VESUFBb0FnUWlBVVVOQUNBQUlBRWdBaUFBS0FJSUVZR0FnSUFBQUNJQlJRMEFJQUFnQWpZQ0ZDQUFJQUUyQWd3Z0FTRURDeUFEQytUekFRTU9md04rQkg4amdJQ0FnQUJCRUdzaUF5U0FnSUNBQUNBQklRUWdBU0VGSUFFaEJpQUJJUWNnQVNFSUlBRWhDU0FCSVFvZ0FTRUxJQUVoRENBQklRMGdBU0VPSUFFaER3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFLQUljSWhCQmYyb08zUUhhQVFIWkFRSURCQVVHQndnSkNnc01EUTdZQVE4UTF3RVJFdFlCRXhRVkZoY1lHUm9iNEFIZkFSd2RIdFVCSHlBaElpTWtKZFFCSmljb0tTb3JMTk1CMGdFdEx0RUIwQUV2TURFeU16UTFOamM0T1RvN1BEMCtQMEJCUWtORVJVYmJBVWRJU1VyUEFjNEJTODBCVE13QlRVNVBVRkZTVTFSVlZsZFlXVnBiWEYxZVgyQmhZbU5rWldabmFHbHFhMnh0Ym05d2NYSnpkSFYyZDNoNWVudDhmWDUvZ0FHQkFZSUJnd0dFQVlVQmhnR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBWkVCa2dHVEFaUUJsUUdXQVpjQm1BR1pBWm9CbXdHY0FaMEJuZ0dmQWFBQm9RR2lBYU1CcEFHbEFhWUJwd0dvQWFrQnFnR3JBYXdCclFHdUFhOEJzQUd4QWJJQnN3RzBBYlVCdGdHM0Fjc0J5Z0c0QWNrQnVRSElBYm9CdXdHOEFiMEJ2Z0cvQWNBQndRSENBY01CeEFIRkFjWUJBTndCQzBFQUlSQU14Z0VMUVE0aEVBekZBUXRCRFNFUURNUUJDMEVQSVJBTXd3RUxRUkFoRUF6Q0FRdEJFeUVRRE1FQkMwRVVJUkFNd0FFTFFSVWhFQXkvQVF0QkZpRVFETDRCQzBFWElSQU12UUVMUVJnaEVBeThBUXRCR1NFUURMc0JDMEVhSVJBTXVnRUxRUnNoRUF5NUFRdEJIQ0VRRExnQkMwRUlJUkFNdHdFTFFSMGhFQXkyQVF0QklDRVFETFVCQzBFZklSQU10QUVMUVFjaEVBeXpBUXRCSVNFUURMSUJDMEVpSVJBTXNRRUxRUjRoRUF5d0FRdEJJeUVRREs4QkMwRVNJUkFNcmdFTFFSRWhFQXl0QVF0QkpDRVFES3dCQzBFbElSQU1xd0VMUVNZaEVBeXFBUXRCSnlFUURLa0JDMEhEQVNFUURLZ0JDMEVwSVJBTXB3RUxRU3NoRUF5bUFRdEJMQ0VRREtVQkMwRXRJUkFNcEFFTFFTNGhFQXlqQVF0Qkx5RVFES0lCQzBIRUFTRVFES0VCQzBFd0lSQU1vQUVMUVRRaEVBeWZBUXRCRENFUURKNEJDMEV4SVJBTW5RRUxRVEloRUF5Y0FRdEJNeUVRREpzQkMwRTVJUkFNbWdFTFFUVWhFQXlaQVF0QnhRRWhFQXlZQVF0QkN5RVFESmNCQzBFNklSQU1sZ0VMUVRZaEVBeVZBUXRCQ2lFUURKUUJDMEUzSVJBTWt3RUxRVGdoRUF5U0FRdEJQQ0VRREpFQkMwRTdJUkFNa0FFTFFUMGhFQXlQQVF0QkNTRVFESTRCQzBFb0lSQU1qUUVMUVQ0aEVBeU1BUXRCUHlFUURJc0JDMEhBQUNFUURJb0JDMEhCQUNFUURJa0JDMEhDQUNFUURJZ0JDMEhEQUNFUURJY0JDMEhFQUNFUURJWUJDMEhGQUNFUURJVUJDMEhHQUNFUURJUUJDMEVxSVJBTWd3RUxRY2NBSVJBTWdnRUxRY2dBSVJBTWdRRUxRY2tBSVJBTWdBRUxRY29BSVJBTWZ3dEJ5d0FoRUF4K0MwSE5BQ0VRREgwTFFjd0FJUkFNZkF0QnpnQWhFQXg3QzBIUEFDRVFESG9MUWRBQUlSQU1lUXRCMFFBaEVBeDRDMEhTQUNFUURIY0xRZE1BSVJBTWRndEIxQUFoRUF4MUMwSFdBQ0VRREhRTFFkVUFJUkFNY3d0QkJpRVFESElMUWRjQUlSQU1jUXRCQlNFUURIQUxRZGdBSVJBTWJ3dEJCQ0VRREc0TFFka0FJUkFNYlF0QjJnQWhFQXhzQzBIYkFDRVFER3NMUWR3QUlSQU1hZ3RCQXlFUURHa0xRZDBBSVJBTWFBdEIzZ0FoRUF4bkMwSGZBQ0VRREdZTFFlRUFJUkFNWlF0QjRBQWhFQXhrQzBIaUFDRVFER01MUWVNQUlSQU1ZZ3RCQWlFUURHRUxRZVFBSVJBTVlBdEI1UUFoRUF4ZkMwSG1BQ0VRREY0TFFlY0FJUkFNWFF0QjZBQWhFQXhjQzBIcEFDRVFERnNMUWVvQUlSQU1XZ3RCNndBaEVBeFpDMEhzQUNFUURGZ0xRZTBBSVJBTVZ3dEI3Z0FoRUF4V0MwSHZBQ0VRREZVTFFmQUFJUkFNVkF0QjhRQWhFQXhUQzBIeUFDRVFERklMUWZNQUlSQU1VUXRCOUFBaEVBeFFDMEgxQUNFUURFOExRZllBSVJBTVRndEI5d0FoRUF4TkMwSDRBQ0VRREV3TFFma0FJUkFNU3d0QitnQWhFQXhLQzBIN0FDRVFERWtMUWZ3QUlSQU1TQXRCL1FBaEVBeEhDMEgrQUNFUURFWUxRZjhBSVJBTVJRdEJnQUVoRUF4RUMwR0JBU0VRREVNTFFZSUJJUkFNUWd0Qmd3RWhFQXhCQzBHRUFTRVFERUFMUVlVQklSQU1Qd3RCaGdFaEVBdytDMEdIQVNFUUREMExRWWdCSVJBTVBBdEJpUUVoRUF3N0MwR0tBU0VRRERvTFFZc0JJUkFNT1F0QmpBRWhFQXc0QzBHTkFTRVFERGNMUVk0QklSQU1OZ3RCandFaEVBdzFDMEdRQVNFUUREUUxRWkVCSVJBTU13dEJrZ0VoRUF3eUMwR1RBU0VRRERFTFFaUUJJUkFNTUF0QmxRRWhFQXd2QzBHV0FTRVFEQzRMUVpjQklSQU1MUXRCbUFFaEVBd3NDMEdaQVNFUURDc0xRWm9CSVJBTUtndEJtd0VoRUF3cEMwR2NBU0VRRENnTFFaMEJJUkFNSnd0Qm5nRWhFQXdtQzBHZkFTRVFEQ1VMUWFBQklSQU1KQXRCb1FFaEVBd2pDMEdpQVNFUURDSUxRYU1CSVJBTUlRdEJwQUVoRUF3Z0MwR2xBU0VRREI4TFFhWUJJUkFNSGd0QnB3RWhFQXdkQzBHb0FTRVFEQndMUWFrQklSQU1Hd3RCcWdFaEVBd2FDMEdyQVNFUURCa0xRYXdCSVJBTUdBdEJyUUVoRUF3WEMwR3VBU0VRREJZTFFRRWhFQXdWQzBHdkFTRVFEQlFMUWJBQklSQU1Fd3RCc1FFaEVBd1NDMEd6QVNFUURCRUxRYklCSVJBTUVBdEJ0QUVoRUF3UEMwRzFBU0VRREE0TFFiWUJJUkFNRFF0QnR3RWhFQXdNQzBHNEFTRVFEQXNMUWJrQklSQU1DZ3RCdWdFaEVBd0pDMEc3QVNFUURBZ0xRY1lCSVJBTUJ3dEJ2QUVoRUF3R0MwRzlBU0VRREFVTFFiNEJJUkFNQkF0QnZ3RWhFQXdEQzBIQUFTRVFEQUlMUWNJQklSQU1BUXRCd1FFaEVBc0RRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUJBT3h3RUFBUUlEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdSb2JIQjRmSUNFakpTZy9RRUZFUlVaSFNFbEtTMHhOVDFCUlVsUGVBMWRaVzF4ZFlHSmxabWRvYVdwcmJHMXZjSEZ5YzNSMWRuZDRlWHA3ZkgxK2dBR0NBWVVCaGdHSEFZa0Jpd0dNQVkwQmpnR1BBWkFCa1FHVUFaVUJsZ0dYQVpnQm1RR2FBWnNCbkFHZEFaNEJud0dnQWFFQm9nR2pBYVFCcFFHbUFhY0JxQUdwQWFvQnF3R3NBYTBCcmdHdkFiQUJzUUd5QWJNQnRBRzFBYllCdHdHNEFia0J1Z0c3QWJ3QnZRRytBYjhCd0FIQkFjSUJ3d0hFQWNVQnhnSEhBY2dCeVFIS0Fjc0J6QUhOQWM0Qnp3SFFBZEVCMGdIVEFkUUIxUUhXQWRjQjJBSFpBZG9CMndIY0FkMEIzZ0hnQWVFQjRnSGpBZVFCNVFIbUFlY0I2QUhwQWVvQjZ3SHNBZTBCN2dIdkFmQUI4UUh5QWZNQm1RS2tBckFDL2dMK0Fnc2dBU0lFSUFKSERmTUJRZDBCSVJBTS93TUxJQUVpRUNBQ1J3M2RBVUhEQVNFUURQNERDeUFCSWdFZ0FrY05rQUZCOXdBaEVBejlBd3NnQVNJQklBSkhEWVlCUWU4QUlSQU0vQU1MSUFFaUFTQUNSdzEvUWVvQUlSQU0rd01MSUFFaUFTQUNSdzE3UWVnQUlSQU0rZ01MSUFFaUFTQUNSdzE0UWVZQUlSQU0rUU1MSUFFaUFTQUNSdzBhUVJnaEVBejRBd3NnQVNJQklBSkhEUlJCRWlFUURQY0RDeUFCSWdFZ0FrY05XVUhGQUNFUURQWURDeUFCSWdFZ0FrY05Ta0UvSVJBTTlRTUxJQUVpQVNBQ1J3MUlRVHdoRUF6MEF3c2dBU0lCSUFKSERVRkJNU0VRRFBNREN5QUFMUUF1UVFGR0Rlc0RESWNDQ3lBQUlBRWlBU0FDRU1DQWdJQUFRUUZIRGVZQklBQkNBRGNESUF6bkFRc2dBQ0FCSWdFZ0FoQzBnSUNBQUNJUURlY0JJQUVoQVF6MUFnc0NRQ0FCSWdFZ0FrY05BRUVHSVJBTThBTUxJQUFnQVVFQmFpSUJJQUlRdTRDQWdBQWlFQTNvQVNBQklRRU1NUXNnQUVJQU53TWdRUkloRUF6VkF3c2dBU0lRSUFKSERTdEJIU0VRRE8wREN3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFVRVFJUkFNMUFNTFFRY2hFQXpzQXdzZ0FFSUFJQUFwQXlBaUVTQUNJQUVpRUd1dEloSjlJaE1nRXlBUlZoczNBeUFnRVNBU1ZpSVVSUTNsQVVFSUlSQU02d01MQWtBZ0FTSUJJQUpHRFFBZ0FFR0pnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJRUlFoRUF6U0F3dEJDU0VRRE9vREN5QUJJUUVnQUNrRElGQU41QUVnQVNFQkRQSUNDd0pBSUFFaUFTQUNSdzBBUVFzaEVBenBBd3NnQUNBQlFRRnFJZ0VnQWhDMmdJQ0FBQ0lRRGVVQklBRWhBUXp5QWdzZ0FDQUJJZ0VnQWhDNGdJQ0FBQ0lRRGVVQklBRWhBUXp5QWdzZ0FDQUJJZ0VnQWhDNGdJQ0FBQ0lRRGVZQklBRWhBUXdOQ3lBQUlBRWlBU0FDRUxxQWdJQUFJaEFONXdFZ0FTRUJEUEFDQ3dKQUlBRWlBU0FDUncwQVFROGhFQXpsQXdzZ0FTMEFBQ0lRUVR0R0RRZ2dFRUVOUnczb0FTQUJRUUZxSVFFTTd3SUxJQUFnQVNJQklBSVF1b0NBZ0FBaUVBM29BU0FCSVFFTThnSUxBMEFDUUNBQkxRQUFRZkMxZ0lBQWFpMEFBQ0lRUVFGR0RRQWdFRUVDUnczckFTQUFLQUlFSVJBZ0FFRUFOZ0lFSUFBZ0VDQUJRUUZxSWdFUXVZQ0FnQUFpRUEzcUFTQUJJUUVNOUFJTElBRkJBV29pQVNBQ1J3MEFDMEVTSVJBTTRnTUxJQUFnQVNJQklBSVF1b0NBZ0FBaUVBM3BBU0FCSVFFTUNnc2dBU0lCSUFKSERRWkJHeUVRRE9BREN3SkFJQUVpQVNBQ1J3MEFRUlloRUF6Z0F3c2dBRUdLZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBQ0FCSUFJUXVJQ0FnQUFpRUEzcUFTQUJJUUZCSUNFUURNWURDd0pBSUFFaUFTQUNSZzBBQTBBQ1FDQUJMUUFBUWZDM2dJQUFhaTBBQUNJUVFRSkdEUUFDUUNBUVFYOXFEZ1RsQWV3QkFPc0I3QUVMSUFGQkFXb2hBVUVJSVJBTXlBTUxJQUZCQVdvaUFTQUNSdzBBQzBFVklSQU0zd01MUVJVaEVBemVBd3NEUUFKQUlBRXRBQUJCOExtQWdBQnFMUUFBSWhCQkFrWU5BQ0FRUVg5cURnVGVBZXdCNEFIckFld0JDeUFCUVFGcUlnRWdBa2NOQUF0QkdDRVFETjBEQ3dKQUlBRWlBU0FDUmcwQUlBQkJpNENBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUVISVJBTXhBTUxRUmtoRUF6Y0F3c2dBVUVCYWlFQkRBSUxBa0FnQVNJVUlBSkhEUUJCR2lFUUROc0RDeUFVSVFFQ1FDQVVMUUFBUVhOcURoVGRBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBZ0R1QWd0QkFDRVFJQUJCQURZQ0hDQUFRYStMZ0lBQU5nSVFJQUJCQWpZQ0RDQUFJQlJCQVdvMkFoUU0yZ01MQWtBZ0FTMEFBQ0lRUVR0R0RRQWdFRUVOUnczb0FTQUJRUUZxSVFFTTVRSUxJQUZCQVdvaEFRdEJJaUVRREw4REN3SkFJQUVpRUNBQ1J3MEFRUndoRUF6WUF3dENBQ0VSSUJBaEFTQVFMUUFBUVZCcURqZm5BZVlCQVFJREJBVUdCd2dBQUFBQUFBQUFDUW9MREEwT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUEVCRVNFeFFBQzBFZUlSQU12UU1MUWdJaEVRemxBUXRDQXlFUkRPUUJDMElFSVJFTTR3RUxRZ1VoRVF6aUFRdENCaUVSRE9FQkMwSUhJUkVNNEFFTFFnZ2hFUXpmQVF0Q0NTRVJETjRCQzBJS0lSRU0zUUVMUWdzaEVRemNBUXRDRENFUkROc0JDMElOSVJFTTJnRUxRZzRoRVF6WkFRdENEeUVSRE5nQkMwSUtJUkVNMXdFTFFnc2hFUXpXQVF0Q0RDRVJETlVCQzBJTklSRU0xQUVMUWc0aEVRelRBUXRDRHlFUkROSUJDMElBSVJFQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQkF0QUFCQlVHb09OK1VCNUFFQUFRSURCQVVHQitZQjVnSG1BZVlCNWdIbUFlWUJDQWtLQ3d3TjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQVE0UEVCRVNFK1lCQzBJQ0lSRU01QUVMUWdNaEVRempBUXRDQkNFUkRPSUJDMElGSVJFTTRRRUxRZ1loRVF6Z0FRdENCeUVSRE44QkMwSUlJUkVNM2dFTFFna2hFUXpkQVF0Q0NpRVJETndCQzBJTElSRU0yd0VMUWd3aEVRemFBUXRDRFNFUkROa0JDMElPSVJFTTJBRUxRZzhoRVF6WEFRdENDaUVSRE5ZQkMwSUxJUkVNMVFFTFFnd2hFUXpVQVF0Q0RTRVJETk1CQzBJT0lSRU0wZ0VMUWc4aEVRelJBUXNnQUVJQUlBQXBBeUFpRVNBQ0lBRWlFR3V0SWhKOUloTWdFeUFSVmhzM0F5QWdFU0FTVmlJVVJRM1NBVUVmSVJBTXdBTUxBa0FnQVNJQklBSkdEUUFnQUVHSmdJQ0FBRFlDQ0NBQUlBRTJBZ1FnQVNFQlFTUWhFQXluQXd0QklDRVFETDhEQ3lBQUlBRWlFQ0FDRUw2QWdJQUFRWDlxRGdXMkFRREZBZ0hSQWRJQkMwRVJJUkFNcEFNTElBQkJBVG9BTHlBUUlRRU11d01MSUFFaUFTQUNSdzNTQVVFa0lSQU11d01MSUFFaURTQUNSdzBlUWNZQUlSQU11Z01MSUFBZ0FTSUJJQUlRc29DQWdBQWlFQTNVQVNBQklRRU10UUVMSUFFaUVDQUNSdzBtUWRBQUlSQU11QU1MQWtBZ0FTSUJJQUpIRFFCQktDRVFETGdEQ3lBQVFRQTJBZ1FnQUVHTWdJQ0FBRFlDQ0NBQUlBRWdBUkN4Z0lDQUFDSVFEZE1CSUFFaEFRellBUXNDUUNBQkloQWdBa2NOQUVFcElSQU10d01MSUJBdEFBQWlBVUVnUmcwVUlBRkJDVWNOMHdFZ0VFRUJhaUVCREJVTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRCY0xRU29oRUF5MUF3c0NRQ0FCSWhBZ0FrY05BRUVySVJBTXRRTUxBa0FnRUMwQUFDSUJRUWxHRFFBZ0FVRWdSdzNWQVFzZ0FDMEFMRUVJUmczVEFTQVFJUUVNa1FNTEFrQWdBU0lCSUFKSERRQkJMQ0VRRExRREN5QUJMUUFBUVFwSERkVUJJQUZCQVdvaEFRekpBZ3NnQVNJT0lBSkhEZFVCUVM4aEVBeXlBd3NEUUFKQUlBRXRBQUFpRUVFZ1JnMEFBa0FnRUVGMmFnNEVBTndCM0FFQTJnRUxJQUVoQVF6Z0FRc2dBVUVCYWlJQklBSkhEUUFMUVRFaEVBeXhBd3RCTWlFUUlBRWlGQ0FDUmcyd0F5QUNJQlJySUFBb0FnQWlBV29oRlNBVUlBRnJRUU5xSVJZQ1FBTkFJQlF0QUFBaUYwRWdjaUFYSUJkQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQjhMdUFnQUJxTFFBQVJ3MEJBa0FnQVVFRFJ3MEFRUVloQVF5V0F3c2dBVUVCYWlFQklCUkJBV29pRkNBQ1J3MEFDeUFBSUJVMkFnQU1zUU1MSUFCQkFEWUNBQ0FVSVFFTTJRRUxRVE1oRUNBQkloUWdBa1lOcndNZ0FpQVVheUFBS0FJQUlnRnFJUlVnRkNBQmEwRUlhaUVXQWtBRFFDQVVMUUFBSWhkQklISWdGeUFYUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWZTN2dJQUFhaTBBQUVjTkFRSkFJQUZCQ0VjTkFFRUZJUUVNbFFNTElBRkJBV29oQVNBVVFRRnFJaFFnQWtjTkFBc2dBQ0FWTmdJQURMQURDeUFBUVFBMkFnQWdGQ0VCRE5nQkMwRTBJUkFnQVNJVUlBSkdEYTRESUFJZ0ZHc2dBQ2dDQUNJQmFpRVZJQlFnQVd0QkJXb2hGZ0pBQTBBZ0ZDMEFBQ0lYUVNCeUlCY2dGMEcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUhRd29DQUFHb3RBQUJIRFFFQ1FDQUJRUVZIRFFCQkJ5RUJESlFEQ3lBQlFRRnFJUUVnRkVFQmFpSVVJQUpIRFFBTElBQWdGVFlDQUF5dkF3c2dBRUVBTmdJQUlCUWhBUXpYQVFzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFFR0F2b0NBQUdvdEFBQWlFRUVCUmcwQUlCQkJBa1lOQ2lBQklRRU0zUUVMSUFGQkFXb2lBU0FDUncwQUMwRXdJUkFNcmdNTFFUQWhFQXl0QXdzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFDSVFRU0JHRFFBZ0VFRjJhZzRFMlFIYUFkb0IyUUhhQVFzZ0FVRUJhaUlCSUFKSERRQUxRVGdoRUF5dEF3dEJPQ0VRREt3REN3TkFBa0FnQVMwQUFDSVFRU0JHRFFBZ0VFRUpSdzBEQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQQ0VRREtzREN3TkFBa0FnQVMwQUFDSVFRU0JHRFFBQ1FBSkFJQkJCZG1vT0JOb0JBUUhhQVFBTElCQkJMRVlOMndFTElBRWhBUXdFQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQeUVRREtvREN5QUJJUUVNMndFTFFjQUFJUkFnQVNJVUlBSkdEYWdESUFJZ0ZHc2dBQ2dDQUNJQmFpRVdJQlFnQVd0QkJtb2hGd0pBQTBBZ0ZDMEFBRUVnY2lBQlFZREFnSUFBYWkwQUFFY05BU0FCUVFaR0RZNERJQUZCQVdvaEFTQVVRUUZxSWhRZ0FrY05BQXNnQUNBV05nSUFES2tEQ3lBQVFRQTJBZ0FnRkNFQkMwRTJJUkFNamdNTEFrQWdBU0lQSUFKSERRQkJ3UUFoRUF5bkF3c2dBRUdNZ0lDQUFEWUNDQ0FBSUE4MkFnUWdEeUVCSUFBdEFDeEJmMm9PQk0wQjFRSFhBZGtCaHdNTElBRkJBV29oQVF6TUFRc0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBQ0lRUVNCeUlCQWdFRUcvZjJwQi93RnhRUnBKRzBIL0FYRWlFRUVKUmcwQUlCQkJJRVlOQUFKQUFrQUNRQUpBSUJCQm5YOXFEaE1BQXdNREF3TURBd0VEQXdNREF3TURBd01DQXdzZ0FVRUJhaUVCUVRFaEVBeVJBd3NnQVVFQmFpRUJRVEloRUF5UUF3c2dBVUVCYWlFQlFUTWhFQXlQQXdzZ0FTRUJETkFCQ3lBQlFRRnFJZ0VnQWtjTkFBdEJOU0VRREtVREMwRTFJUkFNcEFNTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQkJnTHlBZ0FCcUxRQUFRUUZHRFFBZ0FTRUJETk1CQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQU0VRREtRREMwRTlJUkFNb3dNTElBQWdBU0lCSUFJUXNJQ0FnQUFpRUEzV0FTQUJJUUVNQVFzZ0VFRUJhaUVCQzBFOElSQU1od01MQWtBZ0FTSUJJQUpIRFFCQndnQWhFQXlnQXdzQ1FBTkFBa0FnQVMwQUFFRjNhZzRZQUFMK0F2NENoQVArQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0lBL2dJTElBRkJBV29pQVNBQ1J3MEFDMEhDQUNFUURLQURDeUFCUVFGcUlRRWdBQzBBTFVFQmNVVU52UUVnQVNFQkMwRXNJUkFNaFFNTElBRWlBU0FDUnczVEFVSEVBQ0VRREowREN3TkFBa0FnQVMwQUFFR1F3SUNBQUdvdEFBQkJBVVlOQUNBQklRRU10d0lMSUFGQkFXb2lBU0FDUncwQUMwSEZBQ0VRREp3REN5QU5MUUFBSWhCQklFWU5zd0VnRUVFNlJ3MkJBeUFBS0FJRUlRRWdBRUVBTmdJRUlBQWdBU0FORUsrQWdJQUFJZ0VOMEFFZ0RVRUJhaUVCRExNQ0MwSEhBQ0VRSUFFaURTQUNSZzJhQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRVnFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRWkRDZ0lBQWFpMEFBRWNOZ0FNZ0FVRUZSZzMwQWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5YUF3dEJ5QUFoRUNBQklnMGdBa1lObVFNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRUphaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUdXd29DQUFHb3RBQUJIRGY4Q0FrQWdBVUVKUncwQVFRSWhBUXoxQWdzZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTW1RTUxBa0FnQVNJTklBSkhEUUJCeVFBaEVBeVpBd3NDUUFKQUlBMHRBQUFpQVVFZ2NpQUJJQUZCdjM5cVFmOEJjVUVhU1J0Qi93RnhRWkovYWc0SEFJQURnQU9BQTRBRGdBTUJnQU1MSUExQkFXb2hBVUUrSVJBTWdBTUxJQTFCQVdvaEFVRS9JUkFNL3dJTFFjb0FJUkFnQVNJTklBSkdEWmNESUFJZ0RXc2dBQ2dDQUNJQmFpRVdJQTBnQVd0QkFXb2hGd05BSUEwdEFBQWlGRUVnY2lBVUlCUkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJvTUtBZ0FCcUxRQUFSdzM5QWlBQlFRRkdEZkFDSUFGQkFXb2hBU0FOUVFGcUlnMGdBa2NOQUFzZ0FDQVdOZ0lBREpjREMwSExBQ0VRSUFFaURTQUNSZzJXQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRNXFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRYUxDZ0lBQWFpMEFBRWNOL0FJZ0FVRU9SZzN3QWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5V0F3dEJ6QUFoRUNBQklnMGdBa1lObFFNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRVBhaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUhBd29DQUFHb3RBQUJIRGZzQ0FrQWdBVUVQUncwQVFRTWhBUXp4QWdzZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTWxRTUxRYzBBSVJBZ0FTSU5JQUpHRFpRRElBSWdEV3NnQUNnQ0FDSUJhaUVXSUEwZ0FXdEJCV29oRndOQUlBMHRBQUFpRkVFZ2NpQVVJQlJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCME1LQWdBQnFMUUFBUnczNkFnSkFJQUZCQlVjTkFFRUVJUUVNOEFJTElBRkJBV29oQVNBTlFRRnFJZzBnQWtjTkFBc2dBQ0FXTmdJQURKUURDd0pBSUFFaURTQUNSdzBBUWM0QUlSQU1sQU1MQWtBQ1FBSkFBa0FnRFMwQUFDSUJRU0J5SUFFZ0FVRy9mMnBCL3dGeFFScEpHMEgvQVhGQm5YOXFEaE1BL1FMOUF2MEMvUUw5QXYwQy9RTDlBdjBDL1FMOUF2MENBZjBDL1FMOUFnSUQvUUlMSUExQkFXb2hBVUhCQUNFUURQMENDeUFOUVFGcUlRRkJ3Z0FoRUF6OEFnc2dEVUVCYWlFQlFjTUFJUkFNK3dJTElBMUJBV29oQVVIRUFDRVFEUG9DQ3dKQUlBRWlBU0FDUmcwQUlBQkJqWUNBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUhGQUNFUURQb0NDMEhQQUNFUURKSURDeUFRSVFFQ1FBSkFJQkF0QUFCQmRtb09CQUdvQXFnQ0FLZ0NDeUFRUVFGcUlRRUxRU2NoRUF6NEFnc0NRQ0FCSWdFZ0FrY05BRUhSQUNFUURKRURDd0pBSUFFdEFBQkJJRVlOQUNBQklRRU1qUUVMSUFGQkFXb2hBU0FBTFFBdFFRRnhSUTNIQVNBQklRRU1qQUVMSUFFaUZ5QUNSdzNJQVVIU0FDRVFESThEQzBIVEFDRVFJQUVpRkNBQ1JnMk9BeUFDSUJScklBQW9BZ0FpQVdvaEZpQVVJQUZyUVFGcUlSY0RRQ0FVTFFBQUlBRkIxc0tBZ0FCcUxRQUFSdzNNQVNBQlFRRkdEY2NCSUFGQkFXb2hBU0FVUVFGcUloUWdBa2NOQUFzZ0FDQVdOZ0lBREk0REN3SkFJQUVpQVNBQ1J3MEFRZFVBSVJBTWpnTUxJQUV0QUFCQkNrY056QUVnQVVFQmFpRUJETWNCQ3dKQUlBRWlBU0FDUncwQVFkWUFJUkFNalFNTEFrQUNRQ0FCTFFBQVFYWnFEZ1FBelFITkFRSE5BUXNnQVVFQmFpRUJETWNCQ3lBQlFRRnFJUUZCeWdBaEVBenpBZ3NnQUNBQklnRWdBaEN1Z0lDQUFDSVFEY3NCSUFFaEFVSE5BQ0VRRFBJQ0N5QUFMUUFwUVNKR0RZVURES1lDQ3dKQUlBRWlBU0FDUncwQVFkc0FJUkFNaWdNTFFRQWhGRUVCSVJkQkFTRVdRUUFoRUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRVkJxRGdyVUFkTUJBQUVDQXdRRkJnalZBUXRCQWlFUURBWUxRUU1oRUF3RkMwRUVJUkFNQkF0QkJTRVFEQU1MUVFZaEVBd0NDMEVISVJBTUFRdEJDQ0VRQzBFQUlSZEJBQ0VXUVFBaEZBek1BUXRCQ1NFUVFRRWhGRUVBSVJkQkFDRVdETXNCQ3dKQUlBRWlBU0FDUncwQVFkMEFJUkFNaVFNTElBRXRBQUJCTGtjTnpBRWdBVUVCYWlFQkRLWUNDeUFCSWdFZ0FrY056QUZCM3dBaEVBeUhBd3NDUUNBQklnRWdBa1lOQUNBQVFZNkFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkIwQUFoRUF6dUFndEI0QUFoRUF5R0F3dEI0UUFoRUNBQklnRWdBa1lOaFFNZ0FpQUJheUFBS0FJQUloUnFJUllnQVNBVWEwRURhaUVYQTBBZ0FTMEFBQ0FVUWVMQ2dJQUFhaTBBQUVjTnpRRWdGRUVEUmczTUFTQVVRUUZxSVJRZ0FVRUJhaUlCSUFKSERRQUxJQUFnRmpZQ0FBeUZBd3RCNGdBaEVDQUJJZ0VnQWtZTmhBTWdBaUFCYXlBQUtBSUFJaFJxSVJZZ0FTQVVhMEVDYWlFWEEwQWdBUzBBQUNBVVFlYkNnSUFBYWkwQUFFY056QUVnRkVFQ1JnM09BU0FVUVFGcUlSUWdBVUVCYWlJQklBSkhEUUFMSUFBZ0ZqWUNBQXlFQXd0QjR3QWhFQ0FCSWdFZ0FrWU5nd01nQWlBQmF5QUFLQUlBSWhScUlSWWdBU0FVYTBFRGFpRVhBMEFnQVMwQUFDQVVRZW5DZ0lBQWFpMEFBRWNOeXdFZ0ZFRURSZzNPQVNBVVFRRnFJUlFnQVVFQmFpSUJJQUpIRFFBTElBQWdGallDQUF5REF3c0NRQ0FCSWdFZ0FrY05BRUhsQUNFUURJTURDeUFBSUFGQkFXb2lBU0FDRUtpQWdJQUFJaEFOelFFZ0FTRUJRZFlBSVJBTTZRSUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUFpRUVFZ1JnMEFBa0FDUUFKQUlCQkJ1SDlxRGdzQUFjOEJ6d0hQQWM4Qnp3SFBBYzhCendFQ3p3RUxJQUZCQVdvaEFVSFNBQ0VRRE8wQ0N5QUJRUUZxSVFGQjB3QWhFQXpzQWdzZ0FVRUJhaUVCUWRRQUlSQU02d0lMSUFGQkFXb2lBU0FDUncwQUMwSGtBQ0VRRElJREMwSGtBQ0VRRElFREN3TkFBa0FnQVMwQUFFSHd3b0NBQUdvdEFBQWlFRUVCUmcwQUlCQkJmbW9PQTg4QjBBSFJBZElCQ3lBQlFRRnFJZ0VnQWtjTkFBdEI1Z0FoRUF5QUF3c0NRQ0FCSWdFZ0FrWU5BQ0FCUVFGcUlRRU1Bd3RCNXdBaEVBei9BZ3NEUUFKQUlBRXRBQUJCOE1TQWdBQnFMUUFBSWhCQkFVWU5BQUpBSUJCQmZtb09CTklCMHdIVUFRRFZBUXNnQVNFQlFkY0FJUkFNNXdJTElBRkJBV29pQVNBQ1J3MEFDMEhvQUNFUURQNENDd0pBSUFFaUFTQUNSdzBBUWVrQUlSQU0vZ0lMQWtBZ0FTMEFBQ0lRUVhacURocTZBZFVCMVFHOEFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFjb0IxUUhWQVFEVEFRc2dBVUVCYWlFQkMwRUdJUkFNNHdJTEEwQUNRQ0FCTFFBQVFmREdnSUFBYWkwQUFFRUJSZzBBSUFFaEFReWVBZ3NnQVVFQmFpSUJJQUpIRFFBTFFlb0FJUkFNK3dJTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRBTUxRZXNBSVJBTStnSUxBa0FnQVNJQklBSkhEUUJCN0FBaEVBejZBZ3NnQVVFQmFpRUJEQUVMQWtBZ0FTSUJJQUpIRFFCQjdRQWhFQXo1QWdzZ0FVRUJhaUVCQzBFRUlSQU0zZ0lMQWtBZ0FTSVVJQUpIRFFCQjdnQWhFQXozQWdzZ0ZDRUJBa0FDUUFKQUlCUXRBQUJCOE1pQWdBQnFMUUFBUVg5cURnZlVBZFVCMWdFQW5BSUJBdGNCQ3lBVVFRRnFJUUVNQ2dzZ0ZFRUJhaUVCRE0wQkMwRUFJUkFnQUVFQU5nSWNJQUJCbTVLQWdBQTJBaEFnQUVFSE5nSU1JQUFnRkVFQmFqWUNGQXoyQWdzQ1FBTkFBa0FnQVMwQUFFSHd5SUNBQUdvdEFBQWlFRUVFUmcwQUFrQUNRQ0FRUVg5cURnZlNBZE1CMUFIWkFRQUVBZGtCQ3lBQklRRkIyZ0FoRUF6Z0Fnc2dBVUVCYWlFQlFkd0FJUkFNM3dJTElBRkJBV29pQVNBQ1J3MEFDMEh2QUNFUURQWUNDeUFCUVFGcUlRRU15d0VMQWtBZ0FTSVVJQUpIRFFCQjhBQWhFQXoxQWdzZ0ZDMEFBRUV2UnczVUFTQVVRUUZxSVFFTUJnc0NRQ0FCSWhRZ0FrY05BRUh4QUNFUURQUUNDd0pBSUJRdEFBQWlBVUV2UncwQUlCUkJBV29oQVVIZEFDRVFETnNDQ3lBQlFYWnFJZ1JCRmtzTjB3RkJBU0FFZEVHSmdJQUNjVVVOMHdFTXlnSUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJRZDRBSVJBTTJnSUxRZklBSVJBTThnSUxBa0FnQVNJVUlBSkhEUUJCOUFBaEVBenlBZ3NnRkNFQkFrQWdGQzBBQUVId3pJQ0FBR290QUFCQmYyb09BOGtDbEFJQTFBRUxRZUVBSVJBTTJBSUxBa0FnQVNJVUlBSkdEUUFEUUFKQUlCUXRBQUJCOE1xQWdBQnFMUUFBSWdGQkEwWU5BQUpBSUFGQmYyb09Bc3NDQU5VQkN5QVVJUUZCM3dBaEVBemFBZ3NnRkVFQmFpSVVJQUpIRFFBTFFmTUFJUkFNOFFJTFFmTUFJUkFNOEFJTEFrQWdBU0lCSUFKR0RRQWdBRUdQZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCUWVBQUlSQU0xd0lMUWZVQUlSQU03d0lMQWtBZ0FTSUJJQUpIRFFCQjlnQWhFQXp2QWdzZ0FFR1BnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJDMEVESVJBTTFBSUxBMEFnQVMwQUFFRWdSdzNEQWlBQlFRRnFJZ0VnQWtjTkFBdEI5d0FoRUF6c0Fnc0NRQ0FCSWdFZ0FrY05BRUg0QUNFUURPd0NDeUFCTFFBQVFTQkhEYzRCSUFGQkFXb2hBUXp2QVFzZ0FDQUJJZ0VnQWhDc2dJQ0FBQ0lRRGM0QklBRWhBUXlPQWdzQ1FDQUJJZ1FnQWtjTkFFSDZBQ0VRRE9vQ0N5QUVMUUFBUWN3QVJ3M1JBU0FFUVFGcUlRRkJFeUVRRE04QkN3SkFJQUVpQkNBQ1J3MEFRZnNBSVJBTTZRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQldvaEVBTkFJQVF0QUFBZ0FVSHd6b0NBQUdvdEFBQkhEZEFCSUFGQkJVWU56Z0VnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCK3dBaEVBem9BZ3NDUUNBQklnUWdBa2NOQUVIOEFDRVFET2dDQ3dKQUFrQWdCQzBBQUVHOWYyb09EQURSQWRFQjBRSFJBZEVCMFFIUkFkRUIwUUhSQVFIUkFRc2dCRUVCYWlFQlFlWUFJUkFNendJTElBUkJBV29oQVVIbkFDRVFETTRDQ3dKQUlBRWlCQ0FDUncwQVFmMEFJUkFNNXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBbW9oRUFKQUEwQWdCQzBBQUNBQlFlM1BnSUFBYWkwQUFFY056d0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjBBSVJBTTV3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQkVDRVFETXdCQ3dKQUlBRWlCQ0FDUncwQVFmNEFJUkFNNWdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCV29oRUFKQUEwQWdCQzBBQUNBQlFmYk9nSUFBYWkwQUFFY056Z0VnQVVFRlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjRBSVJBTTVnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkZpRVFETXNCQ3dKQUlBRWlCQ0FDUncwQVFmOEFJUkFNNVFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBMm9oRUFKQUEwQWdCQzBBQUNBQlFmek9nSUFBYWkwQUFFY056UUVnQVVFRFJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjhBSVJBTTVRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkJTRVFETW9CQ3dKQUlBRWlCQ0FDUncwQVFZQUJJUkFNNUFJTElBUXRBQUJCMlFCSERjc0JJQVJCQVdvaEFVRUlJUkFNeVFFTEFrQWdBU0lFSUFKSERRQkJnUUVoRUF6akFnc0NRQUpBSUFRdEFBQkJzbjlxRGdNQXpBRUJ6QUVMSUFSQkFXb2hBVUhyQUNFUURNb0NDeUFFUVFGcUlRRkI3QUFoRUF6SkFnc0NRQ0FCSWdRZ0FrY05BRUdDQVNFUURPSUNDd0pBQWtBZ0JDMEFBRUc0ZjJvT0NBRExBY3NCeXdITEFjc0J5d0VCeXdFTElBUkJBV29oQVVIcUFDRVFETWtDQ3lBRVFRRnFJUUZCN1FBaEVBeklBZ3NDUUNBQklnUWdBa2NOQUVHREFTRVFET0VDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hFQ0FFSUFGclFRSnFJUlFDUUFOQUlBUXRBQUFnQVVHQXo0Q0FBR290QUFCSERja0JJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRURZQ0FFR0RBU0VRRE9FQ0MwRUFJUkFnQUVFQU5nSUFJQlJCQVdvaEFRekdBUXNDUUNBQklnUWdBa2NOQUVHRUFTRVFET0FDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRUnFJUkFDUUFOQUlBUXRBQUFnQVVHRHo0Q0FBR290QUFCSERjZ0JJQUZCQkVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR0VBU0VRRE9BQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVNNaEVBekZBUXNDUUNBQklnUWdBa2NOQUVHRkFTRVFETjhDQ3dKQUFrQWdCQzBBQUVHMGYyb09DQURJQWNnQnlBSElBY2dCeUFFQnlBRUxJQVJCQVdvaEFVSHZBQ0VRRE1ZQ0N5QUVRUUZxSVFGQjhBQWhFQXpGQWdzQ1FDQUJJZ1FnQWtjTkFFR0dBU0VRRE40Q0N5QUVMUUFBUWNVQVJ3M0ZBU0FFUVFGcUlRRU1nd0lMQWtBZ0FTSUVJQUpIRFFCQmh3RWhFQXpkQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRURhaUVRQWtBRFFDQUVMUUFBSUFGQmlNK0FnQUJxTFFBQVJ3M0ZBU0FCUVFOR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJod0VoRUF6ZEFnc2dBRUVBTmdJQUlCQkJBV29oQVVFdElSQU13Z0VMQWtBZ0FTSUVJQUpIRFFCQmlBRWhFQXpjQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUlhaUVRQWtBRFFDQUVMUUFBSUFGQjBNK0FnQUJxTFFBQVJ3M0VBU0FCUVFoR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJpQUVoRUF6Y0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFcElSQU13UUVMQWtBZ0FTSUJJQUpIRFFCQmlRRWhFQXpiQWd0QkFTRVFJQUV0QUFCQjN3QkhEY0FCSUFGQkFXb2hBUXlCQWdzQ1FDQUJJZ1FnQWtjTkFFR0tBU0VRRE5vQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBRFFDQUVMUUFBSUFGQmpNK0FnQUJxTFFBQVJ3M0JBU0FCUVFGR0RhOENJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWW9CSVJBTTJRSUxBa0FnQVNJRUlBSkhEUUJCaXdFaEVBelpBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQ2FpRVFBa0FEUUNBRUxRQUFJQUZCanMrQWdBQnFMUUFBUnczQkFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQml3RWhFQXpaQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVDSVJBTXZnRUxBa0FnQVNJRUlBSkhEUUJCakFFaEVBellBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCOE0rQWdBQnFMUUFBUnczQUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmpBRWhFQXpZQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVmSVJBTXZRRUxBa0FnQVNJRUlBSkhEUUJCalFFaEVBelhBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCOHMrQWdBQnFMUUFBUncyL0FTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmpRRWhFQXpYQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVKSVJBTXZBRUxBa0FnQVNJRUlBSkhEUUJCamdFaEVBeldBZ3NDUUFKQUlBUXRBQUJCdDM5cURnY0F2d0cvQWI4QnZ3Ry9BUUcvQVFzZ0JFRUJhaUVCUWZnQUlSQU12UUlMSUFSQkFXb2hBVUg1QUNFUURMd0NDd0pBSUFFaUJDQUNSdzBBUVk4QklSQU0xUUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUVpIUGdJQUFhaTBBQUVjTnZRRWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZOEJJUkFNMVFJTElBQkJBRFlDQUNBUVFRRnFJUUZCR0NFUURMb0JDd0pBSUFFaUJDQUNSdzBBUVpBQklSQU0xQUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUVpmUGdJQUFhaTBBQUVjTnZBRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaQUJJUkFNMUFJTElBQkJBRFlDQUNBUVFRRnFJUUZCRnlFUURMa0JDd0pBSUFFaUJDQUNSdzBBUVpFQklSQU0wd0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJtb2hFQUpBQTBBZ0JDMEFBQ0FCUVpyUGdJQUFhaTBBQUVjTnV3RWdBVUVHUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaRUJJUkFNMHdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRlNFUURMZ0JDd0pBSUFFaUJDQUNSdzBBUVpJQklSQU0wZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUWFIUGdJQUFhaTBBQUVjTnVnRWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaSUJJUkFNMGdJTElBQkJBRFlDQUNBUVFRRnFJUUZCSGlFUURMY0JDd0pBSUFFaUJDQUNSdzBBUVpNQklSQU0wUUlMSUFRdEFBQkJ6QUJIRGJnQklBUkJBV29oQVVFS0lSQU10Z0VMQWtBZ0JDQUNSdzBBUVpRQklSQU0wQUlMQWtBQ1FDQUVMUUFBUWI5L2FnNFBBTGtCdVFHNUFia0J1UUc1QWJrQnVRRzVBYmtCdVFHNUFia0JBYmtCQ3lBRVFRRnFJUUZCL2dBaEVBeTNBZ3NnQkVFQmFpRUJRZjhBSVJBTXRnSUxBa0FnQkNBQ1J3MEFRWlVCSVJBTXp3SUxBa0FDUUNBRUxRQUFRYjkvYWc0REFMZ0JBYmdCQ3lBRVFRRnFJUUZCL1FBaEVBeTJBZ3NnQkVFQmFpRUVRWUFCSVJBTXRRSUxBa0FnQkNBQ1J3MEFRWllCSVJBTXpnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRYWZQZ0lBQWFpMEFBRWNOdGdFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVpZQklSQU16Z0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJDeUVRRExNQkN3SkFJQVFnQWtjTkFFR1hBU0VRRE0wQ0N3SkFBa0FDUUFKQUlBUXRBQUJCVTJvT0l3QzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0JBYmdCdUFHNEFiZ0J1QUVDdUFHNEFiZ0JBN2dCQ3lBRVFRRnFJUUZCK3dBaEVBeTJBZ3NnQkVFQmFpRUJRZndBSVJBTXRRSUxJQVJCQVdvaEJFR0JBU0VRRExRQ0N5QUVRUUZxSVFSQmdnRWhFQXl6QWdzQ1FDQUVJQUpIRFFCQm1BRWhFQXpNQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQnFjK0FnQUJxTFFBQVJ3MjBBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJtQUVoRUF6TUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFWklSQU1zUUVMQWtBZ0JDQUNSdzBBUVprQklSQU15d0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUWE3UGdJQUFhaTBBQUVjTnN3RWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaa0JJUkFNeXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQmlFUURMQUJDd0pBSUFRZ0FrY05BRUdhQVNFUURNb0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQUNRQU5BSUFRdEFBQWdBVUcwejRDQUFHb3RBQUJIRGJJQklBRkJBVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHYUFTRVFETW9DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUndoRUF5dkFRc0NRQ0FFSUFKSERRQkJtd0VoRUF6SkFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUFrQURRQ0FFTFFBQUlBRkJ0cytBZ0FCcUxRQUFSdzJ4QVNBQlFRRkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCbXdFaEVBekpBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRW5JUkFNcmdFTEFrQWdCQ0FDUncwQVFad0JJUkFNeUFJTEFrQUNRQ0FFTFFBQVFheC9hZzRDQUFHeEFRc2dCRUVCYWlFRVFZWUJJUkFNcndJTElBUkJBV29oQkVHSEFTRVFESzRDQ3dKQUlBUWdBa2NOQUVHZEFTRVFETWNDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVHNHo0Q0FBR290QUFCSERhOEJJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR2RBU0VRRE1jQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVNZaEVBeXNBUXNDUUNBRUlBSkhEUUJCbmdFaEVBekdBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCdXMrQWdBQnFMUUFBUncydUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm5nRWhFQXpHQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVESVJBTXF3RUxBa0FnQkNBQ1J3MEFRWjhCSVJBTXhRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZTNQZ0lBQWFpMEFBRWNOclFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVo4QklSQU14UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJEQ0VRREtvQkN3SkFJQVFnQWtjTkFFR2dBU0VRRE1RQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUU5xSVJBQ1FBTkFJQVF0QUFBZ0FVRzh6NENBQUdvdEFBQkhEYXdCSUFGQkEwWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdnQVNFUURNUUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFRMGhFQXlwQVFzQ1FDQUVJQUpIRFFCQm9RRWhFQXpEQWdzQ1FBSkFJQVF0QUFCQnVuOXFEZ3NBckFHc0Fhd0JyQUdzQWF3QnJBR3NBYXdCQWF3QkN5QUVRUUZxSVFSQml3RWhFQXlxQWdzZ0JFRUJhaUVFUVl3QklSQU1xUUlMQWtBZ0JDQUNSdzBBUWFJQklSQU13Z0lMSUFRdEFBQkIwQUJIRGFrQklBUkJBV29oQkF6cEFRc0NRQ0FFSUFKSERRQkJvd0VoRUF6QkFnc0NRQUpBSUFRdEFBQkJ0MzlxRGdjQnFnR3FBYW9CcWdHcUFRQ3FBUXNnQkVFQmFpRUVRWTRCSVJBTXFBSUxJQVJCQVdvaEFVRWlJUkFNcGdFTEFrQWdCQ0FDUncwQVFhUUJJUkFNd0FJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFjRFBnSUFBYWkwQUFFY05xQUVnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYVFCSVJBTXdBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkhTRVFES1VCQ3dKQUlBUWdBa2NOQUVHbEFTRVFETDhDQ3dKQUFrQWdCQzBBQUVHdWYyb09Bd0NvQVFHb0FRc2dCRUVCYWlFRVFaQUJJUkFNcGdJTElBUkJBV29oQVVFRUlSQU1wQUVMQWtBZ0JDQUNSdzBBUWFZQklSQU12Z0lMQWtBQ1FBSkFBa0FDUUNBRUxRQUFRYjkvYWc0VkFLb0JxZ0dxQWFvQnFnR3FBYW9CcWdHcUFhb0JBYW9CcWdFQ3FnR3FBUU9xQWFvQkJLb0JDeUFFUVFGcUlRUkJpQUVoRUF5b0Fnc2dCRUVCYWlFRVFZa0JJUkFNcHdJTElBUkJBV29oQkVHS0FTRVFES1lDQ3lBRVFRRnFJUVJCandFaEVBeWxBZ3NnQkVFQmFpRUVRWkVCSVJBTXBBSUxBa0FnQkNBQ1J3MEFRYWNCSVJBTXZRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZTNQZ0lBQWFpMEFBRWNOcFFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWFjQklSQU12UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJFU0VRREtJQkN3SkFJQVFnQWtjTkFFR29BU0VRREx3Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSEN6NENBQUdvdEFBQkhEYVFCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdvQVNFUURMd0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFTd2hFQXloQVFzQ1FDQUVJQUpIRFFCQnFRRWhFQXk3QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQnhjK0FnQUJxTFFBQVJ3MmpBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJxUUVoRUF5N0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFcklSQU1vQUVMQWtBZ0JDQUNSdzBBUWFvQklSQU11Z0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUWNyUGdJQUFhaTBBQUVjTm9nRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFhb0JJUkFNdWdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRkNFUURKOEJDd0pBSUFRZ0FrY05BRUdyQVNFUURMa0NDd0pBQWtBQ1FBSkFJQVF0QUFCQnZuOXFEZzhBQVFLa0FhUUJwQUdrQWFRQnBBR2tBYVFCcEFHa0FhUUJBNlFCQ3lBRVFRRnFJUVJCa3dFaEVBeWlBZ3NnQkVFQmFpRUVRWlFCSVJBTW9RSUxJQVJCQVdvaEJFR1ZBU0VRREtBQ0N5QUVRUUZxSVFSQmxnRWhFQXlmQWdzQ1FDQUVJQUpIRFFCQnJBRWhFQXk0QWdzZ0JDMEFBRUhGQUVjTm53RWdCRUVCYWlFRURPQUJDd0pBSUFRZ0FrY05BRUd0QVNFUURMY0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUhOejRDQUFHb3RBQUJIRFo4QklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHdEFTRVFETGNDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUTRoRUF5Y0FRc0NRQ0FFSUFKSERRQkJyZ0VoRUF5MkFnc2dCQzBBQUVIUUFFY05uUUVnQkVFQmFpRUJRU1VoRUF5YkFRc0NRQ0FFSUFKSERRQkJyd0VoRUF5MUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVJYWlFUUFrQURRQ0FFTFFBQUlBRkIwTStBZ0FCcUxRQUFSdzJkQVNBQlFRaEdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCcndFaEVBeTFBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRXFJUkFNbWdFTEFrQWdCQ0FDUncwQVFiQUJJUkFNdEFJTEFrQUNRQ0FFTFFBQVFhdC9hZzRMQUowQm5RR2RBWjBCblFHZEFaMEJuUUdkQVFHZEFRc2dCRUVCYWlFRVFab0JJUkFNbXdJTElBUkJBV29oQkVHYkFTRVFESm9DQ3dKQUlBUWdBa2NOQUVHeEFTRVFETE1DQ3dKQUFrQWdCQzBBQUVHL2Yyb09GQUNjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUVCbkFFTElBUkJBV29oQkVHWkFTRVFESm9DQ3lBRVFRRnFJUVJCbkFFaEVBeVpBZ3NDUUNBRUlBSkhEUUJCc2dFaEVBeXlBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFRGFpRVFBa0FEUUNBRUxRQUFJQUZCMmMrQWdBQnFMUUFBUncyYUFTQUJRUU5HRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnNnRWhFQXl5QWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVoSVJBTWx3RUxBa0FnQkNBQ1J3MEFRYk1CSVJBTXNRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQm1vaEVBSkFBMEFnQkMwQUFDQUJRZDNQZ0lBQWFpMEFBRWNObVFFZ0FVRUdSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJNQklSQU1zUUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJHaUVRREpZQkN3SkFJQVFnQWtjTkFFRzBBU0VRRExBQ0N3SkFBa0FDUUNBRUxRQUFRYnQvYWc0UkFKb0JtZ0dhQVpvQm1nR2FBWm9CbWdHYUFRR2FBWm9CbWdHYUFab0JBcG9CQ3lBRVFRRnFJUVJCblFFaEVBeVlBZ3NnQkVFQmFpRUVRWjRCSVJBTWx3SUxJQVJCQVdvaEJFR2ZBU0VRREpZQ0N3SkFJQVFnQWtjTkFFRzFBU0VRREs4Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBQ1FBTkFJQVF0QUFBZ0FVSGt6NENBQUdvdEFBQkhEWmNCSUFGQkJVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUcxQVNFUURLOENDeUFBUVFBMkFnQWdFRUVCYWlFQlFTZ2hFQXlVQVFzQ1FDQUVJQUpIRFFCQnRnRWhFQXl1QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQjZzK0FnQUJxTFFBQVJ3MldBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ0Z0VoRUF5dUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFSElSQU1rd0VMQWtBZ0JDQUNSdzBBUWJjQklSQU1yUUlMQWtBQ1FDQUVMUUFBUWJ0L2FnNE9BSllCbGdHV0FaWUJsZ0dXQVpZQmxnR1dBWllCbGdHV0FRR1dBUXNnQkVFQmFpRUVRYUVCSVJBTWxBSUxJQVJCQVdvaEJFR2lBU0VRREpNQ0N3SkFJQVFnQWtjTkFFRzRBU0VRREt3Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEWlFCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUc0QVNFUURLd0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFSSWhFQXlSQVFzQ1FDQUVJQUpIRFFCQnVRRWhFQXlyQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQjhNK0FnQUJxTFFBQVJ3MlRBU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ1UUVoRUF5ckFnc2dBRUVBTmdJQUlCQkJBV29oQVVFZ0lSQU1rQUVMQWtBZ0JDQUNSdzBBUWJvQklSQU1xZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZMUGdJQUFhaTBBQUVjTmtnRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFib0JJUkFNcWdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRHlFUURJOEJDd0pBSUFRZ0FrY05BRUc3QVNFUURLa0NDd0pBQWtBZ0JDMEFBRUczZjJvT0J3Q1NBWklCa2dHU0FaSUJBWklCQ3lBRVFRRnFJUVJCcFFFaEVBeVFBZ3NnQkVFQmFpRUVRYVlCSVJBTWp3SUxBa0FnQkNBQ1J3MEFRYndCSVJBTXFBSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQjJvaEVBSkFBMEFnQkMwQUFDQUJRZlRQZ0lBQWFpMEFBRWNOa0FFZ0FVRUhSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJ3QklSQU1xQUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJHeUVRREkwQkN3SkFJQVFnQWtjTkFFRzlBU0VRREtjQ0N3SkFBa0FDUUNBRUxRQUFRYjUvYWc0U0FKRUJrUUdSQVpFQmtRR1JBWkVCa1FHUkFRR1JBWkVCa1FHUkFaRUJrUUVDa1FFTElBUkJBV29oQkVHa0FTRVFESThDQ3lBRVFRRnFJUVJCcHdFaEVBeU9BZ3NnQkVFQmFpRUVRYWdCSVJBTWpRSUxBa0FnQkNBQ1J3MEFRYjRCSVJBTXBnSUxJQVF0QUFCQnpnQkhEWTBCSUFSQkFXb2hCQXpQQVFzQ1FDQUVJQUpIRFFCQnZ3RWhFQXlsQWdzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FFTFFBQVFiOS9hZzRWQUFFQ0E1d0JCQVVHbkFHY0Fad0JCd2dKQ2d1Y0FRd05EZytjQVFzZ0JFRUJhaUVCUWVnQUlSQU1tZ0lMSUFSQkFXb2hBVUhwQUNFUURKa0NDeUFFUVFGcUlRRkI3Z0FoRUF5WUFnc2dCRUVCYWlFQlFmSUFJUkFNbHdJTElBUkJBV29oQVVIekFDRVFESllDQ3lBRVFRRnFJUUZCOWdBaEVBeVZBZ3NnQkVFQmFpRUJRZmNBSVJBTWxBSUxJQVJCQVdvaEFVSDZBQ0VRREpNQ0N5QUVRUUZxSVFSQmd3RWhFQXlTQWdzZ0JFRUJhaUVFUVlRQklSQU1rUUlMSUFSQkFXb2hCRUdGQVNFUURKQUNDeUFFUVFGcUlRUkJrZ0VoRUF5UEFnc2dCRUVCYWlFRVFaZ0JJUkFNamdJTElBUkJBV29oQkVHZ0FTRVFESTBDQ3lBRVFRRnFJUVJCb3dFaEVBeU1BZ3NnQkVFQmFpRUVRYW9CSVJBTWl3SUxBa0FnQkNBQ1JnMEFJQUJCa0lDQWdBQTJBZ2dnQUNBRU5nSUVRYXNCSVJBTWl3SUxRY0FCSVJBTW93SUxJQUFnQlNBQ0VLcUFnSUFBSWdFTml3RWdCU0VCREZ3TEFrQWdCaUFDUmcwQUlBWkJBV29oQlF5TkFRdEJ3Z0VoRUF5aEFnc0RRQUpBSUJBdEFBQkJkbW9PQkl3QkFBQ1BBUUFMSUJCQkFXb2lFQ0FDUncwQUMwSERBU0VRREtBQ0N3SkFJQWNnQWtZTkFDQUFRWkdBZ0lBQU5nSUlJQUFnQnpZQ0JDQUhJUUZCQVNFUURJY0NDMEhFQVNFUURKOENDd0pBSUFjZ0FrY05BRUhGQVNFUURKOENDd0pBQWtBZ0J5MEFBRUYyYWc0RUFjNEJ6Z0VBemdFTElBZEJBV29oQmd5TkFRc2dCMEVCYWlFRkRJa0JDd0pBSUFjZ0FrY05BRUhHQVNFUURKNENDd0pBQWtBZ0J5MEFBRUYyYWc0WEFZOEJqd0VCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCQUk4QkN5QUhRUUZxSVFjTFFiQUJJUkFNaEFJTEFrQWdDQ0FDUncwQVFjZ0JJUkFNblFJTElBZ3RBQUJCSUVjTmpRRWdBRUVBT3dFeUlBaEJBV29oQVVHekFTRVFESU1DQ3lBQklSY0NRQU5BSUJjaUJ5QUNSZzBCSUFjdEFBQkJVR3BCL3dGeEloQkJDazhOekFFQ1FDQUFMd0V5SWhSQm1UTkxEUUFnQUNBVVFRcHNJaFE3QVRJZ0VFSC8vd056SUJSQi92OERjVWtOQUNBSFFRRnFJUmNnQUNBVUlCQnFJaEE3QVRJZ0VFSC8vd054UWVnSFNRMEJDd3RCQUNFUUlBQkJBRFlDSENBQVFjR0pnSUFBTmdJUUlBQkJEVFlDRENBQUlBZEJBV28yQWhRTW5BSUxRY2NCSVJBTW13SUxJQUFnQ0NBQ0VLNkFnSUFBSWhCRkRjb0JJQkJCRlVjTmpBRWdBRUhJQVRZQ0hDQUFJQWcyQWhRZ0FFSEpsNENBQURZQ0VDQUFRUlUyQWd4QkFDRVFESm9DQ3dKQUlBa2dBa2NOQUVITUFTRVFESm9DQzBFQUlSUkJBU0VYUVFFaEZrRUFJUkFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQ1MwQUFFRlFhZzRLbGdHVkFRQUJBZ01FQlFZSWx3RUxRUUloRUF3R0MwRURJUkFNQlF0QkJDRVFEQVFMUVFVaEVBd0RDMEVHSVJBTUFndEJCeUVRREFFTFFRZ2hFQXRCQUNFWFFRQWhGa0VBSVJRTWpnRUxRUWtoRUVFQklSUkJBQ0VYUVFBaEZneU5BUXNDUUNBS0lBSkhEUUJCemdFaEVBeVpBZ3NnQ2kwQUFFRXVSdzJPQVNBS1FRRnFJUWtNeWdFTElBc2dBa2NOamdGQjBBRWhFQXlYQWdzQ1FDQUxJQUpHRFFBZ0FFR09nSUNBQURZQ0NDQUFJQXMyQWdSQnR3RWhFQXorQVF0QjBRRWhFQXlXQWdzQ1FDQUVJQUpIRFFCQjBnRWhFQXlXQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUVhaUVMQTBBZ0JDMEFBQ0FRUWZ6UGdJQUFhaTBBQUVjTmpnRWdFRUVFUmczcEFTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFNBU0VRREpVQ0N5QUFJQXdnQWhDc2dJQ0FBQ0lCRFkwQklBd2hBUXk0QVFzQ1FDQUVJQUpIRFFCQjFBRWhFQXlVQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUJhaUVNQTBBZ0JDMEFBQ0FRUVlIUWdJQUFhaTBBQUVjTmp3RWdFRUVCUmcyT0FTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFVBU0VRREpNQ0N3SkFJQVFnQWtjTkFFSFdBU0VRREpNQ0N5QUNJQVJySUFBb0FnQWlFR29oRkNBRUlCQnJRUUpxSVFzRFFDQUVMUUFBSUJCQmc5Q0FnQUJxTFFBQVJ3Mk9BU0FRUVFKR0RaQUJJQkJCQVdvaEVDQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZFlCSVJBTWtnSUxBa0FnQkNBQ1J3MEFRZGNCSVJBTWtnSUxBa0FDUUNBRUxRQUFRYnQvYWc0UUFJOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3RUJqd0VMSUFSQkFXb2hCRUc3QVNFUURQa0JDeUFFUVFGcUlRUkJ2QUVoRUF6NEFRc0NRQ0FFSUFKSERRQkIyQUVoRUF5UkFnc2dCQzBBQUVISUFFY05qQUVnQkVFQmFpRUVETVFCQ3dKQUlBUWdBa1lOQUNBQVFaQ0FnSUFBTmdJSUlBQWdCRFlDQkVHK0FTRVFEUGNCQzBIWkFTRVFESThDQ3dKQUlBUWdBa2NOQUVIYUFTRVFESThDQ3lBRUxRQUFRY2dBUmczREFTQUFRUUU2QUNnTXVRRUxJQUJCQWpvQUx5QUFJQVFnQWhDbWdJQ0FBQ0lRRFkwQlFjSUJJUkFNOUFFTElBQXRBQ2hCZjJvT0FyY0J1UUc0QVFzRFFBSkFJQVF0QUFCQmRtb09CQUNPQVk0QkFJNEJDeUFFUVFGcUlnUWdBa2NOQUF0QjNRRWhFQXlMQWdzZ0FFRUFPZ0F2SUFBdEFDMUJCSEZGRFlRQ0N5QUFRUUE2QUM4Z0FFRUJPZ0EwSUFFaEFReU1BUXNnRUVFVlJnM2FBU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJwNDZBZ0FBMkFoQWdBRUVTTmdJTVFRQWhFQXlJQWdzQ1FDQUFJQkFnQWhDMGdJQ0FBQ0lFRFFBZ0VDRUJESUVDQ3dKQUlBUkJGVWNOQUNBQVFRTTJBaHdnQUNBUU5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF5SUFnc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFhZU9nSUFBTmdJUUlBQkJFallDREVFQUlSQU1od0lMSUJCQkZVWU4xZ0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZHFOZ0lBQU5nSVFJQUJCRkRZQ0RFRUFJUkFNaGdJTElBQW9BZ1FoRnlBQVFRQTJBZ1FnRUNBUnAyb2lGaUVCSUFBZ0Z5QVFJQllnRkJzaUVCQzFnSUNBQUNJVVJRMk5BU0FBUVFjMkFod2dBQ0FRTmdJVUlBQWdGRFlDREVFQUlSQU1oUUlMSUFBZ0FDOEJNRUdBQVhJN0FUQWdBU0VCQzBFcUlSQU02Z0VMSUJCQkZVWU4wUUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWU9NZ0lBQU5nSVFJQUJCRXpZQ0RFRUFJUkFNZ2dJTElCQkJGVVlOendFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVpxUGdJQUFOZ0lRSUFCQklqWUNERUVBSVJBTWdRSUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDM2dJQ0FBQ0lRRFFBZ0FVRUJhaUVCREkwQkN5QUFRUXcyQWh3Z0FDQVFOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU1nQUlMSUJCQkZVWU56QUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWnFQZ0lBQU5nSVFJQUJCSWpZQ0RFRUFJUkFNL3dFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkMzZ0lDQUFDSVFEUUFnQVVFQmFpRUJESXdCQ3lBQVFRMDJBaHdnQUNBUU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTS9nRUxJQkJCRlVZTnlRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjYU1nSUFBTmdJUUlBQkJJellDREVFQUlSQU0vUUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzVnSUNBQUNJUURRQWdBVUVCYWlFQkRJc0JDeUFBUVE0MkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNL0FFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIQWxZQ0FBRFlDRUNBQVFRSTJBZ3hCQUNFUURQc0JDeUFRUVJWR0RjVUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEdqSUNBQURZQ0VDQUFRU00yQWd4QkFDRVFEUG9CQ3lBQVFSQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNK1FFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkM1Z0lDQUFDSUVEUUFnQVVFQmFpRUJEUEVCQ3lBQVFSRTJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTStBRUxJQkJCRlVZTndRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjYU1nSUFBTmdJUUlBQkJJellDREVFQUlSQU05d0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzVnSUNBQUNJUURRQWdBVUVCYWlFQkRJZ0JDeUFBUVJNMkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNOWdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkM1Z0lDQUFDSUVEUUFnQVVFQmFpRUJETzBCQ3lBQVFSUTJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTTlRRUxJQkJCRlVZTnZRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFacVBnSUFBTmdJUUlBQkJJallDREVFQUlSQU05QUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzNnSUNBQUNJUURRQWdBVUVCYWlFQkRJWUJDeUFBUVJZMkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNOHdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkMzZ0lDQUFDSUVEUUFnQVVFQmFpRUJET2tCQ3lBQVFSYzJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTThnRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSE5rNENBQURZQ0VDQUFRUXcyQWd4QkFDRVFEUEVCQzBJQklSRUxJQkJCQVdvaEFRSkFJQUFwQXlBaUVrTC8vLy8vLy8vLy93OVdEUUFnQUNBU1FnU0dJQkdFTndNZ0lBRWhBUXlFQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWEySmdJQUFOZ0lRSUFCQkREWUNERUVBSVJBTTd3RUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFSE5rNENBQURZQ0VDQUFRUXcyQWd4QkFDRVFETzRCQ3lBQUtBSUVJUmNnQUVFQU5nSUVJQkFnRWFkcUloWWhBU0FBSUJjZ0VDQVdJQlFiSWhBUXRZQ0FnQUFpRkVVTmN5QUFRUVUyQWh3Z0FDQVFOZ0lVSUFBZ0ZEWUNERUVBSVJBTTdRRUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFR3FuSUNBQURZQ0VDQUFRUTgyQWd4QkFDRVFET3dCQ3lBQUlCQWdBaEMwZ0lDQUFDSUJEUUVnRUNFQkMwRU9JUkFNMFFFTEFrQWdBVUVWUncwQUlBQkJBallDSENBQUlCQTJBaFFnQUVHd21JQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFUURPb0JDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJwNDZBZ0FBMkFoQWdBRUVTTmdJTVFRQWhFQXpwQVFzZ0FVRUJhaUVRQWtBZ0FDOEJNQ0lCUVlBQmNVVU5BQUpBSUFBZ0VDQUNFTHVBZ0lBQUlnRU5BQ0FRSVFFTWNBc2dBVUVWUncyNkFTQUFRUVUyQWh3Z0FDQVFOZ0lVSUFCQitaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBenBBUXNDUUNBQlFhQUVjVUdnQkVjTkFDQUFMUUF0UVFKeERRQWdBRUVBTmdJY0lBQWdFRFlDRkNBQVFaYVRnSUFBTmdJUUlBQkJCRFlDREVFQUlSQU02UUVMSUFBZ0VDQUNFTDJBZ0lBQUdpQVFJUUVDUUFKQUFrQUNRQUpBSUFBZ0VDQUNFTE9BZ0lBQURoWUNBUUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFEQkFzZ0FFRUJPZ0F1Q3lBQUlBQXZBVEJCd0FCeU93RXdJQkFoQVF0QkppRVFETkVCQ3lBQVFTTTJBaHdnQUNBUU5nSVVJQUJCcFphQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF6cEFRc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFkV0xnSUFBTmdJUUlBQkJFVFlDREVFQUlSQU02QUVMSUFBdEFDMUJBWEZGRFFGQnd3RWhFQXpPQVFzQ1FDQU5JQUpHRFFBRFFBSkFJQTB0QUFCQklFWU5BQ0FOSVFFTXhBRUxJQTFCQVdvaURTQUNSdzBBQzBFbElSQU01d0VMUVNVaEVBem1BUXNnQUNnQ0JDRUVJQUJCQURZQ0JDQUFJQVFnRFJDdmdJQ0FBQ0lFUlEydEFTQUFRU1kyQWh3Z0FDQUVOZ0lNSUFBZ0RVRUJhallDRkVFQUlSQU01UUVMSUJCQkZVWU5xd0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZjJOZ0lBQU5nSVFJQUJCSFRZQ0RFRUFJUkFNNUFFTElBQkJKellDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6akFRc2dFQ0VCUVFFaEZBSkFBa0FDUUFKQUFrQUNRQUpBSUFBdEFDeEJmbW9PQndZRkJRTUJBZ0FGQ3lBQUlBQXZBVEJCQ0hJN0FUQU1Bd3RCQWlFVURBRUxRUVFoRkFzZ0FFRUJPZ0FzSUFBZ0FDOEJNQ0FVY2pzQk1Bc2dFQ0VCQzBFcklSQU15Z0VMSUFCQkFEWUNIQ0FBSUJBMkFoUWdBRUdya29DQUFEWUNFQ0FBUVFzMkFneEJBQ0VRRE9JQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjRZK0FnQUEyQWhBZ0FFRUtOZ0lNUVFBaEVBemhBUXNnQUVFQU9nQXNJQkFoQVF5OUFRc2dFQ0VCUVFFaEZBSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBd0VDQUFVTElBQWdBQzhCTUVFSWNqc0JNQXdEQzBFQ0lSUU1BUXRCQkNFVUN5QUFRUUU2QUN3Z0FDQUFMd0V3SUJSeU93RXdDeUFRSVFFTFFTa2hFQXpGQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZDVWdJQUFOZ0lRSUFCQkF6WUNERUVBSVJBTTNRRUxBa0FnRGkwQUFFRU5SdzBBSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0RoQ3hnSUNBQUNJQkRRQWdEa0VCYWlFQkRIVUxJQUJCTERZQ0hDQUFJQUUyQWd3Z0FDQU9RUUZxTmdJVVFRQWhFQXpkQVFzZ0FDMEFMVUVCY1VVTkFVSEVBU0VRRE1NQkN3SkFJQTRnQWtjTkFFRXRJUkFNM0FFTEFrQUNRQU5BQWtBZ0RpMEFBRUYyYWc0RUFnQUFBd0FMSUE1QkFXb2lEaUFDUncwQUMwRXRJUkFNM1FFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdEaEN4Z0lDQUFDSUJEUUFnRGlFQkRIUUxJQUJCTERZQ0hDQUFJQTQyQWhRZ0FDQUJOZ0lNUVFBaEVBemNBUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBT0VMR0FnSUFBSWdFTkFDQU9RUUZxSVFFTWN3c2dBRUVzTmdJY0lBQWdBVFlDRENBQUlBNUJBV28yQWhSQkFDRVFETnNCQ3lBQUtBSUVJUVFnQUVFQU5nSUVJQUFnQkNBT0VMR0FnSUFBSWdRTm9BRWdEaUVCRE00QkN5QVFRU3hIRFFFZ0FVRUJhaUVRUVFFaEFRSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBd0VDQkFBTElCQWhBUXdFQzBFQ0lRRU1BUXRCQkNFQkN5QUFRUUU2QUN3Z0FDQUFMd0V3SUFGeU93RXdJQkFoQVF3QkN5QUFJQUF2QVRCQkNISTdBVEFnRUNFQkMwRTVJUkFNdndFTElBQkJBRG9BTENBQklRRUxRVFFoRUF5OUFRc2dBQ0FBTHdFd1FTQnlPd0V3SUFFaEFRd0NDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXNZQ0FnQUFpQkEwQUlBRWhBUXpIQVFzZ0FFRTNOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRRE5RQkN5QUFRUWc2QUN3Z0FTRUJDMEV3SVJBTXVRRUxBa0FnQUMwQUtFRUJSZzBBSUFFaEFRd0VDeUFBTFFBdFFRaHhSUTJUQVNBQklRRU1Bd3NnQUMwQU1FRWdjUTJVQVVIRkFTRVFETGNCQ3dKQUlBOGdBa1lOQUFKQUEwQUNRQ0FQTFFBQVFWQnFJZ0ZCL3dGeFFRcEpEUUFnRHlFQlFUVWhFQXk2QVFzZ0FDa0RJQ0lSUXBtejVzeVpzK2JNR1ZZTkFTQUFJQkZDQ240aUVUY0RJQ0FSSUFHdFF2OEJneUlTUW4rRlZnMEJJQUFnRVNBU2ZEY0RJQ0FQUVFGcUlnOGdBa2NOQUF0Qk9TRVFETkVCQ3lBQUtBSUVJUUlnQUVFQU5nSUVJQUFnQWlBUFFRRnFJZ1FRc1lDQWdBQWlBZzJWQVNBRUlRRU13d0VMUVRraEVBelBBUXNDUUNBQUx3RXdJZ0ZCQ0hGRkRRQWdBQzBBS0VFQlJ3MEFJQUF0QUMxQkNIRkZEWkFCQ3lBQUlBRkI5L3NEY1VHQUJISTdBVEFnRHlFQkMwRTNJUkFNdEFFTElBQWdBQzhCTUVFUWNqc0JNQXlyQVFzZ0VFRVZSZzJMQVNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCOEk2QWdBQTJBaEFnQUVFY05nSU1RUUFoRUF6TEFRc2dBRUhEQURZQ0hDQUFJQUUyQWd3Z0FDQU5RUUZxTmdJVVFRQWhFQXpLQVFzQ1FDQUJMUUFBUVRwSERRQWdBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUsrQWdJQUFJaEFOQUNBQlFRRnFJUUVNWXdzZ0FFSERBRFlDSENBQUlCQTJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEVBektBUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYkdSZ0lBQU5nSVFJQUJCQ2pZQ0RFRUFJUkFNeVFFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHZ21ZQ0FBRFlDRUNBQVFSNDJBZ3hCQUNFUURNZ0JDeUFBUVFBMkFnQUxJQUJCZ0JJN0FTb2dBQ0FYUVFGcUlnRWdBaENvZ0lDQUFDSVFEUUVnQVNFQkMwSEhBQ0VRREt3QkN5QVFRUlZIRFlNQklBQkIwUUEyQWh3Z0FDQUJOZ0lVSUFCQjQ1ZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBekVBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNWGdzZ0FFSFNBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6REFRc2dBRUVBTmdJY0lBQWdGRFlDRkNBQVFjR29nSUFBTmdJUUlBQkJCellDRENBQVFRQTJBZ0JCQUNFUURNSUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhkQ3lBQVFkTUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRE1FQkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWUNSZ0lBQU5nSVFJQUJCQ1RZQ0RBekFBUXNnRUVFVlJnMTlJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR1VqWUNBQURZQ0VDQUFRU0UyQWd4QkFDRVFETDhCQzBFQklSWkJBQ0VYUVFBaEZFRUJJUkFMSUFBZ0VEb0FLeUFCUVFGcUlRRUNRQUpBSUFBdEFDMUJFSEVOQUFKQUFrQUNRQ0FBTFFBcURnTUJBQUlFQ3lBV1JRMEREQUlMSUJRTkFRd0NDeUFYUlEwQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcllDQWdBQWlFQTBBSUFFaEFReGNDeUFBUWRnQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETDRCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVFyWUNBZ0FBaUJBMEFJQUVoQVF5dEFRc2dBRUhaQURZQ0hDQUFJQUUyQWhRZ0FDQUVOZ0lNUVFBaEVBeTlBUXNnQUNnQ0JDRUVJQUJCQURZQ0JBSkFJQUFnQkNBQkVLMkFnSUFBSWdRTkFDQUJJUUVNcXdFTElBQkIyZ0EyQWh3Z0FDQUJOZ0lVSUFBZ0JEWUNERUVBSVJBTXZBRUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDdGdJQ0FBQ0lFRFFBZ0FTRUJES2tCQ3lBQVFkd0FOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRRExzQkN3SkFJQUV0QUFCQlVHb2lFRUgvQVhGQkNrOE5BQ0FBSUJBNkFDb2dBVUVCYWlFQlFjOEFJUkFNb2dFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkN0Z0lDQUFDSUVEUUFnQVNFQkRLY0JDeUFBUWQ0QU5nSWNJQUFnQVRZQ0ZDQUFJQVEyQWd4QkFDRVFETG9CQ3lBQVFRQTJBZ0FnRjBFQmFpRUJBa0FnQUMwQUtVRWpUdzBBSUFFaEFReFpDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkIwNG1BZ0FBMkFoQWdBRUVJTmdJTVFRQWhFQXk1QVFzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaQ3pnSUFBTmdJUUlBQkJDRFlDREF5M0FRc2dBRUVBTmdJQUlCZEJBV29oQVFKQUlBQXRBQ2xCSVVjTkFDQUJJUUVNVmdzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVp1S2dJQUFOZ0lRSUFCQkNEWUNERUVBSVJBTXRnRUxJQUJCQURZQ0FDQVhRUUZxSVFFQ1FDQUFMUUFwSWhCQlhXcEJDMDhOQUNBQklRRU1WUXNDUUNBUVFRWkxEUUJCQVNBUWRFSEtBSEZGRFFBZ0FTRUJERlVMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjk0bUFnQUEyQWhBZ0FFRUlOZ0lNRExVQkN5QVFRUlZHRFhFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWJtTmdJQUFOZ0lRSUFCQkdqWUNERUVBSVJBTXRBRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERlFMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNc3dFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFMExJQUJCMGdBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1zZ0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREUwTElBQkIwd0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXNRRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERkVMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNc0FFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIR2lvQ0FBRFlDRUNBQVFRYzJBZ3hCQUNFUURLOEJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhKQ3lBQVFkSUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRREs0QkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReEpDeUFBUWRNQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFESzBCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4TkN5QUFRZVVBTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURLd0JDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkIzSWlBZ0FBMkFoQWdBRUVITmdJTVFRQWhFQXlyQVFzZ0VFRS9SdzBCSUFGQkFXb2hBUXRCQlNFUURKQUJDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWYyU2dJQUFOZ0lRSUFCQkJ6WUNEQXlvQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVFnc2dBRUhTQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeW5BUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNUWdzZ0FFSFRBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5bUFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1SZ3NnQUVIbEFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXlsQVFzZ0FDZ0NCQ0VCSUFCQkFEWUNCQUpBSUFBZ0FTQVVFS2VBZ0lBQUlnRU5BQ0FVSVFFTVB3c2dBRUhTQURZQ0hDQUFJQlEyQWhRZ0FDQUJOZ0lNUVFBaEVBeWtBUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBVUVLZUFnSUFBSWdFTkFDQVVJUUVNUHdzZ0FFSFRBRFlDSENBQUlCUTJBaFFnQUNBQk5nSU1RUUFoRUF5akFRc2dBQ2dDQkNFQklBQkJBRFlDQkFKQUlBQWdBU0FVRUtlQWdJQUFJZ0VOQUNBVUlRRU1Rd3NnQUVIbEFEWUNIQ0FBSUJRMkFoUWdBQ0FCTmdJTVFRQWhFQXlpQVFzZ0FFRUFOZ0ljSUFBZ0ZEWUNGQ0FBUWNPUGdJQUFOZ0lRSUFCQkJ6WUNERUVBSVJBTW9RRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSERqNENBQURZQ0VDQUFRUWMyQWd4QkFDRVFES0FCQzBFQUlSQWdBRUVBTmdJY0lBQWdGRFlDRkNBQVFZeWNnSUFBTmdJUUlBQkJCellDREF5ZkFRc2dBRUVBTmdJY0lBQWdGRFlDRkNBQVFZeWNnSUFBTmdJUUlBQkJCellDREVFQUlSQU1uZ0VMSUFCQkFEWUNIQ0FBSUJRMkFoUWdBRUgra1lDQUFEWUNFQ0FBUVFjMkFneEJBQ0VRREowQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmpwdUFnQUEyQWhBZ0FFRUdOZ0lNUVFBaEVBeWNBUXNnRUVFVlJnMVhJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSE1qb0NBQURZQ0VDQUFRU0EyQWd4QkFDRVFESnNCQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRU1FoRUFzZ0FDQVFPZ0FwSUFBb0FnUWhFQ0FBUVFBMkFnUWdBQ0FRSUFFUXE0Q0FnQUFpRUExVUlBRWhBUXcrQ3lBQVFRQTJBZ0FMUVFBaEVDQUFRUUEyQWh3Z0FDQUVOZ0lVSUFCQjhadUFnQUEyQWhBZ0FFRUdOZ0lNREpjQkN5QUJRUlZHRFZBZ0FFRUFOZ0ljSUFBZ0JUWUNGQ0FBUWZDTWdJQUFOZ0lRSUFCQkd6WUNERUVBSVJBTWxnRUxJQUFvQWdRaEJTQUFRUUEyQWdRZ0FDQUZJQkFRcVlDQWdBQWlCUTBCSUJCQkFXb2hCUXRCclFFaEVBeDdDeUFBUWNFQk5nSWNJQUFnQlRZQ0RDQUFJQkJCQVdvMkFoUkJBQ0VRREpNQkN5QUFLQUlFSVFZZ0FFRUFOZ0lFSUFBZ0JpQVFFS21BZ0lBQUlnWU5BU0FRUVFGcUlRWUxRYTRCSVJBTWVBc2dBRUhDQVRZQ0hDQUFJQVkyQWd3Z0FDQVFRUUZxTmdJVVFRQWhFQXlRQVFzZ0FFRUFOZ0ljSUFBZ0J6WUNGQ0FBUVplTGdJQUFOZ0lRSUFCQkRUWUNERUVBSVJBTWp3RUxJQUJCQURZQ0hDQUFJQWcyQWhRZ0FFSGprSUNBQURZQ0VDQUFRUWsyQWd4QkFDRVFESTRCQ3lBQVFRQTJBaHdnQUNBSU5nSVVJQUJCbEkyQWdBQTJBaEFnQUVFaE5nSU1RUUFoRUF5TkFRdEJBU0VXUVFBaEYwRUFJUlJCQVNFUUN5QUFJQkE2QUNzZ0NVRUJhaUVJQWtBQ1FDQUFMUUF0UVJCeERRQUNRQUpBQWtBZ0FDMEFLZzREQVFBQ0JBc2dGa1VOQXd3Q0N5QVVEUUVNQWdzZ0YwVU5BUXNnQUNnQ0JDRVFJQUJCQURZQ0JDQUFJQkFnQ0JDdGdJQ0FBQ0lRUlEwOUlBQkJ5UUUyQWh3Z0FDQUlOZ0lVSUFBZ0VEWUNERUVBSVJBTWpBRUxJQUFvQWdRaEJDQUFRUUEyQWdRZ0FDQUVJQWdRcllDQWdBQWlCRVVOZGlBQVFjb0JOZ0ljSUFBZ0NEWUNGQ0FBSUFRMkFneEJBQ0VRRElzQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFSUFBZ0JDQUpFSzJBZ0lBQUlnUkZEWFFnQUVITEFUWUNIQ0FBSUFrMkFoUWdBQ0FFTmdJTVFRQWhFQXlLQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0NoQ3RnSUNBQUNJRVJRMXlJQUJCelFFMkFod2dBQ0FLTmdJVUlBQWdCRFlDREVFQUlSQU1pUUVMQWtBZ0N5MEFBRUZRYWlJUVFmOEJjVUVLVHcwQUlBQWdFRG9BS2lBTFFRRnFJUXBCdGdFaEVBeHdDeUFBS0FJRUlRUWdBRUVBTmdJRUlBQWdCQ0FMRUsyQWdJQUFJZ1JGRFhBZ0FFSFBBVFlDSENBQUlBczJBaFFnQUNBRU5nSU1RUUFoRUF5SUFRc2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFaQ3pnSUFBTmdJUUlBQkJDRFlDRENBQVFRQTJBZ0JCQUNFUURJY0JDeUFCUVJWR0RUOGdBRUVBTmdJY0lBQWdERFlDRkNBQVFjeU9nSUFBTmdJUUlBQkJJRFlDREVFQUlSQU1oZ0VMSUFCQmdRUTdBU2dnQUNnQ0JDRVFJQUJDQURjREFDQUFJQkFnREVFQmFpSU1FS3VBZ0lBQUloQkZEVGdnQUVIVEFUWUNIQ0FBSUF3MkFoUWdBQ0FRTmdJTVFRQWhFQXlGQVFzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdCRFlDRkNBQVFkaWJnSUFBTmdJUUlBQkJDRFlDREF5REFRc2dBQ2dDQkNFUUlBQkNBRGNEQUNBQUlCQWdDMEVCYWlJTEVLdUFnSUFBSWhBTkFVSEdBU0VRREdrTElBQkJBam9BS0F4VkN5QUFRZFVCTmdJY0lBQWdDellDRkNBQUlCQTJBZ3hCQUNFUURJQUJDeUFRUVJWR0RUY2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFhU01nSUFBTmdJUUlBQkJFRFlDREVFQUlSQU1md3NnQUMwQU5FRUJSdzAwSUFBZ0JDQUNFTHlBZ0lBQUloQkZEVFFnRUVFVlJ3MDFJQUJCM0FFMkFod2dBQ0FFTmdJVUlBQkIxWmFBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXgrQzBFQUlSQWdBRUVBTmdJY0lBQkJyNHVBZ0FBMkFoQWdBRUVDTmdJTUlBQWdGRUVCYWpZQ0ZBeDlDMEVBSVJBTVl3dEJBaUVRREdJTFFRMGhFQXhoQzBFUElSQU1ZQXRCSlNFUURGOExRUk1oRUF4ZUMwRVZJUkFNWFF0QkZpRVFERndMUVJjaEVBeGJDMEVZSVJBTVdndEJHU0VRREZrTFFSb2hFQXhZQzBFYklSQU1Wd3RCSENFUURGWUxRUjBoRUF4VkMwRWZJUkFNVkF0QklTRVFERk1MUVNNaEVBeFNDMEhHQUNFUURGRUxRUzRoRUF4UUMwRXZJUkFNVHd0Qk95RVFERTRMUVQwaEVBeE5DMEhJQUNFUURFd0xRY2tBSVJBTVN3dEJ5d0FoRUF4S0MwSE1BQ0VRREVrTFFjNEFJUkFNU0F0QjBRQWhFQXhIQzBIVkFDRVFERVlMUWRnQUlSQU1SUXRCMlFBaEVBeEVDMEhiQUNFUURFTUxRZVFBSVJBTVFndEI1UUFoRUF4QkMwSHhBQ0VRREVBTFFmUUFJUkFNUHd0QmpRRWhFQXcrQzBHWEFTRVFERDBMUWFrQklSQU1QQXRCckFFaEVBdzdDMEhBQVNFUUREb0xRYmtCSVJBTU9RdEJyd0VoRUF3NEMwR3hBU0VRRERjTFFiSUJJUkFNTmd0QnRBRWhFQXcxQzBHMUFTRVFERFFMUWJvQklSQU1Nd3RCdlFFaEVBd3lDMEcvQVNFUURERUxRY0VCSVJBTU1Bc2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFlbUxnSUFBTmdJUUlBQkJIellDREVFQUlSQU1TQXNnQUVIYkFUWUNIQ0FBSUFRMkFoUWdBRUg2bG9DQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVjTElBQkIrQUEyQWh3Z0FDQU1OZ0lVSUFCQnlwaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeEdDeUFBUWRFQU5nSWNJQUFnQlRZQ0ZDQUFRYkNYZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNUlFzZ0FFSDVBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF4RUN5QUFRZmdBTmdJY0lBQWdBVFlDRkNBQVFjcVlnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1Rd3NnQUVIa0FEWUNIQ0FBSUFFMkFoUWdBRUhqbDRDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVJTElBQkIxd0EyQWh3Z0FDQUJOZ0lVSUFCQnlaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeEJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ1WTJBZ0FBMkFoQWdBRUVhTmdJTVFRQWhFQXhBQ3lBQVFjSUFOZ0ljSUFBZ0FUWUNGQ0FBUWVPWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTVB3c2dBRUVBTmdJRUlBQWdEeUFQRUxHQWdJQUFJZ1JGRFFFZ0FFRTZOZ0ljSUFBZ0JEWUNEQ0FBSUE5QkFXbzJBaFJCQUNFUURENExJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDeGdJQ0FBQ0lFUlEwQUlBQkJPellDSENBQUlBUTJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEVBdytDeUFCUVFGcUlRRU1MUXNnRDBFQmFpRUJEQzBMSUFCQkFEWUNIQ0FBSUE4MkFoUWdBRUhra29DQUFEWUNFQ0FBUVFRMkFneEJBQ0VRRERzTElBQkJOallDSENBQUlBUTJBaFFnQUNBQ05nSU1RUUFoRUF3NkN5QUFRUzQyQWh3Z0FDQU9OZ0lVSUFBZ0JEWUNERUVBSVJBTU9Rc2dBRUhRQURZQ0hDQUFJQUUyQWhRZ0FFR1JtSUNBQURZQ0VDQUFRUlUyQWd4QkFDRVFERGdMSUExQkFXb2hBUXdzQ3lBQVFSVTJBaHdnQUNBQk5nSVVJQUJCZ3BtQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3MkN5QUFRUnMyQWh3Z0FDQUJOZ0lVSUFCQmtaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBdzFDeUFBUVE4MkFod2dBQ0FCTmdJVUlBQkJrWmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXcwQ3lBQVFRczJBaHdnQUNBQk5nSVVJQUJCa1plQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3ekN5QUFRUm8yQWh3Z0FDQUJOZ0lVSUFCQmdwbUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3lDeUFBUVFzMkFod2dBQ0FCTmdJVUlBQkJncG1BZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXd4Q3lBQVFRbzJBaHdnQUNBQk5nSVVJQUJCNUphQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3d0N5QUFRUjQyQWh3Z0FDQUJOZ0lVSUFCQitaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3ZDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkIybzJBZ0FBMkFoQWdBRUVVTmdJTVFRQWhFQXd1Q3lBQVFRUTJBaHdnQUNBQk5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3dEN5QUFRUUEyQWdBZ0MwRUJhaUVMQzBHNEFTRVFEQklMSUFCQkFEWUNBQ0FRUVFGcUlRRkI5UUFoRUF3UkN5QUJJUUVDUUNBQUxRQXBRUVZIRFFCQjR3QWhFQXdSQzBIaUFDRVFEQkFMUVFBaEVDQUFRUUEyQWh3Z0FFSGtrWUNBQURZQ0VDQUFRUWMyQWd3Z0FDQVVRUUZxTmdJVURDZ0xJQUJCQURZQ0FDQVhRUUZxSVFGQndBQWhFQXdPQzBFQklRRUxJQUFnQVRvQUxDQUFRUUEyQWdBZ0YwRUJhaUVCQzBFb0lSQU1Dd3NnQVNFQkMwRTRJUkFNQ1FzQ1FDQUJJZzhnQWtZTkFBTkFBa0FnRHkwQUFFR0F2b0NBQUdvdEFBQWlBVUVCUmcwQUlBRkJBa2NOQXlBUFFRRnFJUUVNQkFzZ0QwRUJhaUlQSUFKSERRQUxRVDRoRUF3aUMwRStJUkFNSVFzZ0FFRUFPZ0FzSUE4aEFRd0JDMEVMSVJBTUJndEJPaUVRREFVTElBRkJBV29oQVVFdElSQU1CQXNnQUNBQk9nQXNJQUJCQURZQ0FDQVdRUUZxSVFGQkRDRVFEQU1MSUFCQkFEWUNBQ0FYUVFGcUlRRkJDaUVRREFJTElBQkJBRFlDQUFzZ0FFRUFPZ0FzSUEwaEFVRUpJUkFNQUFzTFFRQWhFQ0FBUVFBMkFod2dBQ0FMTmdJVUlBQkJ6WkNBZ0FBMkFoQWdBRUVKTmdJTURCY0xRUUFoRUNBQVFRQTJBaHdnQUNBS05nSVVJQUJCNllxQWdBQTJBaEFnQUVFSk5nSU1EQllMUVFBaEVDQUFRUUEyQWh3Z0FDQUpOZ0lVSUFCQnQ1Q0FnQUEyQWhBZ0FFRUpOZ0lNREJVTFFRQWhFQ0FBUVFBMkFod2dBQ0FJTmdJVUlBQkJuSkdBZ0FBMkFoQWdBRUVKTmdJTURCUUxRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCelpDQWdBQTJBaEFnQUVFSk5nSU1EQk1MUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjZZcUFnQUEyQWhBZ0FFRUpOZ0lNREJJTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ0NUNBZ0FBMkFoQWdBRUVKTmdJTURCRUxRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCbkpHQWdBQTJBaEFnQUVFSk5nSU1EQkFMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmw1V0FnQUEyQWhBZ0FFRVBOZ0lNREE4TFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJsNVdBZ0FBMkFoQWdBRUVQTmdJTURBNExRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCd0pLQWdBQTJBaEFnQUVFTE5nSU1EQTBMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmxZbUFnQUEyQWhBZ0FFRUxOZ0lNREF3TFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkI0WStBZ0FBMkFoQWdBRUVLTmdJTURBc0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCKzQrQWdBQTJBaEFnQUVFS05nSU1EQW9MUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjhabUFnQUEyQWhBZ0FFRUNOZ0lNREFrTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ4SlNBZ0FBMkFoQWdBRUVDTmdJTURBZ0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCOHBXQWdBQTJBaEFnQUVFQ05nSU1EQWNMSUFCQkFqWUNIQ0FBSUFFMkFoUWdBRUdjbW9DQUFEWUNFQ0FBUVJZMkFneEJBQ0VRREFZTFFRRWhFQXdGQzBIVUFDRVFJQUVpQkNBQ1JnMEVJQU5CQ0dvZ0FDQUVJQUpCMk1LQWdBQkJDaERGZ0lDQUFDQURLQUlNSVFRZ0F5Z0NDQTREQVFRQ0FBc1F5b0NBZ0FBQUN5QUFRUUEyQWh3Z0FFRzFtb0NBQURZQ0VDQUFRUmMyQWd3Z0FDQUVRUUZxTmdJVVFRQWhFQXdDQ3lBQVFRQTJBaHdnQUNBRU5nSVVJQUJCeXBxQWdBQTJBaEFnQUVFSk5nSU1RUUFoRUF3QkN3SkFJQUVpQkNBQ1J3MEFRU0loRUF3QkN5QUFRWW1BZ0lBQU5nSUlJQUFnQkRZQ0JFRWhJUkFMSUFOQkVHb2tnSUNBZ0FBZ0VBdXZBUUVDZnlBQktBSUFJUVlDUUFKQUlBSWdBMFlOQUNBRUlBWnFJUVFnQmlBRGFpQUNheUVISUFJZ0JrRi9jeUFGYWlJR2FpRUZBMEFDUUNBQ0xRQUFJQVF0QUFCR0RRQkJBaUVFREFNTEFrQWdCZzBBUVFBaEJDQUZJUUlNQXdzZ0JrRi9haUVHSUFSQkFXb2hCQ0FDUVFGcUlnSWdBMGNOQUFzZ0J5RUdJQU1oQWdzZ0FFRUJOZ0lBSUFFZ0JqWUNBQ0FBSUFJMkFnUVBDeUFCUVFBMkFnQWdBQ0FFTmdJQUlBQWdBallDQkFzS0FDQUFFTWVBZ0lBQUMvSTJBUXQvSTRDQWdJQUFRUkJySWdFa2dJQ0FnQUFDUUVFQUtBS2cwSUNBQUEwQVFRQVF5NENBZ0FCQmdOU0VnQUJySWdKQjJRQkpEUUJCQUNFREFrQkJBQ2dDNE5PQWdBQWlCQTBBUVFCQ2Z6Y0M3Tk9BZ0FCQkFFS0FnSVNBZ0lEQUFEY0M1Tk9BZ0FCQkFDQUJRUWhxUVhCeFFkaXExYW9GY3lJRU5nTGcwNENBQUVFQVFRQTJBdlRUZ0lBQVFRQkJBRFlDeE5PQWdBQUxRUUFnQWpZQ3pOT0FnQUJCQUVHQTFJU0FBRFlDeU5PQWdBQkJBRUdBMUlTQUFEWUNtTkNBZ0FCQkFDQUVOZ0tzMElDQUFFRUFRWDgyQXFqUWdJQUFBMEFnQTBIRTBJQ0FBR29nQTBHNDBJQ0FBR29pQkRZQ0FDQUVJQU5Cc05DQWdBQnFJZ1UyQWdBZ0EwRzgwSUNBQUdvZ0JUWUNBQ0FEUWN6UWdJQUFhaUFEUWNEUWdJQUFhaUlGTmdJQUlBVWdCRFlDQUNBRFFkVFFnSUFBYWlBRFFjalFnSUFBYWlJRU5nSUFJQVFnQlRZQ0FDQURRZERRZ0lBQWFpQUVOZ0lBSUFOQklHb2lBMEdBQWtjTkFBdEJnTlNFZ0FCQmVFR0ExSVNBQUd0QkQzRkJBRUdBMUlTQUFFRUlha0VQY1JzaUEyb2lCRUVFYWlBQ1FVaHFJZ1VnQTJzaUEwRUJjallDQUVFQVFRQW9BdkRUZ0lBQU5nS2swSUNBQUVFQUlBTTJBcFRRZ0lBQVFRQWdCRFlDb05DQWdBQkJnTlNFZ0FBZ0JXcEJPRFlDQkFzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQUVIc0FVc05BQUpBUVFBb0FvalFnSUFBSWdaQkVDQUFRUk5xUVhCeElBQkJDMGtiSWdKQkEzWWlCSFlpQTBFRGNVVU5BQUpBQWtBZ0EwRUJjU0FFY2tFQmN5SUZRUU4wSWdSQnNOQ0FnQUJxSWdNZ0JFRzQwSUNBQUdvb0FnQWlCQ2dDQ0NJQ1J3MEFRUUFnQmtGK0lBVjNjVFlDaU5DQWdBQU1BUXNnQXlBQ05nSUlJQUlnQXpZQ0RBc2dCRUVJYWlFRElBUWdCVUVEZENJRlFRTnlOZ0lFSUFRZ0JXb2lCQ0FFS0FJRVFRRnlOZ0lFREF3TElBSkJBQ2dDa05DQWdBQWlCMDBOQVFKQUlBTkZEUUFDUUFKQUlBTWdCSFJCQWlBRWRDSURRUUFnQTJ0eWNTSURRUUFnQTJ0eFFYOXFJZ01nQTBFTWRrRVFjU0lEZGlJRVFRVjJRUWh4SWdVZ0EzSWdCQ0FGZGlJRFFRSjJRUVJ4SWdSeUlBTWdCSFlpQTBFQmRrRUNjU0lFY2lBRElBUjJJZ05CQVhaQkFYRWlCSElnQXlBRWRtb2lCRUVEZENJRFFiRFFnSUFBYWlJRklBTkJ1TkNBZ0FCcUtBSUFJZ01vQWdnaUFFY05BRUVBSUFaQmZpQUVkM0VpQmpZQ2lOQ0FnQUFNQVFzZ0JTQUFOZ0lJSUFBZ0JUWUNEQXNnQXlBQ1FRTnlOZ0lFSUFNZ0JFRURkQ0lFYWlBRUlBSnJJZ1UyQWdBZ0F5QUNhaUlBSUFWQkFYSTJBZ1FDUUNBSFJRMEFJQWRCZUhGQnNOQ0FnQUJxSVFKQkFDZ0NuTkNBZ0FBaEJBSkFBa0FnQmtFQklBZEJBM1owSWdoeERRQkJBQ0FHSUFoeU5nS0kwSUNBQUNBQ0lRZ01BUXNnQWlnQ0NDRUlDeUFJSUFRMkFnd2dBaUFFTmdJSUlBUWdBallDRENBRUlBZzJBZ2dMSUFOQkNHb2hBMEVBSUFBMkFwelFnSUFBUVFBZ0JUWUNrTkNBZ0FBTURBdEJBQ2dDak5DQWdBQWlDVVVOQVNBSlFRQWdDV3R4UVg5cUlnTWdBMEVNZGtFUWNTSURkaUlFUVFWMlFRaHhJZ1VnQTNJZ0JDQUZkaUlEUVFKMlFRUnhJZ1J5SUFNZ0JIWWlBMEVCZGtFQ2NTSUVjaUFESUFSMklnTkJBWFpCQVhFaUJISWdBeUFFZG1wQkFuUkJ1TktBZ0FCcUtBSUFJZ0FvQWdSQmVIRWdBbXNoQkNBQUlRVUNRQU5BQWtBZ0JTZ0NFQ0lERFFBZ0JVRVVhaWdDQUNJRFJRMENDeUFES0FJRVFYaHhJQUpySWdVZ0JDQUZJQVJKSWdVYklRUWdBeUFBSUFVYklRQWdBeUVGREFBTEN5QUFLQUlZSVFvQ1FDQUFLQUlNSWdnZ0FFWU5BQ0FBS0FJSUlnTkJBQ2dDbU5DQWdBQkpHaUFJSUFNMkFnZ2dBeUFJTmdJTURBc0xBa0FnQUVFVWFpSUZLQUlBSWdNTkFDQUFLQUlRSWdORkRRTWdBRUVRYWlFRkN3TkFJQVVoQ3lBRElnaEJGR29pQlNnQ0FDSUREUUFnQ0VFUWFpRUZJQWdvQWhBaUF3MEFDeUFMUVFBMkFnQU1DZ3RCZnlFQ0lBQkJ2MzlMRFFBZ0FFRVRhaUlEUVhCeElRSkJBQ2dDak5DQWdBQWlCMFVOQUVFQUlRc0NRQ0FDUVlBQ1NRMEFRUjhoQ3lBQ1FmLy8vd2RMRFFBZ0EwRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lFSUFSQmdPQWZha0VRZGtFRWNTSUVkQ0lGSUFWQmdJQVBha0VRZGtFQ2NTSUZkRUVQZGlBRElBUnlJQVZ5YXlJRFFRRjBJQUlnQTBFVmFuWkJBWEZ5UVJ4cUlRc0xRUUFnQW1zaEJBSkFBa0FDUUFKQUlBdEJBblJCdU5LQWdBQnFLQUlBSWdVTkFFRUFJUU5CQUNFSURBRUxRUUFoQXlBQ1FRQkJHU0FMUVFGMmF5QUxRUjlHRzNRaEFFRUFJUWdEUUFKQUlBVW9BZ1JCZUhFZ0Ftc2lCaUFFVHcwQUlBWWhCQ0FGSVFnZ0JnMEFRUUFoQkNBRklRZ2dCU0VEREFNTElBTWdCVUVVYWlnQ0FDSUdJQVlnQlNBQVFSMTJRUVJ4YWtFUWFpZ0NBQ0lGUmhzZ0F5QUdHeUVESUFCQkFYUWhBQ0FGRFFBTEN3SkFJQU1nQ0hJTkFFRUFJUWhCQWlBTGRDSURRUUFnQTJ0eUlBZHhJZ05GRFFNZ0EwRUFJQU5yY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQlVFRmRrRUljU0lBSUFOeUlBVWdBSFlpQTBFQ2RrRUVjU0lGY2lBRElBVjJJZ05CQVhaQkFuRWlCWElnQXlBRmRpSURRUUYyUVFGeElnVnlJQU1nQlhacVFRSjBRYmpTZ0lBQWFpZ0NBQ0VEQ3lBRFJRMEJDd05BSUFNb0FnUkJlSEVnQW1zaUJpQUVTU0VBQWtBZ0F5Z0NFQ0lGRFFBZ0EwRVVhaWdDQUNFRkN5QUdJQVFnQUJzaEJDQURJQWdnQUJzaENDQUZJUU1nQlEwQUN3c2dDRVVOQUNBRVFRQW9BcERRZ0lBQUlBSnJUdzBBSUFnb0FoZ2hDd0pBSUFnb0Fnd2lBQ0FJUmcwQUlBZ29BZ2dpQTBFQUtBS1kwSUNBQUVrYUlBQWdBellDQ0NBRElBQTJBZ3dNQ1FzQ1FDQUlRUlJxSWdVb0FnQWlBdzBBSUFnb0FoQWlBMFVOQXlBSVFSQnFJUVVMQTBBZ0JTRUdJQU1pQUVFVWFpSUZLQUlBSWdNTkFDQUFRUkJxSVFVZ0FDZ0NFQ0lERFFBTElBWkJBRFlDQUF3SUN3SkFRUUFvQXBEUWdJQUFJZ01nQWtrTkFFRUFLQUtjMElDQUFDRUVBa0FDUUNBRElBSnJJZ1ZCRUVrTkFDQUVJQUpxSWdBZ0JVRUJjallDQkVFQUlBVTJBcERRZ0lBQVFRQWdBRFlDbk5DQWdBQWdCQ0FEYWlBRk5nSUFJQVFnQWtFRGNqWUNCQXdCQ3lBRUlBTkJBM0kyQWdRZ0JDQURhaUlESUFNb0FnUkJBWEkyQWdSQkFFRUFOZ0tjMElDQUFFRUFRUUEyQXBEUWdJQUFDeUFFUVFocUlRTU1DZ3NDUUVFQUtBS1UwSUNBQUNJQUlBSk5EUUJCQUNnQ29OQ0FnQUFpQXlBQ2FpSUVJQUFnQW1zaUJVRUJjallDQkVFQUlBVTJBcFRRZ0lBQVFRQWdCRFlDb05DQWdBQWdBeUFDUVFOeU5nSUVJQU5CQ0dvaEF3d0tDd0pBQWtCQkFDZ0M0Tk9BZ0FCRkRRQkJBQ2dDNk5PQWdBQWhCQXdCQzBFQVFuODNBdXpUZ0lBQVFRQkNnSUNFZ0lDQXdBQTNBdVRUZ0lBQVFRQWdBVUVNYWtGd2NVSFlxdFdxQlhNMkF1RFRnSUFBUVFCQkFEWUM5Tk9BZ0FCQkFFRUFOZ0xFMDRDQUFFR0FnQVFoQkF0QkFDRURBa0FnQkNBQ1FjY0FhaUlIYWlJR1FRQWdCR3NpQzNFaUNDQUNTdzBBUVFCQk1EWUMrTk9BZ0FBTUNnc0NRRUVBS0FMQTA0Q0FBQ0lEUlEwQUFrQkJBQ2dDdU5PQWdBQWlCQ0FJYWlJRklBUk5EUUFnQlNBRFRRMEJDMEVBSVFOQkFFRXdOZ0w0MDRDQUFBd0tDMEVBTFFERTA0Q0FBRUVFY1EwRUFrQUNRQUpBUVFBb0FxRFFnSUFBSWdSRkRRQkJ5Tk9BZ0FBaEF3TkFBa0FnQXlnQ0FDSUZJQVJMRFFBZ0JTQURLQUlFYWlBRVN3MERDeUFES0FJSUlnTU5BQXNMUVFBUXk0Q0FnQUFpQUVGL1JnMEZJQWdoQmdKQVFRQW9BdVRUZ0lBQUlnTkJmMm9pQkNBQWNVVU5BQ0FJSUFCcklBUWdBR3BCQUNBRGEzRnFJUVlMSUFZZ0FrME5CU0FHUWY3Ly8vOEhTdzBGQWtCQkFDZ0N3Tk9BZ0FBaUEwVU5BRUVBS0FLNDA0Q0FBQ0lFSUFacUlnVWdCRTBOQmlBRklBTkxEUVlMSUFZUXk0Q0FnQUFpQXlBQVJ3MEJEQWNMSUFZZ0FHc2dDM0VpQmtIKy8vLy9CMHNOQkNBR0VNdUFnSUFBSWdBZ0F5Z0NBQ0FES0FJRWFrWU5BeUFBSVFNTEFrQWdBMEYvUmcwQUlBSkJ5QUJxSUFaTkRRQUNRQ0FISUFaclFRQW9BdWpUZ0lBQUlnUnFRUUFnQkd0eElnUkIvdi8vL3dkTkRRQWdBeUVBREFjTEFrQWdCQkRMZ0lDQUFFRi9SZzBBSUFRZ0Jtb2hCaUFESVFBTUJ3dEJBQ0FHYXhETGdJQ0FBQm9NQkFzZ0F5RUFJQU5CZjBjTkJRd0RDMEVBSVFnTUJ3dEJBQ0VBREFVTElBQkJmMGNOQWd0QkFFRUFLQUxFMDRDQUFFRUVjallDeE5PQWdBQUxJQWhCL3YvLy93ZExEUUVnQ0JETGdJQ0FBQ0VBUVFBUXk0Q0FnQUFoQXlBQVFYOUdEUUVnQTBGL1JnMEJJQUFnQTA4TkFTQURJQUJySWdZZ0FrRTRhazBOQVF0QkFFRUFLQUs0MDRDQUFDQUdhaUlETmdLNDA0Q0FBQUpBSUFOQkFDZ0N2Tk9BZ0FCTkRRQkJBQ0FETmdLODA0Q0FBQXNDUUFKQUFrQUNRRUVBS0FLZzBJQ0FBQ0lFUlEwQVFjalRnSUFBSVFNRFFDQUFJQU1vQWdBaUJTQURLQUlFSWdocVJnMENJQU1vQWdnaUF3MEFEQU1MQ3dKQUFrQkJBQ2dDbU5DQWdBQWlBMFVOQUNBQUlBTlBEUUVMUVFBZ0FEWUNtTkNBZ0FBTFFRQWhBMEVBSUFZMkFzelRnSUFBUVFBZ0FEWUN5Tk9BZ0FCQkFFRi9OZ0tvMElDQUFFRUFRUUFvQXVEVGdJQUFOZ0tzMElDQUFFRUFRUUEyQXRUVGdJQUFBMEFnQTBIRTBJQ0FBR29nQTBHNDBJQ0FBR29pQkRZQ0FDQUVJQU5Cc05DQWdBQnFJZ1UyQWdBZ0EwRzgwSUNBQUdvZ0JUWUNBQ0FEUWN6UWdJQUFhaUFEUWNEUWdJQUFhaUlGTmdJQUlBVWdCRFlDQUNBRFFkVFFnSUFBYWlBRFFjalFnSUFBYWlJRU5nSUFJQVFnQlRZQ0FDQURRZERRZ0lBQWFpQUVOZ0lBSUFOQklHb2lBMEdBQWtjTkFBc2dBRUY0SUFCclFROXhRUUFnQUVFSWFrRVBjUnNpQTJvaUJDQUdRVWhxSWdVZ0Eyc2lBMEVCY2pZQ0JFRUFRUUFvQXZEVGdJQUFOZ0trMElDQUFFRUFJQU0yQXBUUWdJQUFRUUFnQkRZQ29OQ0FnQUFnQUNBRmFrRTROZ0lFREFJTElBTXRBQXhCQ0hFTkFDQUVJQVZKRFFBZ0JDQUFUdzBBSUFSQmVDQUVhMEVQY1VFQUlBUkJDR3BCRDNFYklnVnFJZ0JCQUNnQ2xOQ0FnQUFnQm1vaUN5QUZheUlGUVFGeU5nSUVJQU1nQ0NBR2FqWUNCRUVBUVFBb0F2RFRnSUFBTmdLazBJQ0FBRUVBSUFVMkFwVFFnSUFBUVFBZ0FEWUNvTkNBZ0FBZ0JDQUxha0U0TmdJRURBRUxBa0FnQUVFQUtBS1kwSUNBQUNJSVR3MEFRUUFnQURZQ21OQ0FnQUFnQUNFSUN5QUFJQVpxSVFWQnlOT0FnQUFoQXdKQUFrQUNRQUpBQWtBQ1FBSkFBMEFnQXlnQ0FDQUZSZzBCSUFNb0FnZ2lBdzBBREFJTEN5QURMUUFNUVFoeFJRMEJDMEhJMDRDQUFDRURBMEFDUUNBREtBSUFJZ1VnQkVzTkFDQUZJQU1vQWdScUlnVWdCRXNOQXdzZ0F5Z0NDQ0VEREFBTEN5QURJQUEyQWdBZ0F5QURLQUlFSUFacU5nSUVJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViYWlJTElBSkJBM0kyQWdRZ0JVRjRJQVZyUVE5eFFRQWdCVUVJYWtFUGNSdHFJZ1lnQ3lBQ2FpSUNheUVEQWtBZ0JpQUVSdzBBUVFBZ0FqWUNvTkNBZ0FCQkFFRUFLQUtVMElDQUFDQURhaUlETmdLVTBJQ0FBQ0FDSUFOQkFYSTJBZ1FNQXdzQ1FDQUdRUUFvQXB6UWdJQUFSdzBBUVFBZ0FqWUNuTkNBZ0FCQkFFRUFLQUtRMElDQUFDQURhaUlETmdLUTBJQ0FBQ0FDSUFOQkFYSTJBZ1FnQWlBRGFpQUROZ0lBREFNTEFrQWdCaWdDQkNJRVFRTnhRUUZIRFFBZ0JFRjRjU0VIQWtBQ1FDQUVRZjhCU3cwQUlBWW9BZ2dpQlNBRVFRTjJJZ2hCQTNSQnNOQ0FnQUJxSWdCR0dnSkFJQVlvQWd3aUJDQUZSdzBBUVFCQkFDZ0NpTkNBZ0FCQmZpQUlkM0UyQW9qUWdJQUFEQUlMSUFRZ0FFWWFJQVFnQlRZQ0NDQUZJQVEyQWd3TUFRc2dCaWdDR0NFSkFrQUNRQ0FHS0FJTUlnQWdCa1lOQUNBR0tBSUlJZ1FnQ0VrYUlBQWdCRFlDQ0NBRUlBQTJBZ3dNQVFzQ1FDQUdRUlJxSWdRb0FnQWlCUTBBSUFaQkVHb2lCQ2dDQUNJRkRRQkJBQ0VBREFFTEEwQWdCQ0VJSUFVaUFFRVVhaUlFS0FJQUlnVU5BQ0FBUVJCcUlRUWdBQ2dDRUNJRkRRQUxJQWhCQURZQ0FBc2dDVVVOQUFKQUFrQWdCaUFHS0FJY0lnVkJBblJCdU5LQWdBQnFJZ1FvQWdCSERRQWdCQ0FBTmdJQUlBQU5BVUVBUVFBb0FvelFnSUFBUVg0Z0JYZHhOZ0tNMElDQUFBd0NDeUFKUVJCQkZDQUpLQUlRSUFaR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFrMkFoZ0NRQ0FHS0FJUUlnUkZEUUFnQUNBRU5nSVFJQVFnQURZQ0dBc2dCaWdDRkNJRVJRMEFJQUJCRkdvZ0JEWUNBQ0FFSUFBMkFoZ0xJQWNnQTJvaEF5QUdJQWRxSWdZb0FnUWhCQXNnQmlBRVFYNXhOZ0lFSUFJZ0Eyb2dBellDQUNBQ0lBTkJBWEkyQWdRQ1FDQURRZjhCU3cwQUlBTkJlSEZCc05DQWdBQnFJUVFDUUFKQVFRQW9Bb2pRZ0lBQUlnVkJBU0FEUVFOMmRDSURjUTBBUVFBZ0JTQURjallDaU5DQWdBQWdCQ0VEREFFTElBUW9BZ2doQXdzZ0F5QUNOZ0lNSUFRZ0FqWUNDQ0FDSUFRMkFnd2dBaUFETmdJSURBTUxRUjhoQkFKQUlBTkIvLy8vQjBzTkFDQURRUWgySWdRZ0JFR0EvajlxUVJCMlFRaHhJZ1IwSWdVZ0JVR0E0QjlxUVJCMlFRUnhJZ1YwSWdBZ0FFR0FnQTlxUVJCMlFRSnhJZ0IwUVE5MklBUWdCWElnQUhKcklnUkJBWFFnQXlBRVFSVnFka0VCY1hKQkhHb2hCQXNnQWlBRU5nSWNJQUpDQURjQ0VDQUVRUUowUWJqU2dJQUFhaUVGQWtCQkFDZ0NqTkNBZ0FBaUFFRUJJQVIwSWdoeERRQWdCU0FDTmdJQVFRQWdBQ0FJY2pZQ2pOQ0FnQUFnQWlBRk5nSVlJQUlnQWpZQ0NDQUNJQUkyQWd3TUF3c2dBMEVBUVJrZ0JFRUJkbXNnQkVFZlJodDBJUVFnQlNnQ0FDRUFBMEFnQUNJRktBSUVRWGh4SUFOR0RRSWdCRUVkZGlFQUlBUkJBWFFoQkNBRklBQkJCSEZxUVJCcUlnZ29BZ0FpQUEwQUN5QUlJQUkyQWdBZ0FpQUZOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BZ3NnQUVGNElBQnJRUTl4UVFBZ0FFRUlha0VQY1JzaUEyb2lDeUFHUVVocUlnZ2dBMnNpQTBFQmNqWUNCQ0FBSUFocVFUZzJBZ1FnQkNBRlFUY2dCV3RCRDNGQkFDQUZRVWxxUVE5eEcycEJRV29pQ0NBSUlBUkJFR3BKR3lJSVFTTTJBZ1JCQUVFQUtBTHcwNENBQURZQ3BOQ0FnQUJCQUNBRE5nS1UwSUNBQUVFQUlBczJBcURRZ0lBQUlBaEJFR3BCQUNrQzBOT0FnQUEzQWdBZ0NFRUFLUUxJMDRDQUFEY0NDRUVBSUFoQkNHbzJBdERUZ0lBQVFRQWdCallDek5PQWdBQkJBQ0FBTmdMSTA0Q0FBRUVBUVFBMkF0VFRnSUFBSUFoQkpHb2hBd05BSUFOQkJ6WUNBQ0FEUVFScUlnTWdCVWtOQUFzZ0NDQUVSZzBESUFnZ0NDZ0NCRUYrY1RZQ0JDQUlJQWdnQkdzaUFEWUNBQ0FFSUFCQkFYSTJBZ1FDUUNBQVFmOEJTdzBBSUFCQmVIRkJzTkNBZ0FCcUlRTUNRQUpBUVFBb0FvalFnSUFBSWdWQkFTQUFRUU4yZENJQWNRMEFRUUFnQlNBQWNqWUNpTkNBZ0FBZ0F5RUZEQUVMSUFNb0FnZ2hCUXNnQlNBRU5nSU1JQU1nQkRZQ0NDQUVJQU0yQWd3Z0JDQUZOZ0lJREFRTFFSOGhBd0pBSUFCQi8vLy9CMHNOQUNBQVFRaDJJZ01nQTBHQS9qOXFRUkIyUVFoeElnTjBJZ1VnQlVHQTRCOXFRUkIyUVFSeElnVjBJZ2dnQ0VHQWdBOXFRUkIyUVFKeElnaDBRUTkySUFNZ0JYSWdDSEpySWdOQkFYUWdBQ0FEUVJWcWRrRUJjWEpCSEdvaEF3c2dCQ0FETmdJY0lBUkNBRGNDRUNBRFFRSjBRYmpTZ0lBQWFpRUZBa0JCQUNnQ2pOQ0FnQUFpQ0VFQklBTjBJZ1p4RFFBZ0JTQUVOZ0lBUVFBZ0NDQUdjallDak5DQWdBQWdCQ0FGTmdJWUlBUWdCRFlDQ0NBRUlBUTJBZ3dNQkFzZ0FFRUFRUmtnQTBFQmRtc2dBMEVmUmh0MElRTWdCU2dDQUNFSUEwQWdDQ0lGS0FJRVFYaHhJQUJHRFFNZ0EwRWRkaUVJSUFOQkFYUWhBeUFGSUFoQkJIRnFRUkJxSWdZb0FnQWlDQTBBQ3lBR0lBUTJBZ0FnQkNBRk5nSVlJQVFnQkRZQ0RDQUVJQVEyQWdnTUF3c2dCU2dDQ0NJRElBSTJBZ3dnQlNBQ05nSUlJQUpCQURZQ0dDQUNJQVUyQWd3Z0FpQUROZ0lJQ3lBTFFRaHFJUU1NQlFzZ0JTZ0NDQ0lESUFRMkFnd2dCU0FFTmdJSUlBUkJBRFlDR0NBRUlBVTJBZ3dnQkNBRE5nSUlDMEVBS0FLVTBJQ0FBQ0lESUFKTkRRQkJBQ2dDb05DQWdBQWlCQ0FDYWlJRklBTWdBbXNpQTBFQmNqWUNCRUVBSUFNMkFwVFFnSUFBUVFBZ0JUWUNvTkNBZ0FBZ0JDQUNRUU55TmdJRUlBUkJDR29oQXd3REMwRUFJUU5CQUVFd05nTDQwNENBQUF3Q0N3SkFJQXRGRFFBQ1FBSkFJQWdnQ0NnQ0hDSUZRUUowUWJqU2dJQUFhaUlES0FJQVJ3MEFJQU1nQURZQ0FDQUFEUUZCQUNBSFFYNGdCWGR4SWdjMkFvelFnSUFBREFJTElBdEJFRUVVSUFzb0FoQWdDRVliYWlBQU5nSUFJQUJGRFFFTElBQWdDellDR0FKQUlBZ29BaEFpQTBVTkFDQUFJQU0yQWhBZ0F5QUFOZ0lZQ3lBSVFSUnFLQUlBSWdORkRRQWdBRUVVYWlBRE5nSUFJQU1nQURZQ0dBc0NRQUpBSUFSQkQwc05BQ0FJSUFRZ0Ftb2lBMEVEY2pZQ0JDQUlJQU5xSWdNZ0F5Z0NCRUVCY2pZQ0JBd0JDeUFJSUFKcUlnQWdCRUVCY2pZQ0JDQUlJQUpCQTNJMkFnUWdBQ0FFYWlBRU5nSUFBa0FnQkVIL0FVc05BQ0FFUVhoeFFiRFFnSUFBYWlFREFrQUNRRUVBS0FLSTBJQ0FBQ0lGUVFFZ0JFRURkblFpQkhFTkFFRUFJQVVnQkhJMkFvalFnSUFBSUFNaEJBd0JDeUFES0FJSUlRUUxJQVFnQURZQ0RDQURJQUEyQWdnZ0FDQUROZ0lNSUFBZ0JEWUNDQXdCQzBFZklRTUNRQ0FFUWYvLy93ZExEUUFnQkVFSWRpSURJQU5CZ1A0L2FrRVFka0VJY1NJRGRDSUZJQVZCZ09BZmFrRVFka0VFY1NJRmRDSUNJQUpCZ0lBUGFrRVFka0VDY1NJQ2RFRVBkaUFESUFWeUlBSnlheUlEUVFGMElBUWdBMEVWYW5aQkFYRnlRUnhxSVFNTElBQWdBellDSENBQVFnQTNBaEFnQTBFQ2RFRzQwb0NBQUdvaEJRSkFJQWRCQVNBRGRDSUNjUTBBSUFVZ0FEWUNBRUVBSUFjZ0FuSTJBb3pRZ0lBQUlBQWdCVFlDR0NBQUlBQTJBZ2dnQUNBQU5nSU1EQUVMSUFSQkFFRVpJQU5CQVhacklBTkJIMFliZENFRElBVW9BZ0FoQWdKQUEwQWdBaUlGS0FJRVFYaHhJQVJHRFFFZ0EwRWRkaUVDSUFOQkFYUWhBeUFGSUFKQkJIRnFRUkJxSWdZb0FnQWlBZzBBQ3lBR0lBQTJBZ0FnQUNBRk5nSVlJQUFnQURZQ0RDQUFJQUEyQWdnTUFRc2dCU2dDQ0NJRElBQTJBZ3dnQlNBQU5nSUlJQUJCQURZQ0dDQUFJQVUyQWd3Z0FDQUROZ0lJQ3lBSVFRaHFJUU1NQVFzQ1FDQUtSUTBBQWtBQ1FDQUFJQUFvQWh3aUJVRUNkRUc0MG9DQUFHb2lBeWdDQUVjTkFDQURJQWcyQWdBZ0NBMEJRUUFnQ1VGK0lBVjNjVFlDak5DQWdBQU1BZ3NnQ2tFUVFSUWdDaWdDRUNBQVJodHFJQWcyQWdBZ0NFVU5BUXNnQ0NBS05nSVlBa0FnQUNnQ0VDSURSUTBBSUFnZ0F6WUNFQ0FESUFnMkFoZ0xJQUJCRkdvb0FnQWlBMFVOQUNBSVFSUnFJQU0yQWdBZ0F5QUlOZ0lZQ3dKQUFrQWdCRUVQU3cwQUlBQWdCQ0FDYWlJRFFRTnlOZ0lFSUFBZ0Eyb2lBeUFES0FJRVFRRnlOZ0lFREFFTElBQWdBbW9pQlNBRVFRRnlOZ0lFSUFBZ0FrRURjallDQkNBRklBUnFJQVEyQWdBQ1FDQUhSUTBBSUFkQmVIRkJzTkNBZ0FCcUlRSkJBQ2dDbk5DQWdBQWhBd0pBQWtCQkFTQUhRUU4yZENJSUlBWnhEUUJCQUNBSUlBWnlOZ0tJMElDQUFDQUNJUWdNQVFzZ0FpZ0NDQ0VJQ3lBSUlBTTJBZ3dnQWlBRE5nSUlJQU1nQWpZQ0RDQURJQWcyQWdnTFFRQWdCVFlDbk5DQWdBQkJBQ0FFTmdLUTBJQ0FBQXNnQUVFSWFpRURDeUFCUVJCcUpJQ0FnSUFBSUFNTENnQWdBQkRKZ0lDQUFBdmlEUUVIZndKQUlBQkZEUUFnQUVGNGFpSUJJQUJCZkdvb0FnQWlBa0Y0Y1NJQWFpRURBa0FnQWtFQmNRMEFJQUpCQTNGRkRRRWdBU0FCS0FJQUlnSnJJZ0ZCQUNnQ21OQ0FnQUFpQkVrTkFTQUNJQUJxSVFBQ1FDQUJRUUFvQXB6UWdJQUFSZzBBQWtBZ0FrSC9BVXNOQUNBQktBSUlJZ1FnQWtFRGRpSUZRUU4wUWJEUWdJQUFhaUlHUmhvQ1FDQUJLQUlNSWdJZ0JFY05BRUVBUVFBb0FvalFnSUFBUVg0Z0JYZHhOZ0tJMElDQUFBd0RDeUFDSUFaR0dpQUNJQVEyQWdnZ0JDQUNOZ0lNREFJTElBRW9BaGdoQndKQUFrQWdBU2dDRENJR0lBRkdEUUFnQVNnQ0NDSUNJQVJKR2lBR0lBSTJBZ2dnQWlBR05nSU1EQUVMQWtBZ0FVRVVhaUlDS0FJQUlnUU5BQ0FCUVJCcUlnSW9BZ0FpQkEwQVFRQWhCZ3dCQ3dOQUlBSWhCU0FFSWdaQkZHb2lBaWdDQUNJRURRQWdCa0VRYWlFQ0lBWW9BaEFpQkEwQUN5QUZRUUEyQWdBTElBZEZEUUVDUUFKQUlBRWdBU2dDSENJRVFRSjBRYmpTZ0lBQWFpSUNLQUlBUncwQUlBSWdCallDQUNBR0RRRkJBRUVBS0FLTTBJQ0FBRUYrSUFSM2NUWUNqTkNBZ0FBTUF3c2dCMEVRUVJRZ0J5Z0NFQ0FCUmh0cUlBWTJBZ0FnQmtVTkFnc2dCaUFITmdJWUFrQWdBU2dDRUNJQ1JRMEFJQVlnQWpZQ0VDQUNJQVkyQWhnTElBRW9BaFFpQWtVTkFTQUdRUlJxSUFJMkFnQWdBaUFHTmdJWURBRUxJQU1vQWdRaUFrRURjVUVEUncwQUlBTWdBa0YrY1RZQ0JFRUFJQUEyQXBEUWdJQUFJQUVnQUdvZ0FEWUNBQ0FCSUFCQkFYSTJBZ1FQQ3lBQklBTlBEUUFnQXlnQ0JDSUNRUUZ4UlEwQUFrQUNRQ0FDUVFKeERRQUNRQ0FEUVFBb0FxRFFnSUFBUncwQVFRQWdBVFlDb05DQWdBQkJBRUVBS0FLVTBJQ0FBQ0FBYWlJQU5nS1UwSUNBQUNBQklBQkJBWEkyQWdRZ0FVRUFLQUtjMElDQUFFY05BMEVBUVFBMkFwRFFnSUFBUVFCQkFEWUNuTkNBZ0FBUEN3SkFJQU5CQUNnQ25OQ0FnQUJIRFFCQkFDQUJOZ0tjMElDQUFFRUFRUUFvQXBEUWdJQUFJQUJxSWdBMkFwRFFnSUFBSUFFZ0FFRUJjallDQkNBQklBQnFJQUEyQWdBUEN5QUNRWGh4SUFCcUlRQUNRQUpBSUFKQi93RkxEUUFnQXlnQ0NDSUVJQUpCQTNZaUJVRURkRUd3MElDQUFHb2lCa1lhQWtBZ0F5Z0NEQ0lDSUFSSERRQkJBRUVBS0FLSTBJQ0FBRUYrSUFWM2NUWUNpTkNBZ0FBTUFnc2dBaUFHUmhvZ0FpQUVOZ0lJSUFRZ0FqWUNEQXdCQ3lBREtBSVlJUWNDUUFKQUlBTW9BZ3dpQmlBRFJnMEFJQU1vQWdnaUFrRUFLQUtZMElDQUFFa2FJQVlnQWpZQ0NDQUNJQVkyQWd3TUFRc0NRQ0FEUVJScUlnSW9BZ0FpQkEwQUlBTkJFR29pQWlnQ0FDSUVEUUJCQUNFR0RBRUxBMEFnQWlFRklBUWlCa0VVYWlJQ0tBSUFJZ1FOQUNBR1FSQnFJUUlnQmlnQ0VDSUVEUUFMSUFWQkFEWUNBQXNnQjBVTkFBSkFBa0FnQXlBREtBSWNJZ1JCQW5SQnVOS0FnQUJxSWdJb0FnQkhEUUFnQWlBR05nSUFJQVlOQVVFQVFRQW9Bb3pRZ0lBQVFYNGdCSGR4TmdLTTBJQ0FBQXdDQ3lBSFFSQkJGQ0FIS0FJUUlBTkdHMm9nQmpZQ0FDQUdSUTBCQ3lBR0lBYzJBaGdDUUNBREtBSVFJZ0pGRFFBZ0JpQUNOZ0lRSUFJZ0JqWUNHQXNnQXlnQ0ZDSUNSUTBBSUFaQkZHb2dBallDQUNBQ0lBWTJBaGdMSUFFZ0FHb2dBRFlDQUNBQklBQkJBWEkyQWdRZ0FVRUFLQUtjMElDQUFFY05BVUVBSUFBMkFwRFFnSUFBRHdzZ0F5QUNRWDV4TmdJRUlBRWdBR29nQURZQ0FDQUJJQUJCQVhJMkFnUUxBa0FnQUVIL0FVc05BQ0FBUVhoeFFiRFFnSUFBYWlFQ0FrQUNRRUVBS0FLSTBJQ0FBQ0lFUVFFZ0FFRURkblFpQUhFTkFFRUFJQVFnQUhJMkFvalFnSUFBSUFJaEFBd0JDeUFDS0FJSUlRQUxJQUFnQVRZQ0RDQUNJQUUyQWdnZ0FTQUNOZ0lNSUFFZ0FEWUNDQThMUVI4aEFnSkFJQUJCLy8vL0Iwc05BQ0FBUVFoMklnSWdBa0dBL2o5cVFSQjJRUWh4SWdKMElnUWdCRUdBNEI5cVFSQjJRUVJ4SWdSMElnWWdCa0dBZ0E5cVFSQjJRUUp4SWdaMFFROTJJQUlnQkhJZ0JuSnJJZ0pCQVhRZ0FDQUNRUlZxZGtFQmNYSkJIR29oQWdzZ0FTQUNOZ0ljSUFGQ0FEY0NFQ0FDUVFKMFFialNnSUFBYWlFRUFrQUNRRUVBS0FLTTBJQ0FBQ0lHUVFFZ0FuUWlBM0VOQUNBRUlBRTJBZ0JCQUNBR0lBTnlOZ0tNMElDQUFDQUJJQVEyQWhnZ0FTQUJOZ0lJSUFFZ0FUWUNEQXdCQ3lBQVFRQkJHU0FDUVFGMmF5QUNRUjlHRzNRaEFpQUVLQUlBSVFZQ1FBTkFJQVlpQkNnQ0JFRjRjU0FBUmcwQklBSkJIWFloQmlBQ1FRRjBJUUlnQkNBR1FRUnhha0VRYWlJREtBSUFJZ1lOQUFzZ0F5QUJOZ0lBSUFFZ0JEWUNHQ0FCSUFFMkFnd2dBU0FCTmdJSURBRUxJQVFvQWdnaUFDQUJOZ0lNSUFRZ0FUWUNDQ0FCUVFBMkFoZ2dBU0FFTmdJTUlBRWdBRFlDQ0F0QkFFRUFLQUtvMElDQUFFRi9haUlCUVg4Z0FSczJBcWpRZ0lBQUN3c0VBQUFBQzA0QUFrQWdBQTBBUHdCQkVIUVBDd0pBSUFCQi8vOERjUTBBSUFCQmYwd05BQUpBSUFCQkVIWkFBQ0lBUVg5SERRQkJBRUV3TmdMNDA0Q0FBRUYvRHdzZ0FFRVFkQThMRU1xQWdJQUFBQXZ5QWdJRGZ3RitBa0FnQWtVTkFDQUFJQUU2QUFBZ0FpQUFhaUlEUVg5cUlBRTZBQUFnQWtFRFNRMEFJQUFnQVRvQUFpQUFJQUU2QUFFZ0EwRjlhaUFCT2dBQUlBTkJmbW9nQVRvQUFDQUNRUWRKRFFBZ0FDQUJPZ0FESUFOQmZHb2dBVG9BQUNBQ1FRbEpEUUFnQUVFQUlBQnJRUU54SWdScUlnTWdBVUgvQVhGQmdZS0VDR3dpQVRZQ0FDQURJQUlnQkd0QmZIRWlCR29pQWtGOGFpQUJOZ0lBSUFSQkNVa05BQ0FESUFFMkFnZ2dBeUFCTmdJRUlBSkJlR29nQVRZQ0FDQUNRWFJxSUFFMkFnQWdCRUVaU1EwQUlBTWdBVFlDR0NBRElBRTJBaFFnQXlBQk5nSVFJQU1nQVRZQ0RDQUNRWEJxSUFFMkFnQWdBa0ZzYWlBQk5nSUFJQUpCYUdvZ0FUWUNBQ0FDUVdScUlBRTJBZ0FnQkNBRFFRUnhRUmh5SWdWcklnSkJJRWtOQUNBQnJVS0JnSUNBRUg0aEJpQURJQVZxSVFFRFFDQUJJQVkzQXhnZ0FTQUdOd01RSUFFZ0JqY0RDQ0FCSUFZM0F3QWdBVUVnYWlFQklBSkJZR29pQWtFZlN3MEFDd3NnQUFzTGprZ0JBRUdBQ0F1R1NBRUFBQUFDQUFBQUF3QUFBQUFBQUFBQUFBQUFCQUFBQUFVQUFBQUFBQUFBQUFBQUFBWUFBQUFIQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0J4ZFdWeWVRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgySnZaSGtBUTI5dWRHVnVkQzFNWlc1bmRHZ2diM1psY21ac2IzY0FRMmgxYm1zZ2MybDZaU0J2ZG1WeVpteHZkd0JTWlhOd2IyNXpaU0J2ZG1WeVpteHZkd0JKYm5aaGJHbGtJRzFsZEdodlpDQm1iM0lnU0ZSVVVDOTRMbmdnY21WeGRXVnpkQUJKYm5aaGJHbGtJRzFsZEdodlpDQm1iM0lnVWxSVFVDOTRMbmdnY21WeGRXVnpkQUJGZUhCbFkzUmxaQ0JUVDFWU1EwVWdiV1YwYUc5a0lHWnZjaUJKUTBVdmVDNTRJSEpsY1hWbGMzUUFTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0JtY21GbmJXVnVkQ0J6ZEdGeWRBQkZlSEJsWTNSbFpDQmtiM1FBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDl6ZEdGMGRYTUFTVzUyWVd4cFpDQnlaWE53YjI1elpTQnpkR0YwZFhNQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN3QlZjMlZ5SUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5eVpYTmxkR0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMmhsWVdSbGNtQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMjFsYzNOaFoyVmZZbVZuYVc1Z0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5emRHRjBkWE5mWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5MlpYSnphVzl1WDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmRYSnNYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlvWldGa1pYSmZkbUZzZFdWZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWE56WVdkbFgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1YwYUc5a1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZhR1ZoWkdWeVgyWnBaV3hrWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDI1aGJXVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFGVnVaWGh3WldOMFpXUWdZMmhoY2lCcGJpQjFjbXdnYzJWeWRtVnlBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlIWmhiSFZsSUdOb1lYSUFTVzUyWVd4cFpDQm9aV0ZrWlhJZ1ptbGxiR1FnWTJoaGNnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzWmxjbk5wYjI0QVNXNTJZV3hwWkNCdGFXNXZjaUIyWlhKemFXOXVBRWx1ZG1Gc2FXUWdiV0ZxYjNJZ2RtVnljMmx2YmdCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQjJaWEp6YVc5dUFFVjRjR1ZqZEdWa0lFTlNURVlnWVdaMFpYSWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lFaFVWRkFnZG1WeWMybHZiZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjBiMnRsYmdCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNWeWJBQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNuTWdhVzRnZFhKc0FGVnVaWGh3WldOMFpXUWdjM1JoY25RZ1kyaGhjaUJwYmlCMWNtd0FSRzkxWW14bElFQWdhVzRnZFhKc0FFVnRjSFI1SUVOdmJuUmxiblF0VEdWdVozUm9BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUVOdmJuUmxiblF0VEdWdVozUm9BRVIxY0d4cFkyRjBaU0JEYjI1MFpXNTBMVXhsYm1kMGFBQkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJSEJoZEdnQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnWTJGdUozUWdZbVVnY0hKbGMyVnVkQ0IzYVhSb0lGUnlZVzV6Wm1WeUxVVnVZMjlrYVc1bkFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklITnBlbVVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlvWldGa1pYSmZkbUZzZFdVQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUIyWVd4MVpRQk5hWE56YVc1bklHVjRjR1ZqZEdWa0lFeEdJR0ZtZEdWeUlHaGxZV1JsY2lCMllXeDFaUUJKYm5aaGJHbGtJR0JVY21GdWMyWmxjaTFGYm1OdlpHbHVaMkFnYUdWaFpHVnlJSFpoYkhWbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdjWFZ2ZEdVZ2RtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCeGRXOTBaV1FnZG1Gc2RXVUFVR0YxYzJWa0lHSjVJRzl1WDJobFlXUmxjbk5mWTI5dGNHeGxkR1VBU1c1MllXeHBaQ0JGVDBZZ2MzUmhkR1VBYjI1ZmNtVnpaWFFnY0dGMWMyVUFiMjVmWTJoMWJtdGZhR1ZoWkdWeUlIQmhkWE5sQUc5dVgyMWxjM05oWjJWZlltVm5hVzRnY0dGMWMyVUFiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYM1poYkhWbElIQmhkWE5sQUc5dVgzTjBZWFIxYzE5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5MlpYSnphVzl1WDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDNWeWJGOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOWphSFZ1YTE5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOXRaWFJvYjJSZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmFHVmhaR1Z5WDJacFpXeGtYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOXVZVzFsSUhCaGRYTmxBRlZ1Wlhod1pXTjBaV1FnYzNCaFkyVWdZV1owWlhJZ2MzUmhjblFnYkdsdVpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5dVlXMWxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nYm1GdFpRQlFZWFZ6WlNCdmJpQkRUMDVPUlVOVUwxVndaM0poWkdVQVVHRjFjMlVnYjI0Z1VGSkpMMVZ3WjNKaFpHVUFSWGh3WldOMFpXUWdTRlJVVUM4eUlFTnZibTVsWTNScGIyNGdVSEpsWm1GalpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyMWxkR2h2WkFCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQnRaWFJvYjJRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmWm1sbGJHUUFVR0YxYzJWa0FFbHVkbUZzYVdRZ2QyOXlaQ0JsYm1OdmRXNTBaWEpsWkFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JsYm1OdmRXNTBaWEpsWkFCVmJtVjRjR1ZqZEdWa0lHTm9ZWElnYVc0Z2RYSnNJSE5qYUdWdFlRQlNaWEYxWlhOMElHaGhjeUJwYm5aaGJHbGtJR0JVY21GdWMyWmxjaTFGYm1OdlpHbHVaMkFBVTFkSlZFTklYMUJTVDFoWkFGVlRSVjlRVWs5WVdRQk5TMEZEVkVsV1NWUlpBRlZPVUZKUFEwVlRVMEZDVEVWZlJVNVVTVlJaQUVOUFVGa0FUVTlXUlVSZlVFVlNUVUZPUlU1VVRGa0FWRTlQWDBWQlVreFpBRTVQVkVsR1dRQkdRVWxNUlVSZlJFVlFSVTVFUlU1RFdRQkNRVVJmUjBGVVJWZEJXUUJRVEVGWkFGQlZWQUJEU0VWRFMwOVZWQUJIUVZSRlYwRlpYMVJKVFVWUFZWUUFVa1ZSVlVWVFZGOVVTVTFGVDFWVUFFNUZWRmRQVWt0ZlEwOU9Ua1ZEVkY5VVNVMUZUMVZVQUVOUFRrNUZRMVJKVDA1ZlZFbE5SVTlWVkFCTVQwZEpUbDlVU1UxRlQxVlVBRTVGVkZkUFVrdGZVa1ZCUkY5VVNVMUZUMVZVQUZCUFUxUUFUVWxUUkVsU1JVTlVSVVJmVWtWUlZVVlRWQUJEVEVsRlRsUmZRMHhQVTBWRVgxSkZVVlZGVTFRQVEweEpSVTVVWDBOTVQxTkZSRjlNVDBGRVgwSkJURUZPUTBWRVgxSkZVVlZGVTFRQVFrRkVYMUpGVVZWRlUxUUFTRlJVVUY5U1JWRlZSVk5VWDFORlRsUmZWRTlmU0ZSVVVGTmZVRTlTVkFCU1JWQlBVbFFBU1UxZlFWOVVSVUZRVDFRQVVrVlRSVlJmUTA5T1ZFVk9WQUJPVDE5RFQwNVVSVTVVQUZCQlVsUkpRVXhmUTA5T1ZFVk9WQUJJVUVWZlNVNVdRVXhKUkY5RFQwNVRWRUZPVkFCSVVFVmZRMEpmVWtWVFJWUUFSMFZVQUVoUVJWOVRWRkpKUTFRQVEwOU9Sa3hKUTFRQVZFVk5VRTlTUVZKWlgxSkZSRWxTUlVOVUFGQkZVazFCVGtWT1ZGOVNSVVJKVWtWRFZBQkRUMDVPUlVOVUFFMVZURlJKWDFOVVFWUlZVd0JJVUVWZlNVNVdRVXhKUkY5VFZFRlVWVk1BVkU5UFgwMUJUbGxmVWtWUlZVVlRWRk1BUlVGU1RGbGZTRWxPVkZNQVZVNUJWa0ZKVEVGQ1RFVmZSazlTWDB4RlIwRk1YMUpGUVZOUFRsTUFUMUJVU1U5T1V3QlRWMGxVUTBoSlRrZGZVRkpQVkU5RFQweFRBRlpCVWtsQlRsUmZRVXhUVDE5T1JVZFBWRWxCVkVWVEFFMVZURlJKVUV4RlgwTklUMGxEUlZNQVNVNVVSVkpPUVV4ZlUwVlNWa1ZTWDBWU1VrOVNBRmRGUWw5VFJWSldSVkpmVlU1TFRrOVhUbDlGVWxKUFVnQlNRVWxNUjFWT1gwVlNVazlTQUVsRVJVNVVTVlJaWDFCU1QxWkpSRVZTWDBGVlZFaEZUbFJKUTBGVVNVOU9YMFZTVWs5U0FGTlRURjlEUlZKVVNVWkpRMEZVUlY5RlVsSlBVZ0JKVGxaQlRFbEVYMWhmUms5U1YwRlNSRVZFWDBaUFVnQlRSVlJmVUVGU1FVMUZWRVZTQUVkRlZGOVFRVkpCVFVWVVJWSUFTRkJGWDFWVFJWSUFVMFZGWDA5VVNFVlNBRWhRUlY5RFFsOURTRlZPUzE5SVJVRkVSVklBVFV0RFFVeEZUa1JCVWdCVFJWUlZVQUJYUlVKZlUwVlNWa1ZTWDBsVFgwUlBWMDRBVkVWQlVrUlBWMDRBU0ZCRlgwTk1UMU5GUkY5RFQwNU9SVU5VU1U5T0FFaEZWVkpKVTFSSlExOUZXRkJKVWtGVVNVOU9BRVJKVTBOUFRrNUZRMVJGUkY5UFVFVlNRVlJKVDA0QVRrOU9YMEZWVkVoUFVrbFVRVlJKVmtWZlNVNUdUMUpOUVZSSlQwNEFTRkJGWDBsT1ZrRk1TVVJmVmtWU1UwbFBUZ0JJVUVWZlEwSmZUVVZUVTBGSFJWOUNSVWRKVGdCVFNWUkZYMGxUWDBaU1QxcEZUZ0JJVUVWZlNVNVdRVXhKUkY5SVJVRkVSVkpmVkU5TFJVNEFTVTVXUVV4SlJGOVVUMHRGVGdCR1QxSkNTVVJFUlU0QVJVNUlRVTVEUlY5WlQxVlNYME5CVEUwQVNGQkZYMGxPVmtGTVNVUmZWVkpNQUVKTVQwTkxSVVJmUWxsZlVFRlNSVTVVUVV4ZlEwOU9WRkpQVEFCTlMwTlBUQUJCUTB3QVNGQkZYMGxPVkVWU1RrRk1BRkpGVVZWRlUxUmZTRVZCUkVWU1gwWkpSVXhFVTE5VVQwOWZURUZTUjBWZlZVNVBSa1pKUTBsQlRBQklVRVZmVDBzQVZVNU1TVTVMQUZWT1RFOURTd0JRVWtrQVVrVlVVbGxmVjBsVVNBQklVRVZmU1U1V1FVeEpSRjlEVDA1VVJVNVVYMHhGVGtkVVNBQklVRVZmVlU1RldGQkZRMVJGUkY5RFQwNVVSVTVVWDB4RlRrZFVTQUJHVEZWVFNBQlFVazlRVUVGVVEwZ0FUUzFUUlVGU1EwZ0FWVkpKWDFSUFQxOU1UMDVIQUZCU1QwTkZVMU5KVGtjQVRVbFRRMFZNVEVGT1JVOVZVMTlRUlZKVFNWTlVSVTVVWDFkQlVrNUpUa2NBVFVsVFEwVk1URUZPUlU5VlUxOVhRVkpPU1U1SEFFaFFSVjlKVGxaQlRFbEVYMVJTUVU1VFJrVlNYMFZPUTA5RVNVNUhBRVY0Y0dWamRHVmtJRU5TVEVZQVNGQkZYMGxPVmtGTVNVUmZRMGhWVGt0ZlUwbGFSUUJOVDFaRkFFTlBUbFJKVGxWRkFFaFFSVjlEUWw5VFZFRlVWVk5mUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsTmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gxWkZVbE5KVDA1ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDFWU1RGOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsOVdRVXhWUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmUTBoVlRrdGZSVmhVUlU1VFNVOU9YMVpCVEZWRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlGV0ZSRlRsTkpUMDVmVGtGTlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlRVVlRVMEZIUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmVFVWVVNFOUVYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKZlJrbEZURVJmUTA5TlVFeEZWRVVBUkVWTVJWUkZBRWhRUlY5SlRsWkJURWxFWDBWUFJsOVRWRUZVUlFCSlRsWkJURWxFWDFOVFRGOURSVkpVU1VaSlEwRlVSUUJRUVZWVFJRQk9UMTlTUlZOUVQwNVRSUUJWVGxOVlVGQlBVbFJGUkY5TlJVUkpRVjlVV1ZCRkFFZFBUa1VBVGs5VVgwRkRRMFZRVkVGQ1RFVUFVMFZTVmtsRFJWOVZUa0ZXUVVsTVFVSk1SUUJTUVU1SFJWOU9UMVJmVTBGVVNWTkdTVUZDVEVVQVQxSkpSMGxPWDBsVFgxVk9Va1ZCUTBoQlFreEZBRkpGVTFCUFRsTkZYMGxUWDFOVVFVeEZBRkJWVWtkRkFFMUZVa2RGQUZKRlVWVkZVMVJmU0VWQlJFVlNYMFpKUlV4RVUxOVVUMDlmVEVGU1IwVUFVa1ZSVlVWVFZGOUlSVUZFUlZKZlZFOVBYMHhCVWtkRkFGQkJXVXhQUVVSZlZFOVBYMHhCVWtkRkFFbE9VMVZHUmtsRFNVVk9WRjlUVkU5U1FVZEZBRWhRUlY5UVFWVlRSVVJmVlZCSFVrRkVSUUJJVUVWZlVFRlZVMFZFWDBneVgxVlFSMUpCUkVVQVUwOVZVa05GQUVGT1RrOVZUa05GQUZSU1FVTkZBRWhRUlY5VlRrVllVRVZEVkVWRVgxTlFRVU5GQUVSRlUwTlNTVUpGQUZWT1UxVkNVME5TU1VKRkFGSkZRMDlTUkFCSVVFVmZTVTVXUVV4SlJGOU5SVlJJVDBRQVRrOVVYMFpQVlU1RUFGQlNUMUJHU1U1RUFGVk9Ra2xPUkFCU1JVSkpUa1FBVlU1QlZWUklUMUpKV2tWRUFFMUZWRWhQUkY5T1QxUmZRVXhNVDFkRlJBQklWRlJRWDFaRlVsTkpUMDVmVGs5VVgxTlZVRkJQVWxSRlJBQkJURkpGUVVSWlgxSkZVRTlTVkVWRUFFRkRRMFZRVkVWRUFFNVBWRjlKVFZCTVJVMUZUbFJGUkFCTVQwOVFYMFJGVkVWRFZFVkVBRWhRUlY5RFVsOUZXRkJGUTFSRlJBQklVRVZmVEVaZlJWaFFSVU5VUlVRQVExSkZRVlJGUkFCSlRWOVZVMFZFQUVoUVJWOVFRVlZUUlVRQVZFbE5SVTlWVkY5UFEwTlZVa1ZFQUZCQldVMUZUbFJmVWtWUlZVbFNSVVFBVUZKRlEwOU9SRWxVU1U5T1gxSkZVVlZKVWtWRUFGQlNUMWhaWDBGVlZFaEZUbFJKUTBGVVNVOU9YMUpGVVZWSlVrVkVBRTVGVkZkUFVrdGZRVlZVU0VWT1ZFbERRVlJKVDA1ZlVrVlJWVWxTUlVRQVRFVk9SMVJJWDFKRlVWVkpVa1ZFQUZOVFRGOURSVkpVU1VaSlEwRlVSVjlTUlZGVlNWSkZSQUJWVUVkU1FVUkZYMUpGVVZWSlVrVkVBRkJCUjBWZlJWaFFTVkpGUkFCUVVrVkRUMDVFU1ZSSlQwNWZSa0ZKVEVWRUFFVllVRVZEVkVGVVNVOU9YMFpCU1V4RlJBQlNSVlpCVEVsRVFWUkpUMDVmUmtGSlRFVkVBRk5UVEY5SVFVNUVVMGhCUzBWZlJrRkpURVZFQUV4UFEwdEZSQUJVVWtGT1UwWlBVazFCVkVsUFRsOUJVRkJNU1VWRUFFNVBWRjlOVDBSSlJrbEZSQUJPVDFSZlJWaFVSVTVFUlVRQVFrRk9SRmRKUkZSSVgweEpUVWxVWDBWWVEwVkZSRVZFQUZOSlZFVmZTVk5mVDFaRlVreFBRVVJGUkFCSVJVRkVBRVY0Y0dWamRHVmtJRWhVVkZBdkFBQmVFd0FBSmhNQUFEQVFBQUR3RndBQW5STUFBQlVTQUFBNUZ3QUE4QklBQUFvUUFBQjFFZ0FBclJJQUFJSVRBQUJQRkFBQWZ4QUFBS0FWQUFBakZBQUFpUklBQUlzVUFBQk5GUUFBMUJFQUFNOFVBQUFRR0FBQXlSWUFBTndXQUFEQkVRQUE0QmNBQUxzVUFBQjBGQUFBZkJVQUFPVVVBQUFJRndBQUh4QUFBR1VWQUFDakZBQUFLQlVBQUFJVkFBQ1pGUUFBTEJBQUFJc1pBQUJQRHdBQTFBNEFBR29RQUFET0VBQUFBaGNBQUlrT0FBQnVFd0FBSEJNQUFHWVVBQUJXRndBQXdSTUFBTTBUQUFCc0V3QUFhQmNBQUdZWEFBQmZGd0FBSWhNQUFNNFBBQUJwRGdBQTJBNEFBR01XQUFETEV3QUFxZzRBQUNnWEFBQW1Gd0FBeFJNQUFGMFdBQURvRVFBQVp4TUFBR1VUQUFEeUZnQUFjeE1BQUIwWEFBRDVGZ0FBOHhFQUFNOE9BQURPRlFBQURCSUFBTE1SQUFDbEVRQUFZUkFBQURJWEFBQzdFd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBZ0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdNQ0FnSUNBZ0FBQWdJQUFnSUFBZ0lDQWdJQ0FnSUNBZ0FFQUFBQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFJQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUFBZ0lDQWdJQUFBSUNBQUlDQUFJQ0FnSUNBZ0lDQWdJQUF3QUVBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQUFBQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUNBQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCc2IzTmxaV1Z3TFdGc2FYWmxBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFFQkFRRUJBUUVCQVFFQkFnRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUZqYUhWdWEyVmtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFRQUJBUUVCQVFBQUFRRUFBUUVBQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdWamRHbHZibVZ1ZEMxc1pXNW5kR2h2Ym5KdmVIa3RZMjl1Ym1WamRHbHZiZ0FBQUFBQUFBQUFBQUFBQUFBQUFISmhibk5tWlhJdFpXNWpiMlJwYm1kd1ozSmhaR1VOQ2cwS0RRcFRUUTBLRFFwVVZGQXZRMFV2VkZOUUx3QUFBQUFBQUFBQUFBQUFBQUVDQUFFREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQkFnQUJBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFCQVFVQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBQUFBUUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFBQUFBQkFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd1FBQUFRRUJBUUVCQVFFQkFRRUJRUUVCQVFFQkFRRUJBUUVCQUFFQUFZSEJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUFCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBZ0FBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFNVBWVTVEUlVWRFMwOVZWRTVGUTFSRlZFVkRVa2xDUlV4VlUwaEZWRVZCUkZORlFWSkRTRkpIUlVOVVNWWkpWRmxNUlU1RVFWSldSVTlVU1VaWlVGUkpUMDVUUTBoVFJVRlpVMVJCVkVOSVIwVlBVa1JKVWtWRFZFOVNWRkpEU0ZCQlVrRk5SVlJGVWxWU1EwVkNVME5TU1VKRlFWSkVUMWRPUVVORlNVNUVUa3REUzFWQ1UwTlNTVUpGU0ZSVVVDOUJSRlJRTHc9PSdcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key) => {\n        const value = obj[key];\n        if (typeof value === 'number') {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanM/NjgyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW51bVRvTWFwID0gdm9pZCAwO1xuZnVuY3Rpb24gZW51bVRvTWFwKG9iaikge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuZW51bVRvTWFwID0gZW51bVRvTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-agent.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst Agent = __webpack_require__(/*! ../agent */ \"(ssr)/./node_modules/undici/lib/agent.js\")\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(ssr)/./node_modules/undici/lib/mock/mock-client.js\")\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(ssr)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst Dispatcher = __webpack_require__(/*! ../dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher.js\")\nconst Pluralizer = __webpack_require__(/*! ./pluralizer */ \"(ssr)/./node_modules/undici/lib/mock/pluralizer.js\")\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\")\n\nclass FakeWeakRef {\n  constructor (value) {\n    this.value = value\n  }\n\n  deref () {\n    return this.value\n  }\n}\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n\n    // Instantiate Agent and encapsulate\n    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts && opts.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = buildMockOptions(opts)\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n    return this[kAgent].dispatch(opts, handler)\n  }\n\n  async close () {\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive () {\n    return this[kIsMockActive]\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, new FakeWeakRef(dispatcher))\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const ref = this[kClients].get(origin)\n    if (ref) {\n      return ref.deref()\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n      const nonExplicitDispatcher = nonExplicitRef.deref()\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n\n  pendingInterceptors () {\n    const mockAgentClients = this[kClients]\n\n    return Array.from(mockAgentClients.entries())\n      .flatMap(([origin, scope]) => scope.deref()[kDispatches].map(dispatch => ({ ...dispatch, origin })))\n      .filter(({ pending }) => pending)\n  }\n\n  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n    const pending = this.pendingInterceptors()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length)\n\n    throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim())\n  }\n}\n\nmodule.exports = MockAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLDBEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVCLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFlO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3RDLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBYztBQUMvRCxRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQ3RFLG1CQUFtQixtQkFBTyxDQUFDLG9FQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3pDLHFDQUFxQyxtQkFBTyxDQUFDLGdIQUFrQzs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0ZBQWtGLHFCQUFxQjtBQUN2RyxpQkFBaUIsU0FBUztBQUMxQjs7QUFFQSxpQ0FBaUMsb0VBQW9FLElBQUk7QUFDekc7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxlQUFlOztBQUV4RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWFnZW50LmpzPzA4NzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NsaWVudHMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4uL2FnZW50JylcbmNvbnN0IHtcbiAga0FnZW50LFxuICBrTW9ja0FnZW50U2V0LFxuICBrTW9ja0FnZW50R2V0LFxuICBrRGlzcGF0Y2hlcyxcbiAga0lzTW9ja0FjdGl2ZSxcbiAga05ldENvbm5lY3QsXG4gIGtHZXROZXRDb25uZWN0LFxuICBrT3B0aW9ucyxcbiAga0ZhY3Rvcnlcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCBNb2NrQ2xpZW50ID0gcmVxdWlyZSgnLi9tb2NrLWNsaWVudCcpXG5jb25zdCBNb2NrUG9vbCA9IHJlcXVpcmUoJy4vbW9jay1wb29sJylcbmNvbnN0IHsgbWF0Y2hWYWx1ZSwgYnVpbGRNb2NrT3B0aW9ucyB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFVuZGljaUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlcicpXG5jb25zdCBQbHVyYWxpemVyID0gcmVxdWlyZSgnLi9wbHVyYWxpemVyJylcbmNvbnN0IFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSByZXF1aXJlKCcuL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlcicpXG5cbmNsYXNzIEZha2VXZWFrUmVmIHtcbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICBkZXJlZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxufVxuXG5jbGFzcyBNb2NrQWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuXG4gICAgdGhpc1trTmV0Q29ubmVjdF0gPSB0cnVlXG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IHRydWVcblxuICAgIC8vIEluc3RhbnRpYXRlIEFnZW50IGFuZCBlbmNhcHN1bGF0ZVxuICAgIGlmICgob3B0cyAmJiBvcHRzLmFnZW50ICYmIHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG4gICAgY29uc3QgYWdlbnQgPSBvcHRzICYmIG9wdHMuYWdlbnQgPyBvcHRzLmFnZW50IDogbmV3IEFnZW50KG9wdHMpXG4gICAgdGhpc1trQWdlbnRdID0gYWdlbnRcblxuICAgIHRoaXNba0NsaWVudHNdID0gYWdlbnRba0NsaWVudHNdXG4gICAgdGhpc1trT3B0aW9uc10gPSBidWlsZE1vY2tPcHRpb25zKG9wdHMpXG4gIH1cblxuICBnZXQgKG9yaWdpbikge1xuICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trTW9ja0FnZW50R2V0XShvcmlnaW4pXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgLy8gQ2FsbCBNb2NrQWdlbnQuZ2V0IHRvIHBlcmZvcm0gYWRkaXRpb25hbCBzZXR1cCBiZWZvcmUgZGlzcGF0Y2hpbmcgYXMgbm9ybWFsXG4gICAgdGhpcy5nZXQob3B0cy5vcmlnaW4pXG4gICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgY2xvc2UgKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5jbG9zZSgpXG4gICAgdGhpc1trQ2xpZW50c10uY2xlYXIoKVxuICB9XG5cbiAgZGVhY3RpdmF0ZSAoKSB7XG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IGZhbHNlXG4gIH1cblxuICBhY3RpdmF0ZSAoKSB7XG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IHRydWVcbiAgfVxuXG4gIGVuYWJsZU5ldENvbm5lY3QgKG1hdGNoZXIpIHtcbiAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtYXRjaGVyID09PSAnZnVuY3Rpb24nIHx8IG1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXNba05ldENvbm5lY3RdKSkge1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XS5wdXNoKG1hdGNoZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IFttYXRjaGVyXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdVbnN1cHBvcnRlZCBtYXRjaGVyLiBNdXN0IGJlIG9uZSBvZiBTdHJpbmd8RnVuY3Rpb258UmVnRXhwLicpXG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZU5ldENvbm5lY3QgKCkge1xuICAgIHRoaXNba05ldENvbm5lY3RdID0gZmFsc2VcbiAgfVxuXG4gIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gYnlwYXNzIGlzc3VlcyBjYXVzZWQgYnkgdXNpbmcgZ2xvYmFsIHN5bWJvbHMgLSBzZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNDQ3XG4gIGdldCBpc01vY2tBY3RpdmUgKCkge1xuICAgIHJldHVybiB0aGlzW2tJc01vY2tBY3RpdmVdXG4gIH1cblxuICBba01vY2tBZ2VudFNldF0gKG9yaWdpbiwgZGlzcGF0Y2hlcikge1xuICAgIHRoaXNba0NsaWVudHNdLnNldChvcmlnaW4sIG5ldyBGYWtlV2Vha1JlZihkaXNwYXRjaGVyKSlcbiAgfVxuXG4gIFtrRmFjdG9yeV0gKG9yaWdpbikge1xuICAgIGNvbnN0IG1vY2tPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGFnZW50OiB0aGlzIH0sIHRoaXNba09wdGlvbnNdKVxuICAgIHJldHVybiB0aGlzW2tPcHRpb25zXSAmJiB0aGlzW2tPcHRpb25zXS5jb25uZWN0aW9ucyA9PT0gMVxuICAgICAgPyBuZXcgTW9ja0NsaWVudChvcmlnaW4sIG1vY2tPcHRpb25zKVxuICAgICAgOiBuZXcgTW9ja1Bvb2wob3JpZ2luLCBtb2NrT3B0aW9ucylcbiAgfVxuXG4gIFtrTW9ja0FnZW50R2V0XSAob3JpZ2luKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgY2FuIGltbWVkaWF0ZWx5IGZpbmQgaXRcbiAgICBjb25zdCByZWYgPSB0aGlzW2tDbGllbnRzXS5nZXQob3JpZ2luKVxuICAgIGlmIChyZWYpIHtcbiAgICAgIHJldHVybiByZWYuZGVyZWYoKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBvcmlnaW4gaXMgbm90IGEgc3RyaW5nIGNyZWF0ZSBhIGR1bW15IHBhcmVudCBwb29sIGFuZCByZXR1cm4gdG8gdXNlclxuICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKCdodHRwOi8vbG9jYWxob3N0Ojk5OTknKVxuICAgICAgdGhpc1trTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpXG4gICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIC8vIElmIHdlIG1hdGNoLCBjcmVhdGUgYSBwb29sIGFuZCBhc3NpZ24gdGhlIHNhbWUgZGlzcGF0Y2hlc1xuICAgIGZvciAoY29uc3QgW2tleU1hdGNoZXIsIG5vbkV4cGxpY2l0UmVmXSBvZiBBcnJheS5mcm9tKHRoaXNba0NsaWVudHNdKSkge1xuICAgICAgY29uc3Qgbm9uRXhwbGljaXREaXNwYXRjaGVyID0gbm9uRXhwbGljaXRSZWYuZGVyZWYoKVxuICAgICAgaWYgKG5vbkV4cGxpY2l0RGlzcGF0Y2hlciAmJiB0eXBlb2Yga2V5TWF0Y2hlciAhPT0gJ3N0cmluZycgJiYgbWF0Y2hWYWx1ZShrZXlNYXRjaGVyLCBvcmlnaW4pKSB7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKVxuICAgICAgICBkaXNwYXRjaGVyW2tEaXNwYXRjaGVzXSA9IG5vbkV4cGxpY2l0RGlzcGF0Y2hlcltrRGlzcGF0Y2hlc11cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBba0dldE5ldENvbm5lY3RdICgpIHtcbiAgICByZXR1cm4gdGhpc1trTmV0Q29ubmVjdF1cbiAgfVxuXG4gIHBlbmRpbmdJbnRlcmNlcHRvcnMgKCkge1xuICAgIGNvbnN0IG1vY2tBZ2VudENsaWVudHMgPSB0aGlzW2tDbGllbnRzXVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20obW9ja0FnZW50Q2xpZW50cy5lbnRyaWVzKCkpXG4gICAgICAuZmxhdE1hcCgoW29yaWdpbiwgc2NvcGVdKSA9PiBzY29wZS5kZXJlZigpW2tEaXNwYXRjaGVzXS5tYXAoZGlzcGF0Y2ggPT4gKHsgLi4uZGlzcGF0Y2gsIG9yaWdpbiB9KSkpXG4gICAgICAuZmlsdGVyKCh7IHBlbmRpbmcgfSkgPT4gcGVuZGluZylcbiAgfVxuXG4gIGFzc2VydE5vUGVuZGluZ0ludGVyY2VwdG9ycyAoeyBwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyID0gbmV3IFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIoKSB9ID0ge30pIHtcbiAgICBjb25zdCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nSW50ZXJjZXB0b3JzKClcblxuICAgIGlmIChwZW5kaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcGx1cmFsaXplciA9IG5ldyBQbHVyYWxpemVyKCdpbnRlcmNlcHRvcicsICdpbnRlcmNlcHRvcnMnKS5wbHVyYWxpemUocGVuZGluZy5sZW5ndGgpXG5cbiAgICB0aHJvdyBuZXcgVW5kaWNpRXJyb3IoYFxuJHtwbHVyYWxpemVyLmNvdW50fSAke3BsdXJhbGl6ZXIubm91bn0gJHtwbHVyYWxpemVyLmlzfSBwZW5kaW5nOlxuXG4ke3BlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIuZm9ybWF0KHBlbmRpbmcpfVxuYC50cmltKCkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrQWdlbnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { promisify } = __webpack_require__(/*! util */ \"util\")\nconst Client = __webpack_require__(/*! ../client */ \"(ssr)/./node_modules/undici/lib/client.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */\nclass MockClient extends Client {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockClient\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEMsZUFBZSxtQkFBTyxDQUFDLDREQUFXO0FBQ2xDLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyx3RUFBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVCLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDeEQsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3pDLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1jbGllbnQuanM/NTVmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50JylcbmNvbnN0IHsgYnVpbGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrQ2xvc2UsXG4gIGtPcmlnaW5hbENsb3NlLFxuICBrT3JpZ2luLFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga0Nvbm5lY3RlZFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgTW9ja0ludGVyY2VwdG9yIH0gPSByZXF1aXJlKCcuL21vY2staW50ZXJjZXB0b3InKVxuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbi8qKlxuICogTW9ja0NsaWVudCBwcm92aWRlcyBhbiBBUEkgdGhhdCBleHRlbmRzIHRoZSBDbGllbnQgdG8gaW5mbHVlbmNlIHRoZSBtb2NrRGlzcGF0Y2hlcy5cbiAqL1xuY2xhc3MgTW9ja0NsaWVudCBleHRlbmRzIENsaWVudCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIG9wdHMpIHtcbiAgICBzdXBlcihvcmlnaW4sIG9wdHMpXG5cbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMuYWdlbnQgfHwgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gICAgfVxuXG4gICAgdGhpc1trTW9ja0FnZW50XSA9IG9wdHMuYWdlbnRcbiAgICB0aGlzW2tPcmlnaW5dID0gb3JpZ2luXG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBbXVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAxXG4gICAgdGhpc1trT3JpZ2luYWxEaXNwYXRjaF0gPSB0aGlzLmRpc3BhdGNoXG4gICAgdGhpc1trT3JpZ2luYWxDbG9zZV0gPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBidWlsZE1vY2tEaXNwYXRjaC5jYWxsKHRoaXMpXG4gICAgdGhpcy5jbG9zZSA9IHRoaXNba0Nsb3NlXVxuICB9XG5cbiAgZ2V0IFtTeW1ib2xzLmtDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29ubmVjdGVkXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGJhc2UgaW50ZXJjZXB0b3IgZm9yIG1vY2tpbmcgcmVwbGllcyBmcm9tIHVuZGljaS5cbiAgICovXG4gIGludGVyY2VwdCAob3B0cykge1xuICAgIHJldHVybiBuZXcgTW9ja0ludGVyY2VwdG9yKG9wdHMsIHRoaXNba0Rpc3BhdGNoZXNdKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHByb21pc2lmeSh0aGlzW2tPcmlnaW5hbENsb3NlXSkoKVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAwXG4gICAgdGhpc1trTW9ja0FnZW50XVtTeW1ib2xzLmtDbGllbnRzXS5kZWxldGUodGhpc1trT3JpZ2luXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tDbGllbnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\nclass MockNotMatchedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, MockNotMatchedError)\n    this.name = 'MockNotMatchedError'\n    this.message = message || 'The request does not match any registered mock dispatches'\n    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'\n  }\n}\n\nmodule.exports = {\n  MockNotMatchedError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWVycm9ycy5qcz8xMTM3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFVuZGljaUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNsYXNzIE1vY2tOb3RNYXRjaGVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBNb2NrTm90TWF0Y2hlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdNb2NrTm90TWF0Y2hlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSByZXF1ZXN0IGRvZXMgbm90IG1hdGNoIGFueSByZWdpc3RlcmVkIG1vY2sgZGlzcGF0Y2hlcydcbiAgICB0aGlzLmNvZGUgPSAnVU5EX01PQ0tfRVJSX01PQ0tfTk9UX01BVENIRUQnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1vY2tOb3RNYXRjaGVkRXJyb3Jcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\n/**\n * Defines the scope API for an interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      opts.method = 'GET'\n    }\n    // See https://github.com/nodejs/undici/issues/1245\n    // As per RFC 3986, clients are not supposed to send URI\n    // fragments to servers when they retrieve a document,\n    if (typeof opts.path === 'string') {\n      if (opts.query) {\n        opts.path = buildURL(opts.path, opts.query)\n      } else {\n        // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811\n        const parsedURL = new URL(opts.path, 'data://')\n        opts.path = parsedURL.pathname + parsedURL.search\n      }\n    }\n    if (typeof opts.method === 'string') {\n      opts.method = opts.method.toUpperCase()\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  createMockScopeDispatchData (statusCode, data, responseOptions = {}) {\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n\n    return { statusCode, data, headers, trailers }\n  }\n\n  validateReplyParameters (statusCode, data, responseOptions) {\n    if (typeof statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof data === 'undefined') {\n      throw new InvalidArgumentError('data must be defined')\n    }\n    if (typeof responseOptions !== 'object') {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (replyData) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyData === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = (opts) => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyData(opts)\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object') {\n          throw new InvalidArgumentError('reply options callback must return an object')\n        }\n\n        const { statusCode, data = '', responseOptions = {} } = resolvedData\n        this.validateReplyParameters(statusCode, data, responseOptions)\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return {\n          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)\n        }\n      }\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback)\n      return new MockScope(newMockDispatch)\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 1-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode.\n    const [statusCode, data = '', responseOptions = {}] = [...arguments]\n    this.validateReplyParameters(statusCode, data, responseOptions)\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions)\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData)\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSw2Q0FBNkMsRUFBRSxtQkFBTyxDQUFDLHdFQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVCLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDekQsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFO0FBQ3JFO0FBQ0EsbURBQW1ELHdDQUF3QztBQUMzRixzQkFBc0I7QUFDdEIsdUJBQXVCOztBQUV2QixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsOENBQThDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGLE9BQU87QUFDNUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1pbnRlcmNlcHRvci5qcz81NzM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGdldFJlc3BvbnNlRGF0YSwgYnVpbGRLZXksIGFkZE1vY2tEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtEaXNwYXRjaEtleSxcbiAga0RlZmF1bHRIZWFkZXJzLFxuICBrRGVmYXVsdFRyYWlsZXJzLFxuICBrQ29udGVudExlbmd0aCxcbiAga01vY2tEaXNwYXRjaFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgYnVpbGRVUkwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc2NvcGUgQVBJIGZvciBhbiBpbnRlcmNlcHRvciByZXBseVxuICovXG5jbGFzcyBNb2NrU2NvcGUge1xuICBjb25zdHJ1Y3RvciAobW9ja0Rpc3BhdGNoKSB7XG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXSA9IG1vY2tEaXNwYXRjaFxuICB9XG5cbiAgLyoqXG4gICAqIERlbGF5IGEgcmVwbHkgYnkgYSBzZXQgYW1vdW50IGluIG1zLlxuICAgKi9cbiAgZGVsYXkgKHdhaXRJbk1zKSB7XG4gICAgaWYgKHR5cGVvZiB3YWl0SW5NcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIod2FpdEluTXMpIHx8IHdhaXRJbk1zIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignd2FpdEluTXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwJylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLmRlbGF5ID0gd2FpdEluTXNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhIGRlZmluZWQgcmVwbHksIG5ldmVyIG1hcmsgYXMgY29uc3VtZWQuXG4gICAqL1xuICBwZXJzaXN0ICgpIHtcbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnBlcnNpc3QgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBvbmUgdG8gZGVmaW5lIGEgcmVwbHkgZm9yIGEgc2V0IGFtb3VudCBvZiBtYXRjaGluZyByZXF1ZXN0cy5cbiAgICovXG4gIHRpbWVzIChyZXBlYXRUaW1lcykge1xuICAgIGlmICh0eXBlb2YgcmVwZWF0VGltZXMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHJlcGVhdFRpbWVzKSB8fCByZXBlYXRUaW1lcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3JlcGVhdFRpbWVzIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyID4gMCcpXG4gICAgfVxuXG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXS50aW1lcyA9IHJlcGVhdFRpbWVzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG4vKipcbiAqIERlZmluZXMgYW4gaW50ZXJjZXB0b3IgZm9yIGEgTW9ja1xuICovXG5jbGFzcyBNb2NrSW50ZXJjZXB0b3Ige1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9ja0Rpc3BhdGNoZXMpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMucGF0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cy5wYXRoIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRob2QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRzLm1ldGhvZCA9ICdHRVQnXG4gICAgfVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTI0NVxuICAgIC8vIEFzIHBlciBSRkMgMzk4NiwgY2xpZW50cyBhcmUgbm90IHN1cHBvc2VkIHRvIHNlbmQgVVJJXG4gICAgLy8gZnJhZ21lbnRzIHRvIHNlcnZlcnMgd2hlbiB0aGV5IHJldHJpZXZlIGEgZG9jdW1lbnQsXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAob3B0cy5xdWVyeSkge1xuICAgICAgICBvcHRzLnBhdGggPSBidWlsZFVSTChvcHRzLnBhdGgsIG9wdHMucXVlcnkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYXRjaGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2Jsb2IvbWFpbi9saWIvZmV0Y2gvaW5kZXguanMjTDE4MTFcbiAgICAgICAgY29uc3QgcGFyc2VkVVJMID0gbmV3IFVSTChvcHRzLnBhdGgsICdkYXRhOi8vJylcbiAgICAgICAgb3B0cy5wYXRoID0gcGFyc2VkVVJMLnBhdGhuYW1lICsgcGFyc2VkVVJMLnNlYXJjaFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMubWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0cy5tZXRob2QgPSBvcHRzLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgfVxuXG4gICAgdGhpc1trRGlzcGF0Y2hLZXldID0gYnVpbGRLZXkob3B0cylcbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IG1vY2tEaXNwYXRjaGVzXG4gICAgdGhpc1trRGVmYXVsdEhlYWRlcnNdID0ge31cbiAgICB0aGlzW2tEZWZhdWx0VHJhaWxlcnNdID0ge31cbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IGZhbHNlXG4gIH1cblxuICBjcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEgKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGRhdGEpXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXNba0NvbnRlbnRMZW5ndGhdID8geyAnY29udGVudC1sZW5ndGgnOiByZXNwb25zZURhdGEubGVuZ3RoIH0gOiB7fVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRIZWFkZXJzXSwgLi4uY29udGVudExlbmd0aCwgLi4ucmVzcG9uc2VPcHRpb25zLmhlYWRlcnMgfVxuICAgIGNvbnN0IHRyYWlsZXJzID0geyAuLi50aGlzW2tEZWZhdWx0VHJhaWxlcnNdLCAuLi5yZXNwb25zZU9wdGlvbnMudHJhaWxlcnMgfVxuXG4gICAgcmV0dXJuIHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMgfVxuICB9XG5cbiAgdmFsaWRhdGVSZXBseVBhcmFtZXRlcnMgKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygc3RhdHVzQ29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc3RhdHVzQ29kZSBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2RhdGEgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZU9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Jlc3BvbnNlT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2sgYW4gdW5kaWNpIHJlcXVlc3Qgd2l0aCBhIGRlZmluZWQgcmVwbHkuXG4gICAqL1xuICByZXBseSAocmVwbHlEYXRhKSB7XG4gICAgLy8gVmFsdWVzIG9mIHJlcGx5IGFyZW4ndCBhdmFpbGFibGUgcmlnaHQgbm93IGFzIHRoZXlcbiAgICAvLyBjYW4gb25seSBiZSBhdmFpbGFibGUgd2hlbiB0aGUgcmVwbHkgY2FsbGJhY2sgaXMgaW52b2tlZC5cbiAgICBpZiAodHlwZW9mIHJlcGx5RGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UnbGwgZmlyc3Qgd3JhcCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgaW4gYW5vdGhlciBmdW5jdGlvbixcbiAgICAgIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBwcm9wZXJseSByZXNvbHZlIHRoZSBkYXRhIGZyb20gdGhlIGNhbGxiYWNrXG4gICAgICAvLyB3aGVuIGludm9rZWQuXG4gICAgICBjb25zdCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjayA9IChvcHRzKSA9PiB7XG4gICAgICAgIC8vIE91ciByZXBseSBvcHRpb25zIGNhbGxiYWNrIGNvbnRhaW5zIHRoZSBwYXJhbWV0ZXIgZm9yIHN0YXR1c0NvZGUsIGRhdGEgYW5kIG9wdGlvbnMuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkRGF0YSA9IHJlcGx5RGF0YShvcHRzKVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIGluIHRoZSByaWdodCBmb3JtYXRcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlZERhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdyZXBseSBvcHRpb25zIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIG9iamVjdCcpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXR1c0NvZGUsIGRhdGEgPSAnJywgcmVzcG9uc2VPcHRpb25zID0ge30gfSA9IHJlc29sdmVkRGF0YVxuICAgICAgICB0aGlzLnZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucylcbiAgICAgICAgLy8gU2luY2UgdGhlIHZhbHVlcyBjYW4gYmUgb2J0YWluZWQgaW1tZWRpYXRlbHkgd2UgcmV0dXJuIHRoZW1cbiAgICAgICAgLy8gZnJvbSB0aGlzIGhpZ2hlciBvcmRlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgbGF0ZXIuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGhpcy5jcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB1c3VhbCBkaXNwYXRjaCBkYXRhLCBidXQgdGhpcyB0aW1lIHNldCB0aGUgZGF0YSBwYXJhbWV0ZXIgdG8gZnVuY3Rpb24gdGhhdCB3aWxsIGV2ZW50dWFsbHkgcHJvdmlkZSBkYXRhLlxuICAgICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIHdyYXBwZWREZWZhdWx0c0NhbGxiYWNrKVxuICAgICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICAgIH1cblxuICAgIC8vIFdlIGNhbiBoYXZlIGVpdGhlciBvbmUgb3IgdGhyZWUgcGFyYW1ldGVycywgaWYgd2UgZ2V0IGhlcmUsXG4gICAgLy8gd2Ugc2hvdWxkIGhhdmUgMS0zIHBhcmFtZXRlcnMuIFNvIHdlIHNwcmVhZCB0aGUgYXJndW1lbnRzIG9mXG4gICAgLy8gdGhpcyBmdW5jdGlvbiB0byBvYnRhaW4gdGhlIHBhcmFtZXRlcnMsIHNpbmNlIHJlcGx5RGF0YSB3aWxsIGFsd2F5c1xuICAgIC8vIGp1c3QgYmUgdGhlIHN0YXR1c0NvZGUuXG4gICAgY29uc3QgW3N0YXR1c0NvZGUsIGRhdGEgPSAnJywgcmVzcG9uc2VPcHRpb25zID0ge31dID0gWy4uLmFyZ3VtZW50c11cbiAgICB0aGlzLnZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucylcblxuICAgIC8vIFNlbmQgaW4tYWxyZWFkeSBwcm92aWRlZCBkYXRhIGxpa2UgdXN1YWxcbiAgICBjb25zdCBkaXNwYXRjaERhdGEgPSB0aGlzLmNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YShzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMpXG4gICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIGRpc3BhdGNoRGF0YSlcbiAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gIH1cblxuICAvKipcbiAgICogTW9jayBhbiB1bmRpY2kgcmVxdWVzdCB3aXRoIGEgZGVmaW5lZCBlcnJvci5cbiAgICovXG4gIHJlcGx5V2l0aEVycm9yIChlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Vycm9yIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIHsgZXJyb3IgfSlcbiAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcmVwbHkgaGVhZGVycyBvbiB0aGUgaW50ZXJjZXB0b3IgZm9yIHN1YnNlcXVlbnQgcmVwbGllc1xuICAgKi9cbiAgZGVmYXVsdFJlcGx5SGVhZGVycyAoaGVhZGVycykge1xuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IGhlYWRlcnNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IHJlcGx5IHRyYWlsZXJzIG9uIHRoZSBpbnRlcmNlcHRvciBmb3Igc3Vic2VxdWVudCByZXBsaWVzXG4gICAqL1xuICBkZWZhdWx0UmVwbHlUcmFpbGVycyAodHJhaWxlcnMpIHtcbiAgICBpZiAodHlwZW9mIHRyYWlsZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd0cmFpbGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRUcmFpbGVyc10gPSB0cmFpbGVyc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IHJlcGx5IGNvbnRlbnQgbGVuZ3RoIGhlYWRlciBmb3IgcmVwbGllcyBvbiB0aGUgaW50ZXJjZXB0b3JcbiAgICovXG4gIHJlcGx5Q29udGVudExlbmd0aCAoKSB7XG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Nb2NrSW50ZXJjZXB0b3IgPSBNb2NrSW50ZXJjZXB0b3Jcbm1vZHVsZS5leHBvcnRzLk1vY2tTY29wZSA9IE1vY2tTY29wZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-pool.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-pool.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { promisify } = __webpack_require__(/*! util */ \"util\")\nconst Pool = __webpack_require__(/*! ../pool */ \"(ssr)/./node_modules/undici/lib/pool.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyx3REFBUztBQUM5QixRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsd0VBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3hELGdCQUFnQixtQkFBTyxDQUFDLHdFQUFpQjtBQUN6QyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcz9iYzNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi4vcG9vbCcpXG5jb25zdCB7IGJ1aWxkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga0Nsb3NlLFxuICBrT3JpZ2luYWxDbG9zZSxcbiAga09yaWdpbixcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtDb25uZWN0ZWRcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IE1vY2tJbnRlcmNlcHRvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWludGVyY2VwdG9yJylcbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG4vKipcbiAqIE1vY2tQb29sIHByb3ZpZGVzIGFuIEFQSSB0aGF0IGV4dGVuZHMgdGhlIFBvb2wgdG8gaW5mbHVlbmNlIHRoZSBtb2NrRGlzcGF0Y2hlcy5cbiAqL1xuY2xhc3MgTW9ja1Bvb2wgZXh0ZW5kcyBQb29sIHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwgb3B0cykge1xuICAgIHN1cGVyKG9yaWdpbiwgb3B0cylcblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy5hZ2VudCB8fCB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrQWdlbnRdID0gb3B0cy5hZ2VudFxuICAgIHRoaXNba09yaWdpbl0gPSBvcmlnaW5cbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDFcbiAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2hcbiAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcylcbiAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdXG4gIH1cblxuICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYmFzZSBpbnRlcmNlcHRvciBmb3IgbW9ja2luZyByZXBsaWVzIGZyb20gdW5kaWNpLlxuICAgKi9cbiAgaW50ZXJjZXB0IChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3Iob3B0cywgdGhpc1trRGlzcGF0Y2hlc10pXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgcHJvbWlzaWZ5KHRoaXNba09yaWdpbmFsQ2xvc2VdKSgpXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDBcbiAgICB0aGlzW2tNb2NrQWdlbnRdW1N5bWJvbHMua0NsaWVudHNdLmRlbGV0ZSh0aGlzW2tPcmlnaW5dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja1Bvb2xcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kAgent: Symbol('agent'),\n  kOptions: Symbol('options'),\n  kFactory: Symbol('factory'),\n  kDispatches: Symbol('dispatches'),\n  kDispatchKey: Symbol('dispatch key'),\n  kDefaultHeaders: Symbol('default headers'),\n  kDefaultTrailers: Symbol('default trailers'),\n  kContentLength: Symbol('content length'),\n  kMockAgent: Symbol('mock agent'),\n  kMockAgentSet: Symbol('mock agent set'),\n  kMockAgentGet: Symbol('mock agent get'),\n  kMockDispatch: Symbol('mock dispatch'),\n  kClose: Symbol('close'),\n  kOriginalClose: Symbol('original agent close'),\n  kOrigin: Symbol('origin'),\n  kIsMockActive: Symbol('is mock active'),\n  kNetConnect: Symbol('net connect'),\n  kGetNetConnect: Symbol('get net connect'),\n  kConnected: Symbol('connected')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcz80MGNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0FnZW50OiBTeW1ib2woJ2FnZW50JyksXG4gIGtPcHRpb25zOiBTeW1ib2woJ29wdGlvbnMnKSxcbiAga0ZhY3Rvcnk6IFN5bWJvbCgnZmFjdG9yeScpLFxuICBrRGlzcGF0Y2hlczogU3ltYm9sKCdkaXNwYXRjaGVzJyksXG4gIGtEaXNwYXRjaEtleTogU3ltYm9sKCdkaXNwYXRjaCBrZXknKSxcbiAga0RlZmF1bHRIZWFkZXJzOiBTeW1ib2woJ2RlZmF1bHQgaGVhZGVycycpLFxuICBrRGVmYXVsdFRyYWlsZXJzOiBTeW1ib2woJ2RlZmF1bHQgdHJhaWxlcnMnKSxcbiAga0NvbnRlbnRMZW5ndGg6IFN5bWJvbCgnY29udGVudCBsZW5ndGgnKSxcbiAga01vY2tBZ2VudDogU3ltYm9sKCdtb2NrIGFnZW50JyksXG4gIGtNb2NrQWdlbnRTZXQ6IFN5bWJvbCgnbW9jayBhZ2VudCBzZXQnKSxcbiAga01vY2tBZ2VudEdldDogU3ltYm9sKCdtb2NrIGFnZW50IGdldCcpLFxuICBrTW9ja0Rpc3BhdGNoOiBTeW1ib2woJ21vY2sgZGlzcGF0Y2gnKSxcbiAga0Nsb3NlOiBTeW1ib2woJ2Nsb3NlJyksXG4gIGtPcmlnaW5hbENsb3NlOiBTeW1ib2woJ29yaWdpbmFsIGFnZW50IGNsb3NlJyksXG4gIGtPcmlnaW46IFN5bWJvbCgnb3JpZ2luJyksXG4gIGtJc01vY2tBY3RpdmU6IFN5bWJvbCgnaXMgbW9jayBhY3RpdmUnKSxcbiAga05ldENvbm5lY3Q6IFN5bWJvbCgnbmV0IGNvbm5lY3QnKSxcbiAga0dldE5ldENvbm5lY3Q6IFN5bWJvbCgnZ2V0IG5ldCBjb25uZWN0JyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(ssr)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { buildURL, nop } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! http */ \"http\")\nconst {\n  types: {\n    isPromise\n  }\n} = __webpack_require__(/*! util */ \"util\")\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n\n  const pathSegments = path.split('?')\n\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? buildURL(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [\n    ...keyValuePairs,\n    Buffer.from(`${key}`),\n    Array.isArray(value) ? value.map(x => Buffer.from(`${x}`)) : Buffer.from(`${value}`)\n  ], [])\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches, _data = data) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const body = typeof _data === 'function'\n      ? _data({ ...opts, headers: optsHeaders })\n      : _data\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      body.then((newData) => handleReply(mockDispatches, newData))\n      return\n    }\n\n    const responseData = getResponseData(body)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.abort = nop\n    handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData(Buffer.from(responseData))\n    handler.onComplete(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions,\n  getHeaderByName\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLDBFQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDaEQsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGtCQUFNOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsK0RBQStEO0FBQzFFLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLFVBQVU7QUFDdEIsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLDZCQUE2QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsVUFBVSwwQkFBMEIsTUFBTTtBQUNqRztBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGOztBQUVBO0FBQ0EsMERBQTBELFFBQVE7QUFDbEU7QUFDQSwyRUFBMkUsV0FBVztBQUN0Rjs7QUFFQTtBQUNBLDBEQUEwRCxNQUFNO0FBQ2hFO0FBQ0EseUVBQXlFLFNBQVM7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDRFQUE0RTtBQUN4Sjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCLG1EQUFtRCxpQkFBaUIsSUFBSTtBQUN4RSw0QkFBNEIsNENBQTRDO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHFDQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCLHlEQUF5RCxFQUFFLHFCQUFxQixNQUFNO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0EsVUFBVSxRQUFRLDRDQUE0QyxtQkFBbUI7QUFDakYsVUFBVSxzQkFBc0I7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsaUNBQWlDLFFBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDZDQUE2QyxjQUFjLGlDQUFpQyxRQUFRO0FBQ3BHO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXV0aWxzLmpzPzkzMWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgTW9ja05vdE1hdGNoZWRFcnJvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWVycm9ycycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga09yaWdpbixcbiAga0dldE5ldENvbm5lY3Rcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IGJ1aWxkVVJMLCBub3AgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnaHR0cCcpXG5jb25zdCB7XG4gIHR5cGVzOiB7XG4gICAgaXNQcm9taXNlXG4gIH1cbn0gPSByZXF1aXJlKCd1dGlsJylcblxuZnVuY3Rpb24gbWF0Y2hWYWx1ZSAobWF0Y2gsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1hdGNoID09PSB2YWx1ZVxuICB9XG4gIGlmIChtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBtYXRjaC50ZXN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF0Y2godmFsdWUpID09PSB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGxvd2VyQ2FzZUVudHJpZXMgKGhlYWRlcnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhoZWFkZXJzKS5tYXAoKFtoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZV0pID0+IHtcbiAgICAgIHJldHVybiBbaGVhZGVyTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLCBoZWFkZXJWYWx1ZV1cbiAgICB9KVxuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2luZGV4JykuSGVhZGVyc3xzdHJpbmdbXXxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cbmZ1bmN0aW9uIGdldEhlYWRlckJ5TmFtZSAoaGVhZGVycywga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoaGVhZGVyc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSBrZXkudG9Mb2NhbGVMb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4gaGVhZGVyc1tpICsgMV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH0gZWxzZSBpZiAodHlwZW9mIGhlYWRlcnMuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGhlYWRlcnMuZ2V0KGtleSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG93ZXJDYXNlRW50cmllcyhoZWFkZXJzKVtrZXkudG9Mb2NhbGVMb3dlckNhc2UoKV1cbiAgfVxufVxuXG4vKiogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVycyAqL1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJzRnJvbUFycmF5IChoZWFkZXJzKSB7IC8vIGZldGNoIEhlYWRlcnNMaXN0XG4gIGNvbnN0IGNsb25lID0gaGVhZGVycy5zbGljZSgpXG4gIGNvbnN0IGVudHJpZXMgPSBbXVxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2xvbmUubGVuZ3RoOyBpbmRleCArPSAyKSB7XG4gICAgZW50cmllcy5wdXNoKFtjbG9uZVtpbmRleF0sIGNsb25lW2luZGV4ICsgMV1dKVxuICB9XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcylcbn1cblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJzIChtb2NrRGlzcGF0Y2gsIGhlYWRlcnMpIHtcbiAgaWYgKHR5cGVvZiBtb2NrRGlzcGF0Y2guaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7IC8vIGZldGNoIEhlYWRlcnNMaXN0XG4gICAgICBoZWFkZXJzID0gYnVpbGRIZWFkZXJzRnJvbUFycmF5KGhlYWRlcnMpXG4gICAgfVxuICAgIHJldHVybiBtb2NrRGlzcGF0Y2guaGVhZGVycyhoZWFkZXJzID8gbG93ZXJDYXNlRW50cmllcyhoZWFkZXJzKSA6IHt9KVxuICB9XG4gIGlmICh0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAodHlwZW9mIGhlYWRlcnMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBtb2NrRGlzcGF0Y2guaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgW21hdGNoSGVhZGVyTmFtZSwgbWF0Y2hIZWFkZXJWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobW9ja0Rpc3BhdGNoLmhlYWRlcnMpKSB7XG4gICAgY29uc3QgaGVhZGVyVmFsdWUgPSBnZXRIZWFkZXJCeU5hbWUoaGVhZGVycywgbWF0Y2hIZWFkZXJOYW1lKVxuXG4gICAgaWYgKCFtYXRjaFZhbHVlKG1hdGNoSGVhZGVyVmFsdWUsIGhlYWRlclZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHNhZmVVcmwgKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBjb25zdCBwYXRoU2VnbWVudHMgPSBwYXRoLnNwbGl0KCc/JylcblxuICBpZiAocGF0aFNlZ21lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBjb25zdCBxcCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aFNlZ21lbnRzLnBvcCgpKVxuICBxcC5zb3J0KClcbiAgcmV0dXJuIFsuLi5wYXRoU2VnbWVudHMsIHFwLnRvU3RyaW5nKCldLmpvaW4oJz8nKVxufVxuXG5mdW5jdGlvbiBtYXRjaEtleSAobW9ja0Rpc3BhdGNoLCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycyB9KSB7XG4gIGNvbnN0IHBhdGhNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLnBhdGgsIHBhdGgpXG4gIGNvbnN0IG1ldGhvZE1hdGNoID0gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2gubWV0aG9kLCBtZXRob2QpXG4gIGNvbnN0IGJvZHlNYXRjaCA9IHR5cGVvZiBtb2NrRGlzcGF0Y2guYm9keSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5ib2R5LCBib2R5KSA6IHRydWVcbiAgY29uc3QgaGVhZGVyc01hdGNoID0gbWF0Y2hIZWFkZXJzKG1vY2tEaXNwYXRjaCwgaGVhZGVycylcbiAgcmV0dXJuIHBhdGhNYXRjaCAmJiBtZXRob2RNYXRjaCAmJiBib2R5TWF0Y2ggJiYgaGVhZGVyc01hdGNoXG59XG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YSAoZGF0YSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YS50b1N0cmluZygpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TW9ja0Rpc3BhdGNoIChtb2NrRGlzcGF0Y2hlcywga2V5KSB7XG4gIGNvbnN0IGJhc2VQYXRoID0ga2V5LnF1ZXJ5ID8gYnVpbGRVUkwoa2V5LnBhdGgsIGtleS5xdWVyeSkgOiBrZXkucGF0aFxuICBjb25zdCByZXNvbHZlZFBhdGggPSB0eXBlb2YgYmFzZVBhdGggPT09ICdzdHJpbmcnID8gc2FmZVVybChiYXNlUGF0aCkgOiBiYXNlUGF0aFxuXG4gIC8vIE1hdGNoIHBhdGhcbiAgbGV0IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBjb25zdW1lZCB9KSA9PiAhY29uc3VtZWQpLmZpbHRlcigoeyBwYXRoIH0pID0+IG1hdGNoVmFsdWUoc2FmZVVybChwYXRoKSwgcmVzb2x2ZWRQYXRoKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgcGF0aCAnJHtyZXNvbHZlZFBhdGh9J2ApXG4gIH1cblxuICAvLyBNYXRjaCBtZXRob2RcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBtZXRob2QgfSkgPT4gbWF0Y2hWYWx1ZShtZXRob2QsIGtleS5tZXRob2QpKVxuICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBtZXRob2QgJyR7a2V5Lm1ldGhvZH0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIGJvZHlcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBib2R5IH0pID0+IHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyA/IG1hdGNoVmFsdWUoYm9keSwga2V5LmJvZHkpIDogdHJ1ZSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgYm9keSAnJHtrZXkuYm9keX0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIGhlYWRlcnNcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigobW9ja0Rpc3BhdGNoKSA9PiBtYXRjaEhlYWRlcnMobW9ja0Rpc3BhdGNoLCBrZXkuaGVhZGVycykpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGhlYWRlcnMgJyR7dHlwZW9mIGtleS5oZWFkZXJzID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGtleS5oZWFkZXJzKSA6IGtleS5oZWFkZXJzfSdgKVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRNb2NrRGlzcGF0Y2hlc1swXVxufVxuXG5mdW5jdGlvbiBhZGRNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXksIGRhdGEpIHtcbiAgY29uc3QgYmFzZURhdGEgPSB7IHRpbWVzSW52b2tlZDogMCwgdGltZXM6IDEsIHBlcnNpc3Q6IGZhbHNlLCBjb25zdW1lZDogZmFsc2UgfVxuICBjb25zdCByZXBseURhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IHsgY2FsbGJhY2s6IGRhdGEgfSA6IHsgLi4uZGF0YSB9XG4gIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IHsgLi4uYmFzZURhdGEsIC4uLmtleSwgcGVuZGluZzogdHJ1ZSwgZGF0YTogeyBlcnJvcjogbnVsbCwgLi4ucmVwbHlEYXRhIH0gfVxuICBtb2NrRGlzcGF0Y2hlcy5wdXNoKG5ld01vY2tEaXNwYXRjaClcbiAgcmV0dXJuIG5ld01vY2tEaXNwYXRjaFxufVxuXG5mdW5jdGlvbiBkZWxldGVNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXkpIHtcbiAgY29uc3QgaW5kZXggPSBtb2NrRGlzcGF0Y2hlcy5maW5kSW5kZXgoZGlzcGF0Y2ggPT4ge1xuICAgIGlmICghZGlzcGF0Y2guY29uc3VtZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hLZXkoZGlzcGF0Y2gsIGtleSlcbiAgfSlcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIG1vY2tEaXNwYXRjaGVzLnNwbGljZShpbmRleCwgMSlcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEtleSAob3B0cykge1xuICBjb25zdCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycywgcXVlcnkgfSA9IG9wdHNcbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcXVlcnlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUtleVZhbHVlcyAoZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChrZXlWYWx1ZVBhaXJzLCBba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAuLi5rZXlWYWx1ZVBhaXJzLFxuICAgIEJ1ZmZlci5mcm9tKGAke2tleX1gKSxcbiAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh4ID0+IEJ1ZmZlci5mcm9tKGAke3h9YCkpIDogQnVmZmVyLmZyb20oYCR7dmFsdWV9YClcbiAgXSwgW10pXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1c1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1c0NvZGVcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdHVzVGV4dCAoc3RhdHVzQ29kZSkge1xuICByZXR1cm4gU1RBVFVTX0NPREVTW3N0YXR1c0NvZGVdIHx8ICd1bmtub3duJ1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRSZXNwb25zZSAoYm9keSkge1xuICBjb25zdCBidWZmZXJzID0gW11cbiAgZm9yIGF3YWl0IChjb25zdCBkYXRhIG9mIGJvZHkpIHtcbiAgICBidWZmZXJzLnB1c2goZGF0YSlcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZmZXJzKS50b1N0cmluZygndXRmOCcpXG59XG5cbi8qKlxuICogTW9jayBkaXNwYXRjaCBmdW5jdGlvbiB1c2VkIHRvIHNpbXVsYXRlIHVuZGljaSBkaXNwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIG1vY2tEaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAvLyBHZXQgbW9jayBkaXNwYXRjaCBmcm9tIGJ1aWx0IGtleVxuICBjb25zdCBrZXkgPSBidWlsZEtleShvcHRzKVxuICBjb25zdCBtb2NrRGlzcGF0Y2ggPSBnZXRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIGtleSlcblxuICBtb2NrRGlzcGF0Y2gudGltZXNJbnZva2VkKytcblxuICAvLyBIZXJlJ3Mgd2hlcmUgd2UgcmVzb2x2ZSBhIGNhbGxiYWNrIGlmIGEgY2FsbGJhY2sgaXMgcHJlc2VudCBmb3IgdGhlIGRpc3BhdGNoIGRhdGEuXG4gIGlmIChtb2NrRGlzcGF0Y2guZGF0YS5jYWxsYmFjaykge1xuICAgIG1vY2tEaXNwYXRjaC5kYXRhID0geyAuLi5tb2NrRGlzcGF0Y2guZGF0YSwgLi4ubW9ja0Rpc3BhdGNoLmRhdGEuY2FsbGJhY2sob3B0cykgfVxuICB9XG5cbiAgLy8gUGFyc2UgbW9ja0Rpc3BhdGNoIGRhdGFcbiAgY29uc3QgeyBkYXRhOiB7IHN0YXR1c0NvZGUsIGRhdGEsIGhlYWRlcnMsIHRyYWlsZXJzLCBlcnJvciB9LCBkZWxheSwgcGVyc2lzdCB9ID0gbW9ja0Rpc3BhdGNoXG4gIGNvbnN0IHsgdGltZXNJbnZva2VkLCB0aW1lcyB9ID0gbW9ja0Rpc3BhdGNoXG5cbiAgLy8gSWYgaXQncyB1c2VkIHVwIGFuZCBub3QgcGVyc2lzdGVudCwgbWFyayBhcyBjb25zdW1lZFxuICBtb2NrRGlzcGF0Y2guY29uc3VtZWQgPSAhcGVyc2lzdCAmJiB0aW1lc0ludm9rZWQgPj0gdGltZXNcbiAgbW9ja0Rpc3BhdGNoLnBlbmRpbmcgPSB0aW1lc0ludm9rZWQgPCB0aW1lc1xuXG4gIC8vIElmIHNwZWNpZmllZCwgdHJpZ2dlciBkaXNwYXRjaCBlcnJvclxuICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICBkZWxldGVNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIGtleSlcbiAgICBoYW5kbGVyLm9uRXJyb3IoZXJyb3IpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEhhbmRsZSB0aGUgcmVxdWVzdCB3aXRoIGEgZGVsYXkgaWYgbmVjZXNzYXJ5XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInICYmIGRlbGF5ID4gMCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaGFuZGxlUmVwbHkodGhpc1trRGlzcGF0Y2hlc10pXG4gICAgfSwgZGVsYXkpXG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlUmVwbHkodGhpc1trRGlzcGF0Y2hlc10pXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZXBseSAobW9ja0Rpc3BhdGNoZXMsIF9kYXRhID0gZGF0YSkge1xuICAgIC8vIGZldGNoJ3MgSGVhZGVyc0xpc3QgaXMgYSAxRCBzdHJpbmcgYXJyYXlcbiAgICBjb25zdCBvcHRzSGVhZGVycyA9IEFycmF5LmlzQXJyYXkob3B0cy5oZWFkZXJzKVxuICAgICAgPyBidWlsZEhlYWRlcnNGcm9tQXJyYXkob3B0cy5oZWFkZXJzKVxuICAgICAgOiBvcHRzLmhlYWRlcnNcbiAgICBjb25zdCBib2R5ID0gdHlwZW9mIF9kYXRhID09PSAnZnVuY3Rpb24nXG4gICAgICA/IF9kYXRhKHsgLi4ub3B0cywgaGVhZGVyczogb3B0c0hlYWRlcnMgfSlcbiAgICAgIDogX2RhdGFcblxuICAgIC8vIHV0aWwudHlwZXMuaXNQcm9taXNlIGlzIGxpa2VseSBuZWVkZWQgZm9yIGplc3QuXG4gICAgaWYgKGlzUHJvbWlzZShib2R5KSkge1xuICAgICAgLy8gSWYgaGFuZGxlUmVwbHkgaXMgYXN5bmNocm9ub3VzLCB0aHJvd2luZyBhbiBlcnJvclxuICAgICAgLy8gaW4gdGhlIGNhbGxiYWNrIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLCByYXRoZXIgdGhhblxuICAgICAgLy8gc3luY2hyb25vdXNseSB0aHJvdyB0aGUgZXJyb3IsIHdoaWNoIGJyZWFrcyBzb21lIHRlc3RzLlxuICAgICAgLy8gUmF0aGVyLCB3ZSB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gcmVzb2x2ZSBpZiBpdCBpcyBhXG4gICAgICAvLyBwcm9taXNlLCBhbmQgdGhlbiByZS1ydW4gaGFuZGxlUmVwbHkgd2l0aCB0aGUgbmV3IGJvZHkuXG4gICAgICBib2R5LnRoZW4oKG5ld0RhdGEpID0+IGhhbmRsZVJlcGx5KG1vY2tEaXNwYXRjaGVzLCBuZXdEYXRhKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGdldFJlc3BvbnNlRGF0YShib2R5KVxuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGdlbmVyYXRlS2V5VmFsdWVzKGhlYWRlcnMpXG4gICAgY29uc3QgcmVzcG9uc2VUcmFpbGVycyA9IGdlbmVyYXRlS2V5VmFsdWVzKHRyYWlsZXJzKVxuXG4gICAgaGFuZGxlci5hYm9ydCA9IG5vcFxuICAgIGhhbmRsZXIub25IZWFkZXJzKHN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgcmVzdW1lLCBnZXRTdGF0dXNUZXh0KHN0YXR1c0NvZGUpKVxuICAgIGhhbmRsZXIub25EYXRhKEJ1ZmZlci5mcm9tKHJlc3BvbnNlRGF0YSkpXG4gICAgaGFuZGxlci5vbkNvbXBsZXRlKHJlc3BvbnNlVHJhaWxlcnMpXG4gICAgZGVsZXRlTW9ja0Rpc3BhdGNoKG1vY2tEaXNwYXRjaGVzLCBrZXkpXG4gIH1cblxuICBmdW5jdGlvbiByZXN1bWUgKCkge31cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBidWlsZE1vY2tEaXNwYXRjaCAoKSB7XG4gIGNvbnN0IGFnZW50ID0gdGhpc1trTW9ja0FnZW50XVxuICBjb25zdCBvcmlnaW4gPSB0aGlzW2tPcmlnaW5dXG4gIGNvbnN0IG9yaWdpbmFsRGlzcGF0Y2ggPSB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXVxuXG4gIHJldHVybiBmdW5jdGlvbiBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGlmIChhZ2VudC5pc01vY2tBY3RpdmUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1vY2tEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNb2NrTm90TWF0Y2hlZEVycm9yKSB7XG4gICAgICAgICAgY29uc3QgbmV0Q29ubmVjdCA9IGFnZW50W2tHZXROZXRDb25uZWN0XSgpXG4gICAgICAgICAgaWYgKG5ldENvbm5lY3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgJHtlcnJvci5tZXNzYWdlfTogc3Vic2VxdWVudCByZXF1ZXN0IHRvIG9yaWdpbiAke29yaWdpbn0gd2FzIG5vdCBhbGxvd2VkIChuZXQuY29ubmVjdCBkaXNhYmxlZClgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hlY2tOZXRDb25uZWN0KG5ldENvbm5lY3QsIG9yaWdpbikpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgJHtlcnJvci5tZXNzYWdlfTogc3Vic2VxdWVudCByZXF1ZXN0IHRvIG9yaWdpbiAke29yaWdpbn0gd2FzIG5vdCBhbGxvd2VkIChuZXQuY29ubmVjdCBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBvcmlnaW4pYClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOZXRDb25uZWN0IChuZXRDb25uZWN0LCBvcmlnaW4pIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChvcmlnaW4pXG4gIGlmIChuZXRDb25uZWN0ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5ldENvbm5lY3QpICYmIG5ldENvbm5lY3Quc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hWYWx1ZShtYXRjaGVyLCB1cmwuaG9zdCkpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYnVpbGRNb2NrT3B0aW9ucyAob3B0cykge1xuICBpZiAob3B0cykge1xuICAgIGNvbnN0IHsgYWdlbnQsIC4uLm1vY2tPcHRpb25zIH0gPSBvcHRzXG4gICAgcmV0dXJuIG1vY2tPcHRpb25zXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFJlc3BvbnNlRGF0YSxcbiAgZ2V0TW9ja0Rpc3BhdGNoLFxuICBhZGRNb2NrRGlzcGF0Y2gsXG4gIGRlbGV0ZU1vY2tEaXNwYXRjaCxcbiAgYnVpbGRLZXksXG4gIGdlbmVyYXRlS2V5VmFsdWVzLFxuICBtYXRjaFZhbHVlLFxuICBnZXRSZXNwb25zZSxcbiAgZ2V0U3RhdHVzVGV4dCxcbiAgbW9ja0Rpc3BhdGNoLFxuICBidWlsZE1vY2tEaXNwYXRjaCxcbiAgY2hlY2tOZXRDb25uZWN0LFxuICBidWlsZE1vY2tPcHRpb25zLFxuICBnZXRIZWFkZXJCeU5hbWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Transform } = __webpack_require__(/*! stream */ \"stream\")\nconst { Console } = __webpack_require__(/*! console */ \"console\")\n\n/**\n * Gets the output of `console.table()` as a string.\n */\nmodule.exports = class PendingInterceptorsFormatter {\n  constructor ({ disableColors } = {}) {\n    this.transform = new Transform({\n      transform (chunk, _enc, cb) {\n        cb(null, chunk)\n      }\n    })\n\n    this.logger = new Console({\n      stdout: this.transform,\n      inspectOptions: {\n        colors: !disableColors && !process.env.CI\n      }\n    })\n  }\n\n  format (pendingInterceptors) {\n    const withPrettyHeaders = pendingInterceptors.map(\n      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({\n        Method: method,\n        Origin: origin,\n        Path: path,\n        'Status code': statusCode,\n        Persistent: persist ? '' : '',\n        Invocations: timesInvoked,\n        Remaining: persist ? Infinity : times - timesInvoked\n      }))\n\n    this.logger.table(withPrettyHeaders)\n    return this.transform.read().toString()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3RDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsd0JBQVM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQixJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQixZQUFZLHdDQUF3QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcz8yYTEyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFRyYW5zZm9ybSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHsgQ29uc29sZSB9ID0gcmVxdWlyZSgnY29uc29sZScpXG5cbi8qKlxuICogR2V0cyB0aGUgb3V0cHV0IG9mIGBjb25zb2xlLnRhYmxlKOKApilgIGFzIGEgc3RyaW5nLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBkaXNhYmxlQ29sb3JzIH0gPSB7fSkge1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSh7XG4gICAgICB0cmFuc2Zvcm0gKGNodW5rLCBfZW5jLCBjYikge1xuICAgICAgICBjYihudWxsLCBjaHVuaylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgQ29uc29sZSh7XG4gICAgICBzdGRvdXQ6IHRoaXMudHJhbnNmb3JtLFxuICAgICAgaW5zcGVjdE9wdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiAhZGlzYWJsZUNvbG9ycyAmJiAhcHJvY2Vzcy5lbnYuQ0lcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZm9ybWF0IChwZW5kaW5nSW50ZXJjZXB0b3JzKSB7XG4gICAgY29uc3Qgd2l0aFByZXR0eUhlYWRlcnMgPSBwZW5kaW5nSW50ZXJjZXB0b3JzLm1hcChcbiAgICAgICh7IG1ldGhvZCwgcGF0aCwgZGF0YTogeyBzdGF0dXNDb2RlIH0sIHBlcnNpc3QsIHRpbWVzLCB0aW1lc0ludm9rZWQsIG9yaWdpbiB9KSA9PiAoe1xuICAgICAgICBNZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgT3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIFBhdGg6IHBhdGgsXG4gICAgICAgICdTdGF0dXMgY29kZSc6IHN0YXR1c0NvZGUsXG4gICAgICAgIFBlcnNpc3RlbnQ6IHBlcnNpc3QgPyAn4pyFJyA6ICfinYwnLFxuICAgICAgICBJbnZvY2F0aW9uczogdGltZXNJbnZva2VkLFxuICAgICAgICBSZW1haW5pbmc6IHBlcnNpc3QgPyBJbmZpbml0eSA6IHRpbWVzIC0gdGltZXNJbnZva2VkXG4gICAgICB9KSlcblxuICAgIHRoaXMubG9nZ2VyLnRhYmxlKHdpdGhQcmV0dHlIZWFkZXJzKVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yZWFkKCkudG9TdHJpbmcoKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/pluralizer.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/pluralizer.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst singulars = {\n  pronoun: 'it',\n  is: 'is',\n  was: 'was',\n  this: 'this'\n}\n\nconst plurals = {\n  pronoun: 'they',\n  is: 'are',\n  was: 'were',\n  this: 'these'\n}\n\nmodule.exports = class Pluralizer {\n  constructor (singular, plural) {\n    this.singular = singular\n    this.plural = plural\n  }\n\n  pluralize (count) {\n    const one = count === 1\n    const keys = one ? singulars : plurals\n    const noun = one ? this.singular : this.plural\n    return { ...keys, count, noun }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BsdXJhbGl6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BsdXJhbGl6ZXIuanM/OWE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qgc2luZ3VsYXJzID0ge1xuICBwcm9ub3VuOiAnaXQnLFxuICBpczogJ2lzJyxcbiAgd2FzOiAnd2FzJyxcbiAgdGhpczogJ3RoaXMnXG59XG5cbmNvbnN0IHBsdXJhbHMgPSB7XG4gIHByb25vdW46ICd0aGV5JyxcbiAgaXM6ICdhcmUnLFxuICB3YXM6ICd3ZXJlJyxcbiAgdGhpczogJ3RoZXNlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBsdXJhbGl6ZXIge1xuICBjb25zdHJ1Y3RvciAoc2luZ3VsYXIsIHBsdXJhbCkge1xuICAgIHRoaXMuc2luZ3VsYXIgPSBzaW5ndWxhclxuICAgIHRoaXMucGx1cmFsID0gcGx1cmFsXG4gIH1cblxuICBwbHVyYWxpemUgKGNvdW50KSB7XG4gICAgY29uc3Qgb25lID0gY291bnQgPT09IDFcbiAgICBjb25zdCBrZXlzID0gb25lID8gc2luZ3VsYXJzIDogcGx1cmFsc1xuICAgIGNvbnN0IG5vdW4gPSBvbmUgPyB0aGlzLnNpbmd1bGFyIDogdGhpcy5wbHVyYWxcbiAgICByZXR1cm4geyAuLi5rZXlzLCBjb3VudCwgbm91biB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/pluralizer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/node/fixed-queue.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/node/fixed-queue.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable */\n\n\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9ub2RlL2ZpeGVkLXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbm9kZS9maXhlZC1xdWV1ZS5qcz81YWYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vLyBFeHRyYWN0ZWQgZnJvbSBub2RlL2xpYi9pbnRlcm5hbC9maXhlZF9xdWV1ZS5qc1xuXG4vLyBDdXJyZW50bHkgb3B0aW1hbCBxdWV1ZSBzaXplLCB0ZXN0ZWQgb24gVjggNi4wIC0gNi42LiBNdXN0IGJlIHBvd2VyIG9mIHR3by5cbmNvbnN0IGtTaXplID0gMjA0ODtcbmNvbnN0IGtNYXNrID0ga1NpemUgLSAxO1xuXG4vLyBUaGUgRml4ZWRRdWV1ZSBpcyBpbXBsZW1lbnRlZCBhcyBhIHNpbmdseS1saW5rZWQgbGlzdCBvZiBmaXhlZC1zaXplXG4vLyBjaXJjdWxhciBidWZmZXJzLiBJdCBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICBoZWFkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxcbi8vICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gICAgdiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2XG4vLyArLS0tLS0tLS0tLS0rIDwtLS0tLVxcICAgICAgICstLS0tLS0tLS0tLSsgPC0tLS0tLVxcICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgXFwtLS0tLSB8ICAgbmV4dCAgICB8ICAgICAgICAgXFwtLS0tLS0tIHwgICBuZXh0ICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICBib3R0b20gLS0+IHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgICAuLi4gICAgfCAgICAgICAgICAgICAgIHwgICAgLi4uICAgIHwgICAgICAgICAgICAgICAgICB8ICAgIC4uLiAgICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCA8LS0gdG9wICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8IDwtLSB0b3AgIHRvcCAtLT4gfCAgW2VtcHR5XSAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vL1xuLy8gT3IsIGlmIHRoZXJlIGlzIG9ubHkgb25lIGNpcmN1bGFyIGJ1ZmZlciwgaXQgbG9va3Mgc29tZXRoaW5nXG4vLyBsaWtlIGVpdGhlciBvZiB0aGVzZTpcbi8vXG4vLyAgaGVhZCAgIHRhaWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkICAgdGFpbFxuLy8gICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8XG4vLyAgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgICAgIHZcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbbnVsbF0gICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgICAgICAgICB0b3AgLS0+IHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgW2VtcHR5XSAgfCA8LS0gdG9wICAgICAgICAgICAgYm90dG9tIC0tPiB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy9cbi8vIEFkZGluZyBhIHZhbHVlIG1lYW5zIG1vdmluZyBgdG9wYCBmb3J3YXJkIGJ5IG9uZSwgcmVtb3ZpbmcgbWVhbnNcbi8vIG1vdmluZyBgYm90dG9tYCBmb3J3YXJkIGJ5IG9uZS4gQWZ0ZXIgcmVhY2hpbmcgdGhlIGVuZCwgdGhlIHF1ZXVlXG4vLyB3cmFwcyBhcm91bmQuXG4vL1xuLy8gV2hlbiBgdG9wID09PSBib3R0b21gIHRoZSBjdXJyZW50IHF1ZXVlIGlzIGVtcHR5IGFuZCB3aGVuXG4vLyBgdG9wICsgMSA9PT0gYm90dG9tYCBpdCdzIGZ1bGwuIFRoaXMgd2FzdGVzIGEgc2luZ2xlIHNwYWNlIG9mIHN0b3JhZ2Vcbi8vIGJ1dCBhbGxvd3MgbXVjaCBxdWlja2VyIGNoZWNrcy5cblxuY2xhc3MgRml4ZWRDaXJjdWxhckJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYm90dG9tID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG4gICAgdGhpcy5saXN0ID0gbmV3IEFycmF5KGtTaXplKTtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy50b3AgPT09IHRoaXMuYm90dG9tO1xuICB9XG5cbiAgaXNGdWxsKCkge1xuICAgIHJldHVybiAoKHRoaXMudG9wICsgMSkgJiBrTWFzaykgPT09IHRoaXMuYm90dG9tO1xuICB9XG5cbiAgcHVzaChkYXRhKSB7XG4gICAgdGhpcy5saXN0W3RoaXMudG9wXSA9IGRhdGE7XG4gICAgdGhpcy50b3AgPSAodGhpcy50b3AgKyAxKSAmIGtNYXNrO1xuICB9XG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLmxpc3RbdGhpcy5ib3R0b21dO1xuICAgIGlmIChuZXh0SXRlbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5saXN0W3RoaXMuYm90dG9tXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9ICh0aGlzLmJvdHRvbSArIDEpICYga01hc2s7XG4gICAgcmV0dXJuIG5leHRJdGVtO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRml4ZWRRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKCk7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQuaXNFbXB0eSgpO1xuICB9XG5cbiAgcHVzaChkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGVhZC5pc0Z1bGwoKSkge1xuICAgICAgLy8gSGVhZCBpcyBmdWxsOiBDcmVhdGVzIGEgbmV3IHF1ZXVlLCBzZXRzIHRoZSBvbGQgcXVldWUncyBgLm5leHRgIHRvIGl0LFxuICAgICAgLy8gYW5kIHNldHMgaXQgYXMgdGhlIG5ldyBtYWluIHF1ZXVlLlxuICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQgPSBuZXcgRml4ZWRDaXJjdWxhckJ1ZmZlcigpO1xuICAgIH1cbiAgICB0aGlzLmhlYWQucHVzaChkYXRhKTtcbiAgfVxuXG4gIHNoaWZ0KCkge1xuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnRhaWw7XG4gICAgY29uc3QgbmV4dCA9IHRhaWwuc2hpZnQoKTtcbiAgICBpZiAodGFpbC5pc0VtcHR5KCkgJiYgdGFpbC5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhbm90aGVyIHF1ZXVlLCBpdCBmb3JtcyB0aGUgbmV3IHRhaWwuXG4gICAgICB0aGlzLnRhaWwgPSB0YWlsLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/node/fixed-queue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/pool-base.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/pool-base.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher-base.js\")\nconst FixedQueue = __webpack_require__(/*! ./node/fixed-queue */ \"(ssr)/./node_modules/undici/lib/node/fixed-queue.js\")\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst PoolStats = __webpack_require__(/*! ./pool-stats */ \"(ssr)/./node_modules/undici/lib/pool-stats.js\")\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\nconst kStats = Symbol('stats')\n\nclass PoolBase extends DispatcherBase {\n  constructor () {\n    super()\n\n    this[kQueue] = new FixedQueue()\n    this[kClients] = []\n    this[kQueued] = 0\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (origin, targets) {\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n\n    this[kStats] = new PoolStats(this)\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kConnected] () {\n    return this[kClients].filter(client => client[kConnected]).length\n  }\n\n  get [kFree] () {\n    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get stats () {\n    return this[kStats]\n  }\n\n  async [kClose] () {\n    if (this[kQueue].isEmpty()) {\n      return Promise.all(this[kClients].map(c => c.close()))\n    } else {\n      return new Promise((resolve) => {\n        this[kClosedResolve] = resolve\n      })\n    }\n  }\n\n  async [kDestroy] (err) {\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    return Promise.all(this[kClients].map(c => c.destroy(err)))\n  }\n\n  [kDispatch] (opts, handler) {\n    const dispatcher = this[kGetDispatcher]()\n\n    if (!dispatcher) {\n      this[kNeedDrain] = true\n      this[kQueue].push({ opts, handler })\n      this[kQueued]++\n    } else if (!dispatcher.dispatch(opts, handler)) {\n      dispatcher[kNeedDrain] = true\n      this[kNeedDrain] = !this[kGetDispatcher]()\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain])\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      process.nextTick(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLWJhc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosdUJBQXVCLG1CQUFPLENBQUMsNkVBQW1CO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLCtFQUFvQjtBQUMvQyxRQUFRLGtHQUFrRyxFQUFFLG1CQUFPLENBQUMsdUVBQWdCO0FBQ3BJLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFjOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC1iYXNlLmpzPzk2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgRml4ZWRRdWV1ZSA9IHJlcXVpcmUoJy4vbm9kZS9maXhlZC1xdWV1ZScpXG5jb25zdCB7IGtDb25uZWN0ZWQsIGtTaXplLCBrUnVubmluZywga1BlbmRpbmcsIGtRdWV1ZWQsIGtCdXN5LCBrRnJlZSwga1VybCwga0Nsb3NlLCBrRGVzdHJveSwga0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5jb25zdCBQb29sU3RhdHMgPSByZXF1aXJlKCcuL3Bvb2wtc3RhdHMnKVxuXG5jb25zdCBrQ2xpZW50cyA9IFN5bWJvbCgnY2xpZW50cycpXG5jb25zdCBrTmVlZERyYWluID0gU3ltYm9sKCduZWVkRHJhaW4nKVxuY29uc3Qga1F1ZXVlID0gU3ltYm9sKCdxdWV1ZScpXG5jb25zdCBrQ2xvc2VkUmVzb2x2ZSA9IFN5bWJvbCgnY2xvc2VkIHJlc29sdmUnKVxuY29uc3Qga09uRHJhaW4gPSBTeW1ib2woJ29uRHJhaW4nKVxuY29uc3Qga09uQ29ubmVjdCA9IFN5bWJvbCgnb25Db25uZWN0JylcbmNvbnN0IGtPbkRpc2Nvbm5lY3QgPSBTeW1ib2woJ29uRGlzY29ubmVjdCcpXG5jb25zdCBrT25Db25uZWN0aW9uRXJyb3IgPSBTeW1ib2woJ29uQ29ubmVjdGlvbkVycm9yJylcbmNvbnN0IGtHZXREaXNwYXRjaGVyID0gU3ltYm9sKCdnZXQgZGlzcGF0Y2hlcicpXG5jb25zdCBrQWRkQ2xpZW50ID0gU3ltYm9sKCdhZGQgY2xpZW50JylcbmNvbnN0IGtSZW1vdmVDbGllbnQgPSBTeW1ib2woJ3JlbW92ZSBjbGllbnQnKVxuY29uc3Qga1N0YXRzID0gU3ltYm9sKCdzdGF0cycpXG5cbmNsYXNzIFBvb2xCYXNlIGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trUXVldWVdID0gbmV3IEZpeGVkUXVldWUoKVxuICAgIHRoaXNba0NsaWVudHNdID0gW11cbiAgICB0aGlzW2tRdWV1ZWRdID0gMFxuXG4gICAgY29uc3QgcG9vbCA9IHRoaXNcblxuICAgIHRoaXNba09uRHJhaW5dID0gZnVuY3Rpb24gb25EcmFpbiAob3JpZ2luLCB0YXJnZXRzKSB7XG4gICAgICBjb25zdCBxdWV1ZSA9IHBvb2xba1F1ZXVlXVxuXG4gICAgICBsZXQgbmVlZERyYWluID0gZmFsc2VcblxuICAgICAgd2hpbGUgKCFuZWVkRHJhaW4pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHF1ZXVlLnNoaWZ0KClcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBwb29sW2tRdWV1ZWRdLS1cbiAgICAgICAgbmVlZERyYWluID0gIXRoaXMuZGlzcGF0Y2goaXRlbS5vcHRzLCBpdGVtLmhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSBuZWVkRHJhaW5cblxuICAgICAgaWYgKCF0aGlzW2tOZWVkRHJhaW5dICYmIHBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgcG9vbFtrTmVlZERyYWluXSA9IGZhbHNlXG4gICAgICAgIHBvb2wuZW1pdCgnZHJhaW4nLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSlcbiAgICAgIH1cblxuICAgICAgaWYgKHBvb2xba0Nsb3NlZFJlc29sdmVdICYmIHF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICBQcm9taXNlXG4gICAgICAgICAgLmFsbChwb29sW2tDbGllbnRzXS5tYXAoYyA9PiBjLmNsb3NlKCkpKVxuICAgICAgICAgIC50aGVuKHBvb2xba0Nsb3NlZFJlc29sdmVdKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICBwb29sLmVtaXQoJ2Nvbm5lY3QnLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSlcbiAgICB9XG5cbiAgICB0aGlzW2tPbkRpc2Nvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICBwb29sLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgcG9vbC5lbWl0KCdjb25uZWN0aW9uRXJyb3InLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba1N0YXRzXSA9IG5ldyBQb29sU3RhdHModGhpcylcbiAgfVxuXG4gIGdldCBba0J1c3ldICgpIHtcbiAgICByZXR1cm4gdGhpc1trTmVlZERyYWluXVxuICB9XG5cbiAgZ2V0IFtrQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdLmZpbHRlcihjbGllbnQgPT4gY2xpZW50W2tDb25uZWN0ZWRdKS5sZW5ndGhcbiAgfVxuXG4gIGdldCBba0ZyZWVdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c10uZmlsdGVyKGNsaWVudCA9PiBjbGllbnRba0Nvbm5lY3RlZF0gJiYgIWNsaWVudFtrTmVlZERyYWluXSkubGVuZ3RoXG4gIH1cblxuICBnZXQgW2tQZW5kaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IHRoaXNba1F1ZXVlZF1cbiAgICBmb3IgKGNvbnN0IHsgW2tQZW5kaW5nXTogcGVuZGluZyB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gcGVuZGluZ1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tSdW5uaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IDBcbiAgICBmb3IgKGNvbnN0IHsgW2tSdW5uaW5nXTogcnVubmluZyB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gcnVubmluZ1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tTaXplXSAoKSB7XG4gICAgbGV0IHJldCA9IHRoaXNba1F1ZXVlZF1cbiAgICBmb3IgKGNvbnN0IHsgW2tTaXplXTogc2l6ZSB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gc2l6ZVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgc3RhdHMgKCkge1xuICAgIHJldHVybiB0aGlzW2tTdGF0c11cbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1trUXVldWVdLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXNba0NsaWVudHNdLm1hcChjID0+IGMuY2xvc2UoKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IHJlc29sdmVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2tRdWV1ZV0uc2hpZnQoKVxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpdGVtLmhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXNba0NsaWVudHNdLm1hcChjID0+IGMuZGVzdHJveShlcnIpKSlcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0dldERpc3BhdGNoZXJdKClcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgdGhpc1trTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba1F1ZXVlXS5wdXNoKHsgb3B0cywgaGFuZGxlciB9KVxuICAgICAgdGhpc1trUXVldWVkXSsrXG4gICAgfSBlbHNlIGlmICghZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKSkge1xuICAgICAgZGlzcGF0Y2hlcltrTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAhdGhpc1trR2V0RGlzcGF0Y2hlcl0oKVxuICAgIH1cblxuICAgIHJldHVybiAhdGhpc1trTmVlZERyYWluXVxuICB9XG5cbiAgW2tBZGRDbGllbnRdIChjbGllbnQpIHtcbiAgICBjbGllbnRcbiAgICAgIC5vbignZHJhaW4nLCB0aGlzW2tPbkRyYWluXSlcbiAgICAgIC5vbignY29ubmVjdCcsIHRoaXNba09uQ29ubmVjdF0pXG4gICAgICAub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzW2tPbkRpc2Nvbm5lY3RdKVxuICAgICAgLm9uKCdjb25uZWN0aW9uRXJyb3InLCB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0pXG5cbiAgICB0aGlzW2tDbGllbnRzXS5wdXNoKGNsaWVudClcblxuICAgIGlmICh0aGlzW2tOZWVkRHJhaW5dKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXNba05lZWREcmFpbl0pIHtcbiAgICAgICAgICB0aGlzW2tPbkRyYWluXShjbGllbnRba1VybF0sIFt0aGlzLCBjbGllbnRdKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBba1JlbW92ZUNsaWVudF0gKGNsaWVudCkge1xuICAgIGNsaWVudC5jbG9zZSgoKSA9PiB7XG4gICAgICBjb25zdCBpZHggPSB0aGlzW2tDbGllbnRzXS5pbmRleE9mKGNsaWVudClcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHRoaXNba0NsaWVudHNdLnNwbGljZShpZHgsIDEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXNba05lZWREcmFpbl0gPSB0aGlzW2tDbGllbnRzXS5zb21lKGRpc3BhdGNoZXIgPT4gKFxuICAgICAgIWRpc3BhdGNoZXJba05lZWREcmFpbl0gJiZcbiAgICAgIGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga1JlbW92ZUNsaWVudCxcbiAga0dldERpc3BhdGNoZXJcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/pool-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/pool-stats.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/pool-stats.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst kPool = Symbol('pool')\n\nclass PoolStats {\n  constructor (pool) {\n    this[kPool] = pool\n  }\n\n  get connected () {\n    return this[kPool][kConnected]\n  }\n\n  get free () {\n    return this[kPool][kFree]\n  }\n\n  get pending () {\n    return this[kPool][kPending]\n  }\n\n  get queued () {\n    return this[kPool][kQueued]\n  }\n\n  get running () {\n    return this[kPool][kRunning]\n  }\n\n  get size () {\n    return this[kPool][kSize]\n  }\n}\n\nmodule.exports = PoolStats\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLXN0YXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsd0RBQXdELEVBQUUsbUJBQU8sQ0FBQyx1RUFBZ0I7QUFDMUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Bvb2wtc3RhdHMuanM/NTU3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGtGcmVlLCBrQ29ubmVjdGVkLCBrUGVuZGluZywga1F1ZXVlZCwga1J1bm5pbmcsIGtTaXplIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5jb25zdCBrUG9vbCA9IFN5bWJvbCgncG9vbCcpXG5cbmNsYXNzIFBvb2xTdGF0cyB7XG4gIGNvbnN0cnVjdG9yIChwb29sKSB7XG4gICAgdGhpc1trUG9vbF0gPSBwb29sXG4gIH1cblxuICBnZXQgY29ubmVjdGVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba0Nvbm5lY3RlZF1cbiAgfVxuXG4gIGdldCBmcmVlICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba0ZyZWVdXG4gIH1cblxuICBnZXQgcGVuZGluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tQZW5kaW5nXVxuICB9XG5cbiAgZ2V0IHF1ZXVlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tRdWV1ZWRdXG4gIH1cblxuICBnZXQgcnVubmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tSdW5uaW5nXVxuICB9XG5cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrU2l6ZV1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xTdGF0c1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/pool-stats.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/pool.js":
/*!*****************************************!*\
  !*** ./node_modules/undici/lib/pool.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/undici/lib/pool-base.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/undici/lib/client.js\")\nconst {\n  InvalidArgumentError\n} = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ./core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\")\n\nconst kOptions = Symbol('options')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass Pool extends PoolBase {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    allowH2,\n    ...options\n  } = {}) {\n    super()\n\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout == null ? 10e3 : connectTimeout,\n        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool)\n      ? options.interceptors.Pool\n      : []\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect, allowH2 }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kFactory] = factory\n  }\n\n  [kGetDispatcher] () {\n    let dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain])\n\n    if (dispatcher) {\n      return dispatcher\n    }\n\n    if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n      dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n    }\n\n    return dispatcher\n  }\n}\n\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFhO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQywyREFBVTtBQUNqQztBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscUVBQWU7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLGlFQUFhO0FBQ2xDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx1RUFBZ0I7QUFDeEQsdUJBQXVCLG1CQUFPLENBQUMsdUVBQWdCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsbURBQW1EO0FBQ3BIO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Bvb2wuanM/NDM4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59ID0gcmVxdWlyZSgnLi9wb29sLWJhc2UnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvclxufSA9IHJlcXVpcmUoJy4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJylcbmNvbnN0IHsga1VybCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuL2NvcmUvY29ubmVjdCcpXG5cbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcbmNvbnN0IGtDb25uZWN0aW9ucyA9IFN5bWJvbCgnY29ubmVjdGlvbnMnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgUG9vbCBleHRlbmRzIFBvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwge1xuICAgIGNvbm5lY3Rpb25zLFxuICAgIGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSxcbiAgICBjb25uZWN0LFxuICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgIHRscyxcbiAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICBzb2NrZXRQYXRoLFxuICAgIGF1dG9TZWxlY3RGYW1pbHksXG4gICAgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0LFxuICAgIGFsbG93SDIsXG4gICAgLi4ub3B0aW9uc1xuICB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoY29ubmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShjb25uZWN0aW9ucykgfHwgY29ubmVjdGlvbnMgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbm5lY3Rpb25zJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHtcbiAgICAgICAgLi4udGxzLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgYWxsb3dIMixcbiAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgdGltZW91dDogY29ubmVjdFRpbWVvdXQgPT0gbnVsbCA/IDEwZTMgOiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKHV0aWwubm9kZUhhc0F1dG9TZWxlY3RGYW1pbHkgJiYgYXV0b1NlbGVjdEZhbWlseSA/IHsgYXV0b1NlbGVjdEZhbWlseSwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IH0gOiB1bmRlZmluZWQpLFxuICAgICAgICAuLi5jb25uZWN0XG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBvcHRpb25zLmludGVyY2VwdG9ycyAmJiBvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnRlcmNlcHRvcnMuUG9vbClcbiAgICAgID8gb3B0aW9ucy5pbnRlcmNlcHRvcnMuUG9vbFxuICAgICAgOiBbXVxuICAgIHRoaXNba0Nvbm5lY3Rpb25zXSA9IGNvbm5lY3Rpb25zIHx8IG51bGxcbiAgICB0aGlzW2tVcmxdID0gdXRpbC5wYXJzZU9yaWdpbihvcmlnaW4pXG4gICAgdGhpc1trT3B0aW9uc10gPSB7IC4uLnV0aWwuZGVlcENsb25lKG9wdGlvbnMpLCBjb25uZWN0LCBhbGxvd0gyIH1cbiAgICB0aGlzW2tPcHRpb25zXS5pbnRlcmNlcHRvcnMgPSBvcHRpb25zLmludGVyY2VwdG9yc1xuICAgICAgPyB7IC4uLm9wdGlvbnMuaW50ZXJjZXB0b3JzIH1cbiAgICAgIDogdW5kZWZpbmVkXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gIH1cblxuICBba0dldERpc3BhdGNoZXJdICgpIHtcbiAgICBsZXQgZGlzcGF0Y2hlciA9IHRoaXNba0NsaWVudHNdLmZpbmQoZGlzcGF0Y2hlciA9PiAhZGlzcGF0Y2hlcltrTmVlZERyYWluXSlcblxuICAgIGlmIChkaXNwYXRjaGVyKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIGlmICghdGhpc1trQ29ubmVjdGlvbnNdIHx8IHRoaXNba0NsaWVudHNdLmxlbmd0aCA8IHRoaXNba0Nvbm5lY3Rpb25zXSkge1xuICAgICAgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKHRoaXNba1VybF0sIHRoaXNba09wdGlvbnNdKVxuICAgICAgdGhpc1trQWRkQ2xpZW50XShkaXNwYXRjaGVyKVxuICAgIH1cblxuICAgIHJldHVybiBkaXNwYXRjaGVyXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb29sXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/proxy-agent.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/proxy-agent.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { URL } = __webpack_require__(/*! url */ \"url\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/undici/lib/agent.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/pool.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher-base.js\")\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\")\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction buildProxyOptions (opts) {\n  if (typeof opts === 'string') {\n    opts = { uri: opts }\n  }\n\n  if (!opts || !opts.uri) {\n    throw new InvalidArgumentError('Proxy opts.uri is mandatory')\n  }\n\n  return {\n    uri: opts.uri,\n    protocol: opts.protocol || 'https'\n  }\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    super(opts)\n    this[kProxy] = buildProxyOptions(opts)\n    this[kAgent] = new Agent(opts)\n    this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)\n      ? opts.interceptors.ProxyAgent\n      : []\n\n    if (typeof opts === 'string') {\n      opts = { uri: opts }\n    }\n\n    if (!opts || !opts.uri) {\n      throw new InvalidArgumentError('Proxy opts.uri is mandatory')\n    }\n\n    const { clientFactory = defaultFactory } = opts\n\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')\n    }\n\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = opts.headers || {}\n\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token\n    }\n\n    const resolvedUrl = new URL(opts.uri)\n    const { origin, port, host } = resolvedUrl\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n    this[kClient] = clientFactory(resolvedUrl, { connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedHost = opts.host\n        if (!opts.port) {\n          requestedHost += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedHost,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host\n            }\n          })\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy()\n            callback(new RequestAbortedError('Proxy response !== 200 when HTTP Tunneling'))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          callback(err)\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const { host } = new URL(opts.origin)\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers: {\n          ...headers,\n          host\n        }\n      },\n      handler\n    )\n  }\n\n  async [kClose] () {\n    await this[kAgent].close()\n    await this[kClient].close()\n  }\n\n  async [kDestroy] () {\n    await this[kAgent].destroy()\n    await this[kClient].destroy()\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wcm94eS1hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLDBDQUEwQyxFQUFFLG1CQUFPLENBQUMsdUVBQWdCO0FBQzVFLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsZ0JBQUs7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLHlEQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyx1REFBUTtBQUM3Qix1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDbEQsUUFBUSw0Q0FBNEMsRUFBRSxtQkFBTyxDQUFDLHFFQUFlO0FBQzdFLHVCQUF1QixtQkFBTyxDQUFDLHVFQUFnQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlDQUFpQzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNERBQTRELFVBQVU7QUFDdEUsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHFCQUFxQjs7QUFFakMscUNBQXFDLGtCQUFrQjtBQUN2RCw4Q0FBOEMsb0JBQW9CO0FBQ2xFLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxtQ0FBbUMseUNBQXlDO0FBQzVFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2Qzs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wcm94eS1hZ2VudC5qcz8xNzlmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtQcm94eSwga0Nsb3NlLCBrRGVzdHJveSwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4vY29yZS9lcnJvcnMnKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuL2NvcmUvY29ubmVjdCcpXG5cbmNvbnN0IGtBZ2VudCA9IFN5bWJvbCgncHJveHkgYWdlbnQnKVxuY29uc3Qga0NsaWVudCA9IFN5bWJvbCgncHJveHkgY2xpZW50JylcbmNvbnN0IGtQcm94eUhlYWRlcnMgPSBTeW1ib2woJ3Byb3h5IGhlYWRlcnMnKVxuY29uc3Qga1JlcXVlc3RUbHMgPSBTeW1ib2woJ3JlcXVlc3QgdGxzIHNldHRpbmdzJylcbmNvbnN0IGtQcm94eVRscyA9IFN5bWJvbCgncHJveHkgdGxzIHNldHRpbmdzJylcbmNvbnN0IGtDb25uZWN0RW5kcG9pbnQgPSBTeW1ib2woJ2Nvbm5lY3QgZW5kcG9pbnQgZnVuY3Rpb24nKVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJvdG9jb2xQb3J0IChwcm90b2NvbCkge1xuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODBcbn1cblxuZnVuY3Rpb24gYnVpbGRQcm94eU9wdGlvbnMgKG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgIG9wdHMgPSB7IHVyaTogb3B0cyB9XG4gIH1cblxuICBpZiAoIW9wdHMgfHwgIW9wdHMudXJpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eSBvcHRzLnVyaSBpcyBtYW5kYXRvcnknKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1cmk6IG9wdHMudXJpLFxuICAgIHByb3RvY29sOiBvcHRzLnByb3RvY29sIHx8ICdodHRwcydcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpXG59XG5cbmNsYXNzIFByb3h5QWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzW2tQcm94eV0gPSBidWlsZFByb3h5T3B0aW9ucyhvcHRzKVxuICAgIHRoaXNba0FnZW50XSA9IG5ldyBBZ2VudChvcHRzKVxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBvcHRzLmludGVyY2VwdG9ycyAmJiBvcHRzLmludGVyY2VwdG9ycy5Qcm94eUFnZW50ICYmIEFycmF5LmlzQXJyYXkob3B0cy5pbnRlcmNlcHRvcnMuUHJveHlBZ2VudClcbiAgICAgID8gb3B0cy5pbnRlcmNlcHRvcnMuUHJveHlBZ2VudFxuICAgICAgOiBbXVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0cyA9IHsgdXJpOiBvcHRzIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMudXJpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5IG9wdHMudXJpIGlzIG1hbmRhdG9yeScpXG4gICAgfVxuXG4gICAgY29uc3QgeyBjbGllbnRGYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnkgfSA9IG9wdHNcblxuICAgIGlmICh0eXBlb2YgY2xpZW50RmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eSBvcHRzLmNsaWVudEZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgdGhpc1trUmVxdWVzdFRsc10gPSBvcHRzLnJlcXVlc3RUbHNcbiAgICB0aGlzW2tQcm94eVRsc10gPSBvcHRzLnByb3h5VGxzXG4gICAgdGhpc1trUHJveHlIZWFkZXJzXSA9IG9wdHMuaGVhZGVycyB8fCB7fVxuXG4gICAgaWYgKG9wdHMuYXV0aCAmJiBvcHRzLnRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMuYXV0aCBjYW5ub3QgYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIG9wdHMudG9rZW4nKVxuICAgIH0gZWxzZSBpZiAob3B0cy5hdXRoKSB7XG4gICAgICAvKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Ygb3B0cy50b2tlbiAqL1xuICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVsncHJveHktYXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7b3B0cy5hdXRofWBcbiAgICB9IGVsc2UgaWYgKG9wdHMudG9rZW4pIHtcbiAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bJ3Byb3h5LWF1dGhvcml6YXRpb24nXSA9IG9wdHMudG9rZW5cbiAgICB9XG5cbiAgICBjb25zdCByZXNvbHZlZFVybCA9IG5ldyBVUkwob3B0cy51cmkpXG4gICAgY29uc3QgeyBvcmlnaW4sIHBvcnQsIGhvc3QgfSA9IHJlc29sdmVkVXJsXG5cbiAgICBjb25zdCBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3IoeyAuLi5vcHRzLnByb3h5VGxzIH0pXG4gICAgdGhpc1trQ29ubmVjdEVuZHBvaW50XSA9IGJ1aWxkQ29ubmVjdG9yKHsgLi4ub3B0cy5yZXF1ZXN0VGxzIH0pXG4gICAgdGhpc1trQ2xpZW50XSA9IGNsaWVudEZhY3RvcnkocmVzb2x2ZWRVcmwsIHsgY29ubmVjdCB9KVxuICAgIHRoaXNba0FnZW50XSA9IG5ldyBBZ2VudCh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgY29ubmVjdDogYXN5bmMgKG9wdHMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCByZXF1ZXN0ZWRIb3N0ID0gb3B0cy5ob3N0XG4gICAgICAgIGlmICghb3B0cy5wb3J0KSB7XG4gICAgICAgICAgcmVxdWVzdGVkSG9zdCArPSBgOiR7ZGVmYXVsdFByb3RvY29sUG9ydChvcHRzLnByb3RvY29sKX1gXG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHNvY2tldCwgc3RhdHVzQ29kZSB9ID0gYXdhaXQgdGhpc1trQ2xpZW50XS5jb25uZWN0KHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBwYXRoOiByZXF1ZXN0ZWRIb3N0LFxuICAgICAgICAgICAgc2lnbmFsOiBvcHRzLnNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgLi4udGhpc1trUHJveHlIZWFkZXJzXSxcbiAgICAgICAgICAgICAgaG9zdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHt9KS5kZXN0cm95KClcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCdQcm94eSByZXNwb25zZSAhPT0gMjAwIHdoZW4gSFRUUCBUdW5uZWxpbmcnKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzb2NrZXQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHNlcnZlcm5hbWVcbiAgICAgICAgICBpZiAodGhpc1trUmVxdWVzdFRsc10pIHtcbiAgICAgICAgICAgIHNlcnZlcm5hbWUgPSB0aGlzW2tSZXF1ZXN0VGxzXS5zZXJ2ZXJuYW1lXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcnZlcm5hbWUgPSBvcHRzLnNlcnZlcm5hbWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc1trQ29ubmVjdEVuZHBvaW50XSh7IC4uLm9wdHMsIHNlcnZlcm5hbWUsIGh0dHBTb2NrZXQ6IHNvY2tldCB9LCBjYWxsYmFjaylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgeyBob3N0IH0gPSBuZXcgVVJMKG9wdHMub3JpZ2luKVxuICAgIGNvbnN0IGhlYWRlcnMgPSBidWlsZEhlYWRlcnMob3B0cy5oZWFkZXJzKVxuICAgIHRocm93SWZQcm94eUF1dGhJc1NlbnQoaGVhZGVycylcbiAgICByZXR1cm4gdGhpc1trQWdlbnRdLmRpc3BhdGNoKFxuICAgICAge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICBob3N0XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVyXG4gICAgKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5jbG9zZSgpXG4gICAgYXdhaXQgdGhpc1trQ2xpZW50XS5jbG9zZSgpXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldICgpIHtcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uZGVzdHJveSgpXG4gICAgYXdhaXQgdGhpc1trQ2xpZW50XS5kZXN0cm95KClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJzIChoZWFkZXJzKSB7XG4gIC8vIFdoZW4gdXNpbmcgdW5kaWNpLmZldGNoLCB0aGUgaGVhZGVycyBsaXN0IGlzIHN0b3JlZFxuICAvLyBhcyBhbiBhcnJheS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgY29uc3QgaGVhZGVyc1BhaXIgPSB7fVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBoZWFkZXJzUGFpcltoZWFkZXJzW2ldXSA9IGhlYWRlcnNbaSArIDFdXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnNQYWlyXG4gIH1cblxuICByZXR1cm4gaGVhZGVyc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICpcbiAqIFByZXZpb3VzIHZlcnNpb25zIG9mIFByb3h5QWdlbnQgc3VnZ2VzdHMgdGhlIFByb3h5LUF1dGhvcml6YXRpb24gaW4gcmVxdWVzdCBoZWFkZXJzXG4gKiBOZXZlcnRoZWxlc3MsIGl0IHdhcyBjaGFuZ2VkIGFuZCB0byBhdm9pZCBhIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdHkgYnkgZW5kIHVzZXJzXG4gKiB0aGlzIGNoZWNrIHdhcyBjcmVhdGVkLlxuICogSXQgc2hvdWxkIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICovXG5mdW5jdGlvbiB0aHJvd0lmUHJveHlBdXRoSXNTZW50IChoZWFkZXJzKSB7XG4gIGNvbnN0IGV4aXN0UHJveHlBdXRoID0gaGVhZGVycyAmJiBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgIC5maW5kKChrZXkpID0+IGtleS50b0xvd2VyQ2FzZSgpID09PSAncHJveHktYXV0aG9yaXphdGlvbicpXG4gIGlmIChleGlzdFByb3h5QXV0aCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHktQXV0aG9yaXphdGlvbiBzaG91bGQgYmUgc2VudCBpbiBQcm94eUFnZW50IGNvbnN0cnVjdG9yJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3h5QWdlbnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/proxy-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/timers.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/timers.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nlet fastNow = Date.now()\nlet fastNowTimeout\n\nconst fastTimers = []\n\nfunction onTimeout () {\n  fastNow = Date.now()\n\n  let len = fastTimers.length\n  let idx = 0\n  while (idx < len) {\n    const timer = fastTimers[idx]\n\n    if (timer.state === 0) {\n      timer.state = fastNow + timer.delay\n    } else if (timer.state > 0 && fastNow >= timer.state) {\n      timer.state = -1\n      timer.callback(timer.opaque)\n    }\n\n    if (timer.state === -1) {\n      timer.state = -2\n      if (idx !== len - 1) {\n        fastTimers[idx] = fastTimers.pop()\n      } else {\n        fastTimers.pop()\n      }\n      len -= 1\n    } else {\n      idx += 1\n    }\n  }\n\n  if (fastTimers.length > 0) {\n    refreshTimeout()\n  }\n}\n\nfunction refreshTimeout () {\n  if (fastNowTimeout && fastNowTimeout.refresh) {\n    fastNowTimeout.refresh()\n  } else {\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = setTimeout(onTimeout, 1e3)\n    if (fastNowTimeout.unref) {\n      fastNowTimeout.unref()\n    }\n  }\n}\n\nclass Timeout {\n  constructor (callback, delay, opaque) {\n    this.callback = callback\n    this.delay = delay\n    this.opaque = opaque\n\n    //  -2 not in timer list\n    //  -1 in timer list but inactive\n    //   0 in timer list waiting for time\n    // > 0 in timer list waiting for time to expire\n    this.state = -2\n\n    this.refresh()\n  }\n\n  refresh () {\n    if (this.state === -2) {\n      fastTimers.push(this)\n      if (!fastNowTimeout || fastTimers.length === 1) {\n        refreshTimeout()\n      }\n    }\n\n    this.state = 0\n  }\n\n  clear () {\n    this.state = -1\n  }\n}\n\nmodule.exports = {\n  setTimeout (callback, delay, opaque) {\n    return delay < 1e3\n      ? setTimeout(callback, delay, opaque)\n      : new Timeout(callback, delay, opaque)\n  },\n  clearTimeout (timeout) {\n    if (timeout instanceof Timeout) {\n      timeout.clear()\n    } else {\n      clearTimeout(timeout)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi90aW1lcnMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi90aW1lcnMuanM/NDA0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IGZhc3ROb3cgPSBEYXRlLm5vdygpXG5sZXQgZmFzdE5vd1RpbWVvdXRcblxuY29uc3QgZmFzdFRpbWVycyA9IFtdXG5cbmZ1bmN0aW9uIG9uVGltZW91dCAoKSB7XG4gIGZhc3ROb3cgPSBEYXRlLm5vdygpXG5cbiAgbGV0IGxlbiA9IGZhc3RUaW1lcnMubGVuZ3RoXG4gIGxldCBpZHggPSAwXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBjb25zdCB0aW1lciA9IGZhc3RUaW1lcnNbaWR4XVxuXG4gICAgaWYgKHRpbWVyLnN0YXRlID09PSAwKSB7XG4gICAgICB0aW1lci5zdGF0ZSA9IGZhc3ROb3cgKyB0aW1lci5kZWxheVxuICAgIH0gZWxzZSBpZiAodGltZXIuc3RhdGUgPiAwICYmIGZhc3ROb3cgPj0gdGltZXIuc3RhdGUpIHtcbiAgICAgIHRpbWVyLnN0YXRlID0gLTFcbiAgICAgIHRpbWVyLmNhbGxiYWNrKHRpbWVyLm9wYXF1ZSlcbiAgICB9XG5cbiAgICBpZiAodGltZXIuc3RhdGUgPT09IC0xKSB7XG4gICAgICB0aW1lci5zdGF0ZSA9IC0yXG4gICAgICBpZiAoaWR4ICE9PSBsZW4gLSAxKSB7XG4gICAgICAgIGZhc3RUaW1lcnNbaWR4XSA9IGZhc3RUaW1lcnMucG9wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhc3RUaW1lcnMucG9wKClcbiAgICAgIH1cbiAgICAgIGxlbiAtPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGlkeCArPSAxXG4gICAgfVxuICB9XG5cbiAgaWYgKGZhc3RUaW1lcnMubGVuZ3RoID4gMCkge1xuICAgIHJlZnJlc2hUaW1lb3V0KClcbiAgfVxufVxuXG5mdW5jdGlvbiByZWZyZXNoVGltZW91dCAoKSB7XG4gIGlmIChmYXN0Tm93VGltZW91dCAmJiBmYXN0Tm93VGltZW91dC5yZWZyZXNoKSB7XG4gICAgZmFzdE5vd1RpbWVvdXQucmVmcmVzaCgpXG4gIH0gZWxzZSB7XG4gICAgY2xlYXJUaW1lb3V0KGZhc3ROb3dUaW1lb3V0KVxuICAgIGZhc3ROb3dUaW1lb3V0ID0gc2V0VGltZW91dChvblRpbWVvdXQsIDFlMylcbiAgICBpZiAoZmFzdE5vd1RpbWVvdXQudW5yZWYpIHtcbiAgICAgIGZhc3ROb3dUaW1lb3V0LnVucmVmKClcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgVGltZW91dCB7XG4gIGNvbnN0cnVjdG9yIChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheVxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlXG5cbiAgICAvLyAgLTIgbm90IGluIHRpbWVyIGxpc3RcbiAgICAvLyAgLTEgaW4gdGltZXIgbGlzdCBidXQgaW5hY3RpdmVcbiAgICAvLyAgIDAgaW4gdGltZXIgbGlzdCB3YWl0aW5nIGZvciB0aW1lXG4gICAgLy8gPiAwIGluIHRpbWVyIGxpc3Qgd2FpdGluZyBmb3IgdGltZSB0byBleHBpcmVcbiAgICB0aGlzLnN0YXRlID0gLTJcblxuICAgIHRoaXMucmVmcmVzaCgpXG4gIH1cblxuICByZWZyZXNoICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gLTIpIHtcbiAgICAgIGZhc3RUaW1lcnMucHVzaCh0aGlzKVxuICAgICAgaWYgKCFmYXN0Tm93VGltZW91dCB8fCBmYXN0VGltZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZWZyZXNoVGltZW91dCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IDBcbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICB0aGlzLnN0YXRlID0gLTFcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0VGltZW91dCAoY2FsbGJhY2ssIGRlbGF5LCBvcGFxdWUpIHtcbiAgICByZXR1cm4gZGVsYXkgPCAxZTNcbiAgICAgID8gc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSlcbiAgICAgIDogbmV3IFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5LCBvcGFxdWUpXG4gIH0sXG4gIGNsZWFyVGltZW91dCAodGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0IGluc3RhbmNlb2YgVGltZW91dCkge1xuICAgICAgdGltZW91dC5jbGVhcigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/timers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/websocket/connection.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/websocket/connection.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\")\nconst { uid, states } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/websocket/constants.js\")\nconst {\n  kReadyState,\n  kSentClose,\n  kByteParser,\n  kReceivedClose\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/websocket/symbols.js\")\nconst { fireEvent, failWebsocketConnection } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/websocket/util.js\")\nconst { CloseEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/websocket/events.js\")\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/fetch/request.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/undici/lib/fetch/index.js\")\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/undici/lib/fetch/headers.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(ssr)/./node_modules/undici/lib/global.js\")\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\n\nconst channels = {}\nchannels.open = diagnosticsChannel.channel('undici:websocket:open')\nchannels.close = diagnosticsChannel.channel('undici:websocket:close')\nchannels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error')\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = __webpack_require__(/*! crypto */ \"crypto\")\n} catch {\n\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, ws, onEstablish, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if urls\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = new Headers(options.headers)[kHeadersList]\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to requests header list.\n  // 4. Append (`Connection`, `Upgrade`) to requests header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to requests\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to requests\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13')\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in requests header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  // TODO: enable once permessage-deflate is supported\n  const permessageDeflate = '' // 'permessage-deflate; 15'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     requests header list.\n  // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher ?? getGlobalDispatcher(),\n    processResponse (response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.')\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and responses\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n\n      if (secExtension !== null && secExtension !== permessageDeflate) {\n        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.')\n        return\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.')\n        return\n      }\n\n      response.socket.on('data', onSocketData)\n      response.socket.on('close', onSocketClose)\n      response.socket.on('error', onSocketError)\n\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        })\n      }\n\n      onEstablish(response)\n    }\n  })\n\n  return controller\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData (chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause()\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose () {\n  const { ws } = this\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] && ws[kReceivedClose]\n\n  let code = 1005\n  let reason = ''\n\n  const result = ws[kByteParser].closingInfo\n\n  if (result) {\n    code = result.code ?? 1005\n    reason = result.reason\n  } else if (!ws[kSentClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  fireEvent('close', ws, CloseEvent, {\n    wasClean, code, reason\n  })\n\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    })\n  }\n}\n\nfunction onSocketError (error) {\n  const { ws } = this\n\n  ws[kReadyState] = states.CLOSING\n\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error)\n  }\n\n  this.destroy()\n}\n\nmodule.exports = {\n  establishWebSocketConnection\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWiwyQkFBMkIsbUJBQU8sQ0FBQyxnREFBcUI7QUFDeEQsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQywyRUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDdkIsUUFBUSxxQ0FBcUMsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9ELFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMscUVBQVU7QUFDekMsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQywwRUFBa0I7QUFDbEQsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDN0MsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQywwRUFBa0I7QUFDOUMsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLDREQUFXO0FBQ25ELFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHNCQUFRO0FBQzNCLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlDQUFpQztBQUM1QyxXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLHdEQUF3RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLEtBQUs7O0FBRWY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanM/NzM5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZSgnZGlhZ25vc3RpY3NfY2hhbm5lbCcpXG5jb25zdCB7IHVpZCwgc3RhdGVzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7XG4gIGtSZWFkeVN0YXRlLFxuICBrU2VudENsb3NlLFxuICBrQnl0ZVBhcnNlcixcbiAga1JlY2VpdmVkQ2xvc2Vcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBmaXJlRXZlbnQsIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBDbG9zZUV2ZW50IH0gPSByZXF1aXJlKCcuL2V2ZW50cycpXG5jb25zdCB7IG1ha2VSZXF1ZXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXF1ZXN0JylcbmNvbnN0IHsgZmV0Y2hpbmcgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2luZGV4JylcbmNvbnN0IHsgSGVhZGVycyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaGVhZGVycycpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uL2dsb2JhbCcpXG5jb25zdCB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcblxuY29uc3QgY2hhbm5lbHMgPSB7fVxuY2hhbm5lbHMub3BlbiA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0Om9wZW4nKVxuY2hhbm5lbHMuY2xvc2UgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpjbG9zZScpXG5jaGFubmVscy5zb2NrZXRFcnJvciA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnNvY2tldF9lcnJvcicpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG59IGNhdGNoIHtcblxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC13ZWJzb2NrZXQtZXN0YWJsaXNoXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcHJvdG9jb2xzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcGFyYW0geyhyZXNwb25zZTogYW55KSA9PiB2b2lkfSBvbkVzdGFibGlzaFxuICogQHBhcmFtIHtQYXJ0aWFsPGltcG9ydCgnLi4vLi4vdHlwZXMvd2Vic29ja2V0JykuV2ViU29ja2V0SW5pdD59IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiAodXJsLCBwcm90b2NvbHMsIHdzLCBvbkVzdGFibGlzaCwgb3B0aW9ucykge1xuICAvLyAxLiBMZXQgcmVxdWVzdFVSTCBiZSBhIGNvcHkgb2YgdXJsLCB3aXRoIGl0cyBzY2hlbWUgc2V0IHRvIFwiaHR0cFwiLCBpZiB1cmzigJlzXG4gIC8vICAgIHNjaGVtZSBpcyBcIndzXCIsIGFuZCB0byBcImh0dHBzXCIgb3RoZXJ3aXNlLlxuICBjb25zdCByZXF1ZXN0VVJMID0gdXJsXG5cbiAgcmVxdWVzdFVSTC5wcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gJ3dzOicgPyAnaHR0cDonIDogJ2h0dHBzOidcblxuICAvLyAyLiBMZXQgcmVxdWVzdCBiZSBhIG5ldyByZXF1ZXN0LCB3aG9zZSBVUkwgaXMgcmVxdWVzdFVSTCwgY2xpZW50IGlzIGNsaWVudCxcbiAgLy8gICAgc2VydmljZS13b3JrZXJzIG1vZGUgaXMgXCJub25lXCIsIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgbW9kZSBpc1xuICAvLyAgICBcIndlYnNvY2tldFwiLCBjcmVkZW50aWFscyBtb2RlIGlzIFwiaW5jbHVkZVwiLCBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiAsXG4gIC8vICAgIGFuZCByZWRpcmVjdCBtb2RlIGlzIFwiZXJyb3JcIi5cbiAgY29uc3QgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICB1cmxMaXN0OiBbcmVxdWVzdFVSTF0sXG4gICAgc2VydmljZVdvcmtlcnM6ICdub25lJyxcbiAgICByZWZlcnJlcjogJ25vLXJlZmVycmVyJyxcbiAgICBtb2RlOiAnd2Vic29ja2V0JyxcbiAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgIGNhY2hlOiAnbm8tc3RvcmUnLFxuICAgIHJlZGlyZWN0OiAnZXJyb3InXG4gIH0pXG5cbiAgLy8gTm90ZTogdW5kaWNpIGV4dGVuc2lvbiwgYWxsb3cgc2V0dGluZyBjdXN0b20gaGVhZGVycy5cbiAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVtrSGVhZGVyc0xpc3RdXG5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0ID0gaGVhZGVyc0xpc3RcbiAgfVxuXG4gIC8vIDMuIEFwcGVuZCAoYFVwZ3JhZGVgLCBgd2Vic29ja2V0YCkgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDQuIEFwcGVuZCAoYENvbm5lY3Rpb25gLCBgVXBncmFkZWApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyBOb3RlOiBib3RoIG9mIHRoZXNlIGFyZSBoYW5kbGVkIGJ5IHVuZGljaSBjdXJyZW50bHkuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2Jsb2IvNjhjMjY5YzQxNDRjNDQ2ZjNmMTIyMDk1MTMzOGRhZWY0YTZiNWVjNC9saWIvY2xpZW50LmpzI0wxMzk3XG5cbiAgLy8gNS4gTGV0IGtleVZhbHVlIGJlIGEgbm9uY2UgY29uc2lzdGluZyBvZiBhIHJhbmRvbWx5IHNlbGVjdGVkXG4gIC8vICAgIDE2LWJ5dGUgdmFsdWUgdGhhdCBoYXMgYmVlbiBmb3JnaXZpbmctYmFzZTY0LWVuY29kZWQgYW5kXG4gIC8vICAgIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgY29uc3Qga2V5VmFsdWUgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4gIC8vIDYuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtS2V5YCwga2V5VmFsdWUpIHRvIHJlcXVlc3TigJlzXG4gIC8vICAgIGhlYWRlciBsaXN0LlxuICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1rZXknLCBrZXlWYWx1ZSlcblxuICAvLyA3LiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LVZlcnNpb25gLCBgMTNgKSB0byByZXF1ZXN04oCZc1xuICAvLyAgICBoZWFkZXIgbGlzdC5cbiAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbicsICcxMycpXG5cbiAgLy8gOC4gRm9yIGVhY2ggcHJvdG9jb2wgaW4gcHJvdG9jb2xzLCBjb21iaW5lXG4gIC8vICAgIChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAsIHByb3RvY29sKSBpbiByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdC5cbiAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcsIHByb3RvY29sKVxuICB9XG5cbiAgLy8gOS4gTGV0IHBlcm1lc3NhZ2VEZWZsYXRlIGJlIGEgdXNlci1hZ2VudCBkZWZpbmVkXG4gIC8vICAgIFwicGVybWVzc2FnZS1kZWZsYXRlXCIgZXh0ZW5zaW9uIGhlYWRlciB2YWx1ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvY2U3ODIzNGY1ZTY1M2E1ZDM5MTY4MTNmZjk5MGYwNTM1MTAyMjdiYy9uZXR3ZXJrL3Byb3RvY29sL3dlYnNvY2tldC9XZWJTb2NrZXRDaGFubmVsLmNwcCNMMjY3M1xuICAvLyBUT0RPOiBlbmFibGUgb25jZSBwZXJtZXNzYWdlLWRlZmxhdGUgaXMgc3VwcG9ydGVkXG4gIGNvbnN0IHBlcm1lc3NhZ2VEZWZsYXRlID0gJycgLy8gJ3Blcm1lc3NhZ2UtZGVmbGF0ZTsgMTUnXG5cbiAgLy8gMTAuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AsIHBlcm1lc3NhZ2VEZWZsYXRlKSB0b1xuICAvLyAgICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnLCBwZXJtZXNzYWdlRGVmbGF0ZSlcblxuICAvLyAxMS4gRmV0Y2ggcmVxdWVzdCB3aXRoIHVzZVBhcmFsbGVsUXVldWUgc2V0IHRvIHRydWUsIGFuZFxuICAvLyAgICAgcHJvY2Vzc1Jlc3BvbnNlIGdpdmVuIHJlc3BvbnNlIGJlaW5nIHRoZXNlIHN0ZXBzOlxuICBjb25zdCBjb250cm9sbGVyID0gZmV0Y2hpbmcoe1xuICAgIHJlcXVlc3QsXG4gICAgdXNlUGFyYWxsZWxRdWV1ZTogdHJ1ZSxcbiAgICBkaXNwYXRjaGVyOiBvcHRpb25zLmRpc3BhdGNoZXIgPz8gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpLFxuICAgIHByb2Nlc3NSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICAgIC8vIDEuIElmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciBvciBpdHMgc3RhdHVzIGlzIG5vdCAxMDEsXG4gICAgICAvLyAgICBmYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InIHx8IHJlc3BvbnNlLnN0YXR1cyAhPT0gMTAxKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUmVjZWl2ZWQgbmV0d29yayBlcnJvciBvciBub24tMTAxIHN0YXR1cyBjb2RlLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBwcm90b2NvbHMgaXMgbm90IHRoZSBlbXB0eSBsaXN0IGFuZCBleHRyYWN0aW5nIGhlYWRlclxuICAgICAgLy8gICAgbGlzdCB2YWx1ZXMgZ2l2ZW4gYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGFuZCByZXNwb25zZeKAmXNcbiAgICAgIC8vICAgIGhlYWRlciBsaXN0IHJlc3VsdHMgaW4gbnVsbCwgZmFpbHVyZSwgb3IgdGhlIGVtcHR5IGJ5dGVcbiAgICAgIC8vICAgIHNlcXVlbmNlLCB0aGVuIGZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgaWYgKHByb3RvY29scy5sZW5ndGggIT09IDAgJiYgIXJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcpKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnU2VydmVyIGRpZCBub3QgcmVzcG9uZCB3aXRoIHNlbnQgcHJvdG9jb2xzLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAzLiBGb2xsb3cgdGhlIHJlcXVpcmVtZW50cyBzdGF0ZWQgc3RlcCAyIHRvIHN0ZXAgNiwgaW5jbHVzaXZlLFxuICAgICAgLy8gICAgb2YgdGhlIGxhc3Qgc2V0IG9mIHN0ZXBzIGluIHNlY3Rpb24gNC4xIG9mIFRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgIFByb3RvY29sIHRvIHZhbGlkYXRlIHJlc3BvbnNlLiBUaGlzIGVpdGhlciByZXN1bHRzIGluIGZhaWxcbiAgICAgIC8vICAgIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBvciB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgICAgIC8vICAgIGVzdGFibGlzaGVkLlxuXG4gICAgICAvLyAyLiBJZiB0aGUgcmVzcG9uc2UgbGFja3MgYW4gfFVwZ3JhZGV8IGhlYWRlciBmaWVsZCBvciB0aGUgfFVwZ3JhZGV8XG4gICAgICAvLyAgICBoZWFkZXIgZmllbGQgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBhbiBBU0NJSSBjYXNlLVxuICAgICAgLy8gICAgaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIHRoZSB2YWx1ZSBcIndlYnNvY2tldFwiLCB0aGUgY2xpZW50IE1VU1RcbiAgICAgIC8vICAgIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdVcGdyYWRlJyk/LnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnU2VydmVyIGRpZCBub3Qgc2V0IFVwZ3JhZGUgaGVhZGVyIHRvIFwid2Vic29ja2V0XCIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhIHxDb25uZWN0aW9ufCBoZWFkZXIgZmllbGQgb3IgdGhlXG4gICAgICAvLyAgICB8Q29ubmVjdGlvbnwgaGVhZGVyIGZpZWxkIGRvZXNuJ3QgY29udGFpbiBhIHRva2VuIHRoYXQgaXMgYW5cbiAgICAgIC8vICAgIEFTQ0lJIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIHRoZSB2YWx1ZSBcIlVwZ3JhZGVcIiwgdGhlIGNsaWVudFxuICAgICAgLy8gICAgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnQ29ubmVjdGlvbicpPy50b0xvd2VyQ2FzZSgpICE9PSAndXBncmFkZScpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCBzZXQgQ29ubmVjdGlvbiBoZWFkZXIgdG8gXCJ1cGdyYWRlXCIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDQuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhIHxTZWMtV2ViU29ja2V0LUFjY2VwdHwgaGVhZGVyIGZpZWxkIG9yXG4gICAgICAvLyAgICB0aGUgfFNlYy1XZWJTb2NrZXQtQWNjZXB0fCBjb250YWlucyBhIHZhbHVlIG90aGVyIHRoYW4gdGhlXG4gICAgICAvLyAgICBiYXNlNjQtZW5jb2RlZCBTSEEtMSBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgfFNlYy1XZWJTb2NrZXQtXG4gICAgICAvLyAgICBLZXl8IChhcyBhIHN0cmluZywgbm90IGJhc2U2NC1kZWNvZGVkKSB3aXRoIHRoZSBzdHJpbmcgXCIyNThFQUZBNS1cbiAgICAgIC8vICAgIEU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMVwiIGJ1dCBpZ25vcmluZyBhbnkgbGVhZGluZyBhbmRcbiAgICAgIC8vICAgIHRyYWlsaW5nIHdoaXRlc3BhY2UsIHRoZSBjbGllbnQgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyAgICBDb25uZWN0aW9uXy5cbiAgICAgIGNvbnN0IHNlY1dTQWNjZXB0ID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LUFjY2VwdCcpXG4gICAgICBjb25zdCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShrZXlWYWx1ZSArIHVpZCkuZGlnZXN0KCdiYXNlNjQnKVxuICAgICAgaWYgKHNlY1dTQWNjZXB0ICE9PSBkaWdlc3QpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdJbmNvcnJlY3QgaGFzaCByZWNlaXZlZCBpbiBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIElmIHRoZSByZXNwb25zZSBpbmNsdWRlcyBhIHxTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnN8IGhlYWRlclxuICAgICAgLy8gICAgZmllbGQgYW5kIHRoaXMgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgdXNlIG9mIGFuIGV4dGVuc2lvblxuICAgICAgLy8gICAgdGhhdCB3YXMgbm90IHByZXNlbnQgaW4gdGhlIGNsaWVudCdzIGhhbmRzaGFrZSAodGhlIHNlcnZlciBoYXNcbiAgICAgIC8vICAgIGluZGljYXRlZCBhbiBleHRlbnNpb24gbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50KSwgdGhlIGNsaWVudFxuICAgICAgLy8gICAgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLiAgKFRoZSBwYXJzaW5nIG9mIHRoaXNcbiAgICAgIC8vICAgIGhlYWRlciBmaWVsZCB0byBkZXRlcm1pbmUgd2hpY2ggZXh0ZW5zaW9ucyBhcmUgcmVxdWVzdGVkIGlzXG4gICAgICAvLyAgICBkaXNjdXNzZWQgaW4gU2VjdGlvbiA5LjEuKVxuICAgICAgY29uc3Qgc2VjRXh0ZW5zaW9uID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnKVxuXG4gICAgICBpZiAoc2VjRXh0ZW5zaW9uICE9PSBudWxsICYmIHNlY0V4dGVuc2lvbiAhPT0gcGVybWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdSZWNlaXZlZCBkaWZmZXJlbnQgcGVybWVzc2FnZS1kZWZsYXRlIHRoYW4gdGhlIG9uZSBzZXQuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDYuIElmIHRoZSByZXNwb25zZSBpbmNsdWRlcyBhIHxTZWMtV2ViU29ja2V0LVByb3RvY29sfCBoZWFkZXIgZmllbGRcbiAgICAgIC8vICAgIGFuZCB0aGlzIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHVzZSBvZiBhIHN1YnByb3RvY29sIHRoYXQgd2FzXG4gICAgICAvLyAgICBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhcyBpbmRpY2F0ZWQgYVxuICAgICAgLy8gICAgc3VicHJvdG9jb2wgbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50KSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsXG4gICAgICAvLyAgICB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjUHJvdG9jb2wgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnKVxuXG4gICAgICBpZiAoc2VjUHJvdG9jb2wgIT09IG51bGwgJiYgc2VjUHJvdG9jb2wgIT09IHJlcXVlc3QuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJykpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdQcm90b2NvbCB3YXMgbm90IHNldCBpbiB0aGUgb3BlbmluZyBoYW5kc2hha2UuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJlc3BvbnNlLnNvY2tldC5vbignZGF0YScsIG9uU29ja2V0RGF0YSlcbiAgICAgIHJlc3BvbnNlLnNvY2tldC5vbignY2xvc2UnLCBvblNvY2tldENsb3NlKVxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdlcnJvcicsIG9uU29ja2V0RXJyb3IpXG5cbiAgICAgIGlmIChjaGFubmVscy5vcGVuLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgIGNoYW5uZWxzLm9wZW4ucHVibGlzaCh7XG4gICAgICAgICAgYWRkcmVzczogcmVzcG9uc2Uuc29ja2V0LmFkZHJlc3MoKSxcbiAgICAgICAgICBwcm90b2NvbDogc2VjUHJvdG9jb2wsXG4gICAgICAgICAgZXh0ZW5zaW9uczogc2VjRXh0ZW5zaW9uXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIG9uRXN0YWJsaXNoKHJlc3BvbnNlKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gY29udHJvbGxlclxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICovXG5mdW5jdGlvbiBvblNvY2tldERhdGEgKGNodW5rKSB7XG4gIGlmICghdGhpcy53c1trQnl0ZVBhcnNlcl0ud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS40XG4gKi9cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICBjb25zdCB7IHdzIH0gPSB0aGlzXG5cbiAgLy8gSWYgdGhlIFRDUCBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYWZ0ZXIgdGhlXG4gIC8vIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSB3YXMgY29tcGxldGVkLCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgLy8gaXMgc2FpZCB0byBoYXZlIGJlZW4gY2xvc2VkIF9jbGVhbmx5Xy5cbiAgY29uc3Qgd2FzQ2xlYW4gPSB3c1trU2VudENsb3NlXSAmJiB3c1trUmVjZWl2ZWRDbG9zZV1cblxuICBsZXQgY29kZSA9IDEwMDVcbiAgbGV0IHJlYXNvbiA9ICcnXG5cbiAgY29uc3QgcmVzdWx0ID0gd3Nba0J5dGVQYXJzZXJdLmNsb3NpbmdJbmZvXG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIGNvZGUgPSByZXN1bHQuY29kZSA/PyAxMDA1XG4gICAgcmVhc29uID0gcmVzdWx0LnJlYXNvblxuICB9IGVsc2UgaWYgKCF3c1trU2VudENsb3NlXSkge1xuICAgIC8vIElmIF9UaGUgV2ViU29ja2V0XG4gICAgLy8gQ29ubmVjdGlvbiBpcyBDbG9zZWRfIGFuZCBubyBDbG9zZSBjb250cm9sIGZyYW1lIHdhcyByZWNlaXZlZCBieSB0aGVcbiAgICAvLyBlbmRwb2ludCAoc3VjaCBhcyBjb3VsZCBvY2N1ciBpZiB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgY29ubmVjdGlvblxuICAgIC8vIGlzIGxvc3QpLCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLyAxMDA2LlxuICAgIGNvZGUgPSAxMDA2XG4gIH1cblxuICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIENMT1NFRCAoMykuXG4gIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TRURcblxuICAvLyAyLiBJZiB0aGUgdXNlciBhZ2VudCB3YXMgcmVxdWlyZWQgdG8gZmFpbCB0aGUgV2ViU29ja2V0XG4gIC8vICAgIGNvbm5lY3Rpb24sIG9yIGlmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gIC8vICAgIGFmdGVyIGJlaW5nIGZsYWdnZWQgYXMgZnVsbCwgZmlyZSBhbiBldmVudCBuYW1lZCBlcnJvclxuICAvLyAgICBhdCB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgY2xvc2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsXG4gIC8vICAgIHVzaW5nIENsb3NlRXZlbnQsIHdpdGggdGhlIHdhc0NsZWFuIGF0dHJpYnV0ZVxuICAvLyAgICBpbml0aWFsaXplZCB0byB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIGNsb3NlZCBjbGVhbmx5XG4gIC8vICAgIGFuZCBmYWxzZSBvdGhlcndpc2UsIHRoZSBjb2RlIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0b1xuICAvLyAgICB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgY29kZSwgYW5kIHRoZSByZWFzb25cbiAgLy8gICAgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgVVRGLThcbiAgLy8gICAgZGVjb2RlIHdpdGhvdXQgQk9NIHRvIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZVxuICAvLyAgICByZWFzb24uXG4gIGZpcmVFdmVudCgnY2xvc2UnLCB3cywgQ2xvc2VFdmVudCwge1xuICAgIHdhc0NsZWFuLCBjb2RlLCByZWFzb25cbiAgfSlcblxuICBpZiAoY2hhbm5lbHMuY2xvc2UuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5jbG9zZS5wdWJsaXNoKHtcbiAgICAgIHdlYnNvY2tldDogd3MsXG4gICAgICBjb2RlLFxuICAgICAgcmVhc29uXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBvblNvY2tldEVycm9yIChlcnJvcikge1xuICBjb25zdCB7IHdzIH0gPSB0aGlzXG5cbiAgd3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcblxuICBpZiAoY2hhbm5lbHMuc29ja2V0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5zb2NrZXRFcnJvci5wdWJsaXNoKGVycm9yKVxuICB9XG5cbiAgdGhpcy5kZXN0cm95KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb25cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/websocket/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/websocket/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/websocket/constants.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// This is a Globally Unique Identifier unique used\n// to validate that the endpoint accepts websocket\n// connections.\n// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\nconst uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\nconst states = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n}\n\nconst opcodes = {\n  CONTINUATION: 0x0,\n  TEXT: 0x1,\n  BINARY: 0x2,\n  CLOSE: 0x8,\n  PING: 0x9,\n  PONG: 0xA\n}\n\nconst maxUnsigned16Bit = 2 ** 16 - 1 // 65535\n\nconst parserStates = {\n  INFO: 0,\n  PAYLOADLENGTH_16: 2,\n  PAYLOADLENGTH_64: 3,\n  READ_DATA: 4\n}\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\nmodule.exports = {\n  uid,\n  staticPropertyDescriptors,\n  states,\n  opcodes,\n  maxUnsigned16Bit,\n  parserStates,\n  emptyBuffer\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcz9jYzVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBUaGlzIGlzIGEgR2xvYmFsbHkgVW5pcXVlIElkZW50aWZpZXIgdW5pcXVlIHVzZWRcbi8vIHRvIHZhbGlkYXRlIHRoYXQgdGhlIGVuZHBvaW50IGFjY2VwdHMgd2Vic29ja2V0XG4vLyBjb25uZWN0aW9ucy5cbi8vIFNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjQ1NS5odG1sI3NlY3Rpb24tMS4zXG5jb25zdCB1aWQgPSAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJ1xuXG4vKiogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn0gKi9cbmNvbnN0IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufVxuXG5jb25zdCBzdGF0ZXMgPSB7XG4gIENPTk5FQ1RJTkc6IDAsXG4gIE9QRU46IDEsXG4gIENMT1NJTkc6IDIsXG4gIENMT1NFRDogM1xufVxuXG5jb25zdCBvcGNvZGVzID0ge1xuICBDT05USU5VQVRJT046IDB4MCxcbiAgVEVYVDogMHgxLFxuICBCSU5BUlk6IDB4MixcbiAgQ0xPU0U6IDB4OCxcbiAgUElORzogMHg5LFxuICBQT05HOiAweEFcbn1cblxuY29uc3QgbWF4VW5zaWduZWQxNkJpdCA9IDIgKiogMTYgLSAxIC8vIDY1NTM1XG5cbmNvbnN0IHBhcnNlclN0YXRlcyA9IHtcbiAgSU5GTzogMCxcbiAgUEFZTE9BRExFTkdUSF8xNjogMixcbiAgUEFZTE9BRExFTkdUSF82NDogMyxcbiAgUkVBRF9EQVRBOiA0XG59XG5cbmNvbnN0IGVtcHR5QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1aWQsXG4gIHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHN0YXRlcyxcbiAgb3Bjb2RlcyxcbiAgbWF4VW5zaWduZWQxNkJpdCxcbiAgcGFyc2VyU3RhdGVzLFxuICBlbXB0eUJ1ZmZlclxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/websocket/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/websocket/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/websocket/events.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { MessagePort } = __webpack_require__(/*! worker_threads */ \"worker_threads\")\n\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */\nclass MessageEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent constructor' })\n\n    type = webidl.converters.DOMString(type)\n    eventInitDict = webidl.converters.MessageEventInit(eventInitDict)\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n  }\n\n  get data () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.data\n  }\n\n  get origin () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.origin\n  }\n\n  get lastEventId () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.lastEventId\n  }\n\n  get source () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.source\n  }\n\n  get ports () {\n    webidl.brandCheck(this, MessageEvent)\n\n    if (!Object.isFrozen(this.#eventInit.ports)) {\n      Object.freeze(this.#eventInit.ports)\n    }\n\n    return this.#eventInit.ports\n  }\n\n  initMessageEvent (\n    type,\n    bubbles = false,\n    cancelable = false,\n    data = null,\n    origin = '',\n    lastEventId = '',\n    source = null,\n    ports = []\n  ) {\n    webidl.brandCheck(this, MessageEvent)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent.initMessageEvent' })\n\n    return new MessageEvent(type, {\n      bubbles, cancelable, data, origin, lastEventId, source, ports\n    })\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */\nclass CloseEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    webidl.argumentLengthCheck(arguments, 1, { header: 'CloseEvent constructor' })\n\n    type = webidl.converters.DOMString(type)\n    eventInitDict = webidl.converters.CloseEventInit(eventInitDict)\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n  }\n\n  get wasClean () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.wasClean\n  }\n\n  get code () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.code\n  }\n\n  get reason () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.reason\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict) {\n    webidl.argumentLengthCheck(arguments, 1, { header: 'ErrorEvent constructor' })\n\n    super(type, eventInitDict)\n\n    type = webidl.converters.DOMString(type)\n    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {})\n\n    this.#eventInit = eventInitDict\n  }\n\n  get message () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.message\n  }\n\n  get filename () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.filename\n  }\n\n  get lineno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.lineno\n  }\n\n  get colno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.colno\n  }\n\n  get error () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.error\n  }\n}\n\nObject.defineProperties(MessageEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'MessageEvent',\n    configurable: true\n  },\n  data: kEnumerableProperty,\n  origin: kEnumerableProperty,\n  lastEventId: kEnumerableProperty,\n  source: kEnumerableProperty,\n  ports: kEnumerableProperty,\n  initMessageEvent: kEnumerableProperty\n})\n\nObject.defineProperties(CloseEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CloseEvent',\n    configurable: true\n  },\n  reason: kEnumerableProperty,\n  code: kEnumerableProperty,\n  wasClean: kEnumerableProperty\n})\n\nObject.defineProperties(ErrorEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'ErrorEvent',\n    configurable: true\n  },\n  message: kEnumerableProperty,\n  filename: kEnumerableProperty,\n  lineno: kEnumerableProperty,\n  colno: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\nwebidl.converters.MessagePort = webidl.interfaceConverter(MessagePort)\n\nwebidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(\n  webidl.converters.MessagePort\n)\n\nconst eventInit = [\n  {\n    key: 'bubbles',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'cancelable',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'composed',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  }\n]\n\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'data',\n    converter: webidl.converters.any,\n    defaultValue: null\n  },\n  {\n    key: 'origin',\n    converter: webidl.converters.USVString,\n    defaultValue: ''\n  },\n  {\n    key: 'lastEventId',\n    converter: webidl.converters.DOMString,\n    defaultValue: ''\n  },\n  {\n    key: 'source',\n    // Node doesn't implement WindowProxy or ServiceWorker, so the only\n    // valid value for source is a MessagePort.\n    converter: webidl.nullableConverter(webidl.converters.MessagePort),\n    defaultValue: null\n  },\n  {\n    key: 'ports',\n    converter: webidl.converters['sequence<MessagePort>'],\n    get defaultValue () {\n      return []\n    }\n  }\n])\n\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'wasClean',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'code',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: 0\n  },\n  {\n    key: 'reason',\n    converter: webidl.converters.USVString,\n    defaultValue: ''\n  }\n])\n\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'message',\n    converter: webidl.converters.DOMString,\n    defaultValue: ''\n  },\n  {\n    key: 'filename',\n    converter: webidl.converters.USVString,\n    defaultValue: ''\n  },\n  {\n    key: 'lineno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: 0\n  },\n  {\n    key: 'colno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: 0\n  },\n  {\n    key: 'error',\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  MessageEvent,\n  CloseEvent,\n  ErrorEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQzVDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUN0RCxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHNDQUFnQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkMsK0NBQStDLG9DQUFvQzs7QUFFbkY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLHlDQUF5Qzs7QUFFeEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDLCtDQUErQyxrQ0FBa0M7O0FBRWpGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxrQ0FBa0M7O0FBRWpGOztBQUVBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvZXZlbnRzLmpzP2JlNmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBNZXNzYWdlUG9ydCB9ID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCNtZXNzYWdlZXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdNZXNzYWdlRXZlbnQgY29uc3RydWN0b3InIH0pXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VFdmVudEluaXQoZXZlbnRJbml0RGljdClcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gIH1cblxuICBnZXQgZGF0YSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5kYXRhXG4gIH1cblxuICBnZXQgb3JpZ2luICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lm9yaWdpblxuICB9XG5cbiAgZ2V0IGxhc3RFdmVudElkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lmxhc3RFdmVudElkXG4gIH1cblxuICBnZXQgc291cmNlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnNvdXJjZVxuICB9XG5cbiAgZ2V0IHBvcnRzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICBpZiAoIU9iamVjdC5pc0Zyb3plbih0aGlzLiNldmVudEluaXQucG9ydHMpKSB7XG4gICAgICBPYmplY3QuZnJlZXplKHRoaXMuI2V2ZW50SW5pdC5wb3J0cylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnBvcnRzXG4gIH1cblxuICBpbml0TWVzc2FnZUV2ZW50IChcbiAgICB0eXBlLFxuICAgIGJ1YmJsZXMgPSBmYWxzZSxcbiAgICBjYW5jZWxhYmxlID0gZmFsc2UsXG4gICAgZGF0YSA9IG51bGwsXG4gICAgb3JpZ2luID0gJycsXG4gICAgbGFzdEV2ZW50SWQgPSAnJyxcbiAgICBzb3VyY2UgPSBudWxsLFxuICAgIHBvcnRzID0gW11cbiAgKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ01lc3NhZ2VFdmVudC5pbml0TWVzc2FnZUV2ZW50JyB9KVxuXG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlRXZlbnQodHlwZSwge1xuICAgICAgYnViYmxlcywgY2FuY2VsYWJsZSwgZGF0YSwgb3JpZ2luLCBsYXN0RXZlbnRJZCwgc291cmNlLCBwb3J0c1xuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI3RoZS1jbG9zZWV2ZW50LWludGVyZmFjZVxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDbG9zZUV2ZW50IGNvbnN0cnVjdG9yJyB9KVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5DbG9zZUV2ZW50SW5pdChldmVudEluaXREaWN0KVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgfVxuXG4gIGdldCB3YXNDbGVhbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQud2FzQ2xlYW5cbiAgfVxuXG4gIGdldCBjb2RlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5jb2RlXG4gIH1cblxuICBnZXQgcmVhc29uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5yZWFzb25cbiAgfVxufVxuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjdGhlLWVycm9yZXZlbnQtaW50ZXJmYWNlXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QpIHtcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRXJyb3JFdmVudCBjb25zdHJ1Y3RvcicgfSlcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkVycm9yRXZlbnRJbml0KGV2ZW50SW5pdERpY3QgPz8ge30pXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gIH1cblxuICBnZXQgbWVzc2FnZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubWVzc2FnZVxuICB9XG5cbiAgZ2V0IGZpbGVuYW1lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5maWxlbmFtZVxuICB9XG5cbiAgZ2V0IGxpbmVubyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubGluZW5vXG4gIH1cblxuICBnZXQgY29sbm8gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmNvbG5vXG4gIH1cblxuICBnZXQgZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmVycm9yXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnTWVzc2FnZUV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgZGF0YToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb3JpZ2luOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsYXN0RXZlbnRJZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc291cmNlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwb3J0czoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaW5pdE1lc3NhZ2VFdmVudDoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2xvc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Nsb3NlRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICByZWFzb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNvZGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHdhc0NsZWFuOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFcnJvckV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnRXJyb3JFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1lc3NhZ2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGZpbGVuYW1lOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsaW5lbm86IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNvbG5vOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKE1lc3NhZ2VQb3J0KVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8TWVzc2FnZVBvcnQ+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0XG4pXG5cbmNvbnN0IGV2ZW50SW5pdCA9IFtcbiAge1xuICAgIGtleTogJ2J1YmJsZXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYW5jZWxhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29tcG9zZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH1cbl1cblxud2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZUV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnZGF0YScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnksXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdvcmlnaW4nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2xhc3RFdmVudElkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzb3VyY2UnLFxuICAgIC8vIE5vZGUgZG9lc24ndCBpbXBsZW1lbnQgV2luZG93UHJveHkgb3IgU2VydmljZVdvcmtlciwgc28gdGhlIG9ubHlcbiAgICAvLyB2YWxpZCB2YWx1ZSBmb3Igc291cmNlIGlzIGEgTWVzc2FnZVBvcnQuXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQpLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAga2V5OiAncG9ydHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPE1lc3NhZ2VQb3J0PiddLFxuICAgIGdldCBkZWZhdWx0VmFsdWUgKCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5DbG9zZUV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnd2FzQ2xlYW4nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb2RlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9LFxuICB7XG4gICAga2V5OiAncmVhc29uJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkVycm9yRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5ldmVudEluaXQsXG4gIHtcbiAgICBrZXk6ICdtZXNzYWdlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdmaWxlbmFtZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnbGluZW5vJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb2xubycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9LFxuICB7XG4gICAga2V5OiAnZXJyb3InLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNZXNzYWdlRXZlbnQsXG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/websocket/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/websocket/frame.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/websocket/frame.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { maxUnsigned16Bit } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/websocket/constants.js\")\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = __webpack_require__(/*! crypto */ \"crypto\")\n} catch {\n\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n    this.maskKey = crypto.randomBytes(4)\n  }\n\n  createFrame (opcode) {\n    const bodyLength = this.frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = this.maskKey[0]\n    buffer[offset - 3] = this.maskKey[1]\n    buffer[offset - 2] = this.maskKey[2]\n    buffer[offset - 1] = this.maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; i++) {\n      buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4]\n    }\n\n    return buffer\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvZnJhbWUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLDJFQUFhOztBQUVsRCxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHNCQUFRO0FBQzNCLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2ZyYW1lLmpzP2M3NzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbWF4VW5zaWduZWQxNkJpdCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl9ICovXG5sZXQgY3J5cHRvXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxufSBjYXRjaCB7XG5cbn1cblxuY2xhc3MgV2Vic29ja2V0RnJhbWVTZW5kIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfHVuZGVmaW5lZH0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLmZyYW1lRGF0YSA9IGRhdGFcbiAgICB0aGlzLm1hc2tLZXkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNClcbiAgfVxuXG4gIGNyZWF0ZUZyYW1lIChvcGNvZGUpIHtcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gdGhpcy5mcmFtZURhdGE/LmJ5dGVMZW5ndGggPz8gMFxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBib2R5TGVuZ3RoIC8vIDAtMTI1XG4gICAgbGV0IG9mZnNldCA9IDZcblxuICAgIGlmIChib2R5TGVuZ3RoID4gbWF4VW5zaWduZWQxNkJpdCkge1xuICAgICAgb2Zmc2V0ICs9IDggLy8gcGF5bG9hZCBsZW5ndGggaXMgbmV4dCA4IGJ5dGVzXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3XG4gICAgfSBlbHNlIGlmIChib2R5TGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMiAvLyBwYXlsb2FkIGxlbmd0aCBpcyBuZXh0IDIgYnl0ZXNcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjZcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYm9keUxlbmd0aCArIG9mZnNldClcblxuICAgIC8vIENsZWFyIGZpcnN0IDIgYnl0ZXMsIGV2ZXJ5dGhpbmcgZWxzZSBpcyBvdmVyd3JpdHRlblxuICAgIGJ1ZmZlclswXSA9IGJ1ZmZlclsxXSA9IDBcbiAgICBidWZmZXJbMF0gfD0gMHg4MCAvLyBGSU5cbiAgICBidWZmZXJbMF0gPSAoYnVmZmVyWzBdICYgMHhGMCkgKyBvcGNvZGUgLy8gb3Bjb2RlXG5cbiAgICAvKiEgd3MuIE1JVCBMaWNlbnNlLiBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT4gKi9cbiAgICBidWZmZXJbb2Zmc2V0IC0gNF0gPSB0aGlzLm1hc2tLZXlbMF1cbiAgICBidWZmZXJbb2Zmc2V0IC0gM10gPSB0aGlzLm1hc2tLZXlbMV1cbiAgICBidWZmZXJbb2Zmc2V0IC0gMl0gPSB0aGlzLm1hc2tLZXlbMl1cbiAgICBidWZmZXJbb2Zmc2V0IC0gMV0gPSB0aGlzLm1hc2tLZXlbM11cblxuICAgIGJ1ZmZlclsxXSA9IHBheWxvYWRMZW5ndGhcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGJvZHlMZW5ndGgsIDIpXG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIC8vIENsZWFyIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoXG4gICAgICBidWZmZXJbMl0gPSBidWZmZXJbM10gPSAwXG4gICAgICBidWZmZXIud3JpdGVVSW50QkUoYm9keUxlbmd0aCwgNCwgNilcbiAgICB9XG5cbiAgICBidWZmZXJbMV0gfD0gMHg4MCAvLyBNQVNLXG5cbiAgICAvLyBtYXNrIGJvZHlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvZHlMZW5ndGg7IGkrKykge1xuICAgICAgYnVmZmVyW29mZnNldCArIGldID0gdGhpcy5mcmFtZURhdGFbaV0gXiB0aGlzLm1hc2tLZXlbaSAlIDRdXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJzb2NrZXRGcmFtZVNlbmRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/websocket/frame.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/websocket/receiver.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/websocket/receiver.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\")\nconst diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\")\nconst { parserStates, opcodes, states, emptyBuffer } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/websocket/constants.js\")\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/websocket/symbols.js\")\nconst { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/websocket/util.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/websocket/frame.js\")\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nconst channels = {}\nchannels.ping = diagnosticsChannel.channel('undici:websocket:ping')\nchannels.pong = diagnosticsChannel.channel('undici:websocket:pong')\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #byteOffset = 0\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  constructor (ws) {\n    super()\n\n    this.ws = ws\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (true) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.fin = (buffer[0] & 0x80) !== 0\n        this.#info.opcode = buffer[0] & 0x0F\n\n        // If we receive a fragmented message, we use the type of the first\n        // frame to parse the full message as binary/text, when it's terminated\n        this.#info.originalOpcode ??= this.#info.opcode\n\n        this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION\n\n        if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        const payloadLength = buffer[1] & 0x7F\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (this.#info.fragmented && payloadLength > 125) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.')\n          return\n        } else if (\n          (this.#info.opcode === opcodes.PING ||\n            this.#info.opcode === opcodes.PONG ||\n            this.#info.opcode === opcodes.CLOSE) &&\n          payloadLength > 125\n        ) {\n          // Control frames can have a payload length of 125 bytes MAX\n          failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.')\n          return\n        } else if (this.#info.opcode === opcodes.CLOSE) {\n          if (payloadLength === 1) {\n            failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.')\n            return\n          }\n\n          const body = this.consume(payloadLength)\n\n          this.#info.closeInfo = this.parseCloseBody(false, body)\n\n          if (!this.ws[kSentClose]) {\n            // If an endpoint receives a Close frame and did not previously send a\n            // Close frame, the endpoint MUST send a Close frame in response.  (When\n            // sending a Close frame in response, the endpoint typically echos the\n            // status code it received.)\n            const body = Buffer.allocUnsafe(2)\n            body.writeUInt16BE(this.#info.closeInfo.code, 0)\n            const closeFrame = new WebsocketFrameSend(body)\n\n            this.ws[kResponse].socket.write(\n              closeFrame.createFrame(opcodes.CLOSE),\n              (err) => {\n                if (!err) {\n                  this.ws[kSentClose] = true\n                }\n              }\n            )\n          }\n\n          // Upon either sending or receiving a Close control frame, it is said\n          // that _The WebSocket Closing Handshake is Started_ and that the\n          // WebSocket connection is in the CLOSING state.\n          this.ws[kReadyState] = states.CLOSING\n          this.ws[kReceivedClose] = true\n\n          this.end()\n\n          return\n        } else if (this.#info.opcode === opcodes.PING) {\n          // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n          // response, unless it already received a Close frame.\n          // A Pong frame sent in response to a Ping frame must have identical\n          // \"Application data\"\n\n          const body = this.consume(payloadLength)\n\n          if (!this.ws[kReceivedClose]) {\n            const frame = new WebsocketFrameSend(body)\n\n            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG))\n\n            if (channels.ping.hasSubscribers) {\n              channels.ping.publish({\n                payload: body\n              })\n            }\n          }\n\n          this.#state = parserStates.INFO\n\n          if (this.#byteOffset > 0) {\n            continue\n          } else {\n            callback()\n            return\n          }\n        } else if (this.#info.opcode === opcodes.PONG) {\n          // A Pong frame MAY be sent unsolicited.  This serves as a\n          // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n          // not expected.\n\n          const body = this.consume(payloadLength)\n\n          if (channels.pong.hasSubscribers) {\n            channels.pong.publish({\n              payload: body\n            })\n          }\n\n          if (this.#byteOffset > 0) {\n            continue\n          } else {\n            callback()\n            return\n          }\n        }\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maxinimum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          // If there is still more data in this chunk that needs to be read\n          return callback()\n        } else if (this.#byteOffset >= this.#info.payloadLength) {\n          // If the server sent multiple frames in a single chunk\n\n          const body = this.consume(this.#info.payloadLength)\n\n          this.#fragments.push(body)\n\n          // If the frame is unfragmented, or a fragmented frame was terminated,\n          // a message was received\n          if (!this.#info.fragmented || (this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)) {\n            const fullMessage = Buffer.concat(this.#fragments)\n\n            websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage)\n\n            this.#info = {}\n            this.#fragments.length = 0\n          }\n\n          this.#state = parserStates.INFO\n        }\n      }\n\n      if (this.#byteOffset > 0) {\n        continue\n      } else {\n        callback()\n        break\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer|null}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      return null\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    if (this.#buffers[0].length === n) {\n      this.#byteOffset -= this.#buffers[0].length\n      return this.#buffers.shift()\n    }\n\n    const buffer = Buffer.allocUnsafe(n)\n    let offset = 0\n\n    while (offset !== n) {\n      const next = this.#buffers[0]\n      const { length } = next\n\n      if (length + offset === n) {\n        buffer.set(this.#buffers.shift(), offset)\n        break\n      } else if (length + offset > n) {\n        buffer.set(next.subarray(0, n - offset), offset)\n        this.#buffers[0] = next.subarray(n - offset)\n        break\n      } else {\n        buffer.set(this.#buffers.shift(), offset)\n        offset += next.length\n      }\n    }\n\n    this.#byteOffset -= n\n\n    return buffer\n  }\n\n  parseCloseBody (onlyCode, data) {\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (onlyCode) {\n      if (!isValidStatusCode(code)) {\n        return null\n      }\n\n      return { code }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return null\n    }\n\n    try {\n      // TODO: optimize this\n      reason = new TextDecoder('utf-8', { fatal: true }).decode(reason)\n    } catch {\n      return null\n    }\n\n    return { code, reason }\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvcmVjZWl2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQywyQkFBMkIsbUJBQU8sQ0FBQyxnREFBcUI7QUFDeEQsUUFBUSw2Q0FBNkMsRUFBRSxtQkFBTyxDQUFDLDJFQUFhO0FBQzVFLFFBQVEscURBQXFELEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUNsRixRQUFRLHVFQUF1RSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDakcsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLG1FQUFTOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Riw2Q0FBNkMsTUFBTSxNQUFNO0FBQ3JKLHFHQUFxRyxLQUFLO0FBQzFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RCxNQUFNO0FBQ047QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZml0c3RyZWFrLWZvcmdlLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzPzVhN2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBkaWFnbm9zdGljc0NoYW5uZWwgPSByZXF1aXJlKCdkaWFnbm9zdGljc19jaGFubmVsJylcbmNvbnN0IHsgcGFyc2VyU3RhdGVzLCBvcGNvZGVzLCBzdGF0ZXMsIGVtcHR5QnVmZmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGtSZWFkeVN0YXRlLCBrU2VudENsb3NlLCBrUmVzcG9uc2UsIGtSZWNlaXZlZENsb3NlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24sIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcblxuLy8gVGhpcyBjb2RlIHdhcyBpbmZsdWVuY2VkIGJ5IHdzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vIENvcHlyaWdodCAoYykgMjAxMSBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBcm5vdXQgS2F6ZW1pZXIgYW5kIGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE2IEx1aWdpIFBpbmNhIGFuZCBjb250cmlidXRvcnNcblxuY29uc3QgY2hhbm5lbHMgPSB7fVxuY2hhbm5lbHMucGluZyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBpbmcnKVxuY2hhbm5lbHMucG9uZyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBvbmcnKVxuXG5jbGFzcyBCeXRlUGFyc2VyIGV4dGVuZHMgV3JpdGFibGUge1xuICAjYnVmZmVycyA9IFtdXG4gICNieXRlT2Zmc2V0ID0gMFxuXG4gICNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG5cbiAgI2luZm8gPSB7fVxuICAjZnJhZ21lbnRzID0gW11cblxuICBjb25zdHJ1Y3RvciAod3MpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLndzID0gd3NcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICAgKi9cbiAgX3dyaXRlIChjaHVuaywgXywgY2FsbGJhY2spIHtcbiAgICB0aGlzLiNidWZmZXJzLnB1c2goY2h1bmspXG4gICAgdGhpcy4jYnl0ZU9mZnNldCArPSBjaHVuay5sZW5ndGhcblxuICAgIHRoaXMucnVuKGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgd2hlbmV2ZXIgYSBuZXcgY2h1bmsgaXMgcmVjZWl2ZWQuXG4gICAqIENhbGxiYWNrIGlzIGNhbGxlZCB3aGVuZXZlciB0aGVyZSBhcmUgbm8gbW9yZSBjaHVua3MgYnVmZmVyaW5nLFxuICAgKiBvciBub3QgZW5vdWdoIGJ5dGVzIGFyZSBidWZmZXJlZCB0byBwYXJzZS5cbiAgICovXG4gIHJ1biAoY2FsbGJhY2spIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuSU5GTykge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmVuJ3QgZW5vdWdoIGJ5dGVzIHRvIHBhcnNlIHRoZSBwYXlsb2FkIGxlbmd0aCwgZXRjLlxuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDIpXG5cbiAgICAgICAgdGhpcy4jaW5mby5maW4gPSAoYnVmZmVyWzBdICYgMHg4MCkgIT09IDBcbiAgICAgICAgdGhpcy4jaW5mby5vcGNvZGUgPSBidWZmZXJbMF0gJiAweDBGXG5cbiAgICAgICAgLy8gSWYgd2UgcmVjZWl2ZSBhIGZyYWdtZW50ZWQgbWVzc2FnZSwgd2UgdXNlIHRoZSB0eXBlIG9mIHRoZSBmaXJzdFxuICAgICAgICAvLyBmcmFtZSB0byBwYXJzZSB0aGUgZnVsbCBtZXNzYWdlIGFzIGJpbmFyeS90ZXh0LCB3aGVuIGl0J3MgdGVybWluYXRlZFxuICAgICAgICB0aGlzLiNpbmZvLm9yaWdpbmFsT3Bjb2RlID8/PSB0aGlzLiNpbmZvLm9wY29kZVxuXG4gICAgICAgIHRoaXMuI2luZm8uZnJhZ21lbnRlZCA9ICF0aGlzLiNpbmZvLmZpbiAmJiB0aGlzLiNpbmZvLm9wY29kZSAhPT0gb3Bjb2Rlcy5DT05USU5VQVRJT05cblxuICAgICAgICBpZiAodGhpcy4jaW5mby5mcmFnbWVudGVkICYmIHRoaXMuI2luZm8ub3Bjb2RlICE9PSBvcGNvZGVzLkJJTkFSWSAmJiB0aGlzLiNpbmZvLm9wY29kZSAhPT0gb3Bjb2Rlcy5URVhUKSB7XG4gICAgICAgICAgLy8gT25seSB0ZXh0IGFuZCBiaW5hcnkgZnJhbWVzIGNhbiBiZSBmcmFnbWVudGVkXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0ludmFsaWQgZnJhbWUgdHlwZSB3YXMgZnJhZ21lbnRlZC4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF5bG9hZExlbmd0aCA9IGJ1ZmZlclsxXSAmIDB4N0ZcblxuICAgICAgICBpZiAocGF5bG9hZExlbmd0aCA8PSAxMjUpIHtcbiAgICAgICAgICB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGggPSBwYXlsb2FkTGVuZ3RoXG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF8xNlxuICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfNjRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiNpbmZvLmZyYWdtZW50ZWQgJiYgcGF5bG9hZExlbmd0aCA+IDEyNSkge1xuICAgICAgICAgIC8vIEEgZnJhZ21lbnRlZCBmcmFtZSBjYW4ndCBiZSBmcmFnbWVudGVkIGl0c2VsZlxuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdGcmFnbWVudGVkIGZyYW1lIGV4Y2VlZGVkIDEyNSBieXRlcy4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICh0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5QSU5HIHx8XG4gICAgICAgICAgICB0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5QT05HIHx8XG4gICAgICAgICAgICB0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5DTE9TRSkgJiZcbiAgICAgICAgICBwYXlsb2FkTGVuZ3RoID4gMTI1XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIENvbnRyb2wgZnJhbWVzIGNhbiBoYXZlIGEgcGF5bG9hZCBsZW5ndGggb2YgMTI1IGJ5dGVzIE1BWFxuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdQYXlsb2FkIGxlbmd0aCBmb3IgY29udHJvbCBmcmFtZSBleGNlZWRlZCAxMjUgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5DTE9TRSkge1xuICAgICAgICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnUmVjZWl2ZWQgY2xvc2UgZnJhbWUgd2l0aCBhIDEtYnl0ZSBib2R5LicpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5jb25zdW1lKHBheWxvYWRMZW5ndGgpXG5cbiAgICAgICAgICB0aGlzLiNpbmZvLmNsb3NlSW5mbyA9IHRoaXMucGFyc2VDbG9zZUJvZHkoZmFsc2UsIGJvZHkpXG5cbiAgICAgICAgICBpZiAoIXRoaXMud3Nba1NlbnRDbG9zZV0pIHtcbiAgICAgICAgICAgIC8vIElmIGFuIGVuZHBvaW50IHJlY2VpdmVzIGEgQ2xvc2UgZnJhbWUgYW5kIGRpZCBub3QgcHJldmlvdXNseSBzZW5kIGFcbiAgICAgICAgICAgIC8vIENsb3NlIGZyYW1lLCB0aGUgZW5kcG9pbnQgTVVTVCBzZW5kIGEgQ2xvc2UgZnJhbWUgaW4gcmVzcG9uc2UuICAoV2hlblxuICAgICAgICAgICAgLy8gc2VuZGluZyBhIENsb3NlIGZyYW1lIGluIHJlc3BvbnNlLCB0aGUgZW5kcG9pbnQgdHlwaWNhbGx5IGVjaG9zIHRoZVxuICAgICAgICAgICAgLy8gc3RhdHVzIGNvZGUgaXQgcmVjZWl2ZWQuKVxuICAgICAgICAgICAgY29uc3QgYm9keSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuICAgICAgICAgICAgYm9keS53cml0ZVVJbnQxNkJFKHRoaXMuI2luZm8uY2xvc2VJbmZvLmNvZGUsIDApXG4gICAgICAgICAgICBjb25zdCBjbG9zZUZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZChib2R5KVxuXG4gICAgICAgICAgICB0aGlzLndzW2tSZXNwb25zZV0uc29ja2V0LndyaXRlKFxuICAgICAgICAgICAgICBjbG9zZUZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQ0xPU0UpLFxuICAgICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMud3Nba1NlbnRDbG9zZV0gPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgICAgICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAgICAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgICAgICAgICB0aGlzLndzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG4gICAgICAgICAgdGhpcy53c1trUmVjZWl2ZWRDbG9zZV0gPSB0cnVlXG5cbiAgICAgICAgICB0aGlzLmVuZCgpXG5cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5QSU5HKSB7XG4gICAgICAgICAgLy8gVXBvbiByZWNlaXB0IG9mIGEgUGluZyBmcmFtZSwgYW4gZW5kcG9pbnQgTVVTVCBzZW5kIGEgUG9uZyBmcmFtZSBpblxuICAgICAgICAgIC8vIHJlc3BvbnNlLCB1bmxlc3MgaXQgYWxyZWFkeSByZWNlaXZlZCBhIENsb3NlIGZyYW1lLlxuICAgICAgICAgIC8vIEEgUG9uZyBmcmFtZSBzZW50IGluIHJlc3BvbnNlIHRvIGEgUGluZyBmcmFtZSBtdXN0IGhhdmUgaWRlbnRpY2FsXG4gICAgICAgICAgLy8gXCJBcHBsaWNhdGlvbiBkYXRhXCJcblxuICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmNvbnN1bWUocGF5bG9hZExlbmd0aClcblxuICAgICAgICAgIGlmICghdGhpcy53c1trUmVjZWl2ZWRDbG9zZV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZChib2R5KVxuXG4gICAgICAgICAgICB0aGlzLndzW2tSZXNwb25zZV0uc29ja2V0LndyaXRlKGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuUE9ORykpXG5cbiAgICAgICAgICAgIGlmIChjaGFubmVscy5waW5nLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgIGNoYW5uZWxzLnBpbmcucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogYm9keVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cblxuICAgICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuI2luZm8ub3Bjb2RlID09PSBvcGNvZGVzLlBPTkcpIHtcbiAgICAgICAgICAvLyBBIFBvbmcgZnJhbWUgTUFZIGJlIHNlbnQgdW5zb2xpY2l0ZWQuICBUaGlzIHNlcnZlcyBhcyBhXG4gICAgICAgICAgLy8gdW5pZGlyZWN0aW9uYWwgaGVhcnRiZWF0LiAgQSByZXNwb25zZSB0byBhbiB1bnNvbGljaXRlZCBQb25nIGZyYW1lIGlzXG4gICAgICAgICAgLy8gbm90IGV4cGVjdGVkLlxuXG4gICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuY29uc3VtZShwYXlsb2FkTGVuZ3RoKVxuXG4gICAgICAgICAgaWYgKGNoYW5uZWxzLnBvbmcuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIGNoYW5uZWxzLnBvbmcucHVibGlzaCh7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IGJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzE2KSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgMikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoMilcblxuICAgICAgICB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGggPSBidWZmZXIucmVhZFVJbnQxNkJFKDApXG4gICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlJFQURfREFUQVxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfNjQpIHtcbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCA4KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuY29uc3VtZSg4KVxuICAgICAgICBjb25zdCB1cHBlciA9IGJ1ZmZlci5yZWFkVUludDMyQkUoMClcblxuICAgICAgICAvLyAyXjMxIGlzIHRoZSBtYXhpbmltdW0gYnl0ZXMgYW4gYXJyYXlidWZmZXIgY2FuIGNvbnRhaW5cbiAgICAgICAgLy8gb24gMzItYml0IHN5c3RlbXMuIEFsdGhvdWdoLCBvbiA2NC1iaXQgc3lzdGVtcywgdGhpcyBpc1xuICAgICAgICAvLyAyXjUzLTEgYnl0ZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9JbnZhbGlkX2FycmF5X2xlbmd0aFxuICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp2OC9zcmMvY29tbW9uL2dsb2JhbHMuaDtkcmM9MTk0NjIxMmFjMDEwMDY2OGYxNGViOWUyODQzYmRkODQ2ZTUxMGExZTticHY9MTticHQ9MTtsPTEyNzVcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46djgvc3JjL29iamVjdHMvanMtYXJyYXktYnVmZmVyLmg7bD0zNDtkcmM9MTk0NjIxMmFjMDEwMDY2OGYxNGViOWUyODQzYmRkODQ2ZTUxMGExZVxuICAgICAgICBpZiAodXBwZXIgPiAyICoqIDMxIC0gMSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdSZWNlaXZlZCBwYXlsb2FkIGxlbmd0aCA+IDJeMzEgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvd2VyID0gYnVmZmVyLnJlYWRVSW50MzJCRSg0KVxuXG4gICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9ICh1cHBlciA8PCA4KSArIGxvd2VyXG4gICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlJFQURfREFUQVxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlJFQURfREFUQSkge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIHN0aWxsIG1vcmUgZGF0YSBpbiB0aGlzIGNodW5rIHRoYXQgbmVlZHMgdG8gYmUgcmVhZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy4jYnl0ZU9mZnNldCA+PSB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHNlbnQgbXVsdGlwbGUgZnJhbWVzIGluIGEgc2luZ2xlIGNodW5rXG5cbiAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5jb25zdW1lKHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aClcblxuICAgICAgICAgIHRoaXMuI2ZyYWdtZW50cy5wdXNoKGJvZHkpXG5cbiAgICAgICAgICAvLyBJZiB0aGUgZnJhbWUgaXMgdW5mcmFnbWVudGVkLCBvciBhIGZyYWdtZW50ZWQgZnJhbWUgd2FzIHRlcm1pbmF0ZWQsXG4gICAgICAgICAgLy8gYSBtZXNzYWdlIHdhcyByZWNlaXZlZFxuICAgICAgICAgIGlmICghdGhpcy4jaW5mby5mcmFnbWVudGVkIHx8ICh0aGlzLiNpbmZvLmZpbiAmJiB0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5DT05USU5VQVRJT04pKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQodGhpcy4jZnJhZ21lbnRzKVxuXG4gICAgICAgICAgICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQodGhpcy53cywgdGhpcy4jaW5mby5vcmlnaW5hbE9wY29kZSwgZnVsbE1lc3NhZ2UpXG5cbiAgICAgICAgICAgIHRoaXMuI2luZm8gPSB7fVxuICAgICAgICAgICAgdGhpcy4jZnJhZ21lbnRzLmxlbmd0aCA9IDBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPiAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgbiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBCdWZmZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ8bnVsbH1cbiAgICovXG4gIGNvbnN1bWUgKG4pIHtcbiAgICBpZiAobiA+IHRoaXMuI2J5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gZW1wdHlCdWZmZXJcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jYnVmZmVyc1swXS5sZW5ndGggPT09IG4pIHtcbiAgICAgIHRoaXMuI2J5dGVPZmZzZXQgLT0gdGhpcy4jYnVmZmVyc1swXS5sZW5ndGhcbiAgICAgIHJldHVybiB0aGlzLiNidWZmZXJzLnNoaWZ0KClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgd2hpbGUgKG9mZnNldCAhPT0gbikge1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMuI2J1ZmZlcnNbMF1cbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBuZXh0XG5cbiAgICAgIGlmIChsZW5ndGggKyBvZmZzZXQgPT09IG4pIHtcbiAgICAgICAgYnVmZmVyLnNldCh0aGlzLiNidWZmZXJzLnNoaWZ0KCksIG9mZnNldClcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gbikge1xuICAgICAgICBidWZmZXIuc2V0KG5leHQuc3ViYXJyYXkoMCwgbiAtIG9mZnNldCksIG9mZnNldClcbiAgICAgICAgdGhpcy4jYnVmZmVyc1swXSA9IG5leHQuc3ViYXJyYXkobiAtIG9mZnNldClcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5zZXQodGhpcy4jYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBuZXh0Lmxlbmd0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuI2J5dGVPZmZzZXQgLT0gblxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgcGFyc2VDbG9zZUJvZHkgKG9ubHlDb2RlLCBkYXRhKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy4xLjVcbiAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgbGV0IGNvZGVcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+PSAyKSB7XG4gICAgICAvLyBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzXG4gICAgICAvLyBkZWZpbmVkIGFzIHRoZSBzdGF0dXMgY29kZSAoU2VjdGlvbiA3LjQpIGNvbnRhaW5lZCBpbiB0aGUgZmlyc3QgQ2xvc2VcbiAgICAgIC8vIGNvbnRyb2wgZnJhbWUgcmVjZWl2ZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gICAgICBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMClcbiAgICB9XG5cbiAgICBpZiAob25seUNvZGUpIHtcbiAgICAgIGlmICghaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgY29kZSB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy4xLjZcbiAgICAvKiogQHR5cGUge0J1ZmZlcn0gKi9cbiAgICBsZXQgcmVhc29uID0gZGF0YS5zdWJhcnJheSgyKVxuXG4gICAgLy8gUmVtb3ZlIEJPTVxuICAgIGlmIChyZWFzb25bMF0gPT09IDB4RUYgJiYgcmVhc29uWzFdID09PSAweEJCICYmIHJlYXNvblsyXSA9PT0gMHhCRikge1xuICAgICAgcmVhc29uID0gcmVhc29uLnN1YmFycmF5KDMpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXNcbiAgICAgIHJlYXNvbiA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlIH0pLmRlY29kZShyZWFzb24pXG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB7IGNvZGUsIHJlYXNvbiB9XG4gIH1cblxuICBnZXQgY2xvc2luZ0luZm8gKCkge1xuICAgIHJldHVybiB0aGlzLiNpbmZvLmNsb3NlSW5mb1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCeXRlUGFyc2VyXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/websocket/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/websocket/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/websocket/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kWebSocketURL: Symbol('url'),\n  kReadyState: Symbol('ready state'),\n  kController: Symbol('controller'),\n  kResponse: Symbol('response'),\n  kBinaryType: Symbol('binary type'),\n  kSentClose: Symbol('sent close'),\n  kReceivedClose: Symbol('received close'),\n  kByteParser: Symbol('byte parser')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC9zeW1ib2xzLmpzPzBhZmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrV2ViU29ja2V0VVJMOiBTeW1ib2woJ3VybCcpLFxuICBrUmVhZHlTdGF0ZTogU3ltYm9sKCdyZWFkeSBzdGF0ZScpLFxuICBrQ29udHJvbGxlcjogU3ltYm9sKCdjb250cm9sbGVyJyksXG4gIGtSZXNwb25zZTogU3ltYm9sKCdyZXNwb25zZScpLFxuICBrQmluYXJ5VHlwZTogU3ltYm9sKCdiaW5hcnkgdHlwZScpLFxuICBrU2VudENsb3NlOiBTeW1ib2woJ3NlbnQgY2xvc2UnKSxcbiAga1JlY2VpdmVkQ2xvc2U6IFN5bWJvbCgncmVjZWl2ZWQgY2xvc2UnKSxcbiAga0J5dGVQYXJzZXI6IFN5bWJvbCgnYnl0ZSBwYXJzZXInKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/websocket/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/websocket/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/websocket/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/websocket/symbols.js\")\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/websocket/constants.js\")\nconst { MessageEvent, ErrorEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/websocket/events.js\")\n\n/* globals Blob */\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isEstablished (ws) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return ws[kReadyState] === states.OPEN\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isClosing (ws) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return ws[kReadyState] === states.CLOSING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isClosed (ws) {\n  return ws[kReadyState] === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {EventInit | undefined} eventInitDict\n */\nfunction fireEvent (e, target, eventConstructor = Event, eventInitDict) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize events type attribute to e.\n  const event = new eventConstructor(e, eventInitDict) // eslint-disable-line new-cap\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */\nfunction websocketMessageReceived (ws, type, data) {\n  // 1. If ready state is not OPEN (1), then return.\n  if (ws[kReadyState] !== states.OPEN) {\n    return\n  }\n\n  // 2. Let dataForEvent be determined by switching on type and binary type:\n  let dataForEvent\n\n  if (type === opcodes.TEXT) {\n    // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n      dataForEvent = new TextDecoder('utf-8', { fatal: true }).decode(data)\n    } catch {\n      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.')\n      return\n    }\n  } else if (type === opcodes.BINARY) {\n    if (ws[kBinaryType] === 'blob') {\n      // -> type indicates that the data is Binary and binary type is \"blob\"\n      //      a new Blob object, created in the relevant Realm of the WebSocket\n      //      object, that represents data as its raw data\n      dataForEvent = new Blob([data])\n    } else {\n      // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n      //      a new ArrayBuffer object, created in the relevant Realm of the\n      //      WebSocket object, whose contents are data\n      dataForEvent = new Uint8Array(data).buffer\n    }\n  }\n\n  // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n  //    with the origin attribute initialized to the serialization of the WebSocket\n  //    objects url's origin, and the data attribute initialized to dataForEvent.\n  fireEvent('message', ws, MessageEvent, {\n    origin: ws[kWebSocketURL].origin,\n    data: dataForEvent\n  })\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (const char of protocol) {\n    const code = char.charCodeAt(0)\n\n    if (\n      code < 0x21 ||\n      code > 0x7E ||\n      char === '(' ||\n      char === ')' ||\n      char === '<' ||\n      char === '>' ||\n      char === '@' ||\n      char === ',' ||\n      char === ';' ||\n      char === ':' ||\n      char === '\\\\' ||\n      char === '\"' ||\n      char === '/' ||\n      char === '[' ||\n      char === ']' ||\n      char === '?' ||\n      char === '=' ||\n      char === '{' ||\n      char === '}' ||\n      code === 32 || // SP\n      code === 9 // HT\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */\nfunction failWebsocketConnection (ws, reason) {\n  const { [kController]: controller, [kResponse]: response } = ws\n\n  controller.abort()\n\n  if (response?.socket && !response.socket.destroyed) {\n    response.socket.destroy()\n  }\n\n  if (reason) {\n    fireEvent('error', ws, ErrorEvent, {\n      error: new Error(reason)\n    })\n  }\n}\n\nmodule.exports = {\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGtFQUFrRSxFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDL0YsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLDJFQUFhO0FBQ2pELFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVTs7QUFFdkQ7O0FBRUE7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSxtREFBbUQ7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpdHN0cmVhay1mb3JnZS8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC91dGlsLmpzPzMxNzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga1JlYWR5U3RhdGUsIGtDb250cm9sbGVyLCBrUmVzcG9uc2UsIGtCaW5hcnlUeXBlLCBrV2ViU29ja2V0VVJMIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBzdGF0ZXMsIG9wY29kZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgTWVzc2FnZUV2ZW50LCBFcnJvckV2ZW50IH0gPSByZXF1aXJlKCcuL2V2ZW50cycpXG5cbi8qIGdsb2JhbHMgQmxvYiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqL1xuZnVuY3Rpb24gaXNFc3RhYmxpc2hlZCAod3MpIHtcbiAgLy8gSWYgdGhlIHNlcnZlcidzIHJlc3BvbnNlIGlzIHZhbGlkYXRlZCBhcyBwcm92aWRlZCBmb3IgYWJvdmUsIGl0IGlzXG4gIC8vIHNhaWQgdGhhdCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIGlzIEVzdGFibGlzaGVkXyBhbmQgdGhhdCB0aGVcbiAgLy8gV2ViU29ja2V0IENvbm5lY3Rpb24gaXMgaW4gdGhlIE9QRU4gc3RhdGUuXG4gIHJldHVybiB3c1trUmVhZHlTdGF0ZV0gPT09IHN0YXRlcy5PUEVOXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICovXG5mdW5jdGlvbiBpc0Nsb3NpbmcgKHdzKSB7XG4gIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENsb3NpbmcgSGFuZHNoYWtlIGlzIFN0YXJ0ZWRfIGFuZCB0aGF0IHRoZVxuICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLkNMT1NJTkdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvc2VkICh3cykge1xuICByZXR1cm4gd3Nba1JlYWR5U3RhdGVdID09PSBzdGF0ZXMuQ0xPU0VEXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZXZlbnQtZmlyZVxuICogQHBhcmFtIHtzdHJpbmd9IGVcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtFdmVudEluaXQgfCB1bmRlZmluZWR9IGV2ZW50SW5pdERpY3RcbiAqL1xuZnVuY3Rpb24gZmlyZUV2ZW50IChlLCB0YXJnZXQsIGV2ZW50Q29uc3RydWN0b3IgPSBFdmVudCwgZXZlbnRJbml0RGljdCkge1xuICAvLyAxLiBJZiBldmVudENvbnN0cnVjdG9yIGlzIG5vdCBnaXZlbiwgdGhlbiBsZXQgZXZlbnRDb25zdHJ1Y3RvciBiZSBFdmVudC5cblxuICAvLyAyLiBMZXQgZXZlbnQgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBldmVudCBnaXZlbiBldmVudENvbnN0cnVjdG9yLFxuICAvLyAgICBpbiB0aGUgcmVsZXZhbnQgcmVhbG0gb2YgdGFyZ2V0LlxuICAvLyAzLiBJbml0aWFsaXplIGV2ZW504oCZcyB0eXBlIGF0dHJpYnV0ZSB0byBlLlxuICBjb25zdCBldmVudCA9IG5ldyBldmVudENvbnN0cnVjdG9yKGUsIGV2ZW50SW5pdERpY3QpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXG4gIC8vIDQuIEluaXRpYWxpemUgYW55IG90aGVyIElETCBhdHRyaWJ1dGVzIG9mIGV2ZW50IGFzIGRlc2NyaWJlZCBpbiB0aGVcbiAgLy8gICAgaW52b2NhdGlvbiBvZiB0aGlzIGFsZ29yaXRobS5cblxuICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBkaXNwYXRjaGluZyBldmVudCBhdCB0YXJnZXQsIHdpdGggbGVnYWN5IHRhcmdldFxuICAvLyAgICBvdmVycmlkZSBmbGFnIHNldCBpZiBzZXQuXG4gIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZmVlZGJhY2stZnJvbS10aGUtcHJvdG9jb2xcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIE9wY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgYXBwbGljYXRpb24gZGF0YVxuICovXG5mdW5jdGlvbiB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQgKHdzLCB0eXBlLCBkYXRhKSB7XG4gIC8vIDEuIElmIHJlYWR5IHN0YXRlIGlzIG5vdCBPUEVOICgxKSwgdGhlbiByZXR1cm4uXG4gIGlmICh3c1trUmVhZHlTdGF0ZV0gIT09IHN0YXRlcy5PUEVOKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyAyLiBMZXQgZGF0YUZvckV2ZW50IGJlIGRldGVybWluZWQgYnkgc3dpdGNoaW5nIG9uIHR5cGUgYW5kIGJpbmFyeSB0eXBlOlxuICBsZXQgZGF0YUZvckV2ZW50XG5cbiAgaWYgKHR5cGUgPT09IG9wY29kZXMuVEVYVCkge1xuICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgVGV4dFxuICAgIC8vICAgICAgYSBuZXcgRE9NU3RyaW5nIGNvbnRhaW5pbmcgZGF0YVxuICAgIHRyeSB7XG4gICAgICBkYXRhRm9yRXZlbnQgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSB9KS5kZWNvZGUoZGF0YSlcbiAgICB9IGNhdGNoIHtcbiAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUmVjZWl2ZWQgaW52YWxpZCBVVEYtOCBpbiB0ZXh0IGZyYW1lLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gb3Bjb2Rlcy5CSU5BUlkpIHtcbiAgICBpZiAod3Nba0JpbmFyeVR5cGVdID09PSAnYmxvYicpIHtcbiAgICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgQmluYXJ5IGFuZCBiaW5hcnkgdHlwZSBpcyBcImJsb2JcIlxuICAgICAgLy8gICAgICBhIG5ldyBCbG9iIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgICBvYmplY3QsIHRoYXQgcmVwcmVzZW50cyBkYXRhIGFzIGl0cyByYXcgZGF0YVxuICAgICAgZGF0YUZvckV2ZW50ID0gbmV3IEJsb2IoW2RhdGFdKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIEJpbmFyeSBhbmQgYmluYXJ5IHR5cGUgaXMgXCJhcnJheWJ1ZmZlclwiXG4gICAgICAvLyAgICAgIGEgbmV3IEFycmF5QnVmZmVyIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlXG4gICAgICAvLyAgICAgIFdlYlNvY2tldCBvYmplY3QsIHdob3NlIGNvbnRlbnRzIGFyZSBkYXRhXG4gICAgICBkYXRhRm9yRXZlbnQgPSBuZXcgVWludDhBcnJheShkYXRhKS5idWZmZXJcbiAgICB9XG4gIH1cblxuICAvLyAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIG1lc3NhZ2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsIHVzaW5nIE1lc3NhZ2VFdmVudCxcbiAgLy8gICAgd2l0aCB0aGUgb3JpZ2luIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byB0aGUgc2VyaWFsaXphdGlvbiBvZiB0aGUgV2ViU29ja2V0XG4gIC8vICAgIG9iamVjdOKAmXMgdXJsJ3Mgb3JpZ2luLCBhbmQgdGhlIGRhdGEgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIGRhdGFGb3JFdmVudC5cbiAgZmlyZUV2ZW50KCdtZXNzYWdlJywgd3MsIE1lc3NhZ2VFdmVudCwge1xuICAgIG9yaWdpbjogd3Nba1dlYlNvY2tldFVSTF0ub3JpZ2luLFxuICAgIGRhdGE6IGRhdGFGb3JFdmVudFxuICB9KVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1XG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMjYxNlxuICogQHNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zOTg0MDdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3VicHJvdG9jb2wgKHByb3RvY29sKSB7XG4gIC8vIElmIHByZXNlbnQsIHRoaXMgdmFsdWUgaW5kaWNhdGVzIG9uZVxuICAvLyBvciBtb3JlIGNvbW1hLXNlcGFyYXRlZCBzdWJwcm90b2NvbCB0aGUgY2xpZW50IHdpc2hlcyB0byBzcGVhayxcbiAgLy8gb3JkZXJlZCBieSBwcmVmZXJlbmNlLiAgVGhlIGVsZW1lbnRzIHRoYXQgY29tcHJpc2UgdGhpcyB2YWx1ZVxuICAvLyBNVVNUIGJlIG5vbi1lbXB0eSBzdHJpbmdzIHdpdGggY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgVSswMDIxIHRvXG4gIC8vIFUrMDA3RSBub3QgaW5jbHVkaW5nIHNlcGFyYXRvciBjaGFyYWN0ZXJzIGFzIGRlZmluZWQgaW5cbiAgLy8gW1JGQzI2MTZdIGFuZCBNVVNUIGFsbCBiZSB1bmlxdWUgc3RyaW5ncy5cbiAgaWYgKHByb3RvY29sLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjaGFyIG9mIHByb3RvY29sKSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHxcbiAgICAgIGNvZGUgPiAweDdFIHx8XG4gICAgICBjaGFyID09PSAnKCcgfHxcbiAgICAgIGNoYXIgPT09ICcpJyB8fFxuICAgICAgY2hhciA9PT0gJzwnIHx8XG4gICAgICBjaGFyID09PSAnPicgfHxcbiAgICAgIGNoYXIgPT09ICdAJyB8fFxuICAgICAgY2hhciA9PT0gJywnIHx8XG4gICAgICBjaGFyID09PSAnOycgfHxcbiAgICAgIGNoYXIgPT09ICc6JyB8fFxuICAgICAgY2hhciA9PT0gJ1xcXFwnIHx8XG4gICAgICBjaGFyID09PSAnXCInIHx8XG4gICAgICBjaGFyID09PSAnLycgfHxcbiAgICAgIGNoYXIgPT09ICdbJyB8fFxuICAgICAgY2hhciA9PT0gJ10nIHx8XG4gICAgICBjaGFyID09PSAnPycgfHxcbiAgICAgIGNoYXIgPT09ICc9JyB8fFxuICAgICAgY2hhciA9PT0gJ3snIHx8XG4gICAgICBjaGFyID09PSAnfScgfHxcbiAgICAgIGNvZGUgPT09IDMyIHx8IC8vIFNQXG4gICAgICBjb2RlID09PSA5IC8vIEhUXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy00XG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZSAoY29kZSkge1xuICBpZiAoY29kZSA+PSAxMDAwICYmIGNvZGUgPCAxMDE1KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNvZGUgIT09IDEwMDQgJiYgLy8gcmVzZXJ2ZWRcbiAgICAgIGNvZGUgIT09IDEwMDUgJiYgLy8gXCJNVVNUIE5PVCBiZSBzZXQgYXMgYSBzdGF0dXMgY29kZVwiXG4gICAgICBjb2RlICE9PSAxMDA2IC8vIFwiTVVTVCBOT1QgYmUgc2V0IGFzIGEgc3RhdHVzIGNvZGVcIlxuICAgIClcbiAgfVxuXG4gIHJldHVybiBjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSByZWFzb25cbiAqL1xuZnVuY3Rpb24gZmFpbFdlYnNvY2tldENvbm5lY3Rpb24gKHdzLCByZWFzb24pIHtcbiAgY29uc3QgeyBba0NvbnRyb2xsZXJdOiBjb250cm9sbGVyLCBba1Jlc3BvbnNlXTogcmVzcG9uc2UgfSA9IHdzXG5cbiAgY29udHJvbGxlci5hYm9ydCgpXG5cbiAgaWYgKHJlc3BvbnNlPy5zb2NrZXQgJiYgIXJlc3BvbnNlLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICByZXNwb25zZS5zb2NrZXQuZGVzdHJveSgpXG4gIH1cblxuICBpZiAocmVhc29uKSB7XG4gICAgZmlyZUV2ZW50KCdlcnJvcicsIHdzLCBFcnJvckV2ZW50LCB7XG4gICAgICBlcnJvcjogbmV3IEVycm9yKHJlYXNvbilcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0VzdGFibGlzaGVkLFxuICBpc0Nsb3NpbmcsXG4gIGlzQ2xvc2VkLFxuICBmaXJlRXZlbnQsXG4gIGlzVmFsaWRTdWJwcm90b2NvbCxcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLFxuICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/websocket/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/websocket/websocket.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/websocket/websocket.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/fetch/webidl.js\")\nconst { DOMException } = __webpack_require__(/*! ../fetch/constants */ \"(ssr)/./node_modules/undici/lib/fetch/constants.js\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/dataURL */ \"(ssr)/./node_modules/undici/lib/fetch/dataURL.js\")\nconst { getGlobalOrigin } = __webpack_require__(/*! ../fetch/global */ \"(ssr)/./node_modules/undici/lib/fetch/global.js\")\nconst { staticPropertyDescriptors, states, opcodes, emptyBuffer } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/websocket/constants.js\")\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/websocket/symbols.js\")\nconst { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/websocket/util.js\")\nconst { establishWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/undici/lib/websocket/connection.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/websocket/frame.js\")\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/undici/lib/websocket/receiver.js\")\nconst { kEnumerableProperty, isBlobLike } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(ssr)/./node_modules/undici/lib/global.js\")\nconst { types } = __webpack_require__(/*! util */ \"util\")\n\nlet experimentalWarned = false\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' })\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {\n        code: 'UNDICI-WS'\n      })\n    }\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols)\n\n    url = webidl.converters.USVString(url)\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = getGlobalOrigin()\n\n    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n    let urlRecord\n\n    try {\n      urlRecord = new URL(url, baseURL)\n    } catch (e) {\n      // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 4. If urlRecords scheme is \"http\", then set urlRecords scheme to \"ws\".\n    if (urlRecord.protocol === 'http:') {\n      urlRecord.protocol = 'ws:'\n    } else if (urlRecord.protocol === 'https:') {\n      // 5. Otherwise, if urlRecords scheme is \"https\", set urlRecords scheme to \"wss\".\n      urlRecord.protocol = 'wss:'\n    }\n\n    // 6. If urlRecords scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(\n        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\n        'SyntaxError'\n      )\n    }\n\n    // 7. If urlRecords fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n      throw new DOMException('Got fragment', 'SyntaxError')\n    }\n\n    // 8. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 9. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 10. Set this's url to urlRecord.\n    this[kWebSocketURL] = new URL(urlRecord.href)\n\n    // 11. Let client be this's relevant settings object.\n\n    // 12. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      this,\n      (response) => this.#onConnectionEstablished(response),\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason)\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError')\n      }\n    }\n\n    let reasonByteLength = 0\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason)\n\n      if (reasonByteLength > 123) {\n        throw new DOMException(\n          `Reason must be less than 123 bytes; received ${reasonByteLength}`,\n          'SyntaxError'\n        )\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n      // If this's ready state is CLOSING (2) or CLOSED (3)\n      // Do nothing.\n    } else if (!isEstablished(this)) {\n      // If the WebSocket connection is not yet established\n      // Fail the WebSocket connection and set this's ready state\n      // to CLOSING (2).\n      failWebsocketConnection(this, 'Connection was closed before it was established.')\n      this[kReadyState] = WebSocket.CLOSING\n    } else if (!isClosing(this)) {\n      // If the WebSocket closing handshake has not yet been started\n      // Start the WebSocket closing handshake and set this's ready\n      // state to CLOSING (2).\n      // - If neither code nor reason is present, the WebSocket Close\n      //   message must not have a body.\n      // - If code is present, then the status code to use in the\n      //   WebSocket Close message must be the integer given by code.\n      // - If reason is also present, then reasonBytes must be\n      //   provided in the Close message after the status code.\n\n      const frame = new WebsocketFrameSend()\n\n      // If neither code nor reason is present, the WebSocket Close\n      // message must not have a body.\n\n      // If code is present, then the status code to use in the\n      // WebSocket Close message must be the integer given by code.\n      if (code !== undefined && reason === undefined) {\n        frame.frameData = Buffer.allocUnsafe(2)\n        frame.frameData.writeUInt16BE(code, 0)\n      } else if (code !== undefined && reason !== undefined) {\n        // If reason is also present, then reasonBytes must be\n        // provided in the Close message after the status code.\n        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)\n        frame.frameData.writeUInt16BE(code, 0)\n        // the body MAY contain UTF-8-encoded data with value /reason/\n        frame.frameData.write(reason, 2, 'utf-8')\n      } else {\n        frame.frameData = emptyBuffer\n      }\n\n      /** @type {import('stream').Duplex} */\n      const socket = this[kResponse].socket\n\n      socket.write(frame.createFrame(opcodes.CLOSE), (err) => {\n        if (!err) {\n          this[kSentClose] = true\n        }\n      })\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this[kReadyState] = states.CLOSING\n    } else {\n      // Otherwise\n      // Set this's ready state to CLOSING (2).\n      this[kReadyState] = WebSocket.CLOSING\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' })\n\n    data = webidl.converters.WebSocketSendData(data)\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (this[kReadyState] === WebSocket.CONNECTING) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = this[kResponse].socket\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.TEXT)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of datas buffer in bytes.\n\n      const ab = Buffer.from(data, data.byteOffset, data.byteLength)\n\n      const frame = new WebsocketFrameSend(ab)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += ab.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= ab.byteLength\n      })\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob objects raw data, in bytes.\n\n      const frame = new WebsocketFrameSend()\n\n      data.arrayBuffer().then((ab) => {\n        const value = Buffer.from(ab)\n        frame.frameData = value\n        const buffer = frame.createFrame(opcodes.BINARY)\n\n        this.#bufferedAmount += value.byteLength\n        socket.write(buffer, () => {\n          this.#bufferedAmount -= value.byteLength\n        })\n      })\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState]\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL])\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kBinaryType]\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob'\n    } else {\n      this[kBinaryType] = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response) {\n    // processResponse is called when the \"responses header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response\n\n    const parser = new ByteParser(this)\n    parser.on('drain', function onParserDrain () {\n      this.ws[kResponse].socket.resume()\n    })\n\n    response.socket.ws = this\n    this[kByteParser] = parser\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN\n\n    // 2. Change the extensions attributes value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attributes value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    get defaultValue () {\n      return []\n    }\n  },\n  {\n    key: 'dispatcher',\n    converter: (V) => V,\n    get defaultValue () {\n      return getGlobalDispatcher()\n    }\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V)\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nmodule.exports = {\n  WebSocket\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQzVDLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQ3JELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwRUFBa0I7QUFDcEQsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUNyRCxRQUFRLDBEQUEwRCxFQUFFLG1CQUFPLENBQUMsMkVBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQ3ZCLFFBQVEsbUZBQW1GLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUM3RyxRQUFRLCtCQUErQixFQUFFLG1CQUFPLENBQUMsNkVBQWM7QUFDL0QsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLG1FQUFTO0FBQ2hELFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDM0MsUUFBUSxrQ0FBa0MsRUFBRSxtQkFBTyxDQUFDLGtFQUFjO0FBQ2xFLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyw0REFBVztBQUNuRCxRQUFRLFFBQVEsRUFBRSxtQkFBTyxDQUFDLGtCQUFNOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGlDQUFpQzs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7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TTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGVBQWU7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maXRzdHJlYWstZm9yZ2UvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvd2Vic29ja2V0LmpzPzlhZDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBET01FeGNlcHRpb24gfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2NvbnN0YW50cycpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGFVUkwnKVxuY29uc3QgeyBnZXRHbG9iYWxPcmlnaW4gfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2dsb2JhbCcpXG5jb25zdCB7IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsIHN0YXRlcywgb3Bjb2RlcywgZW1wdHlCdWZmZXIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHtcbiAga1dlYlNvY2tldFVSTCxcbiAga1JlYWR5U3RhdGUsXG4gIGtDb250cm9sbGVyLFxuICBrQmluYXJ5VHlwZSxcbiAga1Jlc3BvbnNlLFxuICBrU2VudENsb3NlLFxuICBrQnl0ZVBhcnNlclxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGlzRXN0YWJsaXNoZWQsIGlzQ2xvc2luZywgaXNWYWxpZFN1YnByb3RvY29sLCBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiwgZmlyZUV2ZW50IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKVxuY29uc3QgeyBXZWJzb2NrZXRGcmFtZVNlbmQgfSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuY29uc3QgeyBCeXRlUGFyc2VyIH0gPSByZXF1aXJlKCcuL3JlY2VpdmVyJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSwgaXNCbG9iTGlrZSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vZ2xvYmFsJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5sZXQgZXhwZXJpbWVudGFsV2FybmVkID0gZmFsc2VcblxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWRlZmluaXRpb25cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgI2V2ZW50cyA9IHtcbiAgICBvcGVuOiBudWxsLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGNsb3NlOiBudWxsLFxuICAgIG1lc3NhZ2U6IG51bGxcbiAgfVxuXG4gICNidWZmZXJlZEFtb3VudCA9IDBcbiAgI3Byb3RvY29sID0gJydcbiAgI2V4dGVuc2lvbnMgPSAnJ1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwcm90b2NvbHNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIHByb3RvY29scyA9IFtdKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ1dlYlNvY2tldCBjb25zdHJ1Y3RvcicgfSlcblxuICAgIGlmICghZXhwZXJpbWVudGFsV2FybmVkKSB7XG4gICAgICBleHBlcmltZW50YWxXYXJuZWQgPSB0cnVlXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdXZWJTb2NrZXRzIGFyZSBleHBlcmltZW50YWwsIGV4cGVjdCB0aGVtIHRvIGNoYW5nZSBhdCBhbnkgdGltZS4nLCB7XG4gICAgICAgIGNvZGU6ICdVTkRJQ0ktV1MnXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4gb3IgV2ViU29ja2V0SW5pdCddKHByb3RvY29scylcblxuICAgIHVybCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh1cmwpXG4gICAgcHJvdG9jb2xzID0gb3B0aW9ucy5wcm90b2NvbHNcblxuICAgIC8vIDEuIExldCBiYXNlVVJMIGJlIHRoaXMncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QncyBBUEkgYmFzZSBVUkwuXG4gICAgY29uc3QgYmFzZVVSTCA9IGdldEdsb2JhbE9yaWdpbigpXG5cbiAgICAvLyAxLiBMZXQgdXJsUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIFVSTCBwYXJzZXIgdG8gdXJsIHdpdGggYmFzZVVSTC5cbiAgICBsZXQgdXJsUmVjb3JkXG5cbiAgICB0cnkge1xuICAgICAgdXJsUmVjb3JkID0gbmV3IFVSTCh1cmwsIGJhc2VVUkwpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gMy4gSWYgdXJsUmVjb3JkIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihlLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDQuIElmIHVybFJlY29yZOKAmXMgc2NoZW1lIGlzIFwiaHR0cFwiLCB0aGVuIHNldCB1cmxSZWNvcmTigJlzIHNjaGVtZSB0byBcIndzXCIuXG4gICAgaWYgKHVybFJlY29yZC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgICAgdXJsUmVjb3JkLnByb3RvY29sID0gJ3dzOidcbiAgICB9IGVsc2UgaWYgKHVybFJlY29yZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgaXMgXCJodHRwc1wiLCBzZXQgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgdG8gXCJ3c3NcIi5cbiAgICAgIHVybFJlY29yZC5wcm90b2NvbCA9ICd3c3M6J1xuICAgIH1cblxuICAgIC8vIDYuIElmIHVybFJlY29yZOKAmXMgc2NoZW1lIGlzIG5vdCBcIndzXCIgb3IgXCJ3c3NcIiwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKHVybFJlY29yZC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgdXJsUmVjb3JkLnByb3RvY29sICE9PSAnd3NzOicpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgIGBFeHBlY3RlZCBhIHdzOiBvciB3c3M6IHByb3RvY29sLCBnb3QgJHt1cmxSZWNvcmQucHJvdG9jb2x9YCxcbiAgICAgICAgJ1N5bnRheEVycm9yJ1xuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDcuIElmIHVybFJlY29yZOKAmXMgZnJhZ21lbnQgaXMgbm9uLW51bGwsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCJcbiAgICAvLyAgICBET01FeGNlcHRpb24uXG4gICAgaWYgKHVybFJlY29yZC5oYXNoIHx8IHVybFJlY29yZC5ocmVmLmVuZHNXaXRoKCcjJykpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0dvdCBmcmFnbWVudCcsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gOC4gSWYgcHJvdG9jb2xzIGlzIGEgc3RyaW5nLCBzZXQgcHJvdG9jb2xzIHRvIGEgc2VxdWVuY2UgY29uc2lzdGluZ1xuICAgIC8vICAgIG9mIGp1c3QgdGhhdCBzdHJpbmcuXG4gICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXVxuICAgIH1cblxuICAgIC8vIDkuIElmIGFueSBvZiB0aGUgdmFsdWVzIGluIHByb3RvY29scyBvY2N1ciBtb3JlIHRoYW4gb25jZSBvciBvdGhlcndpc2VcbiAgICAvLyAgICBmYWlsIHRvIG1hdGNoIHRoZSByZXF1aXJlbWVudHMgZm9yIGVsZW1lbnRzIHRoYXQgY29tcHJpc2UgdGhlIHZhbHVlXG4gICAgLy8gICAgb2YgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGZpZWxkcyBhcyBkZWZpbmVkIGJ5IFRoZSBXZWJTb2NrZXRcbiAgICAvLyAgICBwcm90b2NvbCwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKHByb3RvY29scy5sZW5ndGggIT09IG5ldyBTZXQocHJvdG9jb2xzLm1hcChwID0+IHAudG9Mb3dlckNhc2UoKSkpLnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCB2YWx1ZScsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgaWYgKHByb3RvY29scy5sZW5ndGggPiAwICYmICFwcm90b2NvbHMuZXZlcnkocCA9PiBpc1ZhbGlkU3VicHJvdG9jb2wocCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgdmFsdWUnLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDEwLiBTZXQgdGhpcydzIHVybCB0byB1cmxSZWNvcmQuXG4gICAgdGhpc1trV2ViU29ja2V0VVJMXSA9IG5ldyBVUkwodXJsUmVjb3JkLmhyZWYpXG5cbiAgICAvLyAxMS4gTGV0IGNsaWVudCBiZSB0aGlzJ3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0LlxuXG4gICAgLy8gMTIuIFJ1biB0aGlzIHN0ZXAgaW4gcGFyYWxsZWw6XG5cbiAgICAvLyAgICAxLiBFc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBnaXZlbiB1cmxSZWNvcmQsIHByb3RvY29scyxcbiAgICAvLyAgICAgICBhbmQgY2xpZW50LlxuICAgIHRoaXNba0NvbnRyb2xsZXJdID0gZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbihcbiAgICAgIHVybFJlY29yZCxcbiAgICAgIHByb3RvY29scyxcbiAgICAgIHRoaXMsXG4gICAgICAocmVzcG9uc2UpID0+IHRoaXMuI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkKHJlc3BvbnNlKSxcbiAgICAgIG9wdGlvbnNcbiAgICApXG5cbiAgICAvLyBFYWNoIFdlYlNvY2tldCBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgcmVhZHkgc3RhdGUsIHdoaWNoIGlzIGFcbiAgICAvLyBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbi4gSW5pdGlhbGx5IGl0IG11c3RcbiAgICAvLyBiZSBDT05ORUNUSU5HICgwKS5cbiAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IFdlYlNvY2tldC5DT05ORUNUSU5HXG5cbiAgICAvLyBUaGUgZXh0ZW5zaW9ucyBhdHRyaWJ1dGUgbXVzdCBpbml0aWFsbHkgcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAvLyBUaGUgcHJvdG9jb2wgYXR0cmlidXRlIG11c3QgaW5pdGlhbGx5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgLy8gRWFjaCBXZWJTb2NrZXQgb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIGJpbmFyeSB0eXBlLCB3aGljaCBpcyBhXG4gICAgLy8gQmluYXJ5VHlwZS4gSW5pdGlhbGx5IGl0IG11c3QgYmUgXCJibG9iXCIuXG4gICAgdGhpc1trQmluYXJ5VHlwZV0gPSAnYmxvYidcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2VcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcmVhc29uXG4gICAqL1xuICBjbG9zZSAoY29kZSA9IHVuZGVmaW5lZCwgcmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29kZSA9IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddKGNvZGUsIHsgY2xhbXA6IHRydWUgfSlcbiAgICB9XG5cbiAgICBpZiAocmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlYXNvbiA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhyZWFzb24pXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgY29kZSBpcyBwcmVzZW50LCBidXQgaXMgbmVpdGhlciBhbiBpbnRlZ2VyIGVxdWFsIHRvIDEwMDAgbm9yIGFuXG4gICAgLy8gICAgaW50ZWdlciBpbiB0aGUgcmFuZ2UgMzAwMCB0byA0OTk5LCBpbmNsdXNpdmUsIHRocm93IGFuXG4gICAgLy8gICAgXCJJbnZhbGlkQWNjZXNzRXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvZGUgIT09IDEwMDAgJiYgKGNvZGUgPCAzMDAwIHx8IGNvZGUgPiA0OTk5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdpbnZhbGlkIGNvZGUnLCAnSW52YWxpZEFjY2Vzc0Vycm9yJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVhc29uQnl0ZUxlbmd0aCA9IDBcblxuICAgIC8vIDIuIElmIHJlYXNvbiBpcyBwcmVzZW50LCB0aGVuIHJ1biB0aGVzZSBzdWJzdGVwczpcbiAgICBpZiAocmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCByZWFzb25CeXRlcyBiZSB0aGUgcmVzdWx0IG9mIGVuY29kaW5nIHJlYXNvbi5cbiAgICAgIC8vIDIuIElmIHJlYXNvbkJ5dGVzIGlzIGxvbmdlciB0aGFuIDEyMyBieXRlcywgdGhlbiB0aHJvdyBhXG4gICAgICAvLyAgICBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgICAgcmVhc29uQnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHJlYXNvbilcblxuICAgICAgaWYgKHJlYXNvbkJ5dGVMZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICBgUmVhc29uIG11c3QgYmUgbGVzcyB0aGFuIDEyMyBieXRlczsgcmVjZWl2ZWQgJHtyZWFzb25CeXRlTGVuZ3RofWAsXG4gICAgICAgICAgJ1N5bnRheEVycm9yJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMy4gUnVuIHRoZSBmaXJzdCBtYXRjaGluZyBzdGVwcyBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcbiAgICBpZiAodGhpc1trUmVhZHlTdGF0ZV0gPT09IFdlYlNvY2tldC5DTE9TSU5HIHx8IHRoaXNba1JlYWR5U3RhdGVdID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICAvLyBJZiB0aGlzJ3MgcmVhZHkgc3RhdGUgaXMgQ0xPU0lORyAoMikgb3IgQ0xPU0VEICgzKVxuICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9IGVsc2UgaWYgKCFpc0VzdGFibGlzaGVkKHRoaXMpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgbm90IHlldCBlc3RhYmxpc2hlZFxuICAgICAgLy8gRmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYW5kIHNldCB0aGlzJ3MgcmVhZHkgc3RhdGVcbiAgICAgIC8vIHRvIENMT1NJTkcgKDIpLlxuICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcywgJ0Nvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWZvcmUgaXQgd2FzIGVzdGFibGlzaGVkLicpXG4gICAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IFdlYlNvY2tldC5DTE9TSU5HXG4gICAgfSBlbHNlIGlmICghaXNDbG9zaW5nKHRoaXMpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IGJlZW4gc3RhcnRlZFxuICAgICAgLy8gU3RhcnQgdGhlIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSBhbmQgc2V0IHRoaXMncyByZWFkeVxuICAgICAgLy8gc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgICAvLyAtIElmIG5laXRoZXIgY29kZSBub3IgcmVhc29uIGlzIHByZXNlbnQsIHRoZSBXZWJTb2NrZXQgQ2xvc2VcbiAgICAgIC8vICAgbWVzc2FnZSBtdXN0IG5vdCBoYXZlIGEgYm9keS5cbiAgICAgIC8vIC0gSWYgY29kZSBpcyBwcmVzZW50LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlXG4gICAgICAvLyAgIFdlYlNvY2tldCBDbG9zZSBtZXNzYWdlIG11c3QgYmUgdGhlIGludGVnZXIgZ2l2ZW4gYnkgY29kZS5cbiAgICAgIC8vIC0gSWYgcmVhc29uIGlzIGFsc28gcHJlc2VudCwgdGhlbiByZWFzb25CeXRlcyBtdXN0IGJlXG4gICAgICAvLyAgIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cblxuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKClcblxuICAgICAgLy8gSWYgbmVpdGhlciBjb2RlIG5vciByZWFzb24gaXMgcHJlc2VudCwgdGhlIFdlYlNvY2tldCBDbG9zZVxuICAgICAgLy8gbWVzc2FnZSBtdXN0IG5vdCBoYXZlIGEgYm9keS5cblxuICAgICAgLy8gSWYgY29kZSBpcyBwcmVzZW50LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkICYmIHJlYXNvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuICAgICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgICAgfSBlbHNlIGlmIChjb2RlICE9PSB1bmRlZmluZWQgJiYgcmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgcmVhc29uIGlzIGFsc28gcHJlc2VudCwgdGhlbiByZWFzb25CeXRlcyBtdXN0IGJlXG4gICAgICAgIC8vIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cbiAgICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyByZWFzb25CeXRlTGVuZ3RoKVxuICAgICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgICAgICAvLyB0aGUgYm9keSBNQVkgY29udGFpbiBVVEYtOC1lbmNvZGVkIGRhdGEgd2l0aCB2YWx1ZSAvcmVhc29uL1xuICAgICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGUocmVhc29uLCAyLCAndXRmLTgnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhbWUuZnJhbWVEYXRhID0gZW1wdHlCdWZmZXJcbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJ3N0cmVhbScpLkR1cGxleH0gKi9cbiAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXNba1Jlc3BvbnNlXS5zb2NrZXRcblxuICAgICAgc29ja2V0LndyaXRlKGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQ0xPU0UpLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdGhpc1trU2VudENsb3NlXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENsb3NpbmcgSGFuZHNoYWtlIGlzIFN0YXJ0ZWRfIGFuZCB0aGF0IHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG4gICAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZVxuICAgICAgLy8gU2V0IHRoaXMncyByZWFkeSBzdGF0ZSB0byBDTE9TSU5HICgyKS5cbiAgICAgIHRoaXNba1JlYWR5U3RhdGVdID0gV2ViU29ja2V0LkNMT1NJTkdcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LXNlbmRcbiAgICogQHBhcmFtIHtOb2RlSlMuVHlwZWRBcnJheXxBcnJheUJ1ZmZlcnxCbG9ifHN0cmluZ30gZGF0YVxuICAgKi9cbiAgc2VuZCAoZGF0YSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdXZWJTb2NrZXQuc2VuZCcgfSlcblxuICAgIGRhdGEgPSB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRTZW5kRGF0YShkYXRhKVxuXG4gICAgLy8gMS4gSWYgdGhpcydzIHJlYWR5IHN0YXRlIGlzIENPTk5FQ1RJTkcsIHRoZW4gdGhyb3cgYW5cbiAgICAvLyAgICBcIkludmFsaWRTdGF0ZUVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmICh0aGlzW2tSZWFkeVN0YXRlXSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1NlbnQgYmVmb3JlIGNvbm5lY3RlZC4nLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICAgIH1cblxuICAgIC8vIDIuIFJ1biB0aGUgYXBwcm9wcmlhdGUgc2V0IG9mIHN0ZXBzIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTYuMVxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuMlxuXG4gICAgaWYgKCFpc0VzdGFibGlzaGVkKHRoaXMpIHx8IGlzQ2xvc2luZyh0aGlzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJ3N0cmVhbScpLkR1cGxleH0gKi9cbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzW2tSZXNwb25zZV0uc29ja2V0XG5cbiAgICAvLyBJZiBkYXRhIGlzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50XG4gICAgICAvLyBtdXN0IHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgdGhlIGRhdGEgYXJndW1lbnRcbiAgICAgIC8vIHVzaW5nIGEgdGV4dCBmcmFtZSBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuXG4gICAgICAvLyBiZWNhdXNlIGl0IHdvdWxkIG5lZWQgdG8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCxcbiAgICAgIC8vIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZyB0aGUgV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2VcbiAgICAgIC8vIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gQW55IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhXG4gICAgICAvLyBzdHJpbmcgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZVxuICAgICAgLy8gdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0b1xuICAgICAgLy8gZXhwcmVzcyB0aGUgYXJndW1lbnQgYXMgVVRGLTguXG5cbiAgICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCh2YWx1ZSlcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuVEVYVClcblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgc29ja2V0LndyaXRlKGJ1ZmZlciwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAodHlwZXMuaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkXG4gICAgICAvLyB0byBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWdcbiAgICAgIC8vIHRoZSBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICAvLyBUaGUgZGF0YSB0byBiZSBzZW50IGlzIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgYnVmZmVyIGRlc2NyaWJlZFxuICAgICAgLy8gYnkgdGhlIEFycmF5QnVmZmVyIG9iamVjdC4gQW55IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhblxuICAgICAgLy8gQXJyYXlCdWZmZXIgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdFxuICAgICAgLy8gaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgLy8gQXJyYXlCdWZmZXIgaW4gYnl0ZXMuXG5cbiAgICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCh2YWx1ZSlcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQklOQVJZKVxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICBzb2NrZXQud3JpdGUoYnVmZmVyLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0b1xuICAgICAgLy8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUaGVcbiAgICAgIC8vIGRhdGEgdG8gYmUgc2VudCBpcyB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIHNlY3Rpb24gb2YgdGhlIGJ1ZmZlclxuICAgICAgLy8gZGVzY3JpYmVkIGJ5IHRoZSBBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCBkYXRhIHJlZmVyZW5jZXMuIEFueVxuICAgICAgLy8gaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIHRoaXMga2luZCBvZiBhcmd1bWVudCB0aGF0IGRvZXNcbiAgICAgIC8vIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZSB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlXG4gICAgICAvLyBieSB0aGUgbGVuZ3RoIG9mIGRhdGHigJlzIGJ1ZmZlciBpbiBieXRlcy5cblxuICAgICAgY29uc3QgYWIgPSBCdWZmZXIuZnJvbShkYXRhLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aClcblxuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGFiKVxuICAgICAgY29uc3QgYnVmZmVyID0gZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5CSU5BUlkpXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IGFiLmJ5dGVMZW5ndGhcbiAgICAgIHNvY2tldC53cml0ZShidWZmZXIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gYWIuYnl0ZUxlbmd0aFxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0b1xuICAgICAgLy8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUaGUgZGF0YVxuICAgICAgLy8gdG8gYmUgc2VudCBpcyB0aGUgcmF3IGRhdGEgcmVwcmVzZW50ZWQgYnkgdGhlIEJsb2Igb2JqZWN0LiBBbnlcbiAgICAgIC8vIGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhIEJsb2IgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvd1xuICAgICAgLy8gYW4gZXhjZXB0aW9uIG11c3QgaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgc2l6ZVxuICAgICAgLy8gb2YgdGhlIEJsb2Igb2JqZWN04oCZcyByYXcgZGF0YSwgaW4gYnl0ZXMuXG5cbiAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCgpXG5cbiAgICAgIGRhdGEuYXJyYXlCdWZmZXIoKS50aGVuKChhYikgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5mcm9tKGFiKVxuICAgICAgICBmcmFtZS5mcmFtZURhdGEgPSB2YWx1ZVxuICAgICAgICBjb25zdCBidWZmZXIgPSBmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLkJJTkFSWSlcblxuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICAgIHNvY2tldC53cml0ZShidWZmZXIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGdldCByZWFkeVN0YXRlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICAvLyBUaGUgcmVhZHlTdGF0ZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzJ3MgcmVhZHkgc3RhdGUuXG4gICAgcmV0dXJuIHRoaXNba1JlYWR5U3RhdGVdXG4gIH1cblxuICBnZXQgYnVmZmVyZWRBbW91bnQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNidWZmZXJlZEFtb3VudFxuICB9XG5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzJ3MgdXJsLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHRoaXNba1dlYlNvY2tldFVSTF0pXG4gIH1cblxuICBnZXQgZXh0ZW5zaW9ucyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V4dGVuc2lvbnNcbiAgfVxuXG4gIGdldCBwcm90b2NvbCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI3Byb3RvY29sXG4gIH1cblxuICBnZXQgb25vcGVuICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLm9wZW5cbiAgfVxuXG4gIHNldCBvbm9wZW4gKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5vcGVuKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLiNldmVudHMub3BlbilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMuZXJyb3JcbiAgfVxuXG4gIHNldCBvbmVycm9yIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMuZXJyb3IpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLiNldmVudHMuZXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmNsb3NlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmNsb3NlXG4gIH1cblxuICBzZXQgb25jbG9zZSAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLmNsb3NlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy4jZXZlbnRzLmNsb3NlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5jbG9zZSA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5jbG9zZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25tZXNzYWdlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLm1lc3NhZ2VcbiAgfVxuXG4gIHNldCBvbm1lc3NhZ2UgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5tZXNzYWdlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLiNldmVudHMubWVzc2FnZSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLm1lc3NhZ2UgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IGJpbmFyeVR5cGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzW2tCaW5hcnlUeXBlXVxuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUgKHR5cGUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodHlwZSAhPT0gJ2Jsb2InICYmIHR5cGUgIT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgIHRoaXNba0JpbmFyeVR5cGVdID0gJ2Jsb2InXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0JpbmFyeVR5cGVdID0gdHlwZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gICAqL1xuICAjb25Db25uZWN0aW9uRXN0YWJsaXNoZWQgKHJlc3BvbnNlKSB7XG4gICAgLy8gcHJvY2Vzc1Jlc3BvbnNlIGlzIGNhbGxlZCB3aGVuIHRoZSBcInJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCBoYXMgYmVlbiByZWNlaXZlZCBhbmQgaW5pdGlhbGl6ZWQuXCJcbiAgICAvLyBvbmNlIHRoaXMgaGFwcGVucywgdGhlIGNvbm5lY3Rpb24gaXMgb3BlblxuICAgIHRoaXNba1Jlc3BvbnNlXSA9IHJlc3BvbnNlXG5cbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgQnl0ZVBhcnNlcih0aGlzKVxuICAgIHBhcnNlci5vbignZHJhaW4nLCBmdW5jdGlvbiBvblBhcnNlckRyYWluICgpIHtcbiAgICAgIHRoaXMud3Nba1Jlc3BvbnNlXS5zb2NrZXQucmVzdW1lKClcbiAgICB9KVxuXG4gICAgcmVzcG9uc2Uuc29ja2V0LndzID0gdGhpc1xuICAgIHRoaXNba0J5dGVQYXJzZXJdID0gcGFyc2VyXG5cbiAgICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIE9QRU4gKDEpLlxuICAgIHRoaXNba1JlYWR5U3RhdGVdID0gc3RhdGVzLk9QRU5cblxuICAgIC8vIDIuIENoYW5nZSB0aGUgZXh0ZW5zaW9ucyBhdHRyaWJ1dGXigJlzIHZhbHVlIHRvIHRoZSBleHRlbnNpb25zIGluIHVzZSwgaWZcbiAgICAvLyAgICBpdCBpcyBub3QgdGhlIG51bGwgdmFsdWUuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tOS4xXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJylcblxuICAgIGlmIChleHRlbnNpb25zICE9PSBudWxsKSB7XG4gICAgICB0aGlzLiNleHRlbnNpb25zID0gZXh0ZW5zaW9uc1xuICAgIH1cblxuICAgIC8vIDMuIENoYW5nZSB0aGUgcHJvdG9jb2wgYXR0cmlidXRl4oCZcyB2YWx1ZSB0byB0aGUgc3VicHJvdG9jb2wgaW4gdXNlLCBpZlxuICAgIC8vICAgIGl0IGlzIG5vdCB0aGUgbnVsbCB2YWx1ZS5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi0xLjlcbiAgICBjb25zdCBwcm90b2NvbCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcpXG5cbiAgICBpZiAocHJvdG9jb2wgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuI3Byb3RvY29sID0gcHJvdG9jb2xcbiAgICB9XG5cbiAgICAvLyA0LiBGaXJlIGFuIGV2ZW50IG5hbWVkIG9wZW4gYXQgdGhlIFdlYlNvY2tldCBvYmplY3QuXG4gICAgZmlyZUV2ZW50KCdvcGVuJywgdGhpcylcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNvbm5lY3RpbmdcbldlYlNvY2tldC5DT05ORUNUSU5HID0gV2ViU29ja2V0LnByb3RvdHlwZS5DT05ORUNUSU5HID0gc3RhdGVzLkNPTk5FQ1RJTkdcbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtb3BlblxuV2ViU29ja2V0Lk9QRU4gPSBXZWJTb2NrZXQucHJvdG90eXBlLk9QRU4gPSBzdGF0ZXMuT1BFTlxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zaW5nXG5XZWJTb2NrZXQuQ0xPU0lORyA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ0xPU0lORyA9IHN0YXRlcy5DTE9TSU5HXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NlZFxuV2ViU29ja2V0LkNMT1NFRCA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ0xPU0VEID0gc3RhdGVzLkNMT1NFRFxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWJTb2NrZXQucHJvdG90eXBlLCB7XG4gIENPTk5FQ1RJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIE9QRU46IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NFRDogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBidWZmZXJlZEFtb3VudDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25vcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmNsb3NlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9zZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25tZXNzYWdlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBiaW5hcnlUeXBlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBleHRlbnNpb25zOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwcm90b2NvbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ1dlYlNvY2tldCcsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWJTb2NrZXQsIHtcbiAgQ09OTkVDVElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgT1BFTjogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0lORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0VEOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzXG59KVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8RE9NU3RyaW5nPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+J10gPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIFYpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPERPTVN0cmluZz4nXShWKVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWKVxufVxuXG4vLyBUaGlzIGltcGxlbWVudHMgdGhlIHByb3BzYWwgbWFkZSBpbiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3dlYnNvY2tldHMvaXNzdWVzLzQyXG53ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAncHJvdG9jb2xzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddLFxuICAgIGdldCBkZWZhdWx0VmFsdWUgKCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiAnZGlzcGF0Y2hlcicsXG4gICAgY29udmVydGVyOiAoVikgPT4gVixcbiAgICBnZXQgZGVmYXVsdFZhbHVlICgpIHtcbiAgICAgIHJldHVybiBnZXRHbG9iYWxEaXNwYXRjaGVyKClcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdClcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+IG9yIFdlYlNvY2tldEluaXQnXSA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0JyAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiBWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRJbml0KFYpXG4gIH1cblxuICByZXR1cm4geyBwcm90b2NvbHM6IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddKFYpIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U2VuZERhdGEgPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcpIHtcbiAgICBpZiAoaXNCbG9iTGlrZShWKSkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoViwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgfVxuXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhWKSB8fCB0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlKFYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViU29ja2V0XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/websocket/websocket.js\n");

/***/ })

};
;